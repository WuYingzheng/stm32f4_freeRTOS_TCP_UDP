
RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c134  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000156c  0800c2c4  0800c2c4  0001c2c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0800d830  0800d830  0001d830  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800d838  0800d838  0001d838  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800d83c  0800d83c  0001d83c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000348  20000000  0800d840  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020348  2**0
                  CONTENTS
  8 .bss          000049e8  20000348  20000348  00020348  2**2
                  ALLOC
  9 ._user_heap_stack 00000400  20004d30  20004d30  00020348  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020348  2**0
                  CONTENTS, READONLY
 11 .debug_line   00011e75  00000000  00000000  00020378  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0003f298  00000000  00000000  000321ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000783a  00000000  00000000  00071485  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001758  00000000  00000000  00078cc0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00002448  00000000  00000000  0007a418  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001e97d  00000000  00000000  0007c860  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000bc07  00000000  00000000  0009b1dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007c  00000000  00000000  000a6de4  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004868  00000000  00000000  000a6e60  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stabstr      000000df  00000000  00000000  000ab6c8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000348 	.word	0x20000348
 80001ac:	00000000 	.word	0x00000000
 80001b0:	0800c2ac 	.word	0x0800c2ac

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	2000034c 	.word	0x2000034c
 80001cc:	0800c2ac 	.word	0x0800c2ac

080001d0 <strlen>:
 80001d0:	4603      	mov	r3, r0
 80001d2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001d6:	2a00      	cmp	r2, #0
 80001d8:	d1fb      	bne.n	80001d2 <strlen+0x2>
 80001da:	1a18      	subs	r0, r3, r0
 80001dc:	3801      	subs	r0, #1
 80001de:	4770      	bx	lr

080001e0 <__aeabi_uldivmod>:
 80001e0:	b953      	cbnz	r3, 80001f8 <__aeabi_uldivmod+0x18>
 80001e2:	b94a      	cbnz	r2, 80001f8 <__aeabi_uldivmod+0x18>
 80001e4:	2900      	cmp	r1, #0
 80001e6:	bf08      	it	eq
 80001e8:	2800      	cmpeq	r0, #0
 80001ea:	bf1c      	itt	ne
 80001ec:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80001f0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80001f4:	f000 b97a 	b.w	80004ec <__aeabi_idiv0>
 80001f8:	f1ad 0c08 	sub.w	ip, sp, #8
 80001fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000200:	f000 f806 	bl	8000210 <__udivmoddi4>
 8000204:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000208:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800020c:	b004      	add	sp, #16
 800020e:	4770      	bx	lr

08000210 <__udivmoddi4>:
 8000210:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000214:	468c      	mov	ip, r1
 8000216:	460d      	mov	r5, r1
 8000218:	4604      	mov	r4, r0
 800021a:	9e08      	ldr	r6, [sp, #32]
 800021c:	2b00      	cmp	r3, #0
 800021e:	d151      	bne.n	80002c4 <__udivmoddi4+0xb4>
 8000220:	428a      	cmp	r2, r1
 8000222:	4617      	mov	r7, r2
 8000224:	d96d      	bls.n	8000302 <__udivmoddi4+0xf2>
 8000226:	fab2 fe82 	clz	lr, r2
 800022a:	f1be 0f00 	cmp.w	lr, #0
 800022e:	d00b      	beq.n	8000248 <__udivmoddi4+0x38>
 8000230:	f1ce 0c20 	rsb	ip, lr, #32
 8000234:	fa01 f50e 	lsl.w	r5, r1, lr
 8000238:	fa20 fc0c 	lsr.w	ip, r0, ip
 800023c:	fa02 f70e 	lsl.w	r7, r2, lr
 8000240:	ea4c 0c05 	orr.w	ip, ip, r5
 8000244:	fa00 f40e 	lsl.w	r4, r0, lr
 8000248:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 800024c:	0c25      	lsrs	r5, r4, #16
 800024e:	fbbc f8fa 	udiv	r8, ip, sl
 8000252:	fa1f f987 	uxth.w	r9, r7
 8000256:	fb0a cc18 	mls	ip, sl, r8, ip
 800025a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800025e:	fb08 f309 	mul.w	r3, r8, r9
 8000262:	42ab      	cmp	r3, r5
 8000264:	d90a      	bls.n	800027c <__udivmoddi4+0x6c>
 8000266:	19ed      	adds	r5, r5, r7
 8000268:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 800026c:	f080 8123 	bcs.w	80004b6 <__udivmoddi4+0x2a6>
 8000270:	42ab      	cmp	r3, r5
 8000272:	f240 8120 	bls.w	80004b6 <__udivmoddi4+0x2a6>
 8000276:	f1a8 0802 	sub.w	r8, r8, #2
 800027a:	443d      	add	r5, r7
 800027c:	1aed      	subs	r5, r5, r3
 800027e:	b2a4      	uxth	r4, r4
 8000280:	fbb5 f0fa 	udiv	r0, r5, sl
 8000284:	fb0a 5510 	mls	r5, sl, r0, r5
 8000288:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800028c:	fb00 f909 	mul.w	r9, r0, r9
 8000290:	45a1      	cmp	r9, r4
 8000292:	d909      	bls.n	80002a8 <__udivmoddi4+0x98>
 8000294:	19e4      	adds	r4, r4, r7
 8000296:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800029a:	f080 810a 	bcs.w	80004b2 <__udivmoddi4+0x2a2>
 800029e:	45a1      	cmp	r9, r4
 80002a0:	f240 8107 	bls.w	80004b2 <__udivmoddi4+0x2a2>
 80002a4:	3802      	subs	r0, #2
 80002a6:	443c      	add	r4, r7
 80002a8:	eba4 0409 	sub.w	r4, r4, r9
 80002ac:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80002b0:	2100      	movs	r1, #0
 80002b2:	2e00      	cmp	r6, #0
 80002b4:	d061      	beq.n	800037a <__udivmoddi4+0x16a>
 80002b6:	fa24 f40e 	lsr.w	r4, r4, lr
 80002ba:	2300      	movs	r3, #0
 80002bc:	6034      	str	r4, [r6, #0]
 80002be:	6073      	str	r3, [r6, #4]
 80002c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002c4:	428b      	cmp	r3, r1
 80002c6:	d907      	bls.n	80002d8 <__udivmoddi4+0xc8>
 80002c8:	2e00      	cmp	r6, #0
 80002ca:	d054      	beq.n	8000376 <__udivmoddi4+0x166>
 80002cc:	2100      	movs	r1, #0
 80002ce:	e886 0021 	stmia.w	r6, {r0, r5}
 80002d2:	4608      	mov	r0, r1
 80002d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002d8:	fab3 f183 	clz	r1, r3
 80002dc:	2900      	cmp	r1, #0
 80002de:	f040 808e 	bne.w	80003fe <__udivmoddi4+0x1ee>
 80002e2:	42ab      	cmp	r3, r5
 80002e4:	d302      	bcc.n	80002ec <__udivmoddi4+0xdc>
 80002e6:	4282      	cmp	r2, r0
 80002e8:	f200 80fa 	bhi.w	80004e0 <__udivmoddi4+0x2d0>
 80002ec:	1a84      	subs	r4, r0, r2
 80002ee:	eb65 0503 	sbc.w	r5, r5, r3
 80002f2:	2001      	movs	r0, #1
 80002f4:	46ac      	mov	ip, r5
 80002f6:	2e00      	cmp	r6, #0
 80002f8:	d03f      	beq.n	800037a <__udivmoddi4+0x16a>
 80002fa:	e886 1010 	stmia.w	r6, {r4, ip}
 80002fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000302:	b912      	cbnz	r2, 800030a <__udivmoddi4+0xfa>
 8000304:	2701      	movs	r7, #1
 8000306:	fbb7 f7f2 	udiv	r7, r7, r2
 800030a:	fab7 fe87 	clz	lr, r7
 800030e:	f1be 0f00 	cmp.w	lr, #0
 8000312:	d134      	bne.n	800037e <__udivmoddi4+0x16e>
 8000314:	1beb      	subs	r3, r5, r7
 8000316:	0c3a      	lsrs	r2, r7, #16
 8000318:	fa1f fc87 	uxth.w	ip, r7
 800031c:	2101      	movs	r1, #1
 800031e:	fbb3 f8f2 	udiv	r8, r3, r2
 8000322:	0c25      	lsrs	r5, r4, #16
 8000324:	fb02 3318 	mls	r3, r2, r8, r3
 8000328:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800032c:	fb0c f308 	mul.w	r3, ip, r8
 8000330:	42ab      	cmp	r3, r5
 8000332:	d907      	bls.n	8000344 <__udivmoddi4+0x134>
 8000334:	19ed      	adds	r5, r5, r7
 8000336:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 800033a:	d202      	bcs.n	8000342 <__udivmoddi4+0x132>
 800033c:	42ab      	cmp	r3, r5
 800033e:	f200 80d1 	bhi.w	80004e4 <__udivmoddi4+0x2d4>
 8000342:	4680      	mov	r8, r0
 8000344:	1aed      	subs	r5, r5, r3
 8000346:	b2a3      	uxth	r3, r4
 8000348:	fbb5 f0f2 	udiv	r0, r5, r2
 800034c:	fb02 5510 	mls	r5, r2, r0, r5
 8000350:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000354:	fb0c fc00 	mul.w	ip, ip, r0
 8000358:	45a4      	cmp	ip, r4
 800035a:	d907      	bls.n	800036c <__udivmoddi4+0x15c>
 800035c:	19e4      	adds	r4, r4, r7
 800035e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000362:	d202      	bcs.n	800036a <__udivmoddi4+0x15a>
 8000364:	45a4      	cmp	ip, r4
 8000366:	f200 80b8 	bhi.w	80004da <__udivmoddi4+0x2ca>
 800036a:	4618      	mov	r0, r3
 800036c:	eba4 040c 	sub.w	r4, r4, ip
 8000370:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000374:	e79d      	b.n	80002b2 <__udivmoddi4+0xa2>
 8000376:	4631      	mov	r1, r6
 8000378:	4630      	mov	r0, r6
 800037a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800037e:	f1ce 0420 	rsb	r4, lr, #32
 8000382:	fa05 f30e 	lsl.w	r3, r5, lr
 8000386:	fa07 f70e 	lsl.w	r7, r7, lr
 800038a:	fa20 f804 	lsr.w	r8, r0, r4
 800038e:	0c3a      	lsrs	r2, r7, #16
 8000390:	fa25 f404 	lsr.w	r4, r5, r4
 8000394:	ea48 0803 	orr.w	r8, r8, r3
 8000398:	fbb4 f1f2 	udiv	r1, r4, r2
 800039c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 80003a0:	fb02 4411 	mls	r4, r2, r1, r4
 80003a4:	fa1f fc87 	uxth.w	ip, r7
 80003a8:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 80003ac:	fb01 f30c 	mul.w	r3, r1, ip
 80003b0:	42ab      	cmp	r3, r5
 80003b2:	fa00 f40e 	lsl.w	r4, r0, lr
 80003b6:	d909      	bls.n	80003cc <__udivmoddi4+0x1bc>
 80003b8:	19ed      	adds	r5, r5, r7
 80003ba:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
 80003be:	f080 808a 	bcs.w	80004d6 <__udivmoddi4+0x2c6>
 80003c2:	42ab      	cmp	r3, r5
 80003c4:	f240 8087 	bls.w	80004d6 <__udivmoddi4+0x2c6>
 80003c8:	3902      	subs	r1, #2
 80003ca:	443d      	add	r5, r7
 80003cc:	1aeb      	subs	r3, r5, r3
 80003ce:	fa1f f588 	uxth.w	r5, r8
 80003d2:	fbb3 f0f2 	udiv	r0, r3, r2
 80003d6:	fb02 3310 	mls	r3, r2, r0, r3
 80003da:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003de:	fb00 f30c 	mul.w	r3, r0, ip
 80003e2:	42ab      	cmp	r3, r5
 80003e4:	d907      	bls.n	80003f6 <__udivmoddi4+0x1e6>
 80003e6:	19ed      	adds	r5, r5, r7
 80003e8:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 80003ec:	d26f      	bcs.n	80004ce <__udivmoddi4+0x2be>
 80003ee:	42ab      	cmp	r3, r5
 80003f0:	d96d      	bls.n	80004ce <__udivmoddi4+0x2be>
 80003f2:	3802      	subs	r0, #2
 80003f4:	443d      	add	r5, r7
 80003f6:	1aeb      	subs	r3, r5, r3
 80003f8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80003fc:	e78f      	b.n	800031e <__udivmoddi4+0x10e>
 80003fe:	f1c1 0720 	rsb	r7, r1, #32
 8000402:	fa22 f807 	lsr.w	r8, r2, r7
 8000406:	408b      	lsls	r3, r1
 8000408:	fa05 f401 	lsl.w	r4, r5, r1
 800040c:	ea48 0303 	orr.w	r3, r8, r3
 8000410:	fa20 fe07 	lsr.w	lr, r0, r7
 8000414:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000418:	40fd      	lsrs	r5, r7
 800041a:	ea4e 0e04 	orr.w	lr, lr, r4
 800041e:	fbb5 f9fc 	udiv	r9, r5, ip
 8000422:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000426:	fb0c 5519 	mls	r5, ip, r9, r5
 800042a:	fa1f f883 	uxth.w	r8, r3
 800042e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000432:	fb09 f408 	mul.w	r4, r9, r8
 8000436:	42ac      	cmp	r4, r5
 8000438:	fa02 f201 	lsl.w	r2, r2, r1
 800043c:	fa00 fa01 	lsl.w	sl, r0, r1
 8000440:	d908      	bls.n	8000454 <__udivmoddi4+0x244>
 8000442:	18ed      	adds	r5, r5, r3
 8000444:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000448:	d243      	bcs.n	80004d2 <__udivmoddi4+0x2c2>
 800044a:	42ac      	cmp	r4, r5
 800044c:	d941      	bls.n	80004d2 <__udivmoddi4+0x2c2>
 800044e:	f1a9 0902 	sub.w	r9, r9, #2
 8000452:	441d      	add	r5, r3
 8000454:	1b2d      	subs	r5, r5, r4
 8000456:	fa1f fe8e 	uxth.w	lr, lr
 800045a:	fbb5 f0fc 	udiv	r0, r5, ip
 800045e:	fb0c 5510 	mls	r5, ip, r0, r5
 8000462:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000466:	fb00 f808 	mul.w	r8, r0, r8
 800046a:	45a0      	cmp	r8, r4
 800046c:	d907      	bls.n	800047e <__udivmoddi4+0x26e>
 800046e:	18e4      	adds	r4, r4, r3
 8000470:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 8000474:	d229      	bcs.n	80004ca <__udivmoddi4+0x2ba>
 8000476:	45a0      	cmp	r8, r4
 8000478:	d927      	bls.n	80004ca <__udivmoddi4+0x2ba>
 800047a:	3802      	subs	r0, #2
 800047c:	441c      	add	r4, r3
 800047e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000482:	eba4 0408 	sub.w	r4, r4, r8
 8000486:	fba0 8902 	umull	r8, r9, r0, r2
 800048a:	454c      	cmp	r4, r9
 800048c:	46c6      	mov	lr, r8
 800048e:	464d      	mov	r5, r9
 8000490:	d315      	bcc.n	80004be <__udivmoddi4+0x2ae>
 8000492:	d012      	beq.n	80004ba <__udivmoddi4+0x2aa>
 8000494:	b156      	cbz	r6, 80004ac <__udivmoddi4+0x29c>
 8000496:	ebba 030e 	subs.w	r3, sl, lr
 800049a:	eb64 0405 	sbc.w	r4, r4, r5
 800049e:	fa04 f707 	lsl.w	r7, r4, r7
 80004a2:	40cb      	lsrs	r3, r1
 80004a4:	431f      	orrs	r7, r3
 80004a6:	40cc      	lsrs	r4, r1
 80004a8:	6037      	str	r7, [r6, #0]
 80004aa:	6074      	str	r4, [r6, #4]
 80004ac:	2100      	movs	r1, #0
 80004ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004b2:	4618      	mov	r0, r3
 80004b4:	e6f8      	b.n	80002a8 <__udivmoddi4+0x98>
 80004b6:	4690      	mov	r8, r2
 80004b8:	e6e0      	b.n	800027c <__udivmoddi4+0x6c>
 80004ba:	45c2      	cmp	sl, r8
 80004bc:	d2ea      	bcs.n	8000494 <__udivmoddi4+0x284>
 80004be:	ebb8 0e02 	subs.w	lr, r8, r2
 80004c2:	eb69 0503 	sbc.w	r5, r9, r3
 80004c6:	3801      	subs	r0, #1
 80004c8:	e7e4      	b.n	8000494 <__udivmoddi4+0x284>
 80004ca:	4628      	mov	r0, r5
 80004cc:	e7d7      	b.n	800047e <__udivmoddi4+0x26e>
 80004ce:	4640      	mov	r0, r8
 80004d0:	e791      	b.n	80003f6 <__udivmoddi4+0x1e6>
 80004d2:	4681      	mov	r9, r0
 80004d4:	e7be      	b.n	8000454 <__udivmoddi4+0x244>
 80004d6:	4601      	mov	r1, r0
 80004d8:	e778      	b.n	80003cc <__udivmoddi4+0x1bc>
 80004da:	3802      	subs	r0, #2
 80004dc:	443c      	add	r4, r7
 80004de:	e745      	b.n	800036c <__udivmoddi4+0x15c>
 80004e0:	4608      	mov	r0, r1
 80004e2:	e708      	b.n	80002f6 <__udivmoddi4+0xe6>
 80004e4:	f1a8 0802 	sub.w	r8, r8, #2
 80004e8:	443d      	add	r5, r7
 80004ea:	e72b      	b.n	8000344 <__udivmoddi4+0x134>

080004ec <__aeabi_idiv0>:
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop

080004f0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80004f0:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000528 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80004f4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80004f6:	e003      	b.n	8000500 <LoopCopyDataInit>

080004f8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80004f8:	4b0c      	ldr	r3, [pc, #48]	; (800052c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80004fa:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80004fc:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80004fe:	3104      	adds	r1, #4

08000500 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000500:	480b      	ldr	r0, [pc, #44]	; (8000530 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8000502:	4b0c      	ldr	r3, [pc, #48]	; (8000534 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000504:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000506:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000508:	d3f6      	bcc.n	80004f8 <CopyDataInit>
  ldr  r2, =_sbss
 800050a:	4a0b      	ldr	r2, [pc, #44]	; (8000538 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800050c:	e002      	b.n	8000514 <LoopFillZerobss>

0800050e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800050e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8000510:	f842 3b04 	str.w	r3, [r2], #4

08000514 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000514:	4b09      	ldr	r3, [pc, #36]	; (800053c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000516:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000518:	d3f9      	bcc.n	800050e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800051a:	f000 f823 	bl	8000564 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800051e:	f00b fd69 	bl	800bff4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000522:	f00b fb1d 	bl	800bb60 <main>
  bx  lr    
 8000526:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8000528:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 800052c:	0800d840 	.word	0x0800d840
  ldr  r0, =_sdata
 8000530:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000534:	20000348 	.word	0x20000348
  ldr  r2, =_sbss
 8000538:	20000348 	.word	0x20000348
  ldr  r3, = _ebss
 800053c:	20004d30 	.word	0x20004d30

08000540 <ADC_IRQHandler>:
 * @param  None     
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
  ldr r3, NVIC_INT_CTRL_CONST
 8000540:	4b03      	ldr	r3, [pc, #12]	; (8000550 <NVIC_INT_CTRL_CONST>)
  ldr r2, [r3, #0]
 8000542:	681a      	ldr	r2, [r3, #0]
  uxtb r2, r2
 8000544:	b2d2      	uxtb	r2, r2

08000546 <Infinite_Loop>:
Infinite_Loop:
  /* The number of the active interrupt vector is stored in r2. */
  b  Infinite_Loop
 8000546:	e7fe      	b.n	8000546 <Infinite_Loop>
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <NVIC_INT_CTRL_CONST>:
 8000550:	e000ed04 	.word	0xe000ed04
	...

08000560 <HardFault_Handler>:

    .section  .text.HardFault_Handler,"ax",%progbits
    .align 4
HardFault_Handler:
HardFault_Infinite_Loop:
  b  HardFault_Infinite_Loop
 8000560:	e7fe      	b.n	8000560 <HardFault_Handler>
 8000562:	bf00      	nop

08000564 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000564:	490f      	ldr	r1, [pc, #60]	; (80005a4 <SystemInit+0x40>)
 8000566:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800056a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800056e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000572:	4b0d      	ldr	r3, [pc, #52]	; (80005a8 <SystemInit+0x44>)
 8000574:	681a      	ldr	r2, [r3, #0]
 8000576:	f042 0201 	orr.w	r2, r2, #1
 800057a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800057c:	2000      	movs	r0, #0
 800057e:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000580:	681a      	ldr	r2, [r3, #0]
 8000582:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000586:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800058a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800058c:	4a07      	ldr	r2, [pc, #28]	; (80005ac <SystemInit+0x48>)
 800058e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000590:	681a      	ldr	r2, [r3, #0]
 8000592:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000596:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000598:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800059a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800059e:	608b      	str	r3, [r1, #8]
 80005a0:	4770      	bx	lr
 80005a2:	bf00      	nop
 80005a4:	e000ed00 	.word	0xe000ed00
 80005a8:	40023800 	.word	0x40023800
 80005ac:	24003010 	.word	0x24003010

080005b0 <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 80005b0:	4770      	bx	lr
	...

080005b4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80005b4:	b510      	push	{r4, lr}
 80005b6:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80005b8:	f002 faf2 	bl	8002ba0 <HAL_RCC_GetHCLKFreq>
 80005bc:	4b06      	ldr	r3, [pc, #24]	; (80005d8 <HAL_InitTick+0x24>)
 80005be:	fba3 3000 	umull	r3, r0, r3, r0
 80005c2:	0980      	lsrs	r0, r0, #6
 80005c4:	f000 f88e 	bl	80006e4 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 80005c8:	2200      	movs	r2, #0
 80005ca:	4621      	mov	r1, r4
 80005cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80005d0:	f000 f84c 	bl	800066c <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 80005d4:	2000      	movs	r0, #0
 80005d6:	bd10      	pop	{r4, pc}
 80005d8:	10624dd3 	.word	0x10624dd3

080005dc <HAL_Init>:
{
 80005dc:	b508      	push	{r3, lr}
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80005de:	4b0b      	ldr	r3, [pc, #44]	; (800060c <HAL_Init+0x30>)
 80005e0:	681a      	ldr	r2, [r3, #0]
 80005e2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80005e6:	601a      	str	r2, [r3, #0]
   __HAL_FLASH_DATA_CACHE_ENABLE();
 80005e8:	681a      	ldr	r2, [r3, #0]
 80005ea:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80005ee:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80005f0:	681a      	ldr	r2, [r3, #0]
 80005f2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80005f6:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80005f8:	2003      	movs	r0, #3
 80005fa:	f000 f825 	bl	8000648 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80005fe:	2000      	movs	r0, #0
 8000600:	f7ff ffd8 	bl	80005b4 <HAL_InitTick>
  HAL_MspInit();
 8000604:	f7ff ffd4 	bl	80005b0 <HAL_MspInit>
}
 8000608:	2000      	movs	r0, #0
 800060a:	bd08      	pop	{r3, pc}
 800060c:	40023c00 	.word	0x40023c00

08000610 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000610:	4a02      	ldr	r2, [pc, #8]	; (800061c <HAL_IncTick+0xc>)
 8000612:	6813      	ldr	r3, [r2, #0]
 8000614:	3301      	adds	r3, #1
 8000616:	6013      	str	r3, [r2, #0]
 8000618:	4770      	bx	lr
 800061a:	bf00      	nop
 800061c:	20000364 	.word	0x20000364

08000620 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000620:	4b01      	ldr	r3, [pc, #4]	; (8000628 <HAL_GetTick+0x8>)
 8000622:	6818      	ldr	r0, [r3, #0]
}
 8000624:	4770      	bx	lr
 8000626:	bf00      	nop
 8000628:	20000364 	.word	0x20000364

0800062c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800062c:	b510      	push	{r4, lr}
 800062e:	b082      	sub	sp, #8
 8000630:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000632:	f7ff fff5 	bl	8000620 <HAL_GetTick>
 8000636:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000638:	f7ff fff2 	bl	8000620 <HAL_GetTick>
 800063c:	9b01      	ldr	r3, [sp, #4]
 800063e:	1b00      	subs	r0, r0, r4
 8000640:	4298      	cmp	r0, r3
 8000642:	d3f9      	bcc.n	8000638 <HAL_Delay+0xc>
  {
  }
}
 8000644:	b002      	add	sp, #8
 8000646:	bd10      	pop	{r4, pc}

08000648 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000648:	4a07      	ldr	r2, [pc, #28]	; (8000668 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800064a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 800064c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000650:	041b      	lsls	r3, r3, #16
 8000652:	0c1b      	lsrs	r3, r3, #16
 8000654:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000658:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 800065c:	0200      	lsls	r0, r0, #8
 800065e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                 |
 8000662:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000664:	60d3      	str	r3, [r2, #12]
 8000666:	4770      	bx	lr
 8000668:	e000ed00 	.word	0xe000ed00

0800066c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800066c:	b430      	push	{r4, r5}

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 800066e:	4b15      	ldr	r3, [pc, #84]	; (80006c4 <HAL_NVIC_SetPriority+0x58>)
 8000670:	68dc      	ldr	r4, [r3, #12]
 8000672:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 8000676:	f1c4 0307 	rsb	r3, r4, #7
 800067a:	2b04      	cmp	r3, #4
 800067c:	bf28      	it	cs
 800067e:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8000680:	1d25      	adds	r5, r4, #4
 8000682:	2d06      	cmp	r5, #6
 8000684:	bf8c      	ite	hi
 8000686:	1ee5      	subhi	r5, r4, #3
 8000688:	2500      	movls	r5, #0

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800068a:	2401      	movs	r4, #1
 800068c:	fa04 f303 	lsl.w	r3, r4, r3
 8000690:	3b01      	subs	r3, #1
 8000692:	4019      	ands	r1, r3
 8000694:	40a9      	lsls	r1, r5
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 8000696:	40ac      	lsls	r4, r5
 8000698:	3c01      	subs	r4, #1
 800069a:	4022      	ands	r2, r4
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800069c:	4311      	orrs	r1, r2
  if(IRQn < 0) {
 800069e:	2800      	cmp	r0, #0
 80006a0:	db09      	blt.n	80006b6 <HAL_NVIC_SetPriority+0x4a>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 80006a2:	0109      	lsls	r1, r1, #4
 80006a4:	b2c9      	uxtb	r1, r1
 80006a6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80006aa:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80006ae:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80006b2:	bc30      	pop	{r4, r5}
 80006b4:	4770      	bx	lr
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80006b6:	f000 000f 	and.w	r0, r0, #15
 80006ba:	0109      	lsls	r1, r1, #4
 80006bc:	b2c9      	uxtb	r1, r1
 80006be:	4b02      	ldr	r3, [pc, #8]	; (80006c8 <HAL_NVIC_SetPriority+0x5c>)
 80006c0:	5419      	strb	r1, [r3, r0]
 80006c2:	e7f6      	b.n	80006b2 <HAL_NVIC_SetPriority+0x46>
 80006c4:	e000ed00 	.word	0xe000ed00
 80006c8:	e000ed14 	.word	0xe000ed14

080006cc <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 80006cc:	0942      	lsrs	r2, r0, #5
 80006ce:	f000 001f 	and.w	r0, r0, #31
 80006d2:	2301      	movs	r3, #1
 80006d4:	fa03 f000 	lsl.w	r0, r3, r0
 80006d8:	4b01      	ldr	r3, [pc, #4]	; (80006e0 <HAL_NVIC_EnableIRQ+0x14>)
 80006da:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80006de:	4770      	bx	lr
 80006e0:	e000e100 	.word	0xe000e100

080006e4 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 80006e4:	3801      	subs	r0, #1
 80006e6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80006ea:	d20a      	bcs.n	8000702 <HAL_SYSTICK_Config+0x1e>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 80006ec:	4b06      	ldr	r3, [pc, #24]	; (8000708 <HAL_SYSTICK_Config+0x24>)
 80006ee:	6058      	str	r0, [r3, #4]
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80006f0:	21f0      	movs	r1, #240	; 0xf0
 80006f2:	4a06      	ldr	r2, [pc, #24]	; (800070c <HAL_SYSTICK_Config+0x28>)
 80006f4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80006f8:	2000      	movs	r0, #0
 80006fa:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80006fc:	2207      	movs	r2, #7
 80006fe:	601a      	str	r2, [r3, #0]
 8000700:	4770      	bx	lr
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8000702:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000704:	4770      	bx	lr
 8000706:	bf00      	nop
 8000708:	e000e010 	.word	0xe000e010
 800070c:	e000ed00 	.word	0xe000ed00

08000710 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8000710:	b538      	push	{r3, r4, r5, lr}
 8000712:	4604      	mov	r4, r0
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8000714:	6801      	ldr	r1, [r0, #0]
 8000716:	460b      	mov	r3, r1
 8000718:	4ac2      	ldr	r2, [pc, #776]	; (8000a24 <HAL_DMA_IRQHandler+0x314>)
 800071a:	4291      	cmp	r1, r2
 800071c:	d949      	bls.n	80007b2 <HAL_DMA_IRQHandler+0xa2>
 800071e:	3a58      	subs	r2, #88	; 0x58
 8000720:	6850      	ldr	r0, [r2, #4]
 8000722:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 8000726:	4dc0      	ldr	r5, [pc, #768]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 8000728:	42aa      	cmp	r2, r5
 800072a:	d013      	beq.n	8000754 <HAL_DMA_IRQHandler+0x44>
 800072c:	3560      	adds	r5, #96	; 0x60
 800072e:	42aa      	cmp	r2, r5
 8000730:	d034      	beq.n	800079c <HAL_DMA_IRQHandler+0x8c>
 8000732:	3d48      	subs	r5, #72	; 0x48
 8000734:	42aa      	cmp	r2, r5
 8000736:	d033      	beq.n	80007a0 <HAL_DMA_IRQHandler+0x90>
 8000738:	3560      	adds	r5, #96	; 0x60
 800073a:	42aa      	cmp	r2, r5
 800073c:	d033      	beq.n	80007a6 <HAL_DMA_IRQHandler+0x96>
 800073e:	3d48      	subs	r5, #72	; 0x48
 8000740:	42aa      	cmp	r2, r5
 8000742:	d033      	beq.n	80007ac <HAL_DMA_IRQHandler+0x9c>
 8000744:	3560      	adds	r5, #96	; 0x60
 8000746:	42aa      	cmp	r2, r5
 8000748:	bf0c      	ite	eq
 800074a:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 800074e:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 8000752:	e000      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 8000754:	2208      	movs	r2, #8
 8000756:	4202      	tst	r2, r0
 8000758:	f041 818d 	bne.w	8001a76 <HAL_DMA_IRQHandler+0x1366>
        hdma->XferErrorCallback(hdma);
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 800075c:	4ab3      	ldr	r2, [pc, #716]	; (8000a2c <HAL_DMA_IRQHandler+0x31c>)
 800075e:	6852      	ldr	r2, [r2, #4]
 8000760:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000764:	48b0      	ldr	r0, [pc, #704]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 8000766:	4283      	cmp	r3, r0
 8000768:	f000 81e6 	beq.w	8000b38 <HAL_DMA_IRQHandler+0x428>
 800076c:	3060      	adds	r0, #96	; 0x60
 800076e:	4283      	cmp	r3, r0
 8000770:	f000 8207 	beq.w	8000b82 <HAL_DMA_IRQHandler+0x472>
 8000774:	3848      	subs	r0, #72	; 0x48
 8000776:	4283      	cmp	r3, r0
 8000778:	f000 8205 	beq.w	8000b86 <HAL_DMA_IRQHandler+0x476>
 800077c:	3060      	adds	r0, #96	; 0x60
 800077e:	4283      	cmp	r3, r0
 8000780:	f000 8203 	beq.w	8000b8a <HAL_DMA_IRQHandler+0x47a>
 8000784:	3848      	subs	r0, #72	; 0x48
 8000786:	4283      	cmp	r3, r0
 8000788:	f000 8201 	beq.w	8000b8e <HAL_DMA_IRQHandler+0x47e>
 800078c:	3060      	adds	r0, #96	; 0x60
 800078e:	4283      	cmp	r3, r0
 8000790:	bf0c      	ite	eq
 8000792:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000796:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 800079a:	e1ce      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 800079c:	2208      	movs	r2, #8
 800079e:	e7da      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007a0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80007a4:	e7d7      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007a6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80007aa:	e7d4      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007ac:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80007b0:	e7d1      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007b2:	4a9f      	ldr	r2, [pc, #636]	; (8000a30 <HAL_DMA_IRQHandler+0x320>)
 80007b4:	4291      	cmp	r1, r2
 80007b6:	d957      	bls.n	8000868 <HAL_DMA_IRQHandler+0x158>
 80007b8:	f502 7252 	add.w	r2, r2, #840	; 0x348
 80007bc:	6810      	ldr	r0, [r2, #0]
 80007be:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 80007c2:	4d99      	ldr	r5, [pc, #612]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 80007c4:	42aa      	cmp	r2, r5
 80007c6:	d013      	beq.n	80007f0 <HAL_DMA_IRQHandler+0xe0>
 80007c8:	3560      	adds	r5, #96	; 0x60
 80007ca:	42aa      	cmp	r2, r5
 80007cc:	d041      	beq.n	8000852 <HAL_DMA_IRQHandler+0x142>
 80007ce:	3d48      	subs	r5, #72	; 0x48
 80007d0:	42aa      	cmp	r2, r5
 80007d2:	d040      	beq.n	8000856 <HAL_DMA_IRQHandler+0x146>
 80007d4:	3560      	adds	r5, #96	; 0x60
 80007d6:	42aa      	cmp	r2, r5
 80007d8:	d040      	beq.n	800085c <HAL_DMA_IRQHandler+0x14c>
 80007da:	3d48      	subs	r5, #72	; 0x48
 80007dc:	42aa      	cmp	r2, r5
 80007de:	d040      	beq.n	8000862 <HAL_DMA_IRQHandler+0x152>
 80007e0:	3560      	adds	r5, #96	; 0x60
 80007e2:	42aa      	cmp	r2, r5
 80007e4:	bf0c      	ite	eq
 80007e6:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 80007ea:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 80007ee:	e000      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 80007f0:	2208      	movs	r2, #8
 80007f2:	4202      	tst	r2, r0
 80007f4:	f000 80ea 	beq.w	80009cc <HAL_DMA_IRQHandler+0x2bc>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80007f8:	680b      	ldr	r3, [r1, #0]
 80007fa:	f013 0f04 	tst.w	r3, #4
 80007fe:	f001 8124 	beq.w	8001a4a <HAL_DMA_IRQHandler+0x133a>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8000802:	680b      	ldr	r3, [r1, #0]
 8000804:	f023 0304 	bic.w	r3, r3, #4
 8000808:	600b      	str	r3, [r1, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800080a:	6823      	ldr	r3, [r4, #0]
 800080c:	4a85      	ldr	r2, [pc, #532]	; (8000a24 <HAL_DMA_IRQHandler+0x314>)
 800080e:	4293      	cmp	r3, r2
 8000810:	f240 8114 	bls.w	8000a3c <HAL_DMA_IRQHandler+0x32c>
 8000814:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000818:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 800081c:	4293      	cmp	r3, r2
 800081e:	f000 80ba 	beq.w	8000996 <HAL_DMA_IRQHandler+0x286>
 8000822:	3260      	adds	r2, #96	; 0x60
 8000824:	4293      	cmp	r3, r2
 8000826:	f000 80f1 	beq.w	8000a0c <HAL_DMA_IRQHandler+0x2fc>
 800082a:	3a48      	subs	r2, #72	; 0x48
 800082c:	4293      	cmp	r3, r2
 800082e:	f000 80ef 	beq.w	8000a10 <HAL_DMA_IRQHandler+0x300>
 8000832:	3260      	adds	r2, #96	; 0x60
 8000834:	4293      	cmp	r3, r2
 8000836:	f000 80ee 	beq.w	8000a16 <HAL_DMA_IRQHandler+0x306>
 800083a:	3a48      	subs	r2, #72	; 0x48
 800083c:	4293      	cmp	r3, r2
 800083e:	f000 80ed 	beq.w	8000a1c <HAL_DMA_IRQHandler+0x30c>
 8000842:	3260      	adds	r2, #96	; 0x60
 8000844:	4293      	cmp	r3, r2
 8000846:	bf0c      	ite	eq
 8000848:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 800084c:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000850:	e0a2      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8000852:	2208      	movs	r2, #8
 8000854:	e7cd      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 8000856:	f44f 7200 	mov.w	r2, #512	; 0x200
 800085a:	e7ca      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 800085c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000860:	e7c7      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 8000862:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000866:	e7c4      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 8000868:	4a72      	ldr	r2, [pc, #456]	; (8000a34 <HAL_DMA_IRQHandler+0x324>)
 800086a:	4291      	cmp	r1, r2
 800086c:	d949      	bls.n	8000902 <HAL_DMA_IRQHandler+0x1f2>
 800086e:	3a58      	subs	r2, #88	; 0x58
 8000870:	6850      	ldr	r0, [r2, #4]
 8000872:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 8000876:	4d6c      	ldr	r5, [pc, #432]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 8000878:	42aa      	cmp	r2, r5
 800087a:	d013      	beq.n	80008a4 <HAL_DMA_IRQHandler+0x194>
 800087c:	3560      	adds	r5, #96	; 0x60
 800087e:	42aa      	cmp	r2, r5
 8000880:	d034      	beq.n	80008ec <HAL_DMA_IRQHandler+0x1dc>
 8000882:	3d48      	subs	r5, #72	; 0x48
 8000884:	42aa      	cmp	r2, r5
 8000886:	d033      	beq.n	80008f0 <HAL_DMA_IRQHandler+0x1e0>
 8000888:	3560      	adds	r5, #96	; 0x60
 800088a:	42aa      	cmp	r2, r5
 800088c:	d033      	beq.n	80008f6 <HAL_DMA_IRQHandler+0x1e6>
 800088e:	3d48      	subs	r5, #72	; 0x48
 8000890:	42aa      	cmp	r2, r5
 8000892:	d033      	beq.n	80008fc <HAL_DMA_IRQHandler+0x1ec>
 8000894:	3560      	adds	r5, #96	; 0x60
 8000896:	42aa      	cmp	r2, r5
 8000898:	bf0c      	ite	eq
 800089a:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 800089e:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 80008a2:	e000      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008a4:	2208      	movs	r2, #8
 80008a6:	4202      	tst	r2, r0
 80008a8:	f041 80d3 	bne.w	8001a52 <HAL_DMA_IRQHandler+0x1342>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 80008ac:	4a62      	ldr	r2, [pc, #392]	; (8000a38 <HAL_DMA_IRQHandler+0x328>)
 80008ae:	6852      	ldr	r2, [r2, #4]
 80008b0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80008b4:	485c      	ldr	r0, [pc, #368]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 80008b6:	4283      	cmp	r3, r0
 80008b8:	f000 81aa 	beq.w	8000c10 <HAL_DMA_IRQHandler+0x500>
 80008bc:	3060      	adds	r0, #96	; 0x60
 80008be:	4283      	cmp	r3, r0
 80008c0:	f000 81ac 	beq.w	8000c1c <HAL_DMA_IRQHandler+0x50c>
 80008c4:	3848      	subs	r0, #72	; 0x48
 80008c6:	4283      	cmp	r3, r0
 80008c8:	f000 81aa 	beq.w	8000c20 <HAL_DMA_IRQHandler+0x510>
 80008cc:	3060      	adds	r0, #96	; 0x60
 80008ce:	4283      	cmp	r3, r0
 80008d0:	f000 81a8 	beq.w	8000c24 <HAL_DMA_IRQHandler+0x514>
 80008d4:	3848      	subs	r0, #72	; 0x48
 80008d6:	4283      	cmp	r3, r0
 80008d8:	f000 81a6 	beq.w	8000c28 <HAL_DMA_IRQHandler+0x518>
 80008dc:	3060      	adds	r0, #96	; 0x60
 80008de:	4283      	cmp	r3, r0
 80008e0:	bf0c      	ite	eq
 80008e2:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 80008e6:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 80008ea:	e192      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 80008ec:	2208      	movs	r2, #8
 80008ee:	e7da      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008f0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80008f4:	e7d7      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008f6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80008fa:	e7d4      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008fc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000900:	e7d1      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 8000902:	4a4d      	ldr	r2, [pc, #308]	; (8000a38 <HAL_DMA_IRQHandler+0x328>)
 8000904:	6810      	ldr	r0, [r2, #0]
 8000906:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 800090a:	4d47      	ldr	r5, [pc, #284]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 800090c:	42aa      	cmp	r2, r5
 800090e:	d013      	beq.n	8000938 <HAL_DMA_IRQHandler+0x228>
 8000910:	3560      	adds	r5, #96	; 0x60
 8000912:	42aa      	cmp	r2, r5
 8000914:	d034      	beq.n	8000980 <HAL_DMA_IRQHandler+0x270>
 8000916:	3d48      	subs	r5, #72	; 0x48
 8000918:	42aa      	cmp	r2, r5
 800091a:	d033      	beq.n	8000984 <HAL_DMA_IRQHandler+0x274>
 800091c:	3560      	adds	r5, #96	; 0x60
 800091e:	42aa      	cmp	r2, r5
 8000920:	d033      	beq.n	800098a <HAL_DMA_IRQHandler+0x27a>
 8000922:	3d48      	subs	r5, #72	; 0x48
 8000924:	42aa      	cmp	r2, r5
 8000926:	d033      	beq.n	8000990 <HAL_DMA_IRQHandler+0x280>
 8000928:	3560      	adds	r5, #96	; 0x60
 800092a:	42aa      	cmp	r2, r5
 800092c:	bf0c      	ite	eq
 800092e:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 8000932:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 8000936:	e000      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 8000938:	2208      	movs	r2, #8
 800093a:	4202      	tst	r2, r0
 800093c:	f041 8092 	bne.w	8001a64 <HAL_DMA_IRQHandler+0x1354>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000940:	4a3d      	ldr	r2, [pc, #244]	; (8000a38 <HAL_DMA_IRQHandler+0x328>)
 8000942:	6812      	ldr	r2, [r2, #0]
 8000944:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000948:	4837      	ldr	r0, [pc, #220]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 800094a:	4283      	cmp	r3, r0
 800094c:	f000 816f 	beq.w	8000c2e <HAL_DMA_IRQHandler+0x51e>
 8000950:	3060      	adds	r0, #96	; 0x60
 8000952:	4283      	cmp	r3, r0
 8000954:	f000 8190 	beq.w	8000c78 <HAL_DMA_IRQHandler+0x568>
 8000958:	3848      	subs	r0, #72	; 0x48
 800095a:	4283      	cmp	r3, r0
 800095c:	f000 818e 	beq.w	8000c7c <HAL_DMA_IRQHandler+0x56c>
 8000960:	3060      	adds	r0, #96	; 0x60
 8000962:	4283      	cmp	r3, r0
 8000964:	f000 818c 	beq.w	8000c80 <HAL_DMA_IRQHandler+0x570>
 8000968:	3848      	subs	r0, #72	; 0x48
 800096a:	4283      	cmp	r3, r0
 800096c:	f000 818a 	beq.w	8000c84 <HAL_DMA_IRQHandler+0x574>
 8000970:	3060      	adds	r0, #96	; 0x60
 8000972:	4283      	cmp	r3, r0
 8000974:	bf0c      	ite	eq
 8000976:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800097a:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 800097e:	e157      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8000980:	2208      	movs	r2, #8
 8000982:	e7da      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 8000984:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000988:	e7d7      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 800098a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800098e:	e7d4      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 8000990:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000994:	e7d1      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000996:	2308      	movs	r3, #8
 8000998:	4a24      	ldr	r2, [pc, #144]	; (8000a2c <HAL_DMA_IRQHandler+0x31c>)
 800099a:	60d3      	str	r3, [r2, #12]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800099c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800099e:	f043 0301 	orr.w	r3, r3, #1
 80009a2:	64e3      	str	r3, [r4, #76]	; 0x4c
      hdma->State = HAL_DMA_STATE_ERROR;
 80009a4:	2304      	movs	r3, #4
 80009a6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 80009aa:	2300      	movs	r3, #0
 80009ac:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 80009b0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80009b2:	b10b      	cbz	r3, 80009b8 <HAL_DMA_IRQHandler+0x2a8>
        hdma->XferErrorCallback(hdma);
 80009b4:	4620      	mov	r0, r4
 80009b6:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 80009b8:	6821      	ldr	r1, [r4, #0]
 80009ba:	460b      	mov	r3, r1
 80009bc:	4a19      	ldr	r2, [pc, #100]	; (8000a24 <HAL_DMA_IRQHandler+0x314>)
 80009be:	4291      	cmp	r1, r2
 80009c0:	f63f aecc 	bhi.w	800075c <HAL_DMA_IRQHandler+0x4c>
 80009c4:	4a1a      	ldr	r2, [pc, #104]	; (8000a30 <HAL_DMA_IRQHandler+0x320>)
 80009c6:	4291      	cmp	r1, r2
 80009c8:	f240 811d 	bls.w	8000c06 <HAL_DMA_IRQHandler+0x4f6>
 80009cc:	4a17      	ldr	r2, [pc, #92]	; (8000a2c <HAL_DMA_IRQHandler+0x31c>)
 80009ce:	6812      	ldr	r2, [r2, #0]
 80009d0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80009d4:	4814      	ldr	r0, [pc, #80]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 80009d6:	4283      	cmp	r3, r0
 80009d8:	f000 80dc 	beq.w	8000b94 <HAL_DMA_IRQHandler+0x484>
 80009dc:	3060      	adds	r0, #96	; 0x60
 80009de:	4283      	cmp	r3, r0
 80009e0:	f000 8108 	beq.w	8000bf4 <HAL_DMA_IRQHandler+0x4e4>
 80009e4:	3848      	subs	r0, #72	; 0x48
 80009e6:	4283      	cmp	r3, r0
 80009e8:	f000 8106 	beq.w	8000bf8 <HAL_DMA_IRQHandler+0x4e8>
 80009ec:	3060      	adds	r0, #96	; 0x60
 80009ee:	4283      	cmp	r3, r0
 80009f0:	f000 8104 	beq.w	8000bfc <HAL_DMA_IRQHandler+0x4ec>
 80009f4:	3848      	subs	r0, #72	; 0x48
 80009f6:	4283      	cmp	r3, r0
 80009f8:	f000 8102 	beq.w	8000c00 <HAL_DMA_IRQHandler+0x4f0>
 80009fc:	3060      	adds	r0, #96	; 0x60
 80009fe:	4283      	cmp	r3, r0
 8000a00:	bf0c      	ite	eq
 8000a02:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000a06:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000a0a:	e0c4      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000a0c:	2308      	movs	r3, #8
 8000a0e:	e7c3      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a10:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a14:	e7c0      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a16:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a1a:	e7bd      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a1c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000a20:	e7ba      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a22:	bf00      	nop
 8000a24:	40026458 	.word	0x40026458
 8000a28:	40026010 	.word	0x40026010
 8000a2c:	40026400 	.word	0x40026400
 8000a30:	400260b8 	.word	0x400260b8
 8000a34:	40026058 	.word	0x40026058
 8000a38:	40026000 	.word	0x40026000
 8000a3c:	4ab5      	ldr	r2, [pc, #724]	; (8000d14 <HAL_DMA_IRQHandler+0x604>)
 8000a3e:	4293      	cmp	r3, r2
 8000a40:	d927      	bls.n	8000a92 <HAL_DMA_IRQHandler+0x382>
 8000a42:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000a46:	3aa8      	subs	r2, #168	; 0xa8
 8000a48:	4293      	cmp	r3, r2
 8000a4a:	d013      	beq.n	8000a74 <HAL_DMA_IRQHandler+0x364>
 8000a4c:	3260      	adds	r2, #96	; 0x60
 8000a4e:	4293      	cmp	r3, r2
 8000a50:	d014      	beq.n	8000a7c <HAL_DMA_IRQHandler+0x36c>
 8000a52:	3a48      	subs	r2, #72	; 0x48
 8000a54:	4293      	cmp	r3, r2
 8000a56:	d013      	beq.n	8000a80 <HAL_DMA_IRQHandler+0x370>
 8000a58:	3260      	adds	r2, #96	; 0x60
 8000a5a:	4293      	cmp	r3, r2
 8000a5c:	d013      	beq.n	8000a86 <HAL_DMA_IRQHandler+0x376>
 8000a5e:	3a48      	subs	r2, #72	; 0x48
 8000a60:	4293      	cmp	r3, r2
 8000a62:	d013      	beq.n	8000a8c <HAL_DMA_IRQHandler+0x37c>
 8000a64:	3260      	adds	r2, #96	; 0x60
 8000a66:	4293      	cmp	r3, r2
 8000a68:	bf0c      	ite	eq
 8000a6a:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 8000a6e:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000a72:	e000      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a74:	2308      	movs	r3, #8
 8000a76:	4aa8      	ldr	r2, [pc, #672]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000a78:	6093      	str	r3, [r2, #8]
 8000a7a:	e78f      	b.n	800099c <HAL_DMA_IRQHandler+0x28c>
 8000a7c:	2308      	movs	r3, #8
 8000a7e:	e7fa      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a80:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a84:	e7f7      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a86:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a8a:	e7f4      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a8c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000a90:	e7f1      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a92:	4aa2      	ldr	r2, [pc, #648]	; (8000d1c <HAL_DMA_IRQHandler+0x60c>)
 8000a94:	4293      	cmp	r3, r2
 8000a96:	d927      	bls.n	8000ae8 <HAL_DMA_IRQHandler+0x3d8>
 8000a98:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000a9c:	3a48      	subs	r2, #72	; 0x48
 8000a9e:	4293      	cmp	r3, r2
 8000aa0:	d013      	beq.n	8000aca <HAL_DMA_IRQHandler+0x3ba>
 8000aa2:	3260      	adds	r2, #96	; 0x60
 8000aa4:	4293      	cmp	r3, r2
 8000aa6:	d014      	beq.n	8000ad2 <HAL_DMA_IRQHandler+0x3c2>
 8000aa8:	3a48      	subs	r2, #72	; 0x48
 8000aaa:	4293      	cmp	r3, r2
 8000aac:	d013      	beq.n	8000ad6 <HAL_DMA_IRQHandler+0x3c6>
 8000aae:	3260      	adds	r2, #96	; 0x60
 8000ab0:	4293      	cmp	r3, r2
 8000ab2:	d013      	beq.n	8000adc <HAL_DMA_IRQHandler+0x3cc>
 8000ab4:	3a48      	subs	r2, #72	; 0x48
 8000ab6:	4293      	cmp	r3, r2
 8000ab8:	d013      	beq.n	8000ae2 <HAL_DMA_IRQHandler+0x3d2>
 8000aba:	3260      	adds	r2, #96	; 0x60
 8000abc:	4293      	cmp	r3, r2
 8000abe:	bf0c      	ite	eq
 8000ac0:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 8000ac4:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000ac8:	e000      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000aca:	2308      	movs	r3, #8
 8000acc:	4a94      	ldr	r2, [pc, #592]	; (8000d20 <HAL_DMA_IRQHandler+0x610>)
 8000ace:	60d3      	str	r3, [r2, #12]
 8000ad0:	e764      	b.n	800099c <HAL_DMA_IRQHandler+0x28c>
 8000ad2:	2308      	movs	r3, #8
 8000ad4:	e7fa      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000ad6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ada:	e7f7      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000adc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ae0:	e7f4      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000ae2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000ae6:	e7f1      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000ae8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000aec:	4a8d      	ldr	r2, [pc, #564]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000aee:	4293      	cmp	r3, r2
 8000af0:	d013      	beq.n	8000b1a <HAL_DMA_IRQHandler+0x40a>
 8000af2:	3260      	adds	r2, #96	; 0x60
 8000af4:	4293      	cmp	r3, r2
 8000af6:	d014      	beq.n	8000b22 <HAL_DMA_IRQHandler+0x412>
 8000af8:	3a48      	subs	r2, #72	; 0x48
 8000afa:	4293      	cmp	r3, r2
 8000afc:	d013      	beq.n	8000b26 <HAL_DMA_IRQHandler+0x416>
 8000afe:	3260      	adds	r2, #96	; 0x60
 8000b00:	4293      	cmp	r3, r2
 8000b02:	d013      	beq.n	8000b2c <HAL_DMA_IRQHandler+0x41c>
 8000b04:	3a48      	subs	r2, #72	; 0x48
 8000b06:	4293      	cmp	r3, r2
 8000b08:	d013      	beq.n	8000b32 <HAL_DMA_IRQHandler+0x422>
 8000b0a:	3260      	adds	r2, #96	; 0x60
 8000b0c:	4293      	cmp	r3, r2
 8000b0e:	bf0c      	ite	eq
 8000b10:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 8000b14:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000b18:	e000      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b1a:	2308      	movs	r3, #8
 8000b1c:	4a80      	ldr	r2, [pc, #512]	; (8000d20 <HAL_DMA_IRQHandler+0x610>)
 8000b1e:	6093      	str	r3, [r2, #8]
 8000b20:	e73c      	b.n	800099c <HAL_DMA_IRQHandler+0x28c>
 8000b22:	2308      	movs	r3, #8
 8000b24:	e7fa      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b26:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000b2a:	e7f7      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b2c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000b30:	e7f4      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b32:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000b36:	e7f1      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000b38:	4b7b      	ldr	r3, [pc, #492]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000b3a:	4213      	tst	r3, r2
 8000b3c:	d12e      	bne.n	8000b9c <HAL_DMA_IRQHandler+0x48c>
        hdma->XferErrorCallback(hdma);
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000b3e:	6822      	ldr	r2, [r4, #0]
 8000b40:	4613      	mov	r3, r2
 8000b42:	4975      	ldr	r1, [pc, #468]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000b44:	6849      	ldr	r1, [r1, #4]
 8000b46:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000b4a:	4876      	ldr	r0, [pc, #472]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000b4c:	4283      	cmp	r3, r0
 8000b4e:	f000 8167 	beq.w	8000e20 <HAL_DMA_IRQHandler+0x710>
 8000b52:	3060      	adds	r0, #96	; 0x60
 8000b54:	4283      	cmp	r3, r0
 8000b56:	f000 8188 	beq.w	8000e6a <HAL_DMA_IRQHandler+0x75a>
 8000b5a:	3848      	subs	r0, #72	; 0x48
 8000b5c:	4283      	cmp	r3, r0
 8000b5e:	f000 8186 	beq.w	8000e6e <HAL_DMA_IRQHandler+0x75e>
 8000b62:	3060      	adds	r0, #96	; 0x60
 8000b64:	4283      	cmp	r3, r0
 8000b66:	f000 8185 	beq.w	8000e74 <HAL_DMA_IRQHandler+0x764>
 8000b6a:	3848      	subs	r0, #72	; 0x48
 8000b6c:	4283      	cmp	r3, r0
 8000b6e:	f000 8184 	beq.w	8000e7a <HAL_DMA_IRQHandler+0x76a>
 8000b72:	3060      	adds	r0, #96	; 0x60
 8000b74:	4283      	cmp	r3, r0
 8000b76:	bf0c      	ite	eq
 8000b78:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000b7c:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000b80:	e14f      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000b82:	4b69      	ldr	r3, [pc, #420]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000b84:	e7d9      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b86:	2340      	movs	r3, #64	; 0x40
 8000b88:	e7d7      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b8a:	2340      	movs	r3, #64	; 0x40
 8000b8c:	e7d5      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b8e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000b92:	e7d2      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b94:	4b64      	ldr	r3, [pc, #400]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000b96:	4213      	tst	r3, r2
 8000b98:	f000 874c 	beq.w	8001a34 <HAL_DMA_IRQHandler+0x1324>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8000b9c:	694b      	ldr	r3, [r1, #20]
 8000b9e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8000ba2:	f000 8083 	beq.w	8000cac <HAL_DMA_IRQHandler+0x59c>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 8000ba6:	694b      	ldr	r3, [r1, #20]
 8000ba8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000bac:	614b      	str	r3, [r1, #20]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000bae:	6823      	ldr	r3, [r4, #0]
 8000bb0:	4a5e      	ldr	r2, [pc, #376]	; (8000d2c <HAL_DMA_IRQHandler+0x61c>)
 8000bb2:	4293      	cmp	r3, r2
 8000bb4:	f240 80bc 	bls.w	8000d30 <HAL_DMA_IRQHandler+0x620>
 8000bb8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000bbc:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 8000bc0:	4293      	cmp	r3, r2
 8000bc2:	d062      	beq.n	8000c8a <HAL_DMA_IRQHandler+0x57a>
 8000bc4:	3260      	adds	r2, #96	; 0x60
 8000bc6:	4293      	cmp	r3, r2
 8000bc8:	f000 809a 	beq.w	8000d00 <HAL_DMA_IRQHandler+0x5f0>
 8000bcc:	3a48      	subs	r2, #72	; 0x48
 8000bce:	4293      	cmp	r3, r2
 8000bd0:	f000 8098 	beq.w	8000d04 <HAL_DMA_IRQHandler+0x5f4>
 8000bd4:	3260      	adds	r2, #96	; 0x60
 8000bd6:	4293      	cmp	r3, r2
 8000bd8:	f000 8096 	beq.w	8000d08 <HAL_DMA_IRQHandler+0x5f8>
 8000bdc:	3a48      	subs	r2, #72	; 0x48
 8000bde:	4293      	cmp	r3, r2
 8000be0:	f000 8094 	beq.w	8000d0c <HAL_DMA_IRQHandler+0x5fc>
 8000be4:	3260      	adds	r2, #96	; 0x60
 8000be6:	4293      	cmp	r3, r2
 8000be8:	bf0c      	ite	eq
 8000bea:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000bee:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000bf2:	e04b      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000bf4:	4b4c      	ldr	r3, [pc, #304]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000bf6:	e7ce      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000bf8:	2340      	movs	r3, #64	; 0x40
 8000bfa:	e7cc      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000bfc:	2340      	movs	r3, #64	; 0x40
 8000bfe:	e7ca      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000c00:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c04:	e7c7      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000c06:	4a45      	ldr	r2, [pc, #276]	; (8000d1c <HAL_DMA_IRQHandler+0x60c>)
 8000c08:	4291      	cmp	r1, r2
 8000c0a:	f63f ae4f 	bhi.w	80008ac <HAL_DMA_IRQHandler+0x19c>
 8000c0e:	e697      	b.n	8000940 <HAL_DMA_IRQHandler+0x230>
 8000c10:	4b45      	ldr	r3, [pc, #276]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c12:	4213      	tst	r3, r2
 8000c14:	d1c2      	bne.n	8000b9c <HAL_DMA_IRQHandler+0x48c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000c16:	6822      	ldr	r2, [r4, #0]
 8000c18:	4613      	mov	r3, r2
 8000c1a:	e171      	b.n	8000f00 <HAL_DMA_IRQHandler+0x7f0>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000c1c:	4b42      	ldr	r3, [pc, #264]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c1e:	e7f8      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c20:	2340      	movs	r3, #64	; 0x40
 8000c22:	e7f6      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c24:	2340      	movs	r3, #64	; 0x40
 8000c26:	e7f4      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c28:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c2c:	e7f1      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c2e:	4b3e      	ldr	r3, [pc, #248]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c30:	4213      	tst	r3, r2
 8000c32:	d1b3      	bne.n	8000b9c <HAL_DMA_IRQHandler+0x48c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000c34:	6822      	ldr	r2, [r4, #0]
 8000c36:	4613      	mov	r3, r2
 8000c38:	4939      	ldr	r1, [pc, #228]	; (8000d20 <HAL_DMA_IRQHandler+0x610>)
 8000c3a:	6809      	ldr	r1, [r1, #0]
 8000c3c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000c40:	4838      	ldr	r0, [pc, #224]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000c42:	4283      	cmp	r3, r0
 8000c44:	f000 81a7 	beq.w	8000f96 <HAL_DMA_IRQHandler+0x886>
 8000c48:	3060      	adds	r0, #96	; 0x60
 8000c4a:	4283      	cmp	r3, r0
 8000c4c:	f000 81aa 	beq.w	8000fa4 <HAL_DMA_IRQHandler+0x894>
 8000c50:	3848      	subs	r0, #72	; 0x48
 8000c52:	4283      	cmp	r3, r0
 8000c54:	f000 81a8 	beq.w	8000fa8 <HAL_DMA_IRQHandler+0x898>
 8000c58:	3060      	adds	r0, #96	; 0x60
 8000c5a:	4283      	cmp	r3, r0
 8000c5c:	f000 81a7 	beq.w	8000fae <HAL_DMA_IRQHandler+0x89e>
 8000c60:	3848      	subs	r0, #72	; 0x48
 8000c62:	4283      	cmp	r3, r0
 8000c64:	f000 81a6 	beq.w	8000fb4 <HAL_DMA_IRQHandler+0x8a4>
 8000c68:	3060      	adds	r0, #96	; 0x60
 8000c6a:	4283      	cmp	r3, r0
 8000c6c:	bf0c      	ite	eq
 8000c6e:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000c72:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000c76:	e18f      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000c78:	4b2b      	ldr	r3, [pc, #172]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c7a:	e7d9      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
 8000c7c:	2340      	movs	r3, #64	; 0x40
 8000c7e:	e7d7      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
 8000c80:	2340      	movs	r3, #64	; 0x40
 8000c82:	e7d5      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
 8000c84:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c88:	e7d2      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000c8a:	4b27      	ldr	r3, [pc, #156]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c8c:	4a22      	ldr	r2, [pc, #136]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000c8e:	60d3      	str	r3, [r2, #12]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8000c90:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000c92:	f043 0302 	orr.w	r3, r3, #2
 8000c96:	64e3      	str	r3, [r4, #76]	; 0x4c
      hdma->State = HAL_DMA_STATE_ERROR;
 8000c98:	2304      	movs	r3, #4
 8000c9a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 8000c9e:	2300      	movs	r3, #0
 8000ca0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 8000ca4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000ca6:	b10b      	cbz	r3, 8000cac <HAL_DMA_IRQHandler+0x59c>
        hdma->XferErrorCallback(hdma);
 8000ca8:	4620      	mov	r0, r4
 8000caa:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000cac:	6822      	ldr	r2, [r4, #0]
 8000cae:	4613      	mov	r3, r2
 8000cb0:	491e      	ldr	r1, [pc, #120]	; (8000d2c <HAL_DMA_IRQHandler+0x61c>)
 8000cb2:	428a      	cmp	r2, r1
 8000cb4:	f63f af45 	bhi.w	8000b42 <HAL_DMA_IRQHandler+0x432>
 8000cb8:	4916      	ldr	r1, [pc, #88]	; (8000d14 <HAL_DMA_IRQHandler+0x604>)
 8000cba:	428a      	cmp	r2, r1
 8000cbc:	f240 811c 	bls.w	8000ef8 <HAL_DMA_IRQHandler+0x7e8>
 8000cc0:	4915      	ldr	r1, [pc, #84]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000cc2:	6809      	ldr	r1, [r1, #0]
 8000cc4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000cc8:	4816      	ldr	r0, [pc, #88]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000cca:	4283      	cmp	r3, r0
 8000ccc:	f000 80d8 	beq.w	8000e80 <HAL_DMA_IRQHandler+0x770>
 8000cd0:	3060      	adds	r0, #96	; 0x60
 8000cd2:	4283      	cmp	r3, r0
 8000cd4:	f000 8105 	beq.w	8000ee2 <HAL_DMA_IRQHandler+0x7d2>
 8000cd8:	3848      	subs	r0, #72	; 0x48
 8000cda:	4283      	cmp	r3, r0
 8000cdc:	f000 8103 	beq.w	8000ee6 <HAL_DMA_IRQHandler+0x7d6>
 8000ce0:	3060      	adds	r0, #96	; 0x60
 8000ce2:	4283      	cmp	r3, r0
 8000ce4:	f000 8102 	beq.w	8000eec <HAL_DMA_IRQHandler+0x7dc>
 8000ce8:	3848      	subs	r0, #72	; 0x48
 8000cea:	4283      	cmp	r3, r0
 8000cec:	f000 8101 	beq.w	8000ef2 <HAL_DMA_IRQHandler+0x7e2>
 8000cf0:	3060      	adds	r0, #96	; 0x60
 8000cf2:	4283      	cmp	r3, r0
 8000cf4:	bf0c      	ite	eq
 8000cf6:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000cfa:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000cfe:	e0c0      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000d00:	4b09      	ldr	r3, [pc, #36]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000d02:	e7c3      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d04:	2340      	movs	r3, #64	; 0x40
 8000d06:	e7c1      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d08:	2340      	movs	r3, #64	; 0x40
 8000d0a:	e7bf      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d0c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000d10:	e7bc      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d12:	bf00      	nop
 8000d14:	400260b8 	.word	0x400260b8
 8000d18:	40026400 	.word	0x40026400
 8000d1c:	40026058 	.word	0x40026058
 8000d20:	40026000 	.word	0x40026000
 8000d24:	40026010 	.word	0x40026010
 8000d28:	00800001 	.word	0x00800001
 8000d2c:	40026458 	.word	0x40026458
 8000d30:	4aa2      	ldr	r2, [pc, #648]	; (8000fbc <HAL_DMA_IRQHandler+0x8ac>)
 8000d32:	4293      	cmp	r3, r2
 8000d34:	d925      	bls.n	8000d82 <HAL_DMA_IRQHandler+0x672>
 8000d36:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000d3a:	3aa8      	subs	r2, #168	; 0xa8
 8000d3c:	4293      	cmp	r3, r2
 8000d3e:	d013      	beq.n	8000d68 <HAL_DMA_IRQHandler+0x658>
 8000d40:	3260      	adds	r2, #96	; 0x60
 8000d42:	4293      	cmp	r3, r2
 8000d44:	d014      	beq.n	8000d70 <HAL_DMA_IRQHandler+0x660>
 8000d46:	3a48      	subs	r2, #72	; 0x48
 8000d48:	4293      	cmp	r3, r2
 8000d4a:	d013      	beq.n	8000d74 <HAL_DMA_IRQHandler+0x664>
 8000d4c:	3260      	adds	r2, #96	; 0x60
 8000d4e:	4293      	cmp	r3, r2
 8000d50:	d012      	beq.n	8000d78 <HAL_DMA_IRQHandler+0x668>
 8000d52:	3a48      	subs	r2, #72	; 0x48
 8000d54:	4293      	cmp	r3, r2
 8000d56:	d011      	beq.n	8000d7c <HAL_DMA_IRQHandler+0x66c>
 8000d58:	3260      	adds	r2, #96	; 0x60
 8000d5a:	4293      	cmp	r3, r2
 8000d5c:	bf0c      	ite	eq
 8000d5e:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000d62:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000d66:	e000      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d68:	4b95      	ldr	r3, [pc, #596]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000d6a:	4a96      	ldr	r2, [pc, #600]	; (8000fc4 <HAL_DMA_IRQHandler+0x8b4>)
 8000d6c:	6093      	str	r3, [r2, #8]
 8000d6e:	e78f      	b.n	8000c90 <HAL_DMA_IRQHandler+0x580>
 8000d70:	4b93      	ldr	r3, [pc, #588]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000d72:	e7fa      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d74:	2340      	movs	r3, #64	; 0x40
 8000d76:	e7f8      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d78:	2340      	movs	r3, #64	; 0x40
 8000d7a:	e7f6      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d7c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000d80:	e7f3      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d82:	4a91      	ldr	r2, [pc, #580]	; (8000fc8 <HAL_DMA_IRQHandler+0x8b8>)
 8000d84:	4293      	cmp	r3, r2
 8000d86:	d925      	bls.n	8000dd4 <HAL_DMA_IRQHandler+0x6c4>
 8000d88:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000d8c:	3a48      	subs	r2, #72	; 0x48
 8000d8e:	4293      	cmp	r3, r2
 8000d90:	d013      	beq.n	8000dba <HAL_DMA_IRQHandler+0x6aa>
 8000d92:	3260      	adds	r2, #96	; 0x60
 8000d94:	4293      	cmp	r3, r2
 8000d96:	d014      	beq.n	8000dc2 <HAL_DMA_IRQHandler+0x6b2>
 8000d98:	3a48      	subs	r2, #72	; 0x48
 8000d9a:	4293      	cmp	r3, r2
 8000d9c:	d013      	beq.n	8000dc6 <HAL_DMA_IRQHandler+0x6b6>
 8000d9e:	3260      	adds	r2, #96	; 0x60
 8000da0:	4293      	cmp	r3, r2
 8000da2:	d012      	beq.n	8000dca <HAL_DMA_IRQHandler+0x6ba>
 8000da4:	3a48      	subs	r2, #72	; 0x48
 8000da6:	4293      	cmp	r3, r2
 8000da8:	d011      	beq.n	8000dce <HAL_DMA_IRQHandler+0x6be>
 8000daa:	3260      	adds	r2, #96	; 0x60
 8000dac:	4293      	cmp	r3, r2
 8000dae:	bf0c      	ite	eq
 8000db0:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000db4:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000db8:	e000      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dba:	4b81      	ldr	r3, [pc, #516]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000dbc:	4a83      	ldr	r2, [pc, #524]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000dbe:	60d3      	str	r3, [r2, #12]
 8000dc0:	e766      	b.n	8000c90 <HAL_DMA_IRQHandler+0x580>
 8000dc2:	4b7f      	ldr	r3, [pc, #508]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000dc4:	e7fa      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dc6:	2340      	movs	r3, #64	; 0x40
 8000dc8:	e7f8      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dca:	2340      	movs	r3, #64	; 0x40
 8000dcc:	e7f6      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000dd2:	e7f3      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dd4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000dd8:	4a7d      	ldr	r2, [pc, #500]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000dda:	4293      	cmp	r3, r2
 8000ddc:	d013      	beq.n	8000e06 <HAL_DMA_IRQHandler+0x6f6>
 8000dde:	3260      	adds	r2, #96	; 0x60
 8000de0:	4293      	cmp	r3, r2
 8000de2:	d014      	beq.n	8000e0e <HAL_DMA_IRQHandler+0x6fe>
 8000de4:	3a48      	subs	r2, #72	; 0x48
 8000de6:	4293      	cmp	r3, r2
 8000de8:	d013      	beq.n	8000e12 <HAL_DMA_IRQHandler+0x702>
 8000dea:	3260      	adds	r2, #96	; 0x60
 8000dec:	4293      	cmp	r3, r2
 8000dee:	d012      	beq.n	8000e16 <HAL_DMA_IRQHandler+0x706>
 8000df0:	3a48      	subs	r2, #72	; 0x48
 8000df2:	4293      	cmp	r3, r2
 8000df4:	d011      	beq.n	8000e1a <HAL_DMA_IRQHandler+0x70a>
 8000df6:	3260      	adds	r2, #96	; 0x60
 8000df8:	4293      	cmp	r3, r2
 8000dfa:	bf0c      	ite	eq
 8000dfc:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000e00:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000e04:	e000      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e06:	4b6e      	ldr	r3, [pc, #440]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000e08:	4a70      	ldr	r2, [pc, #448]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000e0a:	6093      	str	r3, [r2, #8]
 8000e0c:	e740      	b.n	8000c90 <HAL_DMA_IRQHandler+0x580>
 8000e0e:	4b6c      	ldr	r3, [pc, #432]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000e10:	e7fa      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e12:	2340      	movs	r3, #64	; 0x40
 8000e14:	e7f8      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e16:	2340      	movs	r3, #64	; 0x40
 8000e18:	e7f6      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e1a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000e1e:	e7f3      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000e20:	4b6c      	ldr	r3, [pc, #432]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000e22:	420b      	tst	r3, r1
 8000e24:	d130      	bne.n	8000e88 <HAL_DMA_IRQHandler+0x778>
        hdma->XferErrorCallback(hdma);
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000e26:	6822      	ldr	r2, [r4, #0]
 8000e28:	4611      	mov	r1, r2
 8000e2a:	4b66      	ldr	r3, [pc, #408]	; (8000fc4 <HAL_DMA_IRQHandler+0x8b4>)
 8000e2c:	6858      	ldr	r0, [r3, #4]
 8000e2e:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 8000e32:	4d67      	ldr	r5, [pc, #412]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000e34:	42ab      	cmp	r3, r5
 8000e36:	f000 8195 	beq.w	8001164 <HAL_DMA_IRQHandler+0xa54>
 8000e3a:	3560      	adds	r5, #96	; 0x60
 8000e3c:	42ab      	cmp	r3, r5
 8000e3e:	f000 81b6 	beq.w	80011ae <HAL_DMA_IRQHandler+0xa9e>
 8000e42:	3d48      	subs	r5, #72	; 0x48
 8000e44:	42ab      	cmp	r3, r5
 8000e46:	f000 81b4 	beq.w	80011b2 <HAL_DMA_IRQHandler+0xaa2>
 8000e4a:	3560      	adds	r5, #96	; 0x60
 8000e4c:	42ab      	cmp	r3, r5
 8000e4e:	f000 81b3 	beq.w	80011b8 <HAL_DMA_IRQHandler+0xaa8>
 8000e52:	3d48      	subs	r5, #72	; 0x48
 8000e54:	42ab      	cmp	r3, r5
 8000e56:	f000 81b2 	beq.w	80011be <HAL_DMA_IRQHandler+0xaae>
 8000e5a:	3560      	adds	r5, #96	; 0x60
 8000e5c:	42ab      	cmp	r3, r5
 8000e5e:	bf0c      	ite	eq
 8000e60:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000e64:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000e68:	e17d      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000e6a:	4b5a      	ldr	r3, [pc, #360]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000e6c:	e7d9      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e6e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000e72:	e7d6      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e74:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000e78:	e7d3      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e7a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000e7e:	e7d0      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e80:	4b54      	ldr	r3, [pc, #336]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000e82:	420b      	tst	r3, r1
 8000e84:	f000 85da 	beq.w	8001a3c <HAL_DMA_IRQHandler+0x132c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8000e88:	6813      	ldr	r3, [r2, #0]
 8000e8a:	f013 0f02 	tst.w	r3, #2
 8000e8e:	f000 80b6 	beq.w	8000ffe <HAL_DMA_IRQHandler+0x8ee>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 8000e92:	6813      	ldr	r3, [r2, #0]
 8000e94:	f023 0302 	bic.w	r3, r3, #2
 8000e98:	6013      	str	r3, [r2, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000e9a:	6823      	ldr	r3, [r4, #0]
 8000e9c:	4a4e      	ldr	r2, [pc, #312]	; (8000fd8 <HAL_DMA_IRQHandler+0x8c8>)
 8000e9e:	4293      	cmp	r3, r2
 8000ea0:	f240 80e2 	bls.w	8001068 <HAL_DMA_IRQHandler+0x958>
 8000ea4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000ea8:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 8000eac:	4293      	cmp	r3, r2
 8000eae:	f000 8095 	beq.w	8000fdc <HAL_DMA_IRQHandler+0x8cc>
 8000eb2:	3260      	adds	r2, #96	; 0x60
 8000eb4:	4293      	cmp	r3, r2
 8000eb6:	f000 80cc 	beq.w	8001052 <HAL_DMA_IRQHandler+0x942>
 8000eba:	3a48      	subs	r2, #72	; 0x48
 8000ebc:	4293      	cmp	r3, r2
 8000ebe:	f000 80ca 	beq.w	8001056 <HAL_DMA_IRQHandler+0x946>
 8000ec2:	3260      	adds	r2, #96	; 0x60
 8000ec4:	4293      	cmp	r3, r2
 8000ec6:	f000 80c9 	beq.w	800105c <HAL_DMA_IRQHandler+0x94c>
 8000eca:	3a48      	subs	r2, #72	; 0x48
 8000ecc:	4293      	cmp	r3, r2
 8000ece:	f000 80c8 	beq.w	8001062 <HAL_DMA_IRQHandler+0x952>
 8000ed2:	3260      	adds	r2, #96	; 0x60
 8000ed4:	4293      	cmp	r3, r2
 8000ed6:	bf0c      	ite	eq
 8000ed8:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000edc:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000ee0:	e07d      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000ee2:	4b3c      	ldr	r3, [pc, #240]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000ee4:	e7cd      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000ee6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000eea:	e7ca      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000eec:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000ef0:	e7c7      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000ef2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000ef6:	e7c4      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000ef8:	4933      	ldr	r1, [pc, #204]	; (8000fc8 <HAL_DMA_IRQHandler+0x8b8>)
 8000efa:	428a      	cmp	r2, r1
 8000efc:	f67f ae9c 	bls.w	8000c38 <HAL_DMA_IRQHandler+0x528>
 8000f00:	4932      	ldr	r1, [pc, #200]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000f02:	6849      	ldr	r1, [r1, #4]
 8000f04:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000f08:	4831      	ldr	r0, [pc, #196]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000f0a:	4283      	cmp	r3, r0
 8000f0c:	d013      	beq.n	8000f36 <HAL_DMA_IRQHandler+0x826>
 8000f0e:	3060      	adds	r0, #96	; 0x60
 8000f10:	4283      	cmp	r3, r0
 8000f12:	d035      	beq.n	8000f80 <HAL_DMA_IRQHandler+0x870>
 8000f14:	3848      	subs	r0, #72	; 0x48
 8000f16:	4283      	cmp	r3, r0
 8000f18:	d034      	beq.n	8000f84 <HAL_DMA_IRQHandler+0x874>
 8000f1a:	3060      	adds	r0, #96	; 0x60
 8000f1c:	4283      	cmp	r3, r0
 8000f1e:	d034      	beq.n	8000f8a <HAL_DMA_IRQHandler+0x87a>
 8000f20:	3848      	subs	r0, #72	; 0x48
 8000f22:	4283      	cmp	r3, r0
 8000f24:	d034      	beq.n	8000f90 <HAL_DMA_IRQHandler+0x880>
 8000f26:	3060      	adds	r0, #96	; 0x60
 8000f28:	4283      	cmp	r3, r0
 8000f2a:	bf0c      	ite	eq
 8000f2c:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000f30:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000f34:	e000      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f36:	4b27      	ldr	r3, [pc, #156]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000f38:	420b      	tst	r3, r1
 8000f3a:	d1a5      	bne.n	8000e88 <HAL_DMA_IRQHandler+0x778>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000f3c:	6822      	ldr	r2, [r4, #0]
 8000f3e:	4611      	mov	r1, r2
 8000f40:	4b22      	ldr	r3, [pc, #136]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000f42:	6858      	ldr	r0, [r3, #4]
 8000f44:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 8000f48:	4d21      	ldr	r5, [pc, #132]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000f4a:	42ab      	cmp	r3, r5
 8000f4c:	f000 8195 	beq.w	800127a <HAL_DMA_IRQHandler+0xb6a>
 8000f50:	3560      	adds	r5, #96	; 0x60
 8000f52:	42ab      	cmp	r3, r5
 8000f54:	f000 81b6 	beq.w	80012c4 <HAL_DMA_IRQHandler+0xbb4>
 8000f58:	3d48      	subs	r5, #72	; 0x48
 8000f5a:	42ab      	cmp	r3, r5
 8000f5c:	f000 81b4 	beq.w	80012c8 <HAL_DMA_IRQHandler+0xbb8>
 8000f60:	3560      	adds	r5, #96	; 0x60
 8000f62:	42ab      	cmp	r3, r5
 8000f64:	f000 81b3 	beq.w	80012ce <HAL_DMA_IRQHandler+0xbbe>
 8000f68:	3d48      	subs	r5, #72	; 0x48
 8000f6a:	42ab      	cmp	r3, r5
 8000f6c:	f000 81b2 	beq.w	80012d4 <HAL_DMA_IRQHandler+0xbc4>
 8000f70:	3560      	adds	r5, #96	; 0x60
 8000f72:	42ab      	cmp	r3, r5
 8000f74:	bf0c      	ite	eq
 8000f76:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000f7a:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000f7e:	e17d      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000f80:	4b14      	ldr	r3, [pc, #80]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000f82:	e7d9      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f84:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000f88:	e7d6      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f8a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000f8e:	e7d3      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f90:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000f94:	e7d0      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f96:	4b0f      	ldr	r3, [pc, #60]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000f98:	420b      	tst	r3, r1
 8000f9a:	f47f af75 	bne.w	8000e88 <HAL_DMA_IRQHandler+0x778>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000f9e:	6822      	ldr	r2, [r4, #0]
 8000fa0:	4611      	mov	r1, r2
 8000fa2:	e14f      	b.n	8001244 <HAL_DMA_IRQHandler+0xb34>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000fa4:	4b0b      	ldr	r3, [pc, #44]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000fa6:	e7f7      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fa8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000fac:	e7f4      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fae:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000fb2:	e7f1      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fb4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000fb8:	e7ee      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fba:	bf00      	nop
 8000fbc:	400260b8 	.word	0x400260b8
 8000fc0:	00800001 	.word	0x00800001
 8000fc4:	40026400 	.word	0x40026400
 8000fc8:	40026058 	.word	0x40026058
 8000fcc:	40026000 	.word	0x40026000
 8000fd0:	40026010 	.word	0x40026010
 8000fd4:	00800004 	.word	0x00800004
 8000fd8:	40026458 	.word	0x40026458
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000fdc:	4bbf      	ldr	r3, [pc, #764]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8000fde:	4ac0      	ldr	r2, [pc, #768]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 8000fe0:	60d3      	str	r3, [r2, #12]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8000fe2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000fe4:	f043 0304 	orr.w	r3, r3, #4
 8000fe8:	64e3      	str	r3, [r4, #76]	; 0x4c
      hdma->State = HAL_DMA_STATE_ERROR;
 8000fea:	2304      	movs	r3, #4
 8000fec:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 8000ff0:	2300      	movs	r3, #0
 8000ff2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 8000ff6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000ff8:	b10b      	cbz	r3, 8000ffe <HAL_DMA_IRQHandler+0x8ee>
        hdma->XferErrorCallback(hdma);
 8000ffa:	4620      	mov	r0, r4
 8000ffc:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000ffe:	6822      	ldr	r2, [r4, #0]
 8001000:	4611      	mov	r1, r2
 8001002:	4bb8      	ldr	r3, [pc, #736]	; (80012e4 <HAL_DMA_IRQHandler+0xbd4>)
 8001004:	429a      	cmp	r2, r3
 8001006:	f63f af10 	bhi.w	8000e2a <HAL_DMA_IRQHandler+0x71a>
 800100a:	4bb7      	ldr	r3, [pc, #732]	; (80012e8 <HAL_DMA_IRQHandler+0xbd8>)
 800100c:	429a      	cmp	r2, r3
 800100e:	f240 8115 	bls.w	800123c <HAL_DMA_IRQHandler+0xb2c>
 8001012:	4bb3      	ldr	r3, [pc, #716]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 8001014:	6818      	ldr	r0, [r3, #0]
 8001016:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 800101a:	4db4      	ldr	r5, [pc, #720]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800101c:	42ab      	cmp	r3, r5
 800101e:	f000 80d1 	beq.w	80011c4 <HAL_DMA_IRQHandler+0xab4>
 8001022:	3560      	adds	r5, #96	; 0x60
 8001024:	42ab      	cmp	r3, r5
 8001026:	f000 80fe 	beq.w	8001226 <HAL_DMA_IRQHandler+0xb16>
 800102a:	3d48      	subs	r5, #72	; 0x48
 800102c:	42ab      	cmp	r3, r5
 800102e:	f000 80fc 	beq.w	800122a <HAL_DMA_IRQHandler+0xb1a>
 8001032:	3560      	adds	r5, #96	; 0x60
 8001034:	42ab      	cmp	r3, r5
 8001036:	f000 80fb 	beq.w	8001230 <HAL_DMA_IRQHandler+0xb20>
 800103a:	3d48      	subs	r5, #72	; 0x48
 800103c:	42ab      	cmp	r3, r5
 800103e:	f000 80fa 	beq.w	8001236 <HAL_DMA_IRQHandler+0xb26>
 8001042:	3560      	adds	r5, #96	; 0x60
 8001044:	42ab      	cmp	r3, r5
 8001046:	bf0c      	ite	eq
 8001048:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 800104c:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001050:	e0b9      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8001052:	4ba2      	ldr	r3, [pc, #648]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001054:	e7c3      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 8001056:	f44f 7380 	mov.w	r3, #256	; 0x100
 800105a:	e7c0      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 800105c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001060:	e7bd      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 8001062:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001066:	e7ba      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 8001068:	4a9f      	ldr	r2, [pc, #636]	; (80012e8 <HAL_DMA_IRQHandler+0xbd8>)
 800106a:	4293      	cmp	r3, r2
 800106c:	d927      	bls.n	80010be <HAL_DMA_IRQHandler+0x9ae>
 800106e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001072:	3aa8      	subs	r2, #168	; 0xa8
 8001074:	4293      	cmp	r3, r2
 8001076:	d013      	beq.n	80010a0 <HAL_DMA_IRQHandler+0x990>
 8001078:	3260      	adds	r2, #96	; 0x60
 800107a:	4293      	cmp	r3, r2
 800107c:	d014      	beq.n	80010a8 <HAL_DMA_IRQHandler+0x998>
 800107e:	3a48      	subs	r2, #72	; 0x48
 8001080:	4293      	cmp	r3, r2
 8001082:	d013      	beq.n	80010ac <HAL_DMA_IRQHandler+0x99c>
 8001084:	3260      	adds	r2, #96	; 0x60
 8001086:	4293      	cmp	r3, r2
 8001088:	d013      	beq.n	80010b2 <HAL_DMA_IRQHandler+0x9a2>
 800108a:	3a48      	subs	r2, #72	; 0x48
 800108c:	4293      	cmp	r3, r2
 800108e:	d013      	beq.n	80010b8 <HAL_DMA_IRQHandler+0x9a8>
 8001090:	3260      	adds	r2, #96	; 0x60
 8001092:	4293      	cmp	r3, r2
 8001094:	bf0c      	ite	eq
 8001096:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 800109a:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 800109e:	e000      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010a0:	4b8e      	ldr	r3, [pc, #568]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 80010a2:	4a8f      	ldr	r2, [pc, #572]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 80010a4:	6093      	str	r3, [r2, #8]
 80010a6:	e79c      	b.n	8000fe2 <HAL_DMA_IRQHandler+0x8d2>
 80010a8:	4b8c      	ldr	r3, [pc, #560]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 80010aa:	e7fa      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010ac:	f44f 7380 	mov.w	r3, #256	; 0x100
 80010b0:	e7f7      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010b2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80010b6:	e7f4      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010b8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80010bc:	e7f1      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010be:	4a8c      	ldr	r2, [pc, #560]	; (80012f0 <HAL_DMA_IRQHandler+0xbe0>)
 80010c0:	4293      	cmp	r3, r2
 80010c2:	d927      	bls.n	8001114 <HAL_DMA_IRQHandler+0xa04>
 80010c4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80010c8:	3a48      	subs	r2, #72	; 0x48
 80010ca:	4293      	cmp	r3, r2
 80010cc:	d013      	beq.n	80010f6 <HAL_DMA_IRQHandler+0x9e6>
 80010ce:	3260      	adds	r2, #96	; 0x60
 80010d0:	4293      	cmp	r3, r2
 80010d2:	d014      	beq.n	80010fe <HAL_DMA_IRQHandler+0x9ee>
 80010d4:	3a48      	subs	r2, #72	; 0x48
 80010d6:	4293      	cmp	r3, r2
 80010d8:	d013      	beq.n	8001102 <HAL_DMA_IRQHandler+0x9f2>
 80010da:	3260      	adds	r2, #96	; 0x60
 80010dc:	4293      	cmp	r3, r2
 80010de:	d013      	beq.n	8001108 <HAL_DMA_IRQHandler+0x9f8>
 80010e0:	3a48      	subs	r2, #72	; 0x48
 80010e2:	4293      	cmp	r3, r2
 80010e4:	d013      	beq.n	800110e <HAL_DMA_IRQHandler+0x9fe>
 80010e6:	3260      	adds	r2, #96	; 0x60
 80010e8:	4293      	cmp	r3, r2
 80010ea:	bf0c      	ite	eq
 80010ec:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 80010f0:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 80010f4:	e000      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 80010f6:	4b79      	ldr	r3, [pc, #484]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 80010f8:	4a7e      	ldr	r2, [pc, #504]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 80010fa:	60d3      	str	r3, [r2, #12]
 80010fc:	e771      	b.n	8000fe2 <HAL_DMA_IRQHandler+0x8d2>
 80010fe:	4b77      	ldr	r3, [pc, #476]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001100:	e7fa      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 8001102:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001106:	e7f7      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 8001108:	f44f 7380 	mov.w	r3, #256	; 0x100
 800110c:	e7f4      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 800110e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001112:	e7f1      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 8001114:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001118:	4a74      	ldr	r2, [pc, #464]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800111a:	4293      	cmp	r3, r2
 800111c:	d013      	beq.n	8001146 <HAL_DMA_IRQHandler+0xa36>
 800111e:	3260      	adds	r2, #96	; 0x60
 8001120:	4293      	cmp	r3, r2
 8001122:	d014      	beq.n	800114e <HAL_DMA_IRQHandler+0xa3e>
 8001124:	3a48      	subs	r2, #72	; 0x48
 8001126:	4293      	cmp	r3, r2
 8001128:	d013      	beq.n	8001152 <HAL_DMA_IRQHandler+0xa42>
 800112a:	3260      	adds	r2, #96	; 0x60
 800112c:	4293      	cmp	r3, r2
 800112e:	d013      	beq.n	8001158 <HAL_DMA_IRQHandler+0xa48>
 8001130:	3a48      	subs	r2, #72	; 0x48
 8001132:	4293      	cmp	r3, r2
 8001134:	d013      	beq.n	800115e <HAL_DMA_IRQHandler+0xa4e>
 8001136:	3260      	adds	r2, #96	; 0x60
 8001138:	4293      	cmp	r3, r2
 800113a:	bf0c      	ite	eq
 800113c:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8001140:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8001144:	e000      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 8001146:	4b65      	ldr	r3, [pc, #404]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001148:	4a6a      	ldr	r2, [pc, #424]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 800114a:	6093      	str	r3, [r2, #8]
 800114c:	e749      	b.n	8000fe2 <HAL_DMA_IRQHandler+0x8d2>
 800114e:	4b63      	ldr	r3, [pc, #396]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001150:	e7fa      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 8001152:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001156:	e7f7      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 8001158:	f44f 7380 	mov.w	r3, #256	; 0x100
 800115c:	e7f4      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 800115e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001162:	e7f1      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001164:	2310      	movs	r3, #16
 8001166:	4203      	tst	r3, r0
 8001168:	d130      	bne.n	80011cc <HAL_DMA_IRQHandler+0xabc>
        hdma->XferHalfCpltCallback(hdma);
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 800116a:	6822      	ldr	r2, [r4, #0]
 800116c:	4611      	mov	r1, r2
 800116e:	4b5c      	ldr	r3, [pc, #368]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 8001170:	6858      	ldr	r0, [r3, #4]
 8001172:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 8001176:	4d5d      	ldr	r5, [pc, #372]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 8001178:	42ab      	cmp	r3, r5
 800117a:	f000 825c 	beq.w	8001636 <HAL_DMA_IRQHandler+0xf26>
 800117e:	3560      	adds	r5, #96	; 0x60
 8001180:	42ab      	cmp	r3, r5
 8001182:	f000 8288 	beq.w	8001696 <HAL_DMA_IRQHandler+0xf86>
 8001186:	3d48      	subs	r5, #72	; 0x48
 8001188:	42ab      	cmp	r3, r5
 800118a:	f000 8286 	beq.w	800169a <HAL_DMA_IRQHandler+0xf8a>
 800118e:	3560      	adds	r5, #96	; 0x60
 8001190:	42ab      	cmp	r3, r5
 8001192:	f000 8285 	beq.w	80016a0 <HAL_DMA_IRQHandler+0xf90>
 8001196:	3d48      	subs	r5, #72	; 0x48
 8001198:	42ab      	cmp	r3, r5
 800119a:	f000 8284 	beq.w	80016a6 <HAL_DMA_IRQHandler+0xf96>
 800119e:	3560      	adds	r5, #96	; 0x60
 80011a0:	42ab      	cmp	r3, r5
 80011a2:	bf0c      	ite	eq
 80011a4:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80011a8:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80011ac:	e244      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 80011ae:	2310      	movs	r3, #16
 80011b0:	e7d9      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80011b6:	e7d6      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80011bc:	e7d3      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011be:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80011c2:	e7d0      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011c4:	2310      	movs	r3, #16
 80011c6:	4203      	tst	r3, r0
 80011c8:	f000 843c 	beq.w	8001a44 <HAL_DMA_IRQHandler+0x1334>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80011cc:	6813      	ldr	r3, [r2, #0]
 80011ce:	f013 0f08 	tst.w	r3, #8
 80011d2:	f000 8171 	beq.w	80014b8 <HAL_DMA_IRQHandler+0xda8>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 80011d6:	6813      	ldr	r3, [r2, #0]
 80011d8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80011dc:	f000 813c 	beq.w	8001458 <HAL_DMA_IRQHandler+0xd48>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80011e0:	4b40      	ldr	r3, [pc, #256]	; (80012e4 <HAL_DMA_IRQHandler+0xbd4>)
 80011e2:	4299      	cmp	r1, r3
 80011e4:	f240 80b2 	bls.w	800134c <HAL_DMA_IRQHandler+0xc3c>
 80011e8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80011ec:	f5a3 6389 	sub.w	r3, r3, #1096	; 0x448
 80011f0:	4299      	cmp	r1, r3
 80011f2:	f000 8093 	beq.w	800131c <HAL_DMA_IRQHandler+0xc0c>
 80011f6:	3360      	adds	r3, #96	; 0x60
 80011f8:	4299      	cmp	r1, r3
 80011fa:	f000 809c 	beq.w	8001336 <HAL_DMA_IRQHandler+0xc26>
 80011fe:	3b48      	subs	r3, #72	; 0x48
 8001200:	4299      	cmp	r1, r3
 8001202:	f000 809a 	beq.w	800133a <HAL_DMA_IRQHandler+0xc2a>
 8001206:	3360      	adds	r3, #96	; 0x60
 8001208:	4299      	cmp	r1, r3
 800120a:	f000 8099 	beq.w	8001340 <HAL_DMA_IRQHandler+0xc30>
 800120e:	3b48      	subs	r3, #72	; 0x48
 8001210:	4299      	cmp	r1, r3
 8001212:	f000 8098 	beq.w	8001346 <HAL_DMA_IRQHandler+0xc36>
 8001216:	3360      	adds	r3, #96	; 0x60
 8001218:	4299      	cmp	r1, r3
 800121a:	bf0c      	ite	eq
 800121c:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 8001220:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001224:	e07b      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001226:	2310      	movs	r3, #16
 8001228:	e7cd      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 800122a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800122e:	e7ca      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 8001230:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001234:	e7c7      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 8001236:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800123a:	e7c4      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 800123c:	4b2c      	ldr	r3, [pc, #176]	; (80012f0 <HAL_DMA_IRQHandler+0xbe0>)
 800123e:	429a      	cmp	r2, r3
 8001240:	f63f ae7e 	bhi.w	8000f40 <HAL_DMA_IRQHandler+0x830>
 8001244:	4b2b      	ldr	r3, [pc, #172]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 8001246:	6818      	ldr	r0, [r3, #0]
 8001248:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 800124c:	4d27      	ldr	r5, [pc, #156]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800124e:	42ab      	cmp	r3, r5
 8001250:	d052      	beq.n	80012f8 <HAL_DMA_IRQHandler+0xbe8>
 8001252:	3560      	adds	r5, #96	; 0x60
 8001254:	42ab      	cmp	r3, r5
 8001256:	d056      	beq.n	8001306 <HAL_DMA_IRQHandler+0xbf6>
 8001258:	3d48      	subs	r5, #72	; 0x48
 800125a:	42ab      	cmp	r3, r5
 800125c:	d055      	beq.n	800130a <HAL_DMA_IRQHandler+0xbfa>
 800125e:	3560      	adds	r5, #96	; 0x60
 8001260:	42ab      	cmp	r3, r5
 8001262:	d055      	beq.n	8001310 <HAL_DMA_IRQHandler+0xc00>
 8001264:	3d48      	subs	r5, #72	; 0x48
 8001266:	42ab      	cmp	r3, r5
 8001268:	d055      	beq.n	8001316 <HAL_DMA_IRQHandler+0xc06>
 800126a:	3560      	adds	r5, #96	; 0x60
 800126c:	42ab      	cmp	r3, r5
 800126e:	bf0c      	ite	eq
 8001270:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8001274:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001278:	e03f      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 800127a:	2310      	movs	r3, #16
 800127c:	4203      	tst	r3, r0
 800127e:	d1a5      	bne.n	80011cc <HAL_DMA_IRQHandler+0xabc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001280:	6822      	ldr	r2, [r4, #0]
 8001282:	4611      	mov	r1, r2
 8001284:	4b1b      	ldr	r3, [pc, #108]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 8001286:	6858      	ldr	r0, [r3, #4]
 8001288:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 800128c:	4d17      	ldr	r5, [pc, #92]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800128e:	42ab      	cmp	r3, r5
 8001290:	f000 823c 	beq.w	800170c <HAL_DMA_IRQHandler+0xffc>
 8001294:	3560      	adds	r5, #96	; 0x60
 8001296:	42ab      	cmp	r3, r5
 8001298:	f000 823e 	beq.w	8001718 <HAL_DMA_IRQHandler+0x1008>
 800129c:	3d48      	subs	r5, #72	; 0x48
 800129e:	42ab      	cmp	r3, r5
 80012a0:	f000 823c 	beq.w	800171c <HAL_DMA_IRQHandler+0x100c>
 80012a4:	3560      	adds	r5, #96	; 0x60
 80012a6:	42ab      	cmp	r3, r5
 80012a8:	f000 823b 	beq.w	8001722 <HAL_DMA_IRQHandler+0x1012>
 80012ac:	3d48      	subs	r5, #72	; 0x48
 80012ae:	42ab      	cmp	r3, r5
 80012b0:	f000 823a 	beq.w	8001728 <HAL_DMA_IRQHandler+0x1018>
 80012b4:	3560      	adds	r5, #96	; 0x60
 80012b6:	42ab      	cmp	r3, r5
 80012b8:	bf0c      	ite	eq
 80012ba:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80012be:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80012c2:	e224      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 80012c4:	2310      	movs	r3, #16
 80012c6:	e7d9      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80012cc:	e7d6      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80012d2:	e7d3      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012d4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80012d8:	e7d0      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012da:	bf00      	nop
 80012dc:	00800004 	.word	0x00800004
 80012e0:	40026400 	.word	0x40026400
 80012e4:	40026458 	.word	0x40026458
 80012e8:	400260b8 	.word	0x400260b8
 80012ec:	40026010 	.word	0x40026010
 80012f0:	40026058 	.word	0x40026058
 80012f4:	40026000 	.word	0x40026000
 80012f8:	2310      	movs	r3, #16
 80012fa:	4203      	tst	r3, r0
 80012fc:	f47f af66 	bne.w	80011cc <HAL_DMA_IRQHandler+0xabc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001300:	6822      	ldr	r2, [r4, #0]
 8001302:	4611      	mov	r1, r2
 8001304:	e1e7      	b.n	80016d6 <HAL_DMA_IRQHandler+0xfc6>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001306:	2310      	movs	r3, #16
 8001308:	e7f7      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 800130a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800130e:	e7f4      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 8001310:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001314:	e7f1      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 8001316:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800131a:	e7ee      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800131c:	2110      	movs	r1, #16
 800131e:	4bba      	ldr	r3, [pc, #744]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 8001320:	60d9      	str	r1, [r3, #12]
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8001322:	6823      	ldr	r3, [r4, #0]
 8001324:	681a      	ldr	r2, [r3, #0]
 8001326:	f412 2f00 	tst.w	r2, #524288	; 0x80000
 800132a:	f040 808d 	bne.w	8001448 <HAL_DMA_IRQHandler+0xd38>
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800132e:	2331      	movs	r3, #49	; 0x31
 8001330:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 8001334:	e0bc      	b.n	80014b0 <HAL_DMA_IRQHandler+0xda0>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001336:	2110      	movs	r1, #16
 8001338:	e7f1      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 800133a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800133e:	e7ee      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 8001340:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001344:	e7eb      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 8001346:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 800134a:	e7e8      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 800134c:	4baf      	ldr	r3, [pc, #700]	; (800160c <HAL_DMA_IRQHandler+0xefc>)
 800134e:	4299      	cmp	r1, r3
 8001350:	d927      	bls.n	80013a2 <HAL_DMA_IRQHandler+0xc92>
 8001352:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001356:	3ba8      	subs	r3, #168	; 0xa8
 8001358:	4299      	cmp	r1, r3
 800135a:	d013      	beq.n	8001384 <HAL_DMA_IRQHandler+0xc74>
 800135c:	3360      	adds	r3, #96	; 0x60
 800135e:	4299      	cmp	r1, r3
 8001360:	d014      	beq.n	800138c <HAL_DMA_IRQHandler+0xc7c>
 8001362:	3b48      	subs	r3, #72	; 0x48
 8001364:	4299      	cmp	r1, r3
 8001366:	d013      	beq.n	8001390 <HAL_DMA_IRQHandler+0xc80>
 8001368:	3360      	adds	r3, #96	; 0x60
 800136a:	4299      	cmp	r1, r3
 800136c:	d013      	beq.n	8001396 <HAL_DMA_IRQHandler+0xc86>
 800136e:	3b48      	subs	r3, #72	; 0x48
 8001370:	4299      	cmp	r1, r3
 8001372:	d013      	beq.n	800139c <HAL_DMA_IRQHandler+0xc8c>
 8001374:	3360      	adds	r3, #96	; 0x60
 8001376:	4299      	cmp	r1, r3
 8001378:	bf0c      	ite	eq
 800137a:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 800137e:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001382:	e000      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 8001384:	2110      	movs	r1, #16
 8001386:	4ba0      	ldr	r3, [pc, #640]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 8001388:	6099      	str	r1, [r3, #8]
 800138a:	e7ca      	b.n	8001322 <HAL_DMA_IRQHandler+0xc12>
 800138c:	2110      	movs	r1, #16
 800138e:	e7fa      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 8001390:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001394:	e7f7      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 8001396:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800139a:	e7f4      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 800139c:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 80013a0:	e7f1      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 80013a2:	4b9b      	ldr	r3, [pc, #620]	; (8001610 <HAL_DMA_IRQHandler+0xf00>)
 80013a4:	4299      	cmp	r1, r3
 80013a6:	d927      	bls.n	80013f8 <HAL_DMA_IRQHandler+0xce8>
 80013a8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80013ac:	3b48      	subs	r3, #72	; 0x48
 80013ae:	4299      	cmp	r1, r3
 80013b0:	d013      	beq.n	80013da <HAL_DMA_IRQHandler+0xcca>
 80013b2:	3360      	adds	r3, #96	; 0x60
 80013b4:	4299      	cmp	r1, r3
 80013b6:	d014      	beq.n	80013e2 <HAL_DMA_IRQHandler+0xcd2>
 80013b8:	3b48      	subs	r3, #72	; 0x48
 80013ba:	4299      	cmp	r1, r3
 80013bc:	d013      	beq.n	80013e6 <HAL_DMA_IRQHandler+0xcd6>
 80013be:	3360      	adds	r3, #96	; 0x60
 80013c0:	4299      	cmp	r1, r3
 80013c2:	d013      	beq.n	80013ec <HAL_DMA_IRQHandler+0xcdc>
 80013c4:	3b48      	subs	r3, #72	; 0x48
 80013c6:	4299      	cmp	r1, r3
 80013c8:	d013      	beq.n	80013f2 <HAL_DMA_IRQHandler+0xce2>
 80013ca:	3360      	adds	r3, #96	; 0x60
 80013cc:	4299      	cmp	r1, r3
 80013ce:	bf0c      	ite	eq
 80013d0:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 80013d4:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 80013d8:	e000      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013da:	2110      	movs	r1, #16
 80013dc:	4b8d      	ldr	r3, [pc, #564]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 80013de:	60d9      	str	r1, [r3, #12]
 80013e0:	e79f      	b.n	8001322 <HAL_DMA_IRQHandler+0xc12>
 80013e2:	2110      	movs	r1, #16
 80013e4:	e7fa      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013ea:	e7f7      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013ec:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013f0:	e7f4      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013f2:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 80013f6:	e7f1      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013f8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80013fc:	4b86      	ldr	r3, [pc, #536]	; (8001618 <HAL_DMA_IRQHandler+0xf08>)
 80013fe:	4299      	cmp	r1, r3
 8001400:	d013      	beq.n	800142a <HAL_DMA_IRQHandler+0xd1a>
 8001402:	3360      	adds	r3, #96	; 0x60
 8001404:	4299      	cmp	r1, r3
 8001406:	d014      	beq.n	8001432 <HAL_DMA_IRQHandler+0xd22>
 8001408:	3b48      	subs	r3, #72	; 0x48
 800140a:	4299      	cmp	r1, r3
 800140c:	d013      	beq.n	8001436 <HAL_DMA_IRQHandler+0xd26>
 800140e:	3360      	adds	r3, #96	; 0x60
 8001410:	4299      	cmp	r1, r3
 8001412:	d013      	beq.n	800143c <HAL_DMA_IRQHandler+0xd2c>
 8001414:	3b48      	subs	r3, #72	; 0x48
 8001416:	4299      	cmp	r1, r3
 8001418:	d013      	beq.n	8001442 <HAL_DMA_IRQHandler+0xd32>
 800141a:	3360      	adds	r3, #96	; 0x60
 800141c:	4299      	cmp	r1, r3
 800141e:	bf0c      	ite	eq
 8001420:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 8001424:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001428:	e000      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 800142a:	2110      	movs	r1, #16
 800142c:	4b79      	ldr	r3, [pc, #484]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 800142e:	6099      	str	r1, [r3, #8]
 8001430:	e777      	b.n	8001322 <HAL_DMA_IRQHandler+0xc12>
 8001432:	2110      	movs	r1, #16
 8001434:	e7fa      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 8001436:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800143a:	e7f7      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 800143c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001440:	e7f4      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 8001442:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 8001446:	e7f1      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 800144e:	d02f      	beq.n	80014b0 <HAL_DMA_IRQHandler+0xda0>
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 8001450:	2341      	movs	r3, #65	; 0x41
 8001452:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 8001456:	e02b      	b.n	80014b0 <HAL_DMA_IRQHandler+0xda0>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001458:	6813      	ldr	r3, [r2, #0]
 800145a:	f413 7f80 	tst.w	r3, #256	; 0x100
 800145e:	d103      	bne.n	8001468 <HAL_DMA_IRQHandler+0xd58>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8001460:	6813      	ldr	r3, [r2, #0]
 8001462:	f023 0308 	bic.w	r3, r3, #8
 8001466:	6013      	str	r3, [r2, #0]
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001468:	6823      	ldr	r3, [r4, #0]
 800146a:	4a6c      	ldr	r2, [pc, #432]	; (800161c <HAL_DMA_IRQHandler+0xf0c>)
 800146c:	4293      	cmp	r3, r2
 800146e:	d958      	bls.n	8001522 <HAL_DMA_IRQHandler+0xe12>
 8001470:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001474:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 8001478:	4293      	cmp	r3, r2
 800147a:	d013      	beq.n	80014a4 <HAL_DMA_IRQHandler+0xd94>
 800147c:	3260      	adds	r2, #96	; 0x60
 800147e:	4293      	cmp	r3, r2
 8001480:	d044      	beq.n	800150c <HAL_DMA_IRQHandler+0xdfc>
 8001482:	3a48      	subs	r2, #72	; 0x48
 8001484:	4293      	cmp	r3, r2
 8001486:	d043      	beq.n	8001510 <HAL_DMA_IRQHandler+0xe00>
 8001488:	3260      	adds	r2, #96	; 0x60
 800148a:	4293      	cmp	r3, r2
 800148c:	d043      	beq.n	8001516 <HAL_DMA_IRQHandler+0xe06>
 800148e:	3a48      	subs	r2, #72	; 0x48
 8001490:	4293      	cmp	r3, r2
 8001492:	d043      	beq.n	800151c <HAL_DMA_IRQHandler+0xe0c>
 8001494:	3260      	adds	r2, #96	; 0x60
 8001496:	4293      	cmp	r3, r2
 8001498:	bf0c      	ite	eq
 800149a:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 800149e:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80014a2:	e000      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 80014a4:	2310      	movs	r3, #16
 80014a6:	4a58      	ldr	r2, [pc, #352]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 80014a8:	60d3      	str	r3, [r2, #12]
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 80014aa:	2331      	movs	r3, #49	; 0x31
 80014ac:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      if(hdma->XferHalfCpltCallback != NULL)
 80014b0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80014b2:	b10b      	cbz	r3, 80014b8 <HAL_DMA_IRQHandler+0xda8>
        hdma->XferHalfCpltCallback(hdma);
 80014b4:	4620      	mov	r0, r4
 80014b6:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 80014b8:	6822      	ldr	r2, [r4, #0]
 80014ba:	4611      	mov	r1, r2
 80014bc:	4b57      	ldr	r3, [pc, #348]	; (800161c <HAL_DMA_IRQHandler+0xf0c>)
 80014be:	429a      	cmp	r2, r3
 80014c0:	f63f ae55 	bhi.w	800116e <HAL_DMA_IRQHandler+0xa5e>
 80014c4:	4b51      	ldr	r3, [pc, #324]	; (800160c <HAL_DMA_IRQHandler+0xefc>)
 80014c6:	429a      	cmp	r2, r3
 80014c8:	f240 8101 	bls.w	80016ce <HAL_DMA_IRQHandler+0xfbe>
 80014cc:	4b4e      	ldr	r3, [pc, #312]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 80014ce:	6818      	ldr	r0, [r3, #0]
 80014d0:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 80014d4:	4d50      	ldr	r5, [pc, #320]	; (8001618 <HAL_DMA_IRQHandler+0xf08>)
 80014d6:	42ab      	cmp	r3, r5
 80014d8:	f000 80e8 	beq.w	80016ac <HAL_DMA_IRQHandler+0xf9c>
 80014dc:	3560      	adds	r5, #96	; 0x60
 80014de:	42ab      	cmp	r3, r5
 80014e0:	f000 80ea 	beq.w	80016b8 <HAL_DMA_IRQHandler+0xfa8>
 80014e4:	3d48      	subs	r5, #72	; 0x48
 80014e6:	42ab      	cmp	r3, r5
 80014e8:	f000 80e8 	beq.w	80016bc <HAL_DMA_IRQHandler+0xfac>
 80014ec:	3560      	adds	r5, #96	; 0x60
 80014ee:	42ab      	cmp	r3, r5
 80014f0:	f000 80e7 	beq.w	80016c2 <HAL_DMA_IRQHandler+0xfb2>
 80014f4:	3d48      	subs	r5, #72	; 0x48
 80014f6:	42ab      	cmp	r3, r5
 80014f8:	f000 80e6 	beq.w	80016c8 <HAL_DMA_IRQHandler+0xfb8>
 80014fc:	3560      	adds	r5, #96	; 0x60
 80014fe:	42ab      	cmp	r3, r5
 8001500:	bf0c      	ite	eq
 8001502:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001506:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800150a:	e0d0      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800150c:	2310      	movs	r3, #16
 800150e:	e7ca      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 8001510:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001514:	e7c7      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 8001516:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800151a:	e7c4      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 800151c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001520:	e7c1      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 8001522:	4a3a      	ldr	r2, [pc, #232]	; (800160c <HAL_DMA_IRQHandler+0xefc>)
 8001524:	4293      	cmp	r3, r2
 8001526:	d927      	bls.n	8001578 <HAL_DMA_IRQHandler+0xe68>
 8001528:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800152c:	3aa8      	subs	r2, #168	; 0xa8
 800152e:	4293      	cmp	r3, r2
 8001530:	d013      	beq.n	800155a <HAL_DMA_IRQHandler+0xe4a>
 8001532:	3260      	adds	r2, #96	; 0x60
 8001534:	4293      	cmp	r3, r2
 8001536:	d014      	beq.n	8001562 <HAL_DMA_IRQHandler+0xe52>
 8001538:	3a48      	subs	r2, #72	; 0x48
 800153a:	4293      	cmp	r3, r2
 800153c:	d013      	beq.n	8001566 <HAL_DMA_IRQHandler+0xe56>
 800153e:	3260      	adds	r2, #96	; 0x60
 8001540:	4293      	cmp	r3, r2
 8001542:	d013      	beq.n	800156c <HAL_DMA_IRQHandler+0xe5c>
 8001544:	3a48      	subs	r2, #72	; 0x48
 8001546:	4293      	cmp	r3, r2
 8001548:	d013      	beq.n	8001572 <HAL_DMA_IRQHandler+0xe62>
 800154a:	3260      	adds	r2, #96	; 0x60
 800154c:	4293      	cmp	r3, r2
 800154e:	bf0c      	ite	eq
 8001550:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8001554:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001558:	e000      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 800155a:	2310      	movs	r3, #16
 800155c:	4a2a      	ldr	r2, [pc, #168]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 800155e:	6093      	str	r3, [r2, #8]
 8001560:	e7a3      	b.n	80014aa <HAL_DMA_IRQHandler+0xd9a>
 8001562:	2310      	movs	r3, #16
 8001564:	e7fa      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 8001566:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800156a:	e7f7      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 800156c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001570:	e7f4      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 8001572:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001576:	e7f1      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 8001578:	4a25      	ldr	r2, [pc, #148]	; (8001610 <HAL_DMA_IRQHandler+0xf00>)
 800157a:	4293      	cmp	r3, r2
 800157c:	d927      	bls.n	80015ce <HAL_DMA_IRQHandler+0xebe>
 800157e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001582:	3a48      	subs	r2, #72	; 0x48
 8001584:	4293      	cmp	r3, r2
 8001586:	d013      	beq.n	80015b0 <HAL_DMA_IRQHandler+0xea0>
 8001588:	3260      	adds	r2, #96	; 0x60
 800158a:	4293      	cmp	r3, r2
 800158c:	d014      	beq.n	80015b8 <HAL_DMA_IRQHandler+0xea8>
 800158e:	3a48      	subs	r2, #72	; 0x48
 8001590:	4293      	cmp	r3, r2
 8001592:	d013      	beq.n	80015bc <HAL_DMA_IRQHandler+0xeac>
 8001594:	3260      	adds	r2, #96	; 0x60
 8001596:	4293      	cmp	r3, r2
 8001598:	d013      	beq.n	80015c2 <HAL_DMA_IRQHandler+0xeb2>
 800159a:	3a48      	subs	r2, #72	; 0x48
 800159c:	4293      	cmp	r3, r2
 800159e:	d013      	beq.n	80015c8 <HAL_DMA_IRQHandler+0xeb8>
 80015a0:	3260      	adds	r2, #96	; 0x60
 80015a2:	4293      	cmp	r3, r2
 80015a4:	bf0c      	ite	eq
 80015a6:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 80015aa:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80015ae:	e000      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015b0:	2310      	movs	r3, #16
 80015b2:	4a18      	ldr	r2, [pc, #96]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 80015b4:	60d3      	str	r3, [r2, #12]
 80015b6:	e778      	b.n	80014aa <HAL_DMA_IRQHandler+0xd9a>
 80015b8:	2310      	movs	r3, #16
 80015ba:	e7fa      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80015c0:	e7f7      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015c2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80015c6:	e7f4      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80015cc:	e7f1      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015ce:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80015d2:	4a11      	ldr	r2, [pc, #68]	; (8001618 <HAL_DMA_IRQHandler+0xf08>)
 80015d4:	4293      	cmp	r3, r2
 80015d6:	d013      	beq.n	8001600 <HAL_DMA_IRQHandler+0xef0>
 80015d8:	3260      	adds	r2, #96	; 0x60
 80015da:	4293      	cmp	r3, r2
 80015dc:	d020      	beq.n	8001620 <HAL_DMA_IRQHandler+0xf10>
 80015de:	3a48      	subs	r2, #72	; 0x48
 80015e0:	4293      	cmp	r3, r2
 80015e2:	d01f      	beq.n	8001624 <HAL_DMA_IRQHandler+0xf14>
 80015e4:	3260      	adds	r2, #96	; 0x60
 80015e6:	4293      	cmp	r3, r2
 80015e8:	d01f      	beq.n	800162a <HAL_DMA_IRQHandler+0xf1a>
 80015ea:	3a48      	subs	r2, #72	; 0x48
 80015ec:	4293      	cmp	r3, r2
 80015ee:	d01f      	beq.n	8001630 <HAL_DMA_IRQHandler+0xf20>
 80015f0:	3260      	adds	r2, #96	; 0x60
 80015f2:	4293      	cmp	r3, r2
 80015f4:	bf0c      	ite	eq
 80015f6:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 80015fa:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80015fe:	e000      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 8001600:	2310      	movs	r3, #16
 8001602:	4a04      	ldr	r2, [pc, #16]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 8001604:	6093      	str	r3, [r2, #8]
 8001606:	e750      	b.n	80014aa <HAL_DMA_IRQHandler+0xd9a>
 8001608:	40026400 	.word	0x40026400
 800160c:	400260b8 	.word	0x400260b8
 8001610:	40026058 	.word	0x40026058
 8001614:	40026000 	.word	0x40026000
 8001618:	40026010 	.word	0x40026010
 800161c:	40026458 	.word	0x40026458
 8001620:	2310      	movs	r3, #16
 8001622:	e7ee      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 8001624:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001628:	e7eb      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 800162a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800162e:	e7e8      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 8001630:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001634:	e7e5      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001636:	2320      	movs	r3, #32
 8001638:	4203      	tst	r3, r0
 800163a:	bf14      	ite	ne
 800163c:	2301      	movne	r3, #1
 800163e:	2300      	moveq	r3, #0
 8001640:	2b00      	cmp	r3, #0
 8001642:	f000 8221 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8001646:	6813      	ldr	r3, [r2, #0]
 8001648:	f013 0f10 	tst.w	r3, #16
 800164c:	f000 821c 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8001650:	6813      	ldr	r3, [r2, #0]
 8001652:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8001656:	f000 8120 	beq.w	800189a <HAL_DMA_IRQHandler+0x118a>
      {
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800165a:	4bb1      	ldr	r3, [pc, #708]	; (8001920 <HAL_DMA_IRQHandler+0x1210>)
 800165c:	4299      	cmp	r1, r3
 800165e:	f240 8092 	bls.w	8001786 <HAL_DMA_IRQHandler+0x1076>
 8001662:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001666:	f5a3 6389 	sub.w	r3, r3, #1096	; 0x448
 800166a:	4299      	cmp	r1, r3
 800166c:	d070      	beq.n	8001750 <HAL_DMA_IRQHandler+0x1040>
 800166e:	3360      	adds	r3, #96	; 0x60
 8001670:	4299      	cmp	r1, r3
 8001672:	d07d      	beq.n	8001770 <HAL_DMA_IRQHandler+0x1060>
 8001674:	3b48      	subs	r3, #72	; 0x48
 8001676:	4299      	cmp	r1, r3
 8001678:	d07c      	beq.n	8001774 <HAL_DMA_IRQHandler+0x1064>
 800167a:	3360      	adds	r3, #96	; 0x60
 800167c:	4299      	cmp	r1, r3
 800167e:	d07c      	beq.n	800177a <HAL_DMA_IRQHandler+0x106a>
 8001680:	3b48      	subs	r3, #72	; 0x48
 8001682:	4299      	cmp	r1, r3
 8001684:	d07c      	beq.n	8001780 <HAL_DMA_IRQHandler+0x1070>
 8001686:	3360      	adds	r3, #96	; 0x60
 8001688:	4299      	cmp	r1, r3
 800168a:	bf0c      	ite	eq
 800168c:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8001690:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8001694:	e05d      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001696:	2320      	movs	r3, #32
 8001698:	e7ce      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 800169a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800169e:	e7cb      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 80016a0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016a4:	e7c8      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 80016a6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80016aa:	e7c5      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 80016ac:	2320      	movs	r3, #32
 80016ae:	4203      	tst	r3, r0
 80016b0:	bf14      	ite	ne
 80016b2:	2301      	movne	r3, #1
 80016b4:	2300      	moveq	r3, #0
 80016b6:	e7c3      	b.n	8001640 <HAL_DMA_IRQHandler+0xf30>
 80016b8:	2320      	movs	r3, #32
 80016ba:	e7f8      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016c0:	e7f5      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016c6:	e7f2      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016c8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80016cc:	e7ef      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016ce:	4b95      	ldr	r3, [pc, #596]	; (8001924 <HAL_DMA_IRQHandler+0x1214>)
 80016d0:	429a      	cmp	r2, r3
 80016d2:	f63f add7 	bhi.w	8001284 <HAL_DMA_IRQHandler+0xb74>
 80016d6:	4b94      	ldr	r3, [pc, #592]	; (8001928 <HAL_DMA_IRQHandler+0x1218>)
 80016d8:	6818      	ldr	r0, [r3, #0]
 80016da:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 80016de:	4d93      	ldr	r5, [pc, #588]	; (800192c <HAL_DMA_IRQHandler+0x121c>)
 80016e0:	42ab      	cmp	r3, r5
 80016e2:	d024      	beq.n	800172e <HAL_DMA_IRQHandler+0x101e>
 80016e4:	3560      	adds	r5, #96	; 0x60
 80016e6:	42ab      	cmp	r3, r5
 80016e8:	d027      	beq.n	800173a <HAL_DMA_IRQHandler+0x102a>
 80016ea:	3d48      	subs	r5, #72	; 0x48
 80016ec:	42ab      	cmp	r3, r5
 80016ee:	d026      	beq.n	800173e <HAL_DMA_IRQHandler+0x102e>
 80016f0:	3560      	adds	r5, #96	; 0x60
 80016f2:	42ab      	cmp	r3, r5
 80016f4:	d026      	beq.n	8001744 <HAL_DMA_IRQHandler+0x1034>
 80016f6:	3d48      	subs	r5, #72	; 0x48
 80016f8:	42ab      	cmp	r3, r5
 80016fa:	d026      	beq.n	800174a <HAL_DMA_IRQHandler+0x103a>
 80016fc:	3560      	adds	r5, #96	; 0x60
 80016fe:	42ab      	cmp	r3, r5
 8001700:	bf0c      	ite	eq
 8001702:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001706:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800170a:	e011      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 800170c:	2320      	movs	r3, #32
 800170e:	4203      	tst	r3, r0
 8001710:	bf14      	ite	ne
 8001712:	2301      	movne	r3, #1
 8001714:	2300      	moveq	r3, #0
 8001716:	e793      	b.n	8001640 <HAL_DMA_IRQHandler+0xf30>
 8001718:	2320      	movs	r3, #32
 800171a:	e7f8      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 800171c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001720:	e7f5      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 8001722:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001726:	e7f2      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 8001728:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800172c:	e7ef      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 800172e:	2320      	movs	r3, #32
 8001730:	4203      	tst	r3, r0
 8001732:	bf14      	ite	ne
 8001734:	2301      	movne	r3, #1
 8001736:	2300      	moveq	r3, #0
 8001738:	e782      	b.n	8001640 <HAL_DMA_IRQHandler+0xf30>
 800173a:	2320      	movs	r3, #32
 800173c:	e7f8      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 800173e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001742:	e7f5      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 8001744:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001748:	e7f2      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 800174a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800174e:	e7ef      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001750:	2120      	movs	r1, #32
 8001752:	4b77      	ldr	r3, [pc, #476]	; (8001930 <HAL_DMA_IRQHandler+0x1220>)
 8001754:	60d9      	str	r1, [r3, #12]

        /* Current memory buffer used is Memory 1 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8001756:	6823      	ldr	r3, [r4, #0]
 8001758:	681a      	ldr	r2, [r3, #0]
 800175a:	f412 2f00 	tst.w	r2, #524288	; 0x80000
 800175e:	f040 8090 	bne.w	8001882 <HAL_DMA_IRQHandler+0x1172>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8001762:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001764:	2b00      	cmp	r3, #0
 8001766:	f000 818f 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 800176a:	4620      	mov	r0, r4
 800176c:	4798      	blx	r3
 800176e:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001770:	2120      	movs	r1, #32
 8001772:	e7ee      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 8001774:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001778:	e7eb      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 800177a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800177e:	e7e8      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 8001780:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001784:	e7e5      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 8001786:	4b6b      	ldr	r3, [pc, #428]	; (8001934 <HAL_DMA_IRQHandler+0x1224>)
 8001788:	4299      	cmp	r1, r3
 800178a:	d927      	bls.n	80017dc <HAL_DMA_IRQHandler+0x10cc>
 800178c:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001790:	3ba8      	subs	r3, #168	; 0xa8
 8001792:	4299      	cmp	r1, r3
 8001794:	d013      	beq.n	80017be <HAL_DMA_IRQHandler+0x10ae>
 8001796:	3360      	adds	r3, #96	; 0x60
 8001798:	4299      	cmp	r1, r3
 800179a:	d014      	beq.n	80017c6 <HAL_DMA_IRQHandler+0x10b6>
 800179c:	3b48      	subs	r3, #72	; 0x48
 800179e:	4299      	cmp	r1, r3
 80017a0:	d013      	beq.n	80017ca <HAL_DMA_IRQHandler+0x10ba>
 80017a2:	3360      	adds	r3, #96	; 0x60
 80017a4:	4299      	cmp	r1, r3
 80017a6:	d013      	beq.n	80017d0 <HAL_DMA_IRQHandler+0x10c0>
 80017a8:	3b48      	subs	r3, #72	; 0x48
 80017aa:	4299      	cmp	r1, r3
 80017ac:	d013      	beq.n	80017d6 <HAL_DMA_IRQHandler+0x10c6>
 80017ae:	3360      	adds	r3, #96	; 0x60
 80017b0:	4299      	cmp	r1, r3
 80017b2:	bf0c      	ite	eq
 80017b4:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 80017b8:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 80017bc:	e000      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017be:	2120      	movs	r1, #32
 80017c0:	4b5b      	ldr	r3, [pc, #364]	; (8001930 <HAL_DMA_IRQHandler+0x1220>)
 80017c2:	6099      	str	r1, [r3, #8]
 80017c4:	e7c7      	b.n	8001756 <HAL_DMA_IRQHandler+0x1046>
 80017c6:	2120      	movs	r1, #32
 80017c8:	e7fa      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017ca:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017ce:	e7f7      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017d0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017d4:	e7f4      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017d6:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80017da:	e7f1      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017dc:	4b51      	ldr	r3, [pc, #324]	; (8001924 <HAL_DMA_IRQHandler+0x1214>)
 80017de:	4299      	cmp	r1, r3
 80017e0:	d927      	bls.n	8001832 <HAL_DMA_IRQHandler+0x1122>
 80017e2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80017e6:	3b48      	subs	r3, #72	; 0x48
 80017e8:	4299      	cmp	r1, r3
 80017ea:	d013      	beq.n	8001814 <HAL_DMA_IRQHandler+0x1104>
 80017ec:	3360      	adds	r3, #96	; 0x60
 80017ee:	4299      	cmp	r1, r3
 80017f0:	d014      	beq.n	800181c <HAL_DMA_IRQHandler+0x110c>
 80017f2:	3b48      	subs	r3, #72	; 0x48
 80017f4:	4299      	cmp	r1, r3
 80017f6:	d013      	beq.n	8001820 <HAL_DMA_IRQHandler+0x1110>
 80017f8:	3360      	adds	r3, #96	; 0x60
 80017fa:	4299      	cmp	r1, r3
 80017fc:	d013      	beq.n	8001826 <HAL_DMA_IRQHandler+0x1116>
 80017fe:	3b48      	subs	r3, #72	; 0x48
 8001800:	4299      	cmp	r1, r3
 8001802:	d013      	beq.n	800182c <HAL_DMA_IRQHandler+0x111c>
 8001804:	3360      	adds	r3, #96	; 0x60
 8001806:	4299      	cmp	r1, r3
 8001808:	bf0c      	ite	eq
 800180a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 800180e:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8001812:	e000      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001814:	2120      	movs	r1, #32
 8001816:	4b44      	ldr	r3, [pc, #272]	; (8001928 <HAL_DMA_IRQHandler+0x1218>)
 8001818:	60d9      	str	r1, [r3, #12]
 800181a:	e79c      	b.n	8001756 <HAL_DMA_IRQHandler+0x1046>
 800181c:	2120      	movs	r1, #32
 800181e:	e7fa      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001820:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001824:	e7f7      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001826:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800182a:	e7f4      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 800182c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001830:	e7f1      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001832:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001836:	4b3d      	ldr	r3, [pc, #244]	; (800192c <HAL_DMA_IRQHandler+0x121c>)
 8001838:	4299      	cmp	r1, r3
 800183a:	d013      	beq.n	8001864 <HAL_DMA_IRQHandler+0x1154>
 800183c:	3360      	adds	r3, #96	; 0x60
 800183e:	4299      	cmp	r1, r3
 8001840:	d014      	beq.n	800186c <HAL_DMA_IRQHandler+0x115c>
 8001842:	3b48      	subs	r3, #72	; 0x48
 8001844:	4299      	cmp	r1, r3
 8001846:	d013      	beq.n	8001870 <HAL_DMA_IRQHandler+0x1160>
 8001848:	3360      	adds	r3, #96	; 0x60
 800184a:	4299      	cmp	r1, r3
 800184c:	d013      	beq.n	8001876 <HAL_DMA_IRQHandler+0x1166>
 800184e:	3b48      	subs	r3, #72	; 0x48
 8001850:	4299      	cmp	r1, r3
 8001852:	d013      	beq.n	800187c <HAL_DMA_IRQHandler+0x116c>
 8001854:	3360      	adds	r3, #96	; 0x60
 8001856:	4299      	cmp	r1, r3
 8001858:	bf0c      	ite	eq
 800185a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 800185e:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8001862:	e000      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 8001864:	2120      	movs	r1, #32
 8001866:	4b30      	ldr	r3, [pc, #192]	; (8001928 <HAL_DMA_IRQHandler+0x1218>)
 8001868:	6099      	str	r1, [r3, #8]
 800186a:	e774      	b.n	8001756 <HAL_DMA_IRQHandler+0x1046>
 800186c:	2120      	movs	r1, #32
 800186e:	e7fa      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 8001870:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001874:	e7f7      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 8001876:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800187a:	e7f4      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 800187c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001880:	e7f1      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
          }
        }
        /* Current memory buffer used is Memory 0 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8001882:	681b      	ldr	r3, [r3, #0]
 8001884:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8001888:	f000 80fe 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
        {
          if(hdma->XferCpltCallback != NULL)
 800188c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800188e:	2b00      	cmp	r3, #0
 8001890:	f000 80fa 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8001894:	4620      	mov	r0, r4
 8001896:	4798      	blx	r3
 8001898:	bd38      	pop	{r3, r4, r5, pc}
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800189a:	6813      	ldr	r3, [r2, #0]
 800189c:	f413 7f80 	tst.w	r3, #256	; 0x100
 80018a0:	d103      	bne.n	80018aa <HAL_DMA_IRQHandler+0x119a>
        {
          /* Disable the transfer complete interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 80018a2:	6813      	ldr	r3, [r2, #0]
 80018a4:	f023 0310 	bic.w	r3, r3, #16
 80018a8:	6013      	str	r3, [r2, #0]
        }
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80018aa:	6823      	ldr	r3, [r4, #0]
 80018ac:	4a1c      	ldr	r2, [pc, #112]	; (8001920 <HAL_DMA_IRQHandler+0x1210>)
 80018ae:	4293      	cmp	r3, r2
 80018b0:	d942      	bls.n	8001938 <HAL_DMA_IRQHandler+0x1228>
 80018b2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80018b6:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 80018ba:	4293      	cmp	r3, r2
 80018bc:	d013      	beq.n	80018e6 <HAL_DMA_IRQHandler+0x11d6>
 80018be:	3260      	adds	r2, #96	; 0x60
 80018c0:	4293      	cmp	r3, r2
 80018c2:	d022      	beq.n	800190a <HAL_DMA_IRQHandler+0x11fa>
 80018c4:	3a48      	subs	r2, #72	; 0x48
 80018c6:	4293      	cmp	r3, r2
 80018c8:	d021      	beq.n	800190e <HAL_DMA_IRQHandler+0x11fe>
 80018ca:	3260      	adds	r2, #96	; 0x60
 80018cc:	4293      	cmp	r3, r2
 80018ce:	d021      	beq.n	8001914 <HAL_DMA_IRQHandler+0x1204>
 80018d0:	3a48      	subs	r2, #72	; 0x48
 80018d2:	4293      	cmp	r3, r2
 80018d4:	d021      	beq.n	800191a <HAL_DMA_IRQHandler+0x120a>
 80018d6:	3260      	adds	r2, #96	; 0x60
 80018d8:	4293      	cmp	r3, r2
 80018da:	bf0c      	ite	eq
 80018dc:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80018e0:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80018e4:	e000      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 80018e6:	2320      	movs	r3, #32
 80018e8:	4a11      	ldr	r2, [pc, #68]	; (8001930 <HAL_DMA_IRQHandler+0x1220>)
 80018ea:	60d3      	str	r3, [r2, #12]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 80018ec:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80018ee:	64e3      	str	r3, [r4, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 80018f0:	2311      	movs	r3, #17
 80018f2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80018f6:	2300      	movs	r3, #0
 80018f8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

        if(hdma->XferCpltCallback != NULL)
 80018fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80018fe:	2b00      	cmp	r3, #0
 8001900:	f000 80c2 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8001904:	4620      	mov	r0, r4
 8001906:	4798      	blx	r3
        }
      }
    }
  }
}
 8001908:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800190a:	2320      	movs	r3, #32
 800190c:	e7ec      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 800190e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001912:	e7e9      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 8001914:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001918:	e7e6      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 800191a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800191e:	e7e3      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 8001920:	40026458 	.word	0x40026458
 8001924:	40026058 	.word	0x40026058
 8001928:	40026000 	.word	0x40026000
 800192c:	40026010 	.word	0x40026010
 8001930:	40026400 	.word	0x40026400
 8001934:	400260b8 	.word	0x400260b8
 8001938:	4a54      	ldr	r2, [pc, #336]	; (8001a8c <HAL_DMA_IRQHandler+0x137c>)
 800193a:	4293      	cmp	r3, r2
 800193c:	d927      	bls.n	800198e <HAL_DMA_IRQHandler+0x127e>
 800193e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001942:	3aa8      	subs	r2, #168	; 0xa8
 8001944:	4293      	cmp	r3, r2
 8001946:	d013      	beq.n	8001970 <HAL_DMA_IRQHandler+0x1260>
 8001948:	3260      	adds	r2, #96	; 0x60
 800194a:	4293      	cmp	r3, r2
 800194c:	d014      	beq.n	8001978 <HAL_DMA_IRQHandler+0x1268>
 800194e:	3a48      	subs	r2, #72	; 0x48
 8001950:	4293      	cmp	r3, r2
 8001952:	d013      	beq.n	800197c <HAL_DMA_IRQHandler+0x126c>
 8001954:	3260      	adds	r2, #96	; 0x60
 8001956:	4293      	cmp	r3, r2
 8001958:	d013      	beq.n	8001982 <HAL_DMA_IRQHandler+0x1272>
 800195a:	3a48      	subs	r2, #72	; 0x48
 800195c:	4293      	cmp	r3, r2
 800195e:	d013      	beq.n	8001988 <HAL_DMA_IRQHandler+0x1278>
 8001960:	3260      	adds	r2, #96	; 0x60
 8001962:	4293      	cmp	r3, r2
 8001964:	bf0c      	ite	eq
 8001966:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 800196a:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800196e:	e000      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 8001970:	2320      	movs	r3, #32
 8001972:	4a47      	ldr	r2, [pc, #284]	; (8001a90 <HAL_DMA_IRQHandler+0x1380>)
 8001974:	6093      	str	r3, [r2, #8]
 8001976:	e7b9      	b.n	80018ec <HAL_DMA_IRQHandler+0x11dc>
 8001978:	2320      	movs	r3, #32
 800197a:	e7fa      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 800197c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001980:	e7f7      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 8001982:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001986:	e7f4      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 8001988:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800198c:	e7f1      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 800198e:	4a41      	ldr	r2, [pc, #260]	; (8001a94 <HAL_DMA_IRQHandler+0x1384>)
 8001990:	4293      	cmp	r3, r2
 8001992:	d927      	bls.n	80019e4 <HAL_DMA_IRQHandler+0x12d4>
 8001994:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001998:	3a48      	subs	r2, #72	; 0x48
 800199a:	4293      	cmp	r3, r2
 800199c:	d013      	beq.n	80019c6 <HAL_DMA_IRQHandler+0x12b6>
 800199e:	3260      	adds	r2, #96	; 0x60
 80019a0:	4293      	cmp	r3, r2
 80019a2:	d014      	beq.n	80019ce <HAL_DMA_IRQHandler+0x12be>
 80019a4:	3a48      	subs	r2, #72	; 0x48
 80019a6:	4293      	cmp	r3, r2
 80019a8:	d013      	beq.n	80019d2 <HAL_DMA_IRQHandler+0x12c2>
 80019aa:	3260      	adds	r2, #96	; 0x60
 80019ac:	4293      	cmp	r3, r2
 80019ae:	d013      	beq.n	80019d8 <HAL_DMA_IRQHandler+0x12c8>
 80019b0:	3a48      	subs	r2, #72	; 0x48
 80019b2:	4293      	cmp	r3, r2
 80019b4:	d013      	beq.n	80019de <HAL_DMA_IRQHandler+0x12ce>
 80019b6:	3260      	adds	r2, #96	; 0x60
 80019b8:	4293      	cmp	r3, r2
 80019ba:	bf0c      	ite	eq
 80019bc:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80019c0:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80019c4:	e000      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019c6:	2320      	movs	r3, #32
 80019c8:	4a33      	ldr	r2, [pc, #204]	; (8001a98 <HAL_DMA_IRQHandler+0x1388>)
 80019ca:	60d3      	str	r3, [r2, #12]
 80019cc:	e78e      	b.n	80018ec <HAL_DMA_IRQHandler+0x11dc>
 80019ce:	2320      	movs	r3, #32
 80019d0:	e7fa      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019d2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80019d6:	e7f7      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019d8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80019dc:	e7f4      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019de:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80019e2:	e7f1      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019e4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80019e8:	4a2c      	ldr	r2, [pc, #176]	; (8001a9c <HAL_DMA_IRQHandler+0x138c>)
 80019ea:	4293      	cmp	r3, r2
 80019ec:	d013      	beq.n	8001a16 <HAL_DMA_IRQHandler+0x1306>
 80019ee:	3260      	adds	r2, #96	; 0x60
 80019f0:	4293      	cmp	r3, r2
 80019f2:	d014      	beq.n	8001a1e <HAL_DMA_IRQHandler+0x130e>
 80019f4:	3a48      	subs	r2, #72	; 0x48
 80019f6:	4293      	cmp	r3, r2
 80019f8:	d013      	beq.n	8001a22 <HAL_DMA_IRQHandler+0x1312>
 80019fa:	3260      	adds	r2, #96	; 0x60
 80019fc:	4293      	cmp	r3, r2
 80019fe:	d013      	beq.n	8001a28 <HAL_DMA_IRQHandler+0x1318>
 8001a00:	3a48      	subs	r2, #72	; 0x48
 8001a02:	4293      	cmp	r3, r2
 8001a04:	d013      	beq.n	8001a2e <HAL_DMA_IRQHandler+0x131e>
 8001a06:	3260      	adds	r2, #96	; 0x60
 8001a08:	4293      	cmp	r3, r2
 8001a0a:	bf0c      	ite	eq
 8001a0c:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001a10:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001a14:	e000      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a16:	2320      	movs	r3, #32
 8001a18:	4a1f      	ldr	r2, [pc, #124]	; (8001a98 <HAL_DMA_IRQHandler+0x1388>)
 8001a1a:	6093      	str	r3, [r2, #8]
 8001a1c:	e766      	b.n	80018ec <HAL_DMA_IRQHandler+0x11dc>
 8001a1e:	2320      	movs	r3, #32
 8001a20:	e7fa      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a22:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001a26:	e7f7      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a28:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001a2c:	e7f4      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a2e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8001a32:	e7f1      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8001a34:	6822      	ldr	r2, [r4, #0]
 8001a36:	4613      	mov	r3, r2
 8001a38:	f7ff b942 	b.w	8000cc0 <HAL_DMA_IRQHandler+0x5b0>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001a3c:	6822      	ldr	r2, [r4, #0]
 8001a3e:	4611      	mov	r1, r2
 8001a40:	f7ff bae7 	b.w	8001012 <HAL_DMA_IRQHandler+0x902>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001a44:	6822      	ldr	r2, [r4, #0]
 8001a46:	4611      	mov	r1, r2
 8001a48:	e540      	b.n	80014cc <HAL_DMA_IRQHandler+0xdbc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a4a:	6821      	ldr	r1, [r4, #0]
 8001a4c:	460b      	mov	r3, r1
 8001a4e:	f7fe bfbd 	b.w	80009cc <HAL_DMA_IRQHandler+0x2bc>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001a52:	680b      	ldr	r3, [r1, #0]
 8001a54:	f013 0f04 	tst.w	r3, #4
 8001a58:	f47e aed3 	bne.w	8000802 <HAL_DMA_IRQHandler+0xf2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a5c:	6821      	ldr	r1, [r4, #0]
 8001a5e:	460b      	mov	r3, r1
 8001a60:	f7fe bf24 	b.w	80008ac <HAL_DMA_IRQHandler+0x19c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001a64:	680b      	ldr	r3, [r1, #0]
 8001a66:	f013 0f04 	tst.w	r3, #4
 8001a6a:	f47e aeca 	bne.w	8000802 <HAL_DMA_IRQHandler+0xf2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a6e:	6821      	ldr	r1, [r4, #0]
 8001a70:	460b      	mov	r3, r1
 8001a72:	f7fe bf65 	b.w	8000940 <HAL_DMA_IRQHandler+0x230>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001a76:	680b      	ldr	r3, [r1, #0]
 8001a78:	f013 0f04 	tst.w	r3, #4
 8001a7c:	f47e aec1 	bne.w	8000802 <HAL_DMA_IRQHandler+0xf2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a80:	6821      	ldr	r1, [r4, #0]
 8001a82:	460b      	mov	r3, r1
 8001a84:	f7fe be6a 	b.w	800075c <HAL_DMA_IRQHandler+0x4c>
 8001a88:	bd38      	pop	{r3, r4, r5, pc}
 8001a8a:	bf00      	nop
 8001a8c:	400260b8 	.word	0x400260b8
 8001a90:	40026400 	.word	0x40026400
 8001a94:	40026058 	.word	0x40026058
 8001a98:	40026000 	.word	0x40026000
 8001a9c:	40026010 	.word	0x40026010

08001aa0 <prvWriteMACCR>:

	heth->Instance->DMAOMR = ulValue;
}

static void prvWriteMACCR( ETH_HandleTypeDef *heth, uint32_t ulValue)
{
 8001aa0:	b538      	push	{r3, r4, r5, lr}
 8001aa2:	4604      	mov	r4, r0
 8001aa4:	460d      	mov	r5, r1
	/* Enable the MAC transmission */
	heth->Instance->MACCR = ulValue;
 8001aa6:	6803      	ldr	r3, [r0, #0]
 8001aa8:	6019      	str	r1, [r3, #0]

	/* Wait until the write operation will be taken into account:
	at least four TX_CLK/RX_CLK clock cycles.
	Read it back, wait a ms and */
	( void ) heth->Instance->MACCR;
 8001aaa:	6803      	ldr	r3, [r0, #0]
 8001aac:	681b      	ldr	r3, [r3, #0]

	HAL_Delay( ETH_REG_WRITE_DELAY );
 8001aae:	2001      	movs	r0, #1
 8001ab0:	f7fe fdbc 	bl	800062c <HAL_Delay>

	heth->Instance->MACCR = ulValue;
 8001ab4:	6823      	ldr	r3, [r4, #0]
 8001ab6:	601d      	str	r5, [r3, #0]
 8001ab8:	bd38      	pop	{r3, r4, r5, pc}

08001aba <prvWriteDMAOMR>:
{
 8001aba:	b570      	push	{r4, r5, r6, lr}
 8001abc:	4605      	mov	r5, r0
 8001abe:	460e      	mov	r6, r1
	heth->Instance->DMAOMR = ulValue;
 8001ac0:	6803      	ldr	r3, [r0, #0]
 8001ac2:	f241 0418 	movw	r4, #4120	; 0x1018
 8001ac6:	5119      	str	r1, [r3, r4]
	( void ) heth->Instance->DMAOMR;
 8001ac8:	6803      	ldr	r3, [r0, #0]
 8001aca:	591b      	ldr	r3, [r3, r4]
	HAL_Delay( ETH_REG_WRITE_DELAY );
 8001acc:	2001      	movs	r0, #1
 8001ace:	f7fe fdad 	bl	800062c <HAL_Delay>
	heth->Instance->DMAOMR = ulValue;
 8001ad2:	682b      	ldr	r3, [r5, #0]
 8001ad4:	511e      	str	r6, [r3, r4]
 8001ad6:	bd70      	pop	{r4, r5, r6, pc}

08001ad8 <ETH_FlushTransmitFIFO>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_FlushTransmitFIFO(ETH_HandleTypeDef *heth)
{
 8001ad8:	b500      	push	{lr}
 8001ada:	b083      	sub	sp, #12
	/* Set the Flush Transmit FIFO bit */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_FTF;
 8001adc:	6802      	ldr	r2, [r0, #0]
 8001ade:	f241 0318 	movw	r3, #4120	; 0x1018
 8001ae2:	58d3      	ldr	r3, [r2, r3]
 8001ae4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001ae8:	9301      	str	r3, [sp, #4]

	prvWriteDMAOMR( heth, tmpreg );
 8001aea:	9901      	ldr	r1, [sp, #4]
 8001aec:	f7ff ffe5 	bl	8001aba <prvWriteDMAOMR>
}
 8001af0:	b003      	add	sp, #12
 8001af2:	f85d fb04 	ldr.w	pc, [sp], #4

08001af6 <HAL_ETH_DMATxDescListInit>:
{
 8001af6:	468c      	mov	ip, r1
	__HAL_LOCK( heth );
 8001af8:	f890 1045 	ldrb.w	r1, [r0, #69]	; 0x45
 8001afc:	2901      	cmp	r1, #1
 8001afe:	d03b      	beq.n	8001b78 <HAL_ETH_DMATxDescListInit+0x82>
{
 8001b00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	__HAL_LOCK( heth );
 8001b04:	2101      	movs	r1, #1
 8001b06:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001b0a:	2102      	movs	r1, #2
 8001b0c:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	heth->TxDesc = pxDMATable;
 8001b10:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
	for( i=0; i < ulBufferCount; i++ )
 8001b14:	b313      	cbz	r3, 8001b5c <HAL_ETH_DMATxDescListInit+0x66>
 8001b16:	46e1      	mov	r9, ip
 8001b18:	4664      	mov	r4, ip
 8001b1a:	2500      	movs	r5, #0
		pxDMADescriptor->Status = ETH_DMATXDESC_TCH;
 8001b1c:	f44f 1880 	mov.w	r8, #1048576	; 0x100000
		pxDMADescriptor->ControlBufferSize = 0;
 8001b20:	4629      	mov	r1, r5
		if(i < ( ulBufferCount - 1 ) )
 8001b22:	f103 3eff 	add.w	lr, r3, #4294967295	; 0xffffffff
 8001b26:	e00c      	b.n	8001b42 <HAL_ETH_DMATxDescListInit+0x4c>
 8001b28:	45ae      	cmp	lr, r5
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) ( pxDMATable + i + 1 );
 8001b2a:	bf86      	itte	hi
 8001b2c:	f104 0720 	addhi.w	r7, r4, #32
 8001b30:	60f7      	strhi	r7, [r6, #12]
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) pxDMATable;
 8001b32:	f8c6 900c 	strls.w	r9, [r6, #12]
	for( i=0; i < ulBufferCount; i++ )
 8001b36:	3501      	adds	r5, #1
 8001b38:	3420      	adds	r4, #32
 8001b3a:	f202 52f4 	addw	r2, r2, #1524	; 0x5f4
 8001b3e:	42ab      	cmp	r3, r5
 8001b40:	d00c      	beq.n	8001b5c <HAL_ETH_DMATxDescListInit+0x66>
		pxDMADescriptor = pxDMATable + i;
 8001b42:	4626      	mov	r6, r4
		pxDMADescriptor->Status = ETH_DMATXDESC_TCH;
 8001b44:	f8c4 8000 	str.w	r8, [r4]
		pxDMADescriptor->ControlBufferSize = 0;
 8001b48:	6061      	str	r1, [r4, #4]
		pxDMADescriptor->Buffer1Addr = ( uint32_t )( &ucDataBuffer[ i * ETH_TX_BUF_SIZE ] );
 8001b4a:	60a2      	str	r2, [r4, #8]
		if (heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8001b4c:	69c7      	ldr	r7, [r0, #28]
 8001b4e:	2f00      	cmp	r7, #0
 8001b50:	d1ea      	bne.n	8001b28 <HAL_ETH_DMATxDescListInit+0x32>
			pxDMADescriptor->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8001b52:	6827      	ldr	r7, [r4, #0]
 8001b54:	f447 0740 	orr.w	r7, r7, #12582912	; 0xc00000
 8001b58:	6027      	str	r7, [r4, #0]
 8001b5a:	e7e5      	b.n	8001b28 <HAL_ETH_DMATxDescListInit+0x32>
	heth->Instance->DMATDLAR = ( uint32_t ) pxDMATable;
 8001b5c:	6802      	ldr	r2, [r0, #0]
 8001b5e:	f241 0310 	movw	r3, #4112	; 0x1010
 8001b62:	f842 c003 	str.w	ip, [r2, r3]
	heth->State= HAL_ETH_STATE_READY;
 8001b66:	2301      	movs	r3, #1
 8001b68:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001b6c:	2300      	movs	r3, #0
 8001b6e:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	return HAL_OK;
 8001b72:	4618      	mov	r0, r3
 8001b74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__HAL_LOCK( heth );
 8001b78:	2002      	movs	r0, #2
 8001b7a:	4770      	bx	lr

08001b7c <HAL_ETH_DMARxDescListInit>:
{
 8001b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b80:	4688      	mov	r8, r1
	__HAL_LOCK( heth );
 8001b82:	f890 1045 	ldrb.w	r1, [r0, #69]	; 0x45
 8001b86:	2901      	cmp	r1, #1
 8001b88:	d02f      	beq.n	8001bea <HAL_ETH_DMARxDescListInit+0x6e>
 8001b8a:	4686      	mov	lr, r0
 8001b8c:	2101      	movs	r1, #1
 8001b8e:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001b92:	2102      	movs	r1, #2
 8001b94:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	heth->RxDesc = pxDMATable;
 8001b98:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
	for(i=0; i < ulBufferCount; i++)
 8001b9c:	b1bb      	cbz	r3, 8001bce <HAL_ETH_DMARxDescListInit+0x52>
 8001b9e:	46c4      	mov	ip, r8
 8001ba0:	4644      	mov	r4, r8
 8001ba2:	2500      	movs	r5, #0
		pxDMADescriptor->Status = ETH_DMARXDESC_OWN;
 8001ba4:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		pxDMADescriptor->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;
 8001ba8:	f244 57f4 	movw	r7, #17908	; 0x45f4
		if(i < (ulBufferCount-1))
 8001bac:	1e5e      	subs	r6, r3, #1
		pxDMADescriptor->Status = ETH_DMARXDESC_OWN;
 8001bae:	6021      	str	r1, [r4, #0]
		pxDMADescriptor->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;
 8001bb0:	6067      	str	r7, [r4, #4]
		pxDMADescriptor->Buffer1Addr = ( uint32_t )( &ucDataBuffer[ i * ETH_RX_BUF_SIZE ] );
 8001bb2:	60a2      	str	r2, [r4, #8]
		if(i < (ulBufferCount-1))
 8001bb4:	42ae      	cmp	r6, r5
			pxDMADescriptor->Buffer2NextDescAddr = (uint32_t)(pxDMATable+i+1);
 8001bb6:	bf86      	itte	hi
 8001bb8:	f104 0020 	addhi.w	r0, r4, #32
 8001bbc:	60e0      	strhi	r0, [r4, #12]
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) pxDMATable;
 8001bbe:	f8c4 c00c 	strls.w	ip, [r4, #12]
	for(i=0; i < ulBufferCount; i++)
 8001bc2:	3501      	adds	r5, #1
 8001bc4:	3420      	adds	r4, #32
 8001bc6:	f202 52f4 	addw	r2, r2, #1524	; 0x5f4
 8001bca:	42ab      	cmp	r3, r5
 8001bcc:	d1ef      	bne.n	8001bae <HAL_ETH_DMARxDescListInit+0x32>
	heth->Instance->DMARDLAR = ( uint32_t ) pxDMATable;
 8001bce:	f8de 2000 	ldr.w	r2, [lr]
 8001bd2:	f241 030c 	movw	r3, #4108	; 0x100c
 8001bd6:	f842 8003 	str.w	r8, [r2, r3]
	heth->State= HAL_ETH_STATE_READY;
 8001bda:	2301      	movs	r3, #1
 8001bdc:	f88e 3044 	strb.w	r3, [lr, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001be0:	2000      	movs	r0, #0
 8001be2:	f88e 0045 	strb.w	r0, [lr, #69]	; 0x45
	return HAL_OK;
 8001be6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__HAL_LOCK( heth );
 8001bea:	2002      	movs	r0, #2
}
 8001bec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001bf0 <HAL_ETH_Init>:
	if( heth == NULL )
 8001bf0:	2800      	cmp	r0, #0
 8001bf2:	f000 80cd 	beq.w	8001d90 <HAL_ETH_Init+0x1a0>
{
 8001bf6:	b570      	push	{r4, r5, r6, lr}
 8001bf8:	4605      	mov	r5, r0
	if( heth->State == HAL_ETH_STATE_RESET )
 8001bfa:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001bfe:	2b00      	cmp	r3, #0
 8001c00:	f000 80a1 	beq.w	8001d46 <HAL_ETH_Init+0x156>
	__HAL_RCC_SYSCFG_CLK_ENABLE();
 8001c04:	4a63      	ldr	r2, [pc, #396]	; (8001d94 <HAL_ETH_Init+0x1a4>)
 8001c06:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8001c08:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001c0c:	6453      	str	r3, [r2, #68]	; 0x44
	SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8001c0e:	4b62      	ldr	r3, [pc, #392]	; (8001d98 <HAL_ETH_Init+0x1a8>)
 8001c10:	685a      	ldr	r2, [r3, #4]
 8001c12:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8001c16:	605a      	str	r2, [r3, #4]
	SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8001c18:	685a      	ldr	r2, [r3, #4]
 8001c1a:	6a29      	ldr	r1, [r5, #32]
 8001c1c:	430a      	orrs	r2, r1
 8001c1e:	605a      	str	r2, [r3, #4]
	heth->Instance->DMABMR |= ETH_DMABMR_SR | ETH_DMABMR_EDE;
 8001c20:	682b      	ldr	r3, [r5, #0]
 8001c22:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001c26:	681a      	ldr	r2, [r3, #0]
 8001c28:	f042 0281 	orr.w	r2, r2, #129	; 0x81
 8001c2c:	601a      	str	r2, [r3, #0]
	while ((heth->Instance->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8001c2e:	6829      	ldr	r1, [r5, #0]
 8001c30:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
 8001c34:	6814      	ldr	r4, [r2, #0]
 8001c36:	f014 0401 	ands.w	r4, r4, #1
 8001c3a:	d1fb      	bne.n	8001c34 <HAL_ETH_Init+0x44>
	tmpreg = heth->Instance->MACMIIAR;
 8001c3c:	690e      	ldr	r6, [r1, #16]
	tmpreg &= ETH_MACMIIAR_CR_MASK;
 8001c3e:	f026 061c 	bic.w	r6, r6, #28
	hclk = HAL_RCC_GetHCLKFreq();
 8001c42:	f000 ffad 	bl	8002ba0 <HAL_RCC_GetHCLKFreq>
	if( ( hclk >= 20000000 ) && ( hclk < 35000000 ) )
 8001c46:	4b55      	ldr	r3, [pc, #340]	; (8001d9c <HAL_ETH_Init+0x1ac>)
 8001c48:	4403      	add	r3, r0
 8001c4a:	4a55      	ldr	r2, [pc, #340]	; (8001da0 <HAL_ETH_Init+0x1b0>)
 8001c4c:	4293      	cmp	r3, r2
 8001c4e:	d87d      	bhi.n	8001d4c <HAL_ETH_Init+0x15c>
		tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div16;
 8001c50:	f046 0608 	orr.w	r6, r6, #8
	heth->Instance->MACMIIAR = (uint32_t)tmpreg;
 8001c54:	682b      	ldr	r3, [r5, #0]
 8001c56:	611e      	str	r6, [r3, #16]
	vMACBProbePhy();
 8001c58:	f006 fc02 	bl	8008460 <vMACBProbePhy>
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8001c5c:	69eb      	ldr	r3, [r5, #28]
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
 8001c5e:	2b00      	cmp	r3, #0
 8001c60:	bf08      	it	eq
 8001c62:	f44f 6480 	moveq.w	r4, #1024	; 0x400
  tmpreg = heth->Instance->MACCR;
 8001c66:	682b      	ldr	r3, [r5, #0]
 8001c68:	681a      	ldr	r2, [r3, #0]
                       macinit.LoopbackMode |
 8001c6a:	68ab      	ldr	r3, [r5, #8]
 8001c6c:	68e9      	ldr	r1, [r5, #12]
 8001c6e:	4319      	orrs	r1, r3
 8001c70:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  tmpreg &= ETH_MACCR_CLEAR_MASK;
 8001c74:	4b4b      	ldr	r3, [pc, #300]	; (8001da4 <HAL_ETH_Init+0x1b4>)
 8001c76:	4013      	ands	r3, r2
 8001c78:	4319      	orrs	r1, r3
  prvWriteMACCR( heth, tmpreg );
 8001c7a:	4321      	orrs	r1, r4
 8001c7c:	4628      	mov	r0, r5
 8001c7e:	f7ff ff0f 	bl	8001aa0 <prvWriteMACCR>
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
 8001c82:	682b      	ldr	r3, [r5, #0]
 8001c84:	2240      	movs	r2, #64	; 0x40
 8001c86:	605a      	str	r2, [r3, #4]
   tmpreg = heth->Instance->MACFFR;
 8001c88:	682b      	ldr	r3, [r5, #0]
 8001c8a:	685c      	ldr	r4, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8001c8c:	2001      	movs	r0, #1
 8001c8e:	f7fe fccd 	bl	800062c <HAL_Delay>
   heth->Instance->MACFFR = tmpreg;
 8001c92:	682b      	ldr	r3, [r5, #0]
 8001c94:	605c      	str	r4, [r3, #4]
   heth->Instance->MACHTHR = (uint32_t)macinit.HashTableHigh;
 8001c96:	682b      	ldr	r3, [r5, #0]
 8001c98:	2600      	movs	r6, #0
 8001c9a:	609e      	str	r6, [r3, #8]
   heth->Instance->MACHTLR = (uint32_t)macinit.HashTableLow;
 8001c9c:	682b      	ldr	r3, [r5, #0]
 8001c9e:	60de      	str	r6, [r3, #12]
   tmpreg = heth->Instance->MACFCR;
 8001ca0:	682b      	ldr	r3, [r5, #0]
 8001ca2:	699c      	ldr	r4, [r3, #24]
   tmpreg &= ETH_MACFCR_CLEAR_MASK;
 8001ca4:	f024 04be 	bic.w	r4, r4, #190	; 0xbe
 8001ca8:	0424      	lsls	r4, r4, #16
 8001caa:	0c24      	lsrs	r4, r4, #16
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
 8001cac:	f044 0480 	orr.w	r4, r4, #128	; 0x80
	heth->Instance->MACFCR = ulValue;
 8001cb0:	619c      	str	r4, [r3, #24]
	( void ) heth->Instance->MACFCR;
 8001cb2:	682b      	ldr	r3, [r5, #0]
 8001cb4:	699b      	ldr	r3, [r3, #24]
	HAL_Delay( ETH_REG_WRITE_DELAY );
 8001cb6:	2001      	movs	r0, #1
 8001cb8:	f7fe fcb8 	bl	800062c <HAL_Delay>
	heth->Instance->MACFCR = ulValue;
 8001cbc:	682b      	ldr	r3, [r5, #0]
 8001cbe:	619c      	str	r4, [r3, #24]
   heth->Instance->MACVLANTR = (uint32_t)(macinit.VLANTagComparison |
 8001cc0:	682b      	ldr	r3, [r5, #0]
 8001cc2:	61de      	str	r6, [r3, #28]
    tmpreg = heth->Instance->MACVLANTR;
 8001cc4:	682b      	ldr	r3, [r5, #0]
 8001cc6:	69dc      	ldr	r4, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8001cc8:	2001      	movs	r0, #1
 8001cca:	f7fe fcaf 	bl	800062c <HAL_Delay>
    heth->Instance->MACVLANTR = tmpreg;
 8001cce:	682b      	ldr	r3, [r5, #0]
 8001cd0:	61dc      	str	r4, [r3, #28]
    tmpreg = heth->Instance->DMAOMR;
 8001cd2:	682a      	ldr	r2, [r5, #0]
 8001cd4:	f241 0318 	movw	r3, #4120	; 0x1018
 8001cd8:	58d3      	ldr	r3, [r2, r3]
    tmpreg &= ETH_DMAOMR_CLEAR_MASK;
 8001cda:	4933      	ldr	r1, [pc, #204]	; (8001da8 <HAL_ETH_Init+0x1b8>)
 8001cdc:	4019      	ands	r1, r3
    prvWriteDMAOMR( heth, tmpreg );
 8001cde:	f041 7108 	orr.w	r1, r1, #35651584	; 0x2200000
 8001ce2:	f041 0104 	orr.w	r1, r1, #4
 8001ce6:	4628      	mov	r0, r5
 8001ce8:	f7ff fee7 	bl	8001aba <prvWriteDMAOMR>
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
 8001cec:	682b      	ldr	r3, [r5, #0]
 8001cee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001cf2:	4a2e      	ldr	r2, [pc, #184]	; (8001dac <HAL_ETH_Init+0x1bc>)
 8001cf4:	601a      	str	r2, [r3, #0]
     tmpreg = heth->Instance->DMABMR;
 8001cf6:	682b      	ldr	r3, [r5, #0]
 8001cf8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001cfc:	681c      	ldr	r4, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 8001cfe:	2001      	movs	r0, #1
 8001d00:	f7fe fc94 	bl	800062c <HAL_Delay>
     heth->Instance->DMABMR = tmpreg;
 8001d04:	682b      	ldr	r3, [r5, #0]
 8001d06:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001d0a:	601c      	str	r4, [r3, #0]
     if(heth->Init.RxMode == ETH_RXINTERRUPT_MODE)
 8001d0c:	69ab      	ldr	r3, [r5, #24]
 8001d0e:	2b01      	cmp	r3, #1
 8001d10:	d034      	beq.n	8001d7c <HAL_ETH_Init+0x18c>
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8001d12:	696a      	ldr	r2, [r5, #20]
	tmpreg = 0x80000000ul | ( ( uint32_t )Addr[ 5 ] << 8) | (uint32_t)Addr[ 4 ];
 8001d14:	7951      	ldrb	r1, [r2, #5]
 8001d16:	7913      	ldrb	r3, [r2, #4]
 8001d18:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001d1c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	( * ( __IO uint32_t * ) ( ( uint32_t ) ( ETH_MAC_ADDR_HBASE + MacAddr ) ) ) = tmpreg;
 8001d20:	4923      	ldr	r1, [pc, #140]	; (8001db0 <HAL_ETH_Init+0x1c0>)
 8001d22:	600b      	str	r3, [r1, #0]
	tmpreg = ( ( uint32_t )Addr[ 3 ] << 24 ) | ( ( uint32_t )Addr[ 2 ] << 16 ) | ( ( uint32_t )Addr[ 1 ] << 8 ) | Addr[ 0 ];
 8001d24:	78d1      	ldrb	r1, [r2, #3]
 8001d26:	7893      	ldrb	r3, [r2, #2]
 8001d28:	041b      	lsls	r3, r3, #16
 8001d2a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8001d2e:	7811      	ldrb	r1, [r2, #0]
 8001d30:	430b      	orrs	r3, r1
 8001d32:	7852      	ldrb	r2, [r2, #1]
 8001d34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	( * ( __IO uint32_t * ) ( ( uint32_t ) ( ETH_MAC_ADDR_LBASE + MacAddr ) ) ) = tmpreg;
 8001d38:	4a1e      	ldr	r2, [pc, #120]	; (8001db4 <HAL_ETH_Init+0x1c4>)
 8001d3a:	6013      	str	r3, [r2, #0]
	heth->State= HAL_ETH_STATE_READY;
 8001d3c:	2301      	movs	r3, #1
 8001d3e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	return HAL_OK;
 8001d42:	2000      	movs	r0, #0
 8001d44:	bd70      	pop	{r4, r5, r6, pc}
		HAL_ETH_MspInit( heth );
 8001d46:	f00a f8ef 	bl	800bf28 <HAL_ETH_MspInit>
 8001d4a:	e75b      	b.n	8001c04 <HAL_ETH_Init+0x14>
	else if( ( hclk >= 35000000 ) && ( hclk < 60000000 ) )
 8001d4c:	4b1a      	ldr	r3, [pc, #104]	; (8001db8 <HAL_ETH_Init+0x1c8>)
 8001d4e:	4403      	add	r3, r0
 8001d50:	4a1a      	ldr	r2, [pc, #104]	; (8001dbc <HAL_ETH_Init+0x1cc>)
 8001d52:	4293      	cmp	r3, r2
 8001d54:	d802      	bhi.n	8001d5c <HAL_ETH_Init+0x16c>
	tmpreg |= ( uint32_t ) ETH_MACMIIAR_CR_Div26;
 8001d56:	f046 060c 	orr.w	r6, r6, #12
 8001d5a:	e77b      	b.n	8001c54 <HAL_ETH_Init+0x64>
	else if((hclk >= 60000000 ) && ( hclk < 100000000 ) )
 8001d5c:	4b18      	ldr	r3, [pc, #96]	; (8001dc0 <HAL_ETH_Init+0x1d0>)
 8001d5e:	4403      	add	r3, r0
 8001d60:	4a18      	ldr	r2, [pc, #96]	; (8001dc4 <HAL_ETH_Init+0x1d4>)
 8001d62:	4293      	cmp	r3, r2
 8001d64:	f67f af76 	bls.w	8001c54 <HAL_ETH_Init+0x64>
	else if((hclk >= 100000000 ) && ( hclk < 150000000))
 8001d68:	4b17      	ldr	r3, [pc, #92]	; (8001dc8 <HAL_ETH_Init+0x1d8>)
 8001d6a:	4403      	add	r3, r0
 8001d6c:	4a17      	ldr	r2, [pc, #92]	; (8001dcc <HAL_ETH_Init+0x1dc>)
 8001d6e:	4293      	cmp	r3, r2
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8001d70:	bf94      	ite	ls
 8001d72:	f046 0604 	orrls.w	r6, r6, #4
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;
 8001d76:	f046 0610 	orrhi.w	r6, r6, #16
 8001d7a:	e76b      	b.n	8001c54 <HAL_ETH_Init+0x64>
       __HAL_ETH_DMA_ENABLE_IT(( heth ), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8001d7c:	6829      	ldr	r1, [r5, #0]
 8001d7e:	f241 021c 	movw	r2, #4124	; 0x101c
 8001d82:	588b      	ldr	r3, [r1, r2]
 8001d84:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001d88:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001d8c:	508b      	str	r3, [r1, r2]
 8001d8e:	e7c0      	b.n	8001d12 <HAL_ETH_Init+0x122>
		return HAL_ERROR;
 8001d90:	2001      	movs	r0, #1
 8001d92:	4770      	bx	lr
 8001d94:	40023800 	.word	0x40023800
 8001d98:	40013800 	.word	0x40013800
 8001d9c:	feced300 	.word	0xfeced300
 8001da0:	00e4e1bf 	.word	0x00e4e1bf
 8001da4:	ff20810f 	.word	0xff20810f
 8001da8:	f8de3f23 	.word	0xf8de3f23
 8001dac:	02c12080 	.word	0x02c12080
 8001db0:	40028040 	.word	0x40028040
 8001db4:	40028044 	.word	0x40028044
 8001db8:	fde9f140 	.word	0xfde9f140
 8001dbc:	017d783f 	.word	0x017d783f
 8001dc0:	fc6c7900 	.word	0xfc6c7900
 8001dc4:	026259ff 	.word	0x026259ff
 8001dc8:	fa0a1f00 	.word	0xfa0a1f00
 8001dcc:	02faf07f 	.word	0x02faf07f

08001dd0 <HAL_ETH_TransmitFrame>:
	__HAL_LOCK( heth );
 8001dd0:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001dd4:	2b01      	cmp	r3, #1
 8001dd6:	d07c      	beq.n	8001ed2 <HAL_ETH_TransmitFrame+0x102>
{
 8001dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
	__IO ETH_DMADescTypeDef *pxDmaTxDesc = heth->TxDesc;
 8001dda:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
	__HAL_LOCK( heth );
 8001ddc:	2301      	movs	r3, #1
 8001dde:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001de2:	2302      	movs	r3, #2
 8001de4:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	if( FrameLength == 0 )
 8001de8:	b1b9      	cbz	r1, 8001e1a <HAL_ETH_TransmitFrame+0x4a>
	if( ( pxDmaTxDesc->Status & ETH_DMATXDESC_OWN ) != ( uint32_t ) RESET )
 8001dea:	683b      	ldr	r3, [r7, #0]
 8001dec:	2b00      	cmp	r3, #0
 8001dee:	db1c      	blt.n	8001e2a <HAL_ETH_TransmitFrame+0x5a>
	bufcount = ( FrameLength + ETH_TX_BUF_SIZE - 1 ) / ETH_TX_BUF_SIZE;
 8001df0:	f201 54f3 	addw	r4, r1, #1523	; 0x5f3
 8001df4:	4b38      	ldr	r3, [pc, #224]	; (8001ed8 <HAL_ETH_TransmitFrame+0x108>)
 8001df6:	fba3 3404 	umull	r3, r4, r3, r4
 8001dfa:	0aa4      	lsrs	r4, r4, #10
	if (bufcount == 1)
 8001dfc:	2c01      	cmp	r4, #1
 8001dfe:	d01c      	beq.n	8001e3a <HAL_ETH_TransmitFrame+0x6a>
		for( i = 0; i < bufcount; i++ )
 8001e00:	b34c      	cbz	r4, 8001e56 <HAL_ETH_TransmitFrame+0x86>
				size = FrameLength - (bufcount-1)*ETH_TX_BUF_SIZE;
 8001e02:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 8001e06:	4e35      	ldr	r6, [pc, #212]	; (8001edc <HAL_ETH_TransmitFrame+0x10c>)
 8001e08:	fb06 1104 	mla	r1, r6, r4, r1
				heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8001e0c:	f3c1 060c 	ubfx	r6, r1, #0, #13
 8001e10:	2300      	movs	r3, #0
			if (i < (bufcount-1))
 8001e12:	1e65      	subs	r5, r4, #1
				heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8001e14:	f240 5ef4 	movw	lr, #1524	; 0x5f4
 8001e18:	e04f      	b.n	8001eba <HAL_ETH_TransmitFrame+0xea>
		heth->State = HAL_ETH_STATE_READY;
 8001e1a:	2301      	movs	r3, #1
 8001e1c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		__HAL_UNLOCK( heth );
 8001e20:	2200      	movs	r2, #0
 8001e22:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
		return  HAL_ERROR;
 8001e26:	4618      	mov	r0, r3
 8001e28:	bdf0      	pop	{r4, r5, r6, r7, pc}
		heth->State = HAL_ETH_STATE_BUSY_TX;
 8001e2a:	2312      	movs	r3, #18
 8001e2c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		__HAL_UNLOCK( heth );
 8001e30:	2300      	movs	r3, #0
 8001e32:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
		return HAL_ERROR;
 8001e36:	2001      	movs	r0, #1
 8001e38:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pxDmaTxDesc->Status |= ETH_DMATXDESC_FS | ETH_DMATXDESC_LS;
 8001e3a:	683b      	ldr	r3, [r7, #0]
 8001e3c:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
 8001e40:	603b      	str	r3, [r7, #0]
		pxDmaTxDesc->ControlBufferSize = ( FrameLength & ETH_DMATXDESC_TBS1 );
 8001e42:	f3c1 010c 	ubfx	r1, r1, #0, #13
 8001e46:	6079      	str	r1, [r7, #4]
		pxDmaTxDesc->Status |= ETH_DMATXDESC_OWN;
 8001e48:	683b      	ldr	r3, [r7, #0]
 8001e4a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001e4e:	603b      	str	r3, [r7, #0]
		heth->TxDesc = ( ETH_DMADescTypeDef * ) ( heth->TxDesc->Buffer2NextDescAddr );
 8001e50:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001e52:	68db      	ldr	r3, [r3, #12]
 8001e54:	62c3      	str	r3, [r0, #44]	; 0x2c
	if( ( heth->Instance->DMASR & ETH_DMASR_TBUS ) != ( uint32_t )RESET )
 8001e56:	6803      	ldr	r3, [r0, #0]
 8001e58:	f241 0214 	movw	r2, #4116	; 0x1014
 8001e5c:	589a      	ldr	r2, [r3, r2]
 8001e5e:	f012 0f04 	tst.w	r2, #4
 8001e62:	d00c      	beq.n	8001e7e <HAL_ETH_TransmitFrame+0xae>
		heth->Instance->DMACHTDR = ( uint32_t )pxDmaTxDesc;
 8001e64:	f241 0248 	movw	r2, #4168	; 0x1048
 8001e68:	509f      	str	r7, [r3, r2]
		heth->Instance->DMASR = ETH_DMASR_TBUS;
 8001e6a:	6802      	ldr	r2, [r0, #0]
 8001e6c:	2104      	movs	r1, #4
 8001e6e:	f241 0314 	movw	r3, #4116	; 0x1014
 8001e72:	50d1      	str	r1, [r2, r3]
		heth->Instance->DMATPDR = 0;
 8001e74:	6802      	ldr	r2, [r0, #0]
 8001e76:	2100      	movs	r1, #0
 8001e78:	f241 0304 	movw	r3, #4100	; 0x1004
 8001e7c:	50d1      	str	r1, [r2, r3]
	heth->State = HAL_ETH_STATE_READY;
 8001e7e:	2301      	movs	r3, #1
 8001e80:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001e84:	2300      	movs	r3, #0
 8001e86:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	return HAL_OK;
 8001e8a:	4618      	mov	r0, r3
 8001e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				heth->TxDesc->Status = ulStatus | ETH_DMATXDESC_FS;
 8001e8e:	f042 5c80 	orr.w	ip, r2, #268435456	; 0x10000000
 8001e92:	f8c1 c000 	str.w	ip, [r1]
 8001e96:	e016      	b.n	8001ec6 <HAL_ETH_TransmitFrame+0xf6>
				heth->TxDesc->Status = ulStatus | ETH_DMATXDESC_LS;
 8001e98:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001e9a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8001e9e:	600a      	str	r2, [r1, #0]
				heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8001ea0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001ea2:	6056      	str	r6, [r2, #4]
			heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8001ea4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001ea6:	680a      	ldr	r2, [r1, #0]
 8001ea8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8001eac:	600a      	str	r2, [r1, #0]
			heth->TxDesc = (ETH_DMADescTypeDef *)( heth->TxDesc->Buffer2NextDescAddr );
 8001eae:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001eb0:	68d2      	ldr	r2, [r2, #12]
 8001eb2:	62c2      	str	r2, [r0, #44]	; 0x2c
		for( i = 0; i < bufcount; i++ )
 8001eb4:	3301      	adds	r3, #1
 8001eb6:	429c      	cmp	r4, r3
 8001eb8:	d0cd      	beq.n	8001e56 <HAL_ETH_TransmitFrame+0x86>
		uint32_t ulStatus = heth->TxDesc->Status & ~( ETH_DMATXDESC_FS | ETH_DMATXDESC_LS );
 8001eba:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001ebc:	680a      	ldr	r2, [r1, #0]
 8001ebe:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
			if( i == 0 )
 8001ec2:	2b00      	cmp	r3, #0
 8001ec4:	d0e3      	beq.n	8001e8e <HAL_ETH_TransmitFrame+0xbe>
			if (i < (bufcount-1))
 8001ec6:	429d      	cmp	r5, r3
 8001ec8:	d9e6      	bls.n	8001e98 <HAL_ETH_TransmitFrame+0xc8>
				heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8001eca:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001ecc:	f8c2 e004 	str.w	lr, [r2, #4]
 8001ed0:	e7e8      	b.n	8001ea4 <HAL_ETH_TransmitFrame+0xd4>
	__HAL_LOCK( heth );
 8001ed2:	2002      	movs	r0, #2
 8001ed4:	4770      	bx	lr
 8001ed6:	bf00      	nop
 8001ed8:	ac02b00b 	.word	0xac02b00b
 8001edc:	fffffa0c 	.word	0xfffffa0c

08001ee0 <HAL_ETH_GetReceivedFrame>:
	__HAL_LOCK( heth );
 8001ee0:	f890 2045 	ldrb.w	r2, [r0, #69]	; 0x45
 8001ee4:	2a01      	cmp	r2, #1
 8001ee6:	d040      	beq.n	8001f6a <HAL_ETH_GetReceivedFrame+0x8a>
{
 8001ee8:	b470      	push	{r4, r5, r6}
 8001eea:	4603      	mov	r3, r0
ETH_DMADescTypeDef *pxDescriptor = heth->RxDesc;
 8001eec:	6a82      	ldr	r2, [r0, #40]	; 0x28
	__HAL_LOCK( heth );
 8001eee:	2101      	movs	r1, #1
 8001ef0:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001ef4:	2102      	movs	r1, #2
 8001ef6:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	while( ( ( pxDescriptor->Status & ETH_DMARXDESC_OWN ) == 0ul ) && ( ulCounter < ETH_RXBUFNB ) )
 8001efa:	2105      	movs	r1, #5
			heth->RxFrameInfos.LSRxDesc = ( ETH_DMADescTypeDef *)NULL;
 8001efc:	2600      	movs	r6, #0
			heth->RxFrameInfos.SegCount = 1;
 8001efe:	2501      	movs	r5, #1
	while( ( ( pxDescriptor->Status & ETH_DMARXDESC_OWN ) == 0ul ) && ( ulCounter < ETH_RXBUFNB ) )
 8001f00:	e00a      	b.n	8001f18 <HAL_ETH_GetReceivedFrame+0x38>
			heth->RxFrameInfos.FSRxDesc = pxDescriptor;
 8001f02:	631a      	str	r2, [r3, #48]	; 0x30
			heth->RxFrameInfos.LSRxDesc = ( ETH_DMADescTypeDef *)NULL;
 8001f04:	635e      	str	r6, [r3, #52]	; 0x34
			heth->RxFrameInfos.SegCount = 1;
 8001f06:	639d      	str	r5, [r3, #56]	; 0x38
			pxDescriptor = (ETH_DMADescTypeDef*) (pxDescriptor->Buffer2NextDescAddr);
 8001f08:	68d2      	ldr	r2, [r2, #12]
			heth->RxDesc = pxDescriptor;
 8001f0a:	629a      	str	r2, [r3, #40]	; 0x28
 8001f0c:	e004      	b.n	8001f18 <HAL_ETH_GetReceivedFrame+0x38>
			heth->RxFrameInfos.SegCount++;
 8001f0e:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8001f10:	3001      	adds	r0, #1
 8001f12:	6398      	str	r0, [r3, #56]	; 0x38
			pxDescriptor = ( ETH_DMADescTypeDef * ) ( pxDescriptor->Buffer2NextDescAddr );
 8001f14:	68d2      	ldr	r2, [r2, #12]
			heth->RxDesc = pxDescriptor;
 8001f16:	629a      	str	r2, [r3, #40]	; 0x28
	while( ( ( pxDescriptor->Status & ETH_DMARXDESC_OWN ) == 0ul ) && ( ulCounter < ETH_RXBUFNB ) )
 8001f18:	6810      	ldr	r0, [r2, #0]
 8001f1a:	2800      	cmp	r0, #0
 8001f1c:	db23      	blt.n	8001f66 <HAL_ETH_GetReceivedFrame+0x86>
 8001f1e:	3901      	subs	r1, #1
 8001f20:	d018      	beq.n	8001f54 <HAL_ETH_GetReceivedFrame+0x74>
	uint32_t ulStatus = pxDescriptor->Status;
 8001f22:	6814      	ldr	r4, [r2, #0]
		if( ( ulStatus & ( ETH_DMARXDESC_FS | ETH_DMARXDESC_LS ) ) == ( uint32_t )ETH_DMARXDESC_FS )
 8001f24:	f404 7040 	and.w	r0, r4, #768	; 0x300
 8001f28:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8001f2c:	d0e9      	beq.n	8001f02 <HAL_ETH_GetReceivedFrame+0x22>
		else if( ( ulStatus & ( ETH_DMARXDESC_LS | ETH_DMARXDESC_FS ) ) == 0ul )
 8001f2e:	2800      	cmp	r0, #0
 8001f30:	d0ed      	beq.n	8001f0e <HAL_ETH_GetReceivedFrame+0x2e>
			if( heth->RxFrameInfos.SegCount == 0 )
 8001f32:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8001f34:	b901      	cbnz	r1, 8001f38 <HAL_ETH_GetReceivedFrame+0x58>
				heth->RxFrameInfos.FSRxDesc = pxDescriptor;
 8001f36:	631a      	str	r2, [r3, #48]	; 0x30
			heth->RxFrameInfos.SegCount++;
 8001f38:	3101      	adds	r1, #1
 8001f3a:	6399      	str	r1, [r3, #56]	; 0x38
			heth->RxFrameInfos.LSRxDesc = pxDescriptor;
 8001f3c:	635a      	str	r2, [r3, #52]	; 0x34
				( ( ulStatus & ETH_DMARXDESC_FL ) >> ETH_DMARXDESC_FRAMELENGTHSHIFT ) - 4;
 8001f3e:	f3c4 440d 	ubfx	r4, r4, #16, #14
 8001f42:	3c04      	subs	r4, #4
			heth->RxFrameInfos.length =
 8001f44:	63dc      	str	r4, [r3, #60]	; 0x3c
			heth->RxFrameInfos.buffer = heth->RxFrameInfos.FSRxDesc->Buffer1Addr;
 8001f46:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001f48:	6889      	ldr	r1, [r1, #8]
 8001f4a:	6419      	str	r1, [r3, #64]	; 0x40
			heth->RxDesc = ( ETH_DMADescTypeDef * ) pxDescriptor->Buffer2NextDescAddr;
 8001f4c:	68d2      	ldr	r2, [r2, #12]
 8001f4e:	629a      	str	r2, [r3, #40]	; 0x28
			xResult = HAL_OK;
 8001f50:	2000      	movs	r0, #0
			break;
 8001f52:	e000      	b.n	8001f56 <HAL_ETH_GetReceivedFrame+0x76>
HAL_StatusTypeDef xResult = HAL_ERROR;
 8001f54:	2001      	movs	r0, #1
	heth->State = HAL_ETH_STATE_READY;
 8001f56:	2201      	movs	r2, #1
 8001f58:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001f5c:	2200      	movs	r2, #0
 8001f5e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
}
 8001f62:	bc70      	pop	{r4, r5, r6}
 8001f64:	4770      	bx	lr
HAL_StatusTypeDef xResult = HAL_ERROR;
 8001f66:	2001      	movs	r0, #1
 8001f68:	e7f5      	b.n	8001f56 <HAL_ETH_GetReceivedFrame+0x76>
	__HAL_LOCK( heth );
 8001f6a:	2002      	movs	r0, #2
 8001f6c:	4770      	bx	lr

08001f6e <HAL_ETH_ErrorCallback>:
{
 8001f6e:	4770      	bx	lr

08001f70 <HAL_ETH_IRQHandler>:
{
 8001f70:	b538      	push	{r3, r4, r5, lr}
 8001f72:	4605      	mov	r5, r0
	dmasr = heth->Instance->DMASR & ETH_DMA_ALL_INTS;
 8001f74:	6801      	ldr	r1, [r0, #0]
 8001f76:	f241 0214 	movw	r2, #4116	; 0x1014
 8001f7a:	588c      	ldr	r4, [r1, r2]
 8001f7c:	4b0b      	ldr	r3, [pc, #44]	; (8001fac <HAL_ETH_IRQHandler+0x3c>)
 8001f7e:	4023      	ands	r3, r4
	heth->Instance->DMASR = dmasr;
 8001f80:	508b      	str	r3, [r1, r2]
	if( ( dmasr & ( ETH_DMA_FLAG_R | ETH_DMA_IT_RBU ) ) != 0 )
 8001f82:	f014 0fc0 	tst.w	r4, #192	; 0xc0
 8001f86:	d106      	bne.n	8001f96 <HAL_ETH_IRQHandler+0x26>
	if( ( dmasr & ( ETH_DMA_FLAG_T ) ) != 0 )
 8001f88:	f014 0f01 	tst.w	r4, #1
 8001f8c:	d106      	bne.n	8001f9c <HAL_ETH_IRQHandler+0x2c>
	if( ( dmasr & ( ETH_DMA_FLAG_AIS ) ) != 0 )
 8001f8e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8001f92:	d107      	bne.n	8001fa4 <HAL_ETH_IRQHandler+0x34>
 8001f94:	bd38      	pop	{r3, r4, r5, pc}
		HAL_ETH_RxCpltCallback( heth );
 8001f96:	f006 f999 	bl	80082cc <HAL_ETH_RxCpltCallback>
 8001f9a:	e7f5      	b.n	8001f88 <HAL_ETH_IRQHandler+0x18>
		HAL_ETH_TxCpltCallback( heth );
 8001f9c:	4628      	mov	r0, r5
 8001f9e:	f006 f9b7 	bl	8008310 <HAL_ETH_TxCpltCallback>
 8001fa2:	e7f4      	b.n	8001f8e <HAL_ETH_IRQHandler+0x1e>
		HAL_ETH_ErrorCallback( heth );
 8001fa4:	4628      	mov	r0, r5
 8001fa6:	f7ff ffe2 	bl	8001f6e <HAL_ETH_ErrorCallback>
}
 8001faa:	e7f3      	b.n	8001f94 <HAL_ETH_IRQHandler+0x24>
 8001fac:	3801e7fb 	.word	0x3801e7fb

08001fb0 <HAL_ETH_ReadPHYRegister>:
{
 8001fb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( heth->State == HAL_ETH_STATE_BUSY_RD )
 8001fb2:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001fb6:	b2db      	uxtb	r3, r3
 8001fb8:	2b82      	cmp	r3, #130	; 0x82
 8001fba:	d03d      	beq.n	8002038 <HAL_ETH_ReadPHYRegister+0x88>
 8001fbc:	4604      	mov	r4, r0
 8001fbe:	4616      	mov	r6, r2
		__HAL_LOCK( heth );
 8001fc0:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001fc4:	2b01      	cmp	r3, #1
 8001fc6:	d102      	bne.n	8001fce <HAL_ETH_ReadPHYRegister+0x1e>
 8001fc8:	2402      	movs	r4, #2
}
 8001fca:	4620      	mov	r0, r4
 8001fcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		__HAL_LOCK( heth );
 8001fce:	2301      	movs	r3, #1
 8001fd0:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
		heth->State = HAL_ETH_STATE_BUSY_RD;
 8001fd4:	2382      	movs	r3, #130	; 0x82
 8001fd6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		tmpreg = heth->Instance->MACMIIAR;
 8001fda:	6802      	ldr	r2, [r0, #0]
 8001fdc:	6913      	ldr	r3, [r2, #16]
		tmpreg |= ( ( ( uint32_t )PHYReg << 6 ) & ETH_MACMIIAR_MR );                   /* Set the PHY register address */
 8001fde:	0189      	lsls	r1, r1, #6
 8001fe0:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
		tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8001fe4:	f003 031c 	and.w	r3, r3, #28
 8001fe8:	4319      	orrs	r1, r3
		tmpreg |= ( ( ( uint32_t )heth->Init.PhyAddress << 11) & ETH_MACMIIAR_PA );    /* Set the PHY device address   */
 8001fea:	8a03      	ldrh	r3, [r0, #16]
 8001fec:	02db      	lsls	r3, r3, #11
 8001fee:	b29b      	uxth	r3, r3
		tmpreg &= ~ETH_MACMIIAR_MW;                                           /* Set the read mode            */
 8001ff0:	4319      	orrs	r1, r3
		tmpreg |= ETH_MACMIIAR_MB;                                            /* Set the MII Busy bit         */
 8001ff2:	f041 0101 	orr.w	r1, r1, #1
		heth->Instance->MACMIIAR = tmpreg;
 8001ff6:	6111      	str	r1, [r2, #16]
		tickstart = HAL_GetTick();
 8001ff8:	f7fe fb12 	bl	8000620 <HAL_GetTick>
 8001ffc:	4607      	mov	r7, r0
			if( ( HAL_GetTick( ) - tickstart ) > PHY_READ_TO )
 8001ffe:	4d11      	ldr	r5, [pc, #68]	; (8002044 <HAL_ETH_ReadPHYRegister+0x94>)
			tmpreg = heth->Instance->MACMIIAR;
 8002000:	6823      	ldr	r3, [r4, #0]
 8002002:	691a      	ldr	r2, [r3, #16]
			if( ( tmpreg & ETH_MACMIIAR_MB ) == 0ul )
 8002004:	f012 0f01 	tst.w	r2, #1
 8002008:	d00c      	beq.n	8002024 <HAL_ETH_ReadPHYRegister+0x74>
			if( ( HAL_GetTick( ) - tickstart ) > PHY_READ_TO )
 800200a:	f7fe fb09 	bl	8000620 <HAL_GetTick>
 800200e:	1bc0      	subs	r0, r0, r7
 8002010:	42a8      	cmp	r0, r5
 8002012:	d9f5      	bls.n	8002000 <HAL_ETH_ReadPHYRegister+0x50>
		heth->State = HAL_ETH_STATE_READY;
 8002014:	2301      	movs	r3, #1
 8002016:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 800201a:	2300      	movs	r3, #0
 800201c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
				xResult = HAL_TIMEOUT;
 8002020:	2403      	movs	r4, #3
 8002022:	e00a      	b.n	800203a <HAL_ETH_ReadPHYRegister+0x8a>
				*RegValue = ( uint32_t ) heth->Instance->MACMIIDR;
 8002024:	695b      	ldr	r3, [r3, #20]
 8002026:	6033      	str	r3, [r6, #0]
		heth->State = HAL_ETH_STATE_READY;
 8002028:	2301      	movs	r3, #1
 800202a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 800202e:	2300      	movs	r3, #0
 8002030:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	return xResult;
 8002034:	461c      	mov	r4, r3
 8002036:	e7c8      	b.n	8001fca <HAL_ETH_ReadPHYRegister+0x1a>
		xResult = HAL_BUSY;
 8002038:	2402      	movs	r4, #2
		lUDPLoggingPrintf( "ReadPHY: %d\n", xResult );
 800203a:	4621      	mov	r1, r4
 800203c:	4802      	ldr	r0, [pc, #8]	; (8002048 <HAL_ETH_ReadPHYRegister+0x98>)
 800203e:	f009 f9cb 	bl	800b3d8 <lUDPLoggingPrintf>
 8002042:	e7c2      	b.n	8001fca <HAL_ETH_ReadPHYRegister+0x1a>
 8002044:	0004ffff 	.word	0x0004ffff
 8002048:	0800c2c4 	.word	0x0800c2c4

0800204c <HAL_ETH_WritePHYRegister>:
{
 800204c:	b570      	push	{r4, r5, r6, lr}
	if( heth->State == HAL_ETH_STATE_BUSY_WR )
 800204e:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8002052:	b2db      	uxtb	r3, r3
 8002054:	2b42      	cmp	r3, #66	; 0x42
 8002056:	d035      	beq.n	80020c4 <HAL_ETH_WritePHYRegister+0x78>
 8002058:	4604      	mov	r4, r0
		__HAL_LOCK( heth );
 800205a:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 800205e:	2b01      	cmp	r3, #1
 8002060:	d102      	bne.n	8002068 <HAL_ETH_WritePHYRegister+0x1c>
 8002062:	2402      	movs	r4, #2
}
 8002064:	4620      	mov	r0, r4
 8002066:	bd70      	pop	{r4, r5, r6, pc}
		__HAL_LOCK( heth );
 8002068:	2301      	movs	r3, #1
 800206a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
		heth->State = HAL_ETH_STATE_BUSY_WR;
 800206e:	2342      	movs	r3, #66	; 0x42
 8002070:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		tmpreg = heth->Instance->MACMIIAR;
 8002074:	6800      	ldr	r0, [r0, #0]
 8002076:	6905      	ldr	r5, [r0, #16]
		tmpreg |= ( ( ( uint32_t ) PHYReg << 6 ) & ETH_MACMIIAR_MR );                 /* Set the PHY register address */
 8002078:	018b      	lsls	r3, r1, #6
 800207a:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 800207e:	f043 0303 	orr.w	r3, r3, #3
		tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8002082:	f005 011c 	and.w	r1, r5, #28
 8002086:	430b      	orrs	r3, r1
		tmpreg |= ( ( ( uint32_t ) heth->Init.PhyAddress << 11 ) & ETH_MACMIIAR_PA ); /* Set the PHY device address */
 8002088:	8a21      	ldrh	r1, [r4, #16]
 800208a:	02c9      	lsls	r1, r1, #11
 800208c:	b289      	uxth	r1, r1
		tmpreg |= ETH_MACMIIAR_MB;                                          /* Set the MII Busy bit */
 800208e:	430b      	orrs	r3, r1
 8002090:	b292      	uxth	r2, r2
		heth->Instance->MACMIIDR = ( uint16_t ) RegValue;
 8002092:	6142      	str	r2, [r0, #20]
		heth->Instance->MACMIIAR = tmpreg;
 8002094:	6822      	ldr	r2, [r4, #0]
 8002096:	6113      	str	r3, [r2, #16]
		tickstart = HAL_GetTick();
 8002098:	f7fe fac2 	bl	8000620 <HAL_GetTick>
 800209c:	4606      	mov	r6, r0
			if( ( HAL_GetTick( ) - tickstart ) > PHY_WRITE_TO )
 800209e:	4d10      	ldr	r5, [pc, #64]	; (80020e0 <HAL_ETH_WritePHYRegister+0x94>)
			tmpreg = heth->Instance->MACMIIAR;
 80020a0:	6823      	ldr	r3, [r4, #0]
 80020a2:	691b      	ldr	r3, [r3, #16]
			if( ( tmpreg & ETH_MACMIIAR_MB ) == 0ul )
 80020a4:	f013 0f01 	tst.w	r3, #1
 80020a8:	d012      	beq.n	80020d0 <HAL_ETH_WritePHYRegister+0x84>
			if( ( HAL_GetTick( ) - tickstart ) > PHY_WRITE_TO )
 80020aa:	f7fe fab9 	bl	8000620 <HAL_GetTick>
 80020ae:	1b80      	subs	r0, r0, r6
 80020b0:	42a8      	cmp	r0, r5
 80020b2:	d9f5      	bls.n	80020a0 <HAL_ETH_WritePHYRegister+0x54>
		heth->State = HAL_ETH_STATE_READY;
 80020b4:	2301      	movs	r3, #1
 80020b6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 80020ba:	2300      	movs	r3, #0
 80020bc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
				xResult = HAL_TIMEOUT;
 80020c0:	2403      	movs	r4, #3
 80020c2:	e000      	b.n	80020c6 <HAL_ETH_WritePHYRegister+0x7a>
		xResult = HAL_BUSY;
 80020c4:	2402      	movs	r4, #2
		lUDPLoggingPrintf( "WritePHY: %d\n", xResult );
 80020c6:	4621      	mov	r1, r4
 80020c8:	4806      	ldr	r0, [pc, #24]	; (80020e4 <HAL_ETH_WritePHYRegister+0x98>)
 80020ca:	f009 f985 	bl	800b3d8 <lUDPLoggingPrintf>
 80020ce:	e7c9      	b.n	8002064 <HAL_ETH_WritePHYRegister+0x18>
		heth->State = HAL_ETH_STATE_READY;
 80020d0:	2301      	movs	r3, #1
 80020d2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 80020d6:	2300      	movs	r3, #0
 80020d8:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	return xResult;
 80020dc:	461c      	mov	r4, r3
 80020de:	e7c1      	b.n	8002064 <HAL_ETH_WritePHYRegister+0x18>
 80020e0:	0004ffff 	.word	0x0004ffff
 80020e4:	0800c2d4 	.word	0x0800c2d4

080020e8 <HAL_ETH_Start>:
	__HAL_LOCK( heth );
 80020e8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80020ec:	2b01      	cmp	r3, #1
 80020ee:	d101      	bne.n	80020f4 <HAL_ETH_Start+0xc>
 80020f0:	2002      	movs	r0, #2
 80020f2:	4770      	bx	lr
{
 80020f4:	b570      	push	{r4, r5, r6, lr}
 80020f6:	b084      	sub	sp, #16
 80020f8:	4604      	mov	r4, r0
	__HAL_LOCK( heth );
 80020fa:	2501      	movs	r5, #1
 80020fc:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8002100:	2302      	movs	r3, #2
 8002102:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	uint32_t tmpreg = heth->Instance->MACCR | ETH_MACCR_TE;
 8002106:	6803      	ldr	r3, [r0, #0]
 8002108:	6819      	ldr	r1, [r3, #0]
	prvWriteMACCR( heth, tmpreg );
 800210a:	f041 0108 	orr.w	r1, r1, #8
 800210e:	f7ff fcc7 	bl	8001aa0 <prvWriteMACCR>
	__IO uint32_t tmpreg = heth->Instance->MACCR | ETH_MACCR_RE;
 8002112:	6823      	ldr	r3, [r4, #0]
 8002114:	681b      	ldr	r3, [r3, #0]
 8002116:	f043 0304 	orr.w	r3, r3, #4
 800211a:	9303      	str	r3, [sp, #12]
	prvWriteMACCR( heth, tmpreg );
 800211c:	9903      	ldr	r1, [sp, #12]
 800211e:	4620      	mov	r0, r4
 8002120:	f7ff fcbe 	bl	8001aa0 <prvWriteMACCR>
	ETH_FlushTransmitFIFO( heth );
 8002124:	4620      	mov	r0, r4
 8002126:	f7ff fcd7 	bl	8001ad8 <ETH_FlushTransmitFIFO>
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_ST;
 800212a:	6823      	ldr	r3, [r4, #0]
 800212c:	f241 0618 	movw	r6, #4120	; 0x1018
 8002130:	599b      	ldr	r3, [r3, r6]
 8002132:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002136:	9302      	str	r3, [sp, #8]
	prvWriteDMAOMR( heth, tmpreg );
 8002138:	9902      	ldr	r1, [sp, #8]
 800213a:	4620      	mov	r0, r4
 800213c:	f7ff fcbd 	bl	8001aba <prvWriteDMAOMR>
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_SR;
 8002140:	6823      	ldr	r3, [r4, #0]
 8002142:	599b      	ldr	r3, [r3, r6]
 8002144:	f043 0302 	orr.w	r3, r3, #2
 8002148:	9301      	str	r3, [sp, #4]
	prvWriteDMAOMR( heth, tmpreg );
 800214a:	9901      	ldr	r1, [sp, #4]
 800214c:	4620      	mov	r0, r4
 800214e:	f7ff fcb4 	bl	8001aba <prvWriteDMAOMR>
	heth->State= HAL_ETH_STATE_READY;
 8002152:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8002156:	2000      	movs	r0, #0
 8002158:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 800215c:	b004      	add	sp, #16
 800215e:	bd70      	pop	{r4, r5, r6, pc}

08002160 <HAL_ETH_Stop>:
  __HAL_LOCK( heth );
 8002160:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8002164:	2b01      	cmp	r3, #1
 8002166:	d101      	bne.n	800216c <HAL_ETH_Stop+0xc>
 8002168:	2002      	movs	r0, #2
 800216a:	4770      	bx	lr
{
 800216c:	b570      	push	{r4, r5, r6, lr}
 800216e:	b084      	sub	sp, #16
 8002170:	4604      	mov	r4, r0
  __HAL_LOCK( heth );
 8002172:	2501      	movs	r5, #1
 8002174:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8002178:	2302      	movs	r3, #2
 800217a:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	__IO uint32_t tmpreg = heth->Instance->DMAOMR & ~( ETH_DMAOMR_ST );
 800217e:	6803      	ldr	r3, [r0, #0]
 8002180:	f241 0618 	movw	r6, #4120	; 0x1018
 8002184:	599b      	ldr	r3, [r3, r6]
 8002186:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800218a:	9303      	str	r3, [sp, #12]
	prvWriteDMAOMR( heth, tmpreg );
 800218c:	9903      	ldr	r1, [sp, #12]
 800218e:	f7ff fc94 	bl	8001aba <prvWriteDMAOMR>
	__IO uint32_t tmpreg = heth->Instance->DMAOMR & ~( ETH_DMAOMR_SR );
 8002192:	6823      	ldr	r3, [r4, #0]
 8002194:	599b      	ldr	r3, [r3, r6]
 8002196:	f023 0302 	bic.w	r3, r3, #2
 800219a:	9302      	str	r3, [sp, #8]
	prvWriteDMAOMR( heth, tmpreg );
 800219c:	9902      	ldr	r1, [sp, #8]
 800219e:	4620      	mov	r0, r4
 80021a0:	f7ff fc8b 	bl	8001aba <prvWriteDMAOMR>
	__IO uint32_t tmpreg = heth->Instance->MACCR & ~( ETH_MACCR_RE );
 80021a4:	6823      	ldr	r3, [r4, #0]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	f023 0304 	bic.w	r3, r3, #4
 80021ac:	9301      	str	r3, [sp, #4]
	prvWriteMACCR( heth, tmpreg );
 80021ae:	9901      	ldr	r1, [sp, #4]
 80021b0:	4620      	mov	r0, r4
 80021b2:	f7ff fc75 	bl	8001aa0 <prvWriteMACCR>
  ETH_FlushTransmitFIFO( heth );
 80021b6:	4620      	mov	r0, r4
 80021b8:	f7ff fc8e 	bl	8001ad8 <ETH_FlushTransmitFIFO>
	uint32_t tmpreg = heth->Instance->MACCR & ~( ETH_MACCR_TE );
 80021bc:	6823      	ldr	r3, [r4, #0]
 80021be:	6819      	ldr	r1, [r3, #0]
	prvWriteMACCR( heth, tmpreg );
 80021c0:	f021 0108 	bic.w	r1, r1, #8
 80021c4:	4620      	mov	r0, r4
 80021c6:	f7ff fc6b 	bl	8001aa0 <prvWriteMACCR>
  heth->State = HAL_ETH_STATE_READY;
 80021ca:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
  __HAL_UNLOCK( heth );
 80021ce:	2000      	movs	r0, #0
 80021d0:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 80021d4:	b004      	add	sp, #16
 80021d6:	bd70      	pop	{r4, r5, r6, pc}

080021d8 <HAL_ETH_ConfigMAC>:
	__HAL_LOCK( heth );
 80021d8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80021dc:	2b01      	cmp	r3, #1
 80021de:	f000 8082 	beq.w	80022e6 <HAL_ETH_ConfigMAC+0x10e>
{
 80021e2:	b570      	push	{r4, r5, r6, lr}
 80021e4:	460c      	mov	r4, r1
 80021e6:	4605      	mov	r5, r0
	__HAL_LOCK( heth );
 80021e8:	2301      	movs	r3, #1
 80021ea:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	heth->State= HAL_ETH_STATE_BUSY;
 80021ee:	2302      	movs	r3, #2
 80021f0:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	if (macconf != NULL)
 80021f4:	2900      	cmp	r1, #0
 80021f6:	d06b      	beq.n	80022d0 <HAL_ETH_ConfigMAC+0xf8>
		tmpreg = heth->Instance->MACCR;
 80021f8:	6803      	ldr	r3, [r0, #0]
 80021fa:	681b      	ldr	r3, [r3, #0]
		tmpreg &= ETH_MACCR_CLEAR_MASK;
 80021fc:	493b      	ldr	r1, [pc, #236]	; (80022ec <HAL_ETH_ConfigMAC+0x114>)
 80021fe:	4019      	ands	r1, r3
			macconf->BackOffLimit |
 8002200:	6823      	ldr	r3, [r4, #0]
 8002202:	6862      	ldr	r2, [r4, #4]
 8002204:	4313      	orrs	r3, r2
 8002206:	68a2      	ldr	r2, [r4, #8]
 8002208:	4313      	orrs	r3, r2
 800220a:	68e2      	ldr	r2, [r4, #12]
 800220c:	4313      	orrs	r3, r2
 800220e:	6922      	ldr	r2, [r4, #16]
 8002210:	4313      	orrs	r3, r2
 8002212:	6962      	ldr	r2, [r4, #20]
 8002214:	4313      	orrs	r3, r2
 8002216:	69a2      	ldr	r2, [r4, #24]
 8002218:	4313      	orrs	r3, r2
 800221a:	69e2      	ldr	r2, [r4, #28]
 800221c:	4313      	orrs	r3, r2
 800221e:	6a22      	ldr	r2, [r4, #32]
 8002220:	4313      	orrs	r3, r2
 8002222:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002224:	4313      	orrs	r3, r2
 8002226:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002228:	4313      	orrs	r3, r2
 800222a:	6882      	ldr	r2, [r0, #8]
 800222c:	4313      	orrs	r3, r2
 800222e:	68c2      	ldr	r2, [r0, #12]
 8002230:	4313      	orrs	r3, r2
		prvWriteMACCR( heth, tmpreg );
 8002232:	4319      	orrs	r1, r3
 8002234:	f7ff fc34 	bl	8001aa0 <prvWriteMACCR>
		heth->Instance->MACFFR = (uint32_t)(
 8002238:	682a      	ldr	r2, [r5, #0]
			macconf->ReceiveAll |
 800223a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800223c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800223e:	430b      	orrs	r3, r1
			macconf->SourceAddrFilter |
 8002240:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8002242:	430b      	orrs	r3, r1
			macconf->PassControlFrames |
 8002244:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8002246:	430b      	orrs	r3, r1
			macconf->BroadcastFramesReception |
 8002248:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800224a:	430b      	orrs	r3, r1
			macconf->DestinationAddrFilter |
 800224c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800224e:	430b      	orrs	r3, r1
			macconf->PromiscuousMode |
 8002250:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8002252:	430b      	orrs	r3, r1
			macconf->MulticastFramesFilter |
 8002254:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8002256:	430b      	orrs	r3, r1
		heth->Instance->MACFFR = (uint32_t)(
 8002258:	6053      	str	r3, [r2, #4]
		tmpreg = heth->Instance->MACFFR;
 800225a:	682b      	ldr	r3, [r5, #0]
 800225c:	685e      	ldr	r6, [r3, #4]
		HAL_Delay(ETH_REG_WRITE_DELAY);
 800225e:	2001      	movs	r0, #1
 8002260:	f7fe f9e4 	bl	800062c <HAL_Delay>
		heth->Instance->MACFFR = tmpreg;
 8002264:	682b      	ldr	r3, [r5, #0]
 8002266:	605e      	str	r6, [r3, #4]
		heth->Instance->MACHTHR = (uint32_t)macconf->HashTableHigh;
 8002268:	682b      	ldr	r3, [r5, #0]
 800226a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800226c:	609a      	str	r2, [r3, #8]
		heth->Instance->MACHTLR = (uint32_t)macconf->HashTableLow;
 800226e:	682b      	ldr	r3, [r5, #0]
 8002270:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8002272:	60da      	str	r2, [r3, #12]
		tmpreg = heth->Instance->MACFCR;
 8002274:	6829      	ldr	r1, [r5, #0]
 8002276:	698a      	ldr	r2, [r1, #24]
		tmpreg &= ETH_MACFCR_CLEAR_MASK;
 8002278:	f022 02be 	bic.w	r2, r2, #190	; 0xbe
 800227c:	0412      	lsls	r2, r2, #16
 800227e:	0c12      	lsrs	r2, r2, #16
			macconf->ReceiveFlowControl |
 8002280:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002282:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 8002284:	431e      	orrs	r6, r3
 8002286:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002288:	431e      	orrs	r6, r3
 800228a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800228c:	431e      	orrs	r6, r3
 800228e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8002290:	431e      	orrs	r6, r3
			macconf->PauseTime << 16) |
 8002292:	6d63      	ldr	r3, [r4, #84]	; 0x54
			macconf->ReceiveFlowControl |
 8002294:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
		tmpreg |= (uint32_t)((
 8002298:	4316      	orrs	r6, r2
	heth->Instance->MACFCR = ulValue;
 800229a:	618e      	str	r6, [r1, #24]
	( void ) heth->Instance->MACFCR;
 800229c:	682b      	ldr	r3, [r5, #0]
 800229e:	699b      	ldr	r3, [r3, #24]
	HAL_Delay( ETH_REG_WRITE_DELAY );
 80022a0:	2001      	movs	r0, #1
 80022a2:	f7fe f9c3 	bl	800062c <HAL_Delay>
	heth->Instance->MACFCR = ulValue;
 80022a6:	682b      	ldr	r3, [r5, #0]
 80022a8:	619e      	str	r6, [r3, #24]
		heth->Instance->MACVLANTR = (uint32_t)(macconf->VLANTagComparison |
 80022aa:	682a      	ldr	r2, [r5, #0]
 80022ac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80022ae:	6f21      	ldr	r1, [r4, #112]	; 0x70
 80022b0:	430b      	orrs	r3, r1
 80022b2:	61d3      	str	r3, [r2, #28]
		tmpreg = heth->Instance->MACVLANTR;
 80022b4:	682b      	ldr	r3, [r5, #0]
 80022b6:	69dc      	ldr	r4, [r3, #28]
		HAL_Delay(ETH_REG_WRITE_DELAY);
 80022b8:	2001      	movs	r0, #1
 80022ba:	f7fe f9b7 	bl	800062c <HAL_Delay>
		heth->Instance->MACVLANTR = tmpreg;
 80022be:	682b      	ldr	r3, [r5, #0]
 80022c0:	61dc      	str	r4, [r3, #28]
	heth->State= HAL_ETH_STATE_READY;
 80022c2:	2301      	movs	r3, #1
 80022c4:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	__HAL_UNLOCK( heth );
 80022c8:	2000      	movs	r0, #0
 80022ca:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
	return HAL_OK;
 80022ce:	bd70      	pop	{r4, r5, r6, pc}
		tmpreg = heth->Instance->MACCR;
 80022d0:	6803      	ldr	r3, [r0, #0]
 80022d2:	681b      	ldr	r3, [r3, #0]
		tmpreg &= ~((uint32_t)0x00004800);
 80022d4:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
		tmpreg |= (uint32_t)(heth->Init.Speed | heth->Init.DuplexMode);
 80022d8:	6881      	ldr	r1, [r0, #8]
 80022da:	68c2      	ldr	r2, [r0, #12]
 80022dc:	4311      	orrs	r1, r2
		prvWriteMACCR( heth, tmpreg );
 80022de:	4319      	orrs	r1, r3
 80022e0:	f7ff fbde 	bl	8001aa0 <prvWriteMACCR>
 80022e4:	e7ed      	b.n	80022c2 <HAL_ETH_ConfigMAC+0xea>
	__HAL_LOCK( heth );
 80022e6:	2002      	movs	r0, #2
 80022e8:	4770      	bx	lr
 80022ea:	bf00      	nop
 80022ec:	ff20810f 	.word	0xff20810f

080022f0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80022f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 80022f4:	2500      	movs	r5, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80022f6:	4f69      	ldr	r7, [pc, #420]	; (800249c <HAL_GPIO_Init+0x1ac>)

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80022f8:	f8df e1ac 	ldr.w	lr, [pc, #428]	; 80024a8 <HAL_GPIO_Init+0x1b8>
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80022fc:	4e68      	ldr	r6, [pc, #416]	; (80024a0 <HAL_GPIO_Init+0x1b0>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80022fe:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 80024ac <HAL_GPIO_Init+0x1bc>
 8002302:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 80024b0 <HAL_GPIO_Init+0x1c0>
 8002306:	e057      	b.n	80023b8 <HAL_GPIO_Init+0xc8>
        temp = GPIOx->AFR[position >> 3];
 8002308:	08ec      	lsrs	r4, r5, #3
 800230a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800230e:	f8d4 c020 	ldr.w	ip, [r4, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8002312:	f005 0207 	and.w	r2, r5, #7
 8002316:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 800231a:	220f      	movs	r2, #15
 800231c:	fa02 f20b 	lsl.w	r2, r2, fp
 8002320:	ea2c 0c02 	bic.w	ip, ip, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8002324:	690a      	ldr	r2, [r1, #16]
 8002326:	fa02 f20b 	lsl.w	r2, r2, fp
 800232a:	ea42 020c 	orr.w	r2, r2, ip
        GPIOx->AFR[position >> 3] = temp;
 800232e:	6222      	str	r2, [r4, #32]
 8002330:	e04e      	b.n	80023d0 <HAL_GPIO_Init+0xe0>
        temp = GPIOx->OSPEEDR;
 8002332:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8002334:	ea02 0b04 	and.w	fp, r2, r4
        temp |= (GPIO_Init->Speed << (position * 2));
 8002338:	68cc      	ldr	r4, [r1, #12]
 800233a:	fa04 f40c 	lsl.w	r4, r4, ip
 800233e:	ea44 040b 	orr.w	r4, r4, fp
        GPIOx->OSPEEDR = temp;
 8002342:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 8002344:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002346:	ea24 0b03 	bic.w	fp, r4, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800234a:	684c      	ldr	r4, [r1, #4]
 800234c:	f3c4 1300 	ubfx	r3, r4, #4, #1
 8002350:	40ab      	lsls	r3, r5
 8002352:	ea43 030b 	orr.w	r3, r3, fp
        GPIOx->OTYPER = temp;
 8002356:	6043      	str	r3, [r0, #4]
 8002358:	e051      	b.n	80023fe <HAL_GPIO_Init+0x10e>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800235a:	2200      	movs	r2, #0
 800235c:	fa02 f20b 	lsl.w	r2, r2, fp
 8002360:	ea42 020c 	orr.w	r2, r2, ip
        SYSCFG->EXTICR[position >> 2] = temp;
 8002364:	609a      	str	r2, [r3, #8]
        temp = EXTI->IMR;
 8002366:	6833      	ldr	r3, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 8002368:	ea6f 0408 	mvn.w	r4, r8
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800236c:	684a      	ldr	r2, [r1, #4]
 800236e:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8002372:	bf0c      	ite	eq
 8002374:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 8002376:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->IMR = temp;
 800237a:	6033      	str	r3, [r6, #0]

        temp = EXTI->EMR;
 800237c:	6873      	ldr	r3, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800237e:	684a      	ldr	r2, [r1, #4]
 8002380:	f412 3f00 	tst.w	r2, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8002384:	bf0c      	ite	eq
 8002386:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 8002388:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->EMR = temp;
 800238c:	6073      	str	r3, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800238e:	68b2      	ldr	r2, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002390:	684b      	ldr	r3, [r1, #4]
 8002392:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8002396:	bf0c      	ite	eq
 8002398:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 800239a:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->RTSR = temp;
 800239e:	60b2      	str	r2, [r6, #8]

        temp = EXTI->FTSR;
 80023a0:	68f3      	ldr	r3, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80023a2:	684a      	ldr	r2, [r1, #4]
 80023a4:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
        temp &= ~((uint32_t)iocurrent);
 80023a8:	bf0c      	ite	eq
 80023aa:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 80023ac:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->FTSR = temp;
 80023b0:	60f3      	str	r3, [r6, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 80023b2:	3501      	adds	r5, #1
 80023b4:	2d10      	cmp	r5, #16
 80023b6:	d06f      	beq.n	8002498 <HAL_GPIO_Init+0x1a8>
    ioposition = ((uint32_t)0x01) << position;
 80023b8:	2301      	movs	r3, #1
 80023ba:	40ab      	lsls	r3, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80023bc:	680a      	ldr	r2, [r1, #0]
 80023be:	ea03 0802 	and.w	r8, r3, r2
    if(iocurrent == ioposition)
 80023c2:	4543      	cmp	r3, r8
 80023c4:	d1f5      	bne.n	80023b2 <HAL_GPIO_Init+0xc2>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80023c6:	684a      	ldr	r2, [r1, #4]
 80023c8:	f022 0210 	bic.w	r2, r2, #16
 80023cc:	2a02      	cmp	r2, #2
 80023ce:	d09b      	beq.n	8002308 <HAL_GPIO_Init+0x18>
      temp = GPIOx->MODER;
 80023d0:	6804      	ldr	r4, [r0, #0]
 80023d2:	ea4f 0c45 	mov.w	ip, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80023d6:	2203      	movs	r2, #3
 80023d8:	fa02 f20c 	lsl.w	r2, r2, ip
 80023dc:	43d2      	mvns	r2, r2
 80023de:	ea04 0b02 	and.w	fp, r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80023e2:	684c      	ldr	r4, [r1, #4]
 80023e4:	f004 0403 	and.w	r4, r4, #3
 80023e8:	fa04 f40c 	lsl.w	r4, r4, ip
 80023ec:	ea44 040b 	orr.w	r4, r4, fp
      GPIOx->MODER = temp;
 80023f0:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80023f2:	684c      	ldr	r4, [r1, #4]
 80023f4:	f024 0410 	bic.w	r4, r4, #16
 80023f8:	3c01      	subs	r4, #1
 80023fa:	2c01      	cmp	r4, #1
 80023fc:	d999      	bls.n	8002332 <HAL_GPIO_Init+0x42>
      temp = GPIOx->PUPDR;
 80023fe:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8002400:	401a      	ands	r2, r3
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8002402:	688b      	ldr	r3, [r1, #8]
 8002404:	fa03 f30c 	lsl.w	r3, r3, ip
 8002408:	4313      	orrs	r3, r2
      GPIOx->PUPDR = temp;
 800240a:	60c3      	str	r3, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800240c:	684b      	ldr	r3, [r1, #4]
 800240e:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8002412:	d0ce      	beq.n	80023b2 <HAL_GPIO_Init+0xc2>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002414:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002416:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800241a:	647b      	str	r3, [r7, #68]	; 0x44
 800241c:	f025 0303 	bic.w	r3, r5, #3
 8002420:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002424:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
        temp = SYSCFG->EXTICR[position >> 2];
 8002428:	689c      	ldr	r4, [r3, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800242a:	f005 0203 	and.w	r2, r5, #3
 800242e:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 8002432:	220f      	movs	r2, #15
 8002434:	fa02 f20b 	lsl.w	r2, r2, fp
 8002438:	ea24 0c02 	bic.w	ip, r4, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800243c:	4570      	cmp	r0, lr
 800243e:	d08c      	beq.n	800235a <HAL_GPIO_Init+0x6a>
 8002440:	4548      	cmp	r0, r9
 8002442:	d01b      	beq.n	800247c <HAL_GPIO_Init+0x18c>
 8002444:	4550      	cmp	r0, sl
 8002446:	d01b      	beq.n	8002480 <HAL_GPIO_Init+0x190>
 8002448:	4a16      	ldr	r2, [pc, #88]	; (80024a4 <HAL_GPIO_Init+0x1b4>)
 800244a:	4290      	cmp	r0, r2
 800244c:	d01a      	beq.n	8002484 <HAL_GPIO_Init+0x194>
 800244e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002452:	4290      	cmp	r0, r2
 8002454:	d018      	beq.n	8002488 <HAL_GPIO_Init+0x198>
 8002456:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800245a:	4290      	cmp	r0, r2
 800245c:	d016      	beq.n	800248c <HAL_GPIO_Init+0x19c>
 800245e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002462:	4290      	cmp	r0, r2
 8002464:	d014      	beq.n	8002490 <HAL_GPIO_Init+0x1a0>
 8002466:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800246a:	4290      	cmp	r0, r2
 800246c:	d012      	beq.n	8002494 <HAL_GPIO_Init+0x1a4>
 800246e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002472:	4290      	cmp	r0, r2
 8002474:	bf0c      	ite	eq
 8002476:	2208      	moveq	r2, #8
 8002478:	2209      	movne	r2, #9
 800247a:	e76f      	b.n	800235c <HAL_GPIO_Init+0x6c>
 800247c:	2201      	movs	r2, #1
 800247e:	e76d      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002480:	2202      	movs	r2, #2
 8002482:	e76b      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002484:	2203      	movs	r2, #3
 8002486:	e769      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002488:	2204      	movs	r2, #4
 800248a:	e767      	b.n	800235c <HAL_GPIO_Init+0x6c>
 800248c:	2205      	movs	r2, #5
 800248e:	e765      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002490:	2206      	movs	r2, #6
 8002492:	e763      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002494:	2207      	movs	r2, #7
 8002496:	e761      	b.n	800235c <HAL_GPIO_Init+0x6c>
      }
    }
  }
}
 8002498:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800249c:	40023800 	.word	0x40023800
 80024a0:	40013c00 	.word	0x40013c00
 80024a4:	40020c00 	.word	0x40020c00
 80024a8:	40020000 	.word	0x40020000
 80024ac:	40020400 	.word	0x40020400
 80024b0:	40020800 	.word	0x40020800

080024b4 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80024b4:	6943      	ldr	r3, [r0, #20]
 80024b6:	4059      	eors	r1, r3
 80024b8:	6141      	str	r1, [r0, #20]
 80024ba:	4770      	bx	lr

080024bc <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80024bc:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 80024be:	4b05      	ldr	r3, [pc, #20]	; (80024d4 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 80024c0:	695b      	ldr	r3, [r3, #20]
 80024c2:	4203      	tst	r3, r0
 80024c4:	d100      	bne.n	80024c8 <HAL_GPIO_EXTI_IRQHandler+0xc>
 80024c6:	bd08      	pop	{r3, pc}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80024c8:	4b02      	ldr	r3, [pc, #8]	; (80024d4 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 80024ca:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80024cc:	f000 fe72 	bl	80031b4 <HAL_GPIO_EXTI_Callback>
  }
}
 80024d0:	e7f9      	b.n	80024c6 <HAL_GPIO_EXTI_IRQHandler+0xa>
 80024d2:	bf00      	nop
 80024d4:	40013c00 	.word	0x40013c00

080024d8 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80024d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80024da:	4604      	mov	r4, r0
  uint32_t tickstart = 0;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80024dc:	6803      	ldr	r3, [r0, #0]
 80024de:	f013 0f01 	tst.w	r3, #1
 80024e2:	d02d      	beq.n	8002540 <HAL_RCC_OscConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80024e4:	4bae      	ldr	r3, [pc, #696]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80024e6:	689b      	ldr	r3, [r3, #8]
 80024e8:	f003 030c 	and.w	r3, r3, #12
 80024ec:	2b04      	cmp	r3, #4
 80024ee:	d01e      	beq.n	800252e <HAL_RCC_OscConfig+0x56>
 80024f0:	4bab      	ldr	r3, [pc, #684]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80024f2:	689b      	ldr	r3, [r3, #8]
 80024f4:	f003 030c 	and.w	r3, r3, #12
 80024f8:	2b08      	cmp	r3, #8
 80024fa:	d013      	beq.n	8002524 <HAL_RCC_OscConfig+0x4c>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 80024fc:	2200      	movs	r2, #0
 80024fe:	4ba9      	ldr	r3, [pc, #676]	; (80027a4 <HAL_RCC_OscConfig+0x2cc>)
 8002500:	701a      	strb	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002502:	f7fe f88d 	bl	8000620 <HAL_GetTick>
 8002506:	4607      	mov	r7, r0

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002508:	4da5      	ldr	r5, [pc, #660]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800250a:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800250e:	682b      	ldr	r3, [r5, #0]
 8002510:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002514:	d038      	beq.n	8002588 <HAL_RCC_OscConfig+0xb0>
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002516:	f7fe f883 	bl	8000620 <HAL_GetTick>
 800251a:	1bc0      	subs	r0, r0, r7
 800251c:	42b0      	cmp	r0, r6
 800251e:	d9f6      	bls.n	800250e <HAL_RCC_OscConfig+0x36>
        {
          return HAL_TIMEOUT;
 8002520:	2003      	movs	r0, #3
 8002522:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002524:	4b9e      	ldr	r3, [pc, #632]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002526:	685b      	ldr	r3, [r3, #4]
 8002528:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800252c:	d0e6      	beq.n	80024fc <HAL_RCC_OscConfig+0x24>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800252e:	4b9c      	ldr	r3, [pc, #624]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002530:	681b      	ldr	r3, [r3, #0]
 8002532:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002536:	d003      	beq.n	8002540 <HAL_RCC_OscConfig+0x68>
 8002538:	6863      	ldr	r3, [r4, #4]
 800253a:	2b00      	cmp	r3, #0
 800253c:	f000 818e 	beq.w	800285c <HAL_RCC_OscConfig+0x384>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002540:	6823      	ldr	r3, [r4, #0]
 8002542:	f013 0f02 	tst.w	r3, #2
 8002546:	d064      	beq.n	8002612 <HAL_RCC_OscConfig+0x13a>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002548:	4b95      	ldr	r3, [pc, #596]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 800254a:	689b      	ldr	r3, [r3, #8]
 800254c:	f013 0f0c 	tst.w	r3, #12
 8002550:	d046      	beq.n	80025e0 <HAL_RCC_OscConfig+0x108>
 8002552:	4b93      	ldr	r3, [pc, #588]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002554:	689b      	ldr	r3, [r3, #8]
 8002556:	f003 030c 	and.w	r3, r3, #12
 800255a:	2b08      	cmp	r3, #8
 800255c:	d03b      	beq.n	80025d6 <HAL_RCC_OscConfig+0xfe>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800255e:	68e3      	ldr	r3, [r4, #12]
 8002560:	2b00      	cmp	r3, #0
 8002562:	d07f      	beq.n	8002664 <HAL_RCC_OscConfig+0x18c>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8002564:	2201      	movs	r2, #1
 8002566:	4b90      	ldr	r3, [pc, #576]	; (80027a8 <HAL_RCC_OscConfig+0x2d0>)
 8002568:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800256a:	f7fe f859 	bl	8000620 <HAL_GetTick>
 800256e:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002570:	4d8b      	ldr	r5, [pc, #556]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002572:	682b      	ldr	r3, [r5, #0]
 8002574:	f013 0f02 	tst.w	r3, #2
 8002578:	d164      	bne.n	8002644 <HAL_RCC_OscConfig+0x16c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800257a:	f7fe f851 	bl	8000620 <HAL_GetTick>
 800257e:	1b80      	subs	r0, r0, r6
 8002580:	2864      	cmp	r0, #100	; 0x64
 8002582:	d9f6      	bls.n	8002572 <HAL_RCC_OscConfig+0x9a>
          {
            return HAL_TIMEOUT;
 8002584:	2003      	movs	r0, #3
 8002586:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002588:	7922      	ldrb	r2, [r4, #4]
 800258a:	4b86      	ldr	r3, [pc, #536]	; (80027a4 <HAL_RCC_OscConfig+0x2cc>)
 800258c:	701a      	strb	r2, [r3, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800258e:	6863      	ldr	r3, [r4, #4]
 8002590:	b183      	cbz	r3, 80025b4 <HAL_RCC_OscConfig+0xdc>
        tickstart = HAL_GetTick();
 8002592:	f7fe f845 	bl	8000620 <HAL_GetTick>
 8002596:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002598:	4d81      	ldr	r5, [pc, #516]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800259a:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800259e:	682b      	ldr	r3, [r5, #0]
 80025a0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80025a4:	d1cc      	bne.n	8002540 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025a6:	f7fe f83b 	bl	8000620 <HAL_GetTick>
 80025aa:	1bc0      	subs	r0, r0, r7
 80025ac:	42b0      	cmp	r0, r6
 80025ae:	d9f6      	bls.n	800259e <HAL_RCC_OscConfig+0xc6>
            return HAL_TIMEOUT;
 80025b0:	2003      	movs	r0, #3
 80025b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tickstart = HAL_GetTick();
 80025b4:	f7fe f834 	bl	8000620 <HAL_GetTick>
 80025b8:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80025ba:	4d79      	ldr	r5, [pc, #484]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025bc:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80025c0:	682b      	ldr	r3, [r5, #0]
 80025c2:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80025c6:	d0bb      	beq.n	8002540 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025c8:	f7fe f82a 	bl	8000620 <HAL_GetTick>
 80025cc:	1bc0      	subs	r0, r0, r7
 80025ce:	42b0      	cmp	r0, r6
 80025d0:	d9f6      	bls.n	80025c0 <HAL_RCC_OscConfig+0xe8>
            return HAL_TIMEOUT;
 80025d2:	2003      	movs	r0, #3
 80025d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80025d6:	4b72      	ldr	r3, [pc, #456]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80025d8:	685b      	ldr	r3, [r3, #4]
 80025da:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80025de:	d1be      	bne.n	800255e <HAL_RCC_OscConfig+0x86>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80025e0:	4b6f      	ldr	r3, [pc, #444]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80025e2:	681b      	ldr	r3, [r3, #0]
 80025e4:	f013 0f02 	tst.w	r3, #2
 80025e8:	d004      	beq.n	80025f4 <HAL_RCC_OscConfig+0x11c>
 80025ea:	68e3      	ldr	r3, [r4, #12]
 80025ec:	2b01      	cmp	r3, #1
 80025ee:	d001      	beq.n	80025f4 <HAL_RCC_OscConfig+0x11c>
        return HAL_ERROR;
 80025f0:	2001      	movs	r0, #1
 80025f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80025f4:	486a      	ldr	r0, [pc, #424]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80025f6:	6802      	ldr	r2, [r0, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80025f8:	23f8      	movs	r3, #248	; 0xf8
 80025fa:	fa93 f3a3 	rbit	r3, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
  uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80025fe:	fab3 f383 	clz	r3, r3
 8002602:	b2db      	uxtb	r3, r3
 8002604:	6921      	ldr	r1, [r4, #16]
 8002606:	fa01 f303 	lsl.w	r3, r1, r3
 800260a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800260e:	4313      	orrs	r3, r2
 8002610:	6003      	str	r3, [r0, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002612:	6823      	ldr	r3, [r4, #0]
 8002614:	f013 0f08 	tst.w	r3, #8
 8002618:	d048      	beq.n	80026ac <HAL_RCC_OscConfig+0x1d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800261a:	6963      	ldr	r3, [r4, #20]
 800261c:	2b00      	cmp	r3, #0
 800261e:	d033      	beq.n	8002688 <HAL_RCC_OscConfig+0x1b0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002620:	2201      	movs	r2, #1
 8002622:	4b62      	ldr	r3, [pc, #392]	; (80027ac <HAL_RCC_OscConfig+0x2d4>)
 8002624:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002626:	f7fd fffb 	bl	8000620 <HAL_GetTick>
 800262a:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800262c:	4d5c      	ldr	r5, [pc, #368]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 800262e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002630:	f013 0f02 	tst.w	r3, #2
 8002634:	d13a      	bne.n	80026ac <HAL_RCC_OscConfig+0x1d4>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002636:	f7fd fff3 	bl	8000620 <HAL_GetTick>
 800263a:	1b80      	subs	r0, r0, r6
 800263c:	2864      	cmp	r0, #100	; 0x64
 800263e:	d9f6      	bls.n	800262e <HAL_RCC_OscConfig+0x156>
        {
          return HAL_TIMEOUT;
 8002640:	2003      	movs	r0, #3
 8002642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002644:	4856      	ldr	r0, [pc, #344]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002646:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002648:	23f8      	movs	r3, #248	; 0xf8
 800264a:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800264e:	fab3 f383 	clz	r3, r3
 8002652:	b2db      	uxtb	r3, r3
 8002654:	6921      	ldr	r1, [r4, #16]
 8002656:	fa01 f303 	lsl.w	r3, r1, r3
 800265a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800265e:	4313      	orrs	r3, r2
 8002660:	6003      	str	r3, [r0, #0]
 8002662:	e7d6      	b.n	8002612 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_DISABLE();
 8002664:	2200      	movs	r2, #0
 8002666:	4b50      	ldr	r3, [pc, #320]	; (80027a8 <HAL_RCC_OscConfig+0x2d0>)
 8002668:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800266a:	f7fd ffd9 	bl	8000620 <HAL_GetTick>
 800266e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002670:	4d4b      	ldr	r5, [pc, #300]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002672:	682b      	ldr	r3, [r5, #0]
 8002674:	f013 0f02 	tst.w	r3, #2
 8002678:	d0cb      	beq.n	8002612 <HAL_RCC_OscConfig+0x13a>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800267a:	f7fd ffd1 	bl	8000620 <HAL_GetTick>
 800267e:	1b80      	subs	r0, r0, r6
 8002680:	2864      	cmp	r0, #100	; 0x64
 8002682:	d9f6      	bls.n	8002672 <HAL_RCC_OscConfig+0x19a>
            return HAL_TIMEOUT;
 8002684:	2003      	movs	r0, #3
 8002686:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002688:	2200      	movs	r2, #0
 800268a:	4b48      	ldr	r3, [pc, #288]	; (80027ac <HAL_RCC_OscConfig+0x2d4>)
 800268c:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800268e:	f7fd ffc7 	bl	8000620 <HAL_GetTick>
 8002692:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002694:	4d42      	ldr	r5, [pc, #264]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002696:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002698:	f013 0f02 	tst.w	r3, #2
 800269c:	d006      	beq.n	80026ac <HAL_RCC_OscConfig+0x1d4>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800269e:	f7fd ffbf 	bl	8000620 <HAL_GetTick>
 80026a2:	1b80      	subs	r0, r0, r6
 80026a4:	2864      	cmp	r0, #100	; 0x64
 80026a6:	d9f6      	bls.n	8002696 <HAL_RCC_OscConfig+0x1be>
        {
          return HAL_TIMEOUT;
 80026a8:	2003      	movs	r0, #3
 80026aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80026ac:	6823      	ldr	r3, [r4, #0]
 80026ae:	f013 0f04 	tst.w	r3, #4
 80026b2:	d11f      	bne.n	80026f4 <HAL_RCC_OscConfig+0x21c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80026b4:	69a3      	ldr	r3, [r4, #24]
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	f000 80d2 	beq.w	8002860 <HAL_RCC_OscConfig+0x388>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80026bc:	4a38      	ldr	r2, [pc, #224]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80026be:	6892      	ldr	r2, [r2, #8]
 80026c0:	f002 020c 	and.w	r2, r2, #12
 80026c4:	2a08      	cmp	r2, #8
 80026c6:	f000 80cd 	beq.w	8002864 <HAL_RCC_OscConfig+0x38c>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80026ca:	2b02      	cmp	r3, #2
 80026cc:	d076      	beq.n	80027bc <HAL_RCC_OscConfig+0x2e4>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80026ce:	2200      	movs	r2, #0
 80026d0:	4b37      	ldr	r3, [pc, #220]	; (80027b0 <HAL_RCC_OscConfig+0x2d8>)
 80026d2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80026d4:	f7fd ffa4 	bl	8000620 <HAL_GetTick>
 80026d8:	4605      	mov	r5, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80026da:	4c31      	ldr	r4, [pc, #196]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80026dc:	6823      	ldr	r3, [r4, #0]
 80026de:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80026e2:	f000 80b9 	beq.w	8002858 <HAL_RCC_OscConfig+0x380>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80026e6:	f7fd ff9b 	bl	8000620 <HAL_GetTick>
 80026ea:	1b40      	subs	r0, r0, r5
 80026ec:	2864      	cmp	r0, #100	; 0x64
 80026ee:	d9f5      	bls.n	80026dc <HAL_RCC_OscConfig+0x204>
          {
            return HAL_TIMEOUT;
 80026f0:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80026f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 80026f4:	4a2a      	ldr	r2, [pc, #168]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80026f6:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80026f8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80026fc:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_DBP;
 80026fe:	f5a2 32e4 	sub.w	r2, r2, #116736	; 0x1c800
 8002702:	6813      	ldr	r3, [r2, #0]
 8002704:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002708:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800270a:	f7fd ff89 	bl	8000620 <HAL_GetTick>
 800270e:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8002710:	4d28      	ldr	r5, [pc, #160]	; (80027b4 <HAL_RCC_OscConfig+0x2dc>)
 8002712:	682b      	ldr	r3, [r5, #0]
 8002714:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002718:	d106      	bne.n	8002728 <HAL_RCC_OscConfig+0x250>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800271a:	f7fd ff81 	bl	8000620 <HAL_GetTick>
 800271e:	1b80      	subs	r0, r0, r6
 8002720:	2864      	cmp	r0, #100	; 0x64
 8002722:	d9f6      	bls.n	8002712 <HAL_RCC_OscConfig+0x23a>
        return HAL_TIMEOUT;
 8002724:	2003      	movs	r0, #3
 8002726:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8002728:	2200      	movs	r2, #0
 800272a:	4b23      	ldr	r3, [pc, #140]	; (80027b8 <HAL_RCC_OscConfig+0x2e0>)
 800272c:	701a      	strb	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800272e:	f7fd ff77 	bl	8000620 <HAL_GetTick>
 8002732:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002734:	4d1a      	ldr	r5, [pc, #104]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002736:	f241 3688 	movw	r6, #5000	; 0x1388
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800273a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800273c:	f013 0f02 	tst.w	r3, #2
 8002740:	d006      	beq.n	8002750 <HAL_RCC_OscConfig+0x278>
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002742:	f7fd ff6d 	bl	8000620 <HAL_GetTick>
 8002746:	1bc0      	subs	r0, r0, r7
 8002748:	42b0      	cmp	r0, r6
 800274a:	d9f6      	bls.n	800273a <HAL_RCC_OscConfig+0x262>
        return HAL_TIMEOUT;
 800274c:	2003      	movs	r0, #3
 800274e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002750:	7a22      	ldrb	r2, [r4, #8]
 8002752:	4b19      	ldr	r3, [pc, #100]	; (80027b8 <HAL_RCC_OscConfig+0x2e0>)
 8002754:	701a      	strb	r2, [r3, #0]
    if((RCC_OscInitStruct->LSEState) == RCC_LSE_ON)
 8002756:	68a3      	ldr	r3, [r4, #8]
 8002758:	2b01      	cmp	r3, #1
 800275a:	d010      	beq.n	800277e <HAL_RCC_OscConfig+0x2a6>
      tickstart = HAL_GetTick();
 800275c:	f7fd ff60 	bl	8000620 <HAL_GetTick>
 8002760:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002762:	4d0f      	ldr	r5, [pc, #60]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002764:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002768:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800276a:	f013 0f02 	tst.w	r3, #2
 800276e:	d0a1      	beq.n	80026b4 <HAL_RCC_OscConfig+0x1dc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002770:	f7fd ff56 	bl	8000620 <HAL_GetTick>
 8002774:	1bc0      	subs	r0, r0, r7
 8002776:	42b0      	cmp	r0, r6
 8002778:	d9f6      	bls.n	8002768 <HAL_RCC_OscConfig+0x290>
          return HAL_TIMEOUT;
 800277a:	2003      	movs	r0, #3
 800277c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tickstart = HAL_GetTick();
 800277e:	f7fd ff4f 	bl	8000620 <HAL_GetTick>
 8002782:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002784:	4d06      	ldr	r5, [pc, #24]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002786:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800278a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800278c:	f013 0f02 	tst.w	r3, #2
 8002790:	d190      	bne.n	80026b4 <HAL_RCC_OscConfig+0x1dc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002792:	f7fd ff45 	bl	8000620 <HAL_GetTick>
 8002796:	1bc0      	subs	r0, r0, r7
 8002798:	42b0      	cmp	r0, r6
 800279a:	d9f6      	bls.n	800278a <HAL_RCC_OscConfig+0x2b2>
          return HAL_TIMEOUT;
 800279c:	2003      	movs	r0, #3
 800279e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80027a0:	40023800 	.word	0x40023800
 80027a4:	40023802 	.word	0x40023802
 80027a8:	42470000 	.word	0x42470000
 80027ac:	42470e80 	.word	0x42470e80
 80027b0:	42470060 	.word	0x42470060
 80027b4:	40007000 	.word	0x40007000
 80027b8:	40023870 	.word	0x40023870
        __HAL_RCC_PLL_DISABLE();
 80027bc:	2200      	movs	r2, #0
 80027be:	4b2a      	ldr	r3, [pc, #168]	; (8002868 <HAL_RCC_OscConfig+0x390>)
 80027c0:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80027c2:	f7fd ff2d 	bl	8000620 <HAL_GetTick>
 80027c6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80027c8:	4d28      	ldr	r5, [pc, #160]	; (800286c <HAL_RCC_OscConfig+0x394>)
 80027ca:	682b      	ldr	r3, [r5, #0]
 80027cc:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80027d0:	d006      	beq.n	80027e0 <HAL_RCC_OscConfig+0x308>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80027d2:	f7fd ff25 	bl	8000620 <HAL_GetTick>
 80027d6:	1b80      	subs	r0, r0, r6
 80027d8:	2864      	cmp	r0, #100	; 0x64
 80027da:	d9f6      	bls.n	80027ca <HAL_RCC_OscConfig+0x2f2>
            return HAL_TIMEOUT;
 80027dc:	2003      	movs	r0, #3
 80027de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80027e0:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80027e4:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80027e8:	fab2 f282 	clz	r2, r2
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80027ec:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 80027f0:	fa90 f0a0 	rbit	r0, r0
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80027f4:	fab0 f080 	clz	r0, r0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80027f8:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 80027fc:	fa91 f1a1 	rbit	r1, r1
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002800:	fab1 f181 	clz	r1, r1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002804:	6a23      	ldr	r3, [r4, #32]
 8002806:	69e5      	ldr	r5, [r4, #28]
 8002808:	432b      	orrs	r3, r5
 800280a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800280e:	b2d2      	uxtb	r2, r2
 8002810:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8002812:	fa05 f202 	lsl.w	r2, r5, r2
 8002816:	4313      	orrs	r3, r2
 8002818:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800281a:	0852      	lsrs	r2, r2, #1
 800281c:	3a01      	subs	r2, #1
 800281e:	b2c0      	uxtb	r0, r0
 8002820:	4082      	lsls	r2, r0
 8002822:	4313      	orrs	r3, r2
 8002824:	b2c9      	uxtb	r1, r1
 8002826:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002828:	408a      	lsls	r2, r1
 800282a:	4313      	orrs	r3, r2
 800282c:	4a0f      	ldr	r2, [pc, #60]	; (800286c <HAL_RCC_OscConfig+0x394>)
 800282e:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 8002830:	2201      	movs	r2, #1
 8002832:	4b0d      	ldr	r3, [pc, #52]	; (8002868 <HAL_RCC_OscConfig+0x390>)
 8002834:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002836:	f7fd fef3 	bl	8000620 <HAL_GetTick>
 800283a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800283c:	4c0b      	ldr	r4, [pc, #44]	; (800286c <HAL_RCC_OscConfig+0x394>)
 800283e:	6823      	ldr	r3, [r4, #0]
 8002840:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002844:	d106      	bne.n	8002854 <HAL_RCC_OscConfig+0x37c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002846:	f7fd feeb 	bl	8000620 <HAL_GetTick>
 800284a:	1b40      	subs	r0, r0, r5
 800284c:	2864      	cmp	r0, #100	; 0x64
 800284e:	d9f6      	bls.n	800283e <HAL_RCC_OscConfig+0x366>
            return HAL_TIMEOUT;
 8002850:	2003      	movs	r0, #3
 8002852:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8002854:	2000      	movs	r0, #0
 8002856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002858:	2000      	movs	r0, #0
 800285a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_ERROR;
 800285c:	2001      	movs	r0, #1
 800285e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8002860:	2000      	movs	r0, #0
 8002862:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_ERROR;
 8002864:	2001      	movs	r0, #1
 8002866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002868:	42470060 	.word	0x42470060
 800286c:	40023800 	.word	0x40023800

08002870 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8002870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002874:	4604      	mov	r4, r0
 8002876:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002878:	4b87      	ldr	r3, [pc, #540]	; (8002a98 <HAL_RCC_ClockConfig+0x228>)
 800287a:	681b      	ldr	r3, [r3, #0]
 800287c:	f003 030f 	and.w	r3, r3, #15
 8002880:	428b      	cmp	r3, r1
 8002882:	d274      	bcs.n	800296e <HAL_RCC_ClockConfig+0xfe>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002884:	b2ca      	uxtb	r2, r1
 8002886:	4b84      	ldr	r3, [pc, #528]	; (8002a98 <HAL_RCC_ClockConfig+0x228>)
 8002888:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800288a:	681b      	ldr	r3, [r3, #0]
 800288c:	f003 030f 	and.w	r3, r3, #15
 8002890:	4299      	cmp	r1, r3
 8002892:	d002      	beq.n	800289a <HAL_RCC_ClockConfig+0x2a>
    {
      return HAL_ERROR;
 8002894:	2001      	movs	r0, #1
 8002896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800289a:	6803      	ldr	r3, [r0, #0]
 800289c:	f013 0f02 	tst.w	r3, #2
 80028a0:	d006      	beq.n	80028b0 <HAL_RCC_ClockConfig+0x40>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80028a2:	4a7e      	ldr	r2, [pc, #504]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80028a4:	6893      	ldr	r3, [r2, #8]
 80028a6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80028aa:	6881      	ldr	r1, [r0, #8]
 80028ac:	430b      	orrs	r3, r1
 80028ae:	6093      	str	r3, [r2, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80028b0:	6823      	ldr	r3, [r4, #0]
 80028b2:	f013 0f01 	tst.w	r3, #1
 80028b6:	f000 80cb 	beq.w	8002a50 <HAL_RCC_ClockConfig+0x1e0>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80028ba:	6862      	ldr	r2, [r4, #4]
 80028bc:	2a01      	cmp	r2, #1
 80028be:	d025      	beq.n	800290c <HAL_RCC_ClockConfig+0x9c>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80028c0:	2a02      	cmp	r2, #2
 80028c2:	d02b      	beq.n	800291c <HAL_RCC_ClockConfig+0xac>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80028c4:	4b75      	ldr	r3, [pc, #468]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80028c6:	681b      	ldr	r3, [r3, #0]
 80028c8:	f013 0f02 	tst.w	r3, #2
 80028cc:	f000 80dd 	beq.w	8002a8a <HAL_RCC_ClockConfig+0x21a>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80028d0:	4972      	ldr	r1, [pc, #456]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80028d2:	688b      	ldr	r3, [r1, #8]
 80028d4:	f023 0303 	bic.w	r3, r3, #3
 80028d8:	4313      	orrs	r3, r2
 80028da:	608b      	str	r3, [r1, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80028dc:	f7fd fea0 	bl	8000620 <HAL_GetTick>
 80028e0:	4605      	mov	r5, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80028e2:	6863      	ldr	r3, [r4, #4]
 80028e4:	2b01      	cmp	r3, #1
 80028e6:	d021      	beq.n	800292c <HAL_RCC_ClockConfig+0xbc>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80028e8:	2b02      	cmp	r3, #2
 80028ea:	d030      	beq.n	800294e <HAL_RCC_ClockConfig+0xde>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80028ec:	4e6b      	ldr	r6, [pc, #428]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80028ee:	f241 3788 	movw	r7, #5000	; 0x1388
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80028f2:	68b3      	ldr	r3, [r6, #8]
 80028f4:	f013 0f0c 	tst.w	r3, #12
 80028f8:	f000 80aa 	beq.w	8002a50 <HAL_RCC_ClockConfig+0x1e0>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80028fc:	f7fd fe90 	bl	8000620 <HAL_GetTick>
 8002900:	1b40      	subs	r0, r0, r5
 8002902:	42b8      	cmp	r0, r7
 8002904:	d9f5      	bls.n	80028f2 <HAL_RCC_ClockConfig+0x82>
          {
            return HAL_TIMEOUT;
 8002906:	2003      	movs	r0, #3
 8002908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800290c:	4b63      	ldr	r3, [pc, #396]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 800290e:	681b      	ldr	r3, [r3, #0]
 8002910:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002914:	d1dc      	bne.n	80028d0 <HAL_RCC_ClockConfig+0x60>
          return HAL_ERROR;
 8002916:	2001      	movs	r0, #1
 8002918:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800291c:	4b5f      	ldr	r3, [pc, #380]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002924:	d1d4      	bne.n	80028d0 <HAL_RCC_ClockConfig+0x60>
          return HAL_ERROR;
 8002926:	2001      	movs	r0, #1
 8002928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 800292c:	4e5b      	ldr	r6, [pc, #364]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800292e:	f241 3788 	movw	r7, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8002932:	68b3      	ldr	r3, [r6, #8]
 8002934:	f003 030c 	and.w	r3, r3, #12
 8002938:	2b04      	cmp	r3, #4
 800293a:	f000 8089 	beq.w	8002a50 <HAL_RCC_ClockConfig+0x1e0>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800293e:	f7fd fe6f 	bl	8000620 <HAL_GetTick>
 8002942:	1b40      	subs	r0, r0, r5
 8002944:	42b8      	cmp	r0, r7
 8002946:	d9f4      	bls.n	8002932 <HAL_RCC_ClockConfig+0xc2>
            return HAL_TIMEOUT;
 8002948:	2003      	movs	r0, #3
 800294a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800294e:	4e53      	ldr	r6, [pc, #332]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002950:	f241 3788 	movw	r7, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002954:	68b3      	ldr	r3, [r6, #8]
 8002956:	f003 030c 	and.w	r3, r3, #12
 800295a:	2b08      	cmp	r3, #8
 800295c:	d078      	beq.n	8002a50 <HAL_RCC_ClockConfig+0x1e0>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800295e:	f7fd fe5f 	bl	8000620 <HAL_GetTick>
 8002962:	1b40      	subs	r0, r0, r5
 8002964:	42b8      	cmp	r0, r7
 8002966:	d9f5      	bls.n	8002954 <HAL_RCC_ClockConfig+0xe4>
            return HAL_TIMEOUT;
 8002968:	2003      	movs	r0, #3
 800296a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800296e:	6803      	ldr	r3, [r0, #0]
 8002970:	f013 0f02 	tst.w	r3, #2
 8002974:	d006      	beq.n	8002984 <HAL_RCC_ClockConfig+0x114>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002976:	4a49      	ldr	r2, [pc, #292]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002978:	6893      	ldr	r3, [r2, #8]
 800297a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800297e:	6881      	ldr	r1, [r0, #8]
 8002980:	430b      	orrs	r3, r1
 8002982:	6093      	str	r3, [r2, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002984:	6823      	ldr	r3, [r4, #0]
 8002986:	f013 0f01 	tst.w	r3, #1
 800298a:	d056      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800298c:	6862      	ldr	r2, [r4, #4]
 800298e:	2a01      	cmp	r2, #1
 8002990:	d023      	beq.n	80029da <HAL_RCC_ClockConfig+0x16a>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002992:	2a02      	cmp	r2, #2
 8002994:	d029      	beq.n	80029ea <HAL_RCC_ClockConfig+0x17a>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002996:	4b41      	ldr	r3, [pc, #260]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002998:	681b      	ldr	r3, [r3, #0]
 800299a:	f013 0f02 	tst.w	r3, #2
 800299e:	d077      	beq.n	8002a90 <HAL_RCC_ClockConfig+0x220>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80029a0:	493e      	ldr	r1, [pc, #248]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80029a2:	688b      	ldr	r3, [r1, #8]
 80029a4:	f023 0303 	bic.w	r3, r3, #3
 80029a8:	4313      	orrs	r3, r2
 80029aa:	608b      	str	r3, [r1, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80029ac:	f7fd fe38 	bl	8000620 <HAL_GetTick>
 80029b0:	4606      	mov	r6, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80029b2:	6863      	ldr	r3, [r4, #4]
 80029b4:	2b01      	cmp	r3, #1
 80029b6:	d020      	beq.n	80029fa <HAL_RCC_ClockConfig+0x18a>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80029b8:	2b02      	cmp	r3, #2
 80029ba:	d02e      	beq.n	8002a1a <HAL_RCC_ClockConfig+0x1aa>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80029bc:	4f37      	ldr	r7, [pc, #220]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029be:	f241 3888 	movw	r8, #5000	; 0x1388
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80029c2:	68bb      	ldr	r3, [r7, #8]
 80029c4:	f013 0f0c 	tst.w	r3, #12
 80029c8:	d037      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029ca:	f7fd fe29 	bl	8000620 <HAL_GetTick>
 80029ce:	1b80      	subs	r0, r0, r6
 80029d0:	4540      	cmp	r0, r8
 80029d2:	d9f6      	bls.n	80029c2 <HAL_RCC_ClockConfig+0x152>
          {
            return HAL_TIMEOUT;
 80029d4:	2003      	movs	r0, #3
 80029d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80029da:	4b30      	ldr	r3, [pc, #192]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80029dc:	681b      	ldr	r3, [r3, #0]
 80029de:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80029e2:	d1dd      	bne.n	80029a0 <HAL_RCC_ClockConfig+0x130>
          return HAL_ERROR;
 80029e4:	2001      	movs	r0, #1
 80029e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80029ea:	4b2c      	ldr	r3, [pc, #176]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80029ec:	681b      	ldr	r3, [r3, #0]
 80029ee:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80029f2:	d1d5      	bne.n	80029a0 <HAL_RCC_ClockConfig+0x130>
          return HAL_ERROR;
 80029f4:	2001      	movs	r0, #1
 80029f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80029fa:	4f28      	ldr	r7, [pc, #160]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029fc:	f241 3888 	movw	r8, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8002a00:	68bb      	ldr	r3, [r7, #8]
 8002a02:	f003 030c 	and.w	r3, r3, #12
 8002a06:	2b04      	cmp	r3, #4
 8002a08:	d017      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a0a:	f7fd fe09 	bl	8000620 <HAL_GetTick>
 8002a0e:	1b80      	subs	r0, r0, r6
 8002a10:	4540      	cmp	r0, r8
 8002a12:	d9f5      	bls.n	8002a00 <HAL_RCC_ClockConfig+0x190>
            return HAL_TIMEOUT;
 8002a14:	2003      	movs	r0, #3
 8002a16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002a1a:	4f20      	ldr	r7, [pc, #128]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a1c:	f241 3888 	movw	r8, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002a20:	68bb      	ldr	r3, [r7, #8]
 8002a22:	f003 030c 	and.w	r3, r3, #12
 8002a26:	2b08      	cmp	r3, #8
 8002a28:	d007      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a2a:	f7fd fdf9 	bl	8000620 <HAL_GetTick>
 8002a2e:	1b80      	subs	r0, r0, r6
 8002a30:	4540      	cmp	r0, r8
 8002a32:	d9f5      	bls.n	8002a20 <HAL_RCC_ClockConfig+0x1b0>
            return HAL_TIMEOUT;
 8002a34:	2003      	movs	r0, #3
 8002a36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002a3a:	b2ea      	uxtb	r2, r5
 8002a3c:	4b16      	ldr	r3, [pc, #88]	; (8002a98 <HAL_RCC_ClockConfig+0x228>)
 8002a3e:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	f003 030f 	and.w	r3, r3, #15
 8002a46:	429d      	cmp	r5, r3
 8002a48:	d002      	beq.n	8002a50 <HAL_RCC_ClockConfig+0x1e0>
    {
      return HAL_ERROR;
 8002a4a:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 8002a4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002a50:	6823      	ldr	r3, [r4, #0]
 8002a52:	f013 0f04 	tst.w	r3, #4
 8002a56:	d006      	beq.n	8002a66 <HAL_RCC_ClockConfig+0x1f6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002a58:	4a10      	ldr	r2, [pc, #64]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002a5a:	6893      	ldr	r3, [r2, #8]
 8002a5c:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8002a60:	68e1      	ldr	r1, [r4, #12]
 8002a62:	430b      	orrs	r3, r1
 8002a64:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002a66:	6823      	ldr	r3, [r4, #0]
 8002a68:	f013 0f08 	tst.w	r3, #8
 8002a6c:	d007      	beq.n	8002a7e <HAL_RCC_ClockConfig+0x20e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002a6e:	4a0b      	ldr	r2, [pc, #44]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002a70:	6893      	ldr	r3, [r2, #8]
 8002a72:	6921      	ldr	r1, [r4, #16]
 8002a74:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8002a78:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002a7c:	6093      	str	r3, [r2, #8]
  HAL_InitTick (TICK_INT_PRIORITY);
 8002a7e:	2000      	movs	r0, #0
 8002a80:	f7fd fd98 	bl	80005b4 <HAL_InitTick>
  return HAL_OK;
 8002a84:	2000      	movs	r0, #0
 8002a86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          return HAL_ERROR;
 8002a8a:	2001      	movs	r0, #1
 8002a8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          return HAL_ERROR;
 8002a90:	2001      	movs	r0, #1
 8002a92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002a96:	bf00      	nop
 8002a98:	40023c00 	.word	0x40023c00
 8002a9c:	40023800 	.word	0x40023800

08002aa0 <HAL_RCC_MCOConfig>:
  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8002aa0:	b570      	push	{r4, r5, r6, lr}
 8002aa2:	b086      	sub	sp, #24
 8002aa4:	460c      	mov	r4, r1
 8002aa6:	4616      	mov	r6, r2
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 8002aa8:	b1d8      	cbz	r0, 8002ae2 <HAL_RCC_MCOConfig+0x42>
  else
  {
    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));

    /* MCO2 Clock Enable */
    __MCO2_CLK_ENABLE();
 8002aaa:	4d1b      	ldr	r5, [pc, #108]	; (8002b18 <HAL_RCC_MCOConfig+0x78>)
 8002aac:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002aae:	f043 0304 	orr.w	r3, r3, #4
 8002ab2:	632b      	str	r3, [r5, #48]	; 0x30

    /* Configure the MCO2 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO2_PIN;
 8002ab4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002ab8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002aba:	2302      	movs	r3, #2
 8002abc:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002abe:	2303      	movs	r3, #3
 8002ac0:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002ac2:	2300      	movs	r3, #0
 8002ac4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8002ac6:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 8002ac8:	a901      	add	r1, sp, #4
 8002aca:	4814      	ldr	r0, [pc, #80]	; (8002b1c <HAL_RCC_MCOConfig+0x7c>)
 8002acc:	f7ff fc10 	bl	80022f0 <HAL_GPIO_Init>

    /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
 8002ad0:	68ab      	ldr	r3, [r5, #8]
 8002ad2:	ea44 04c6 	orr.w	r4, r4, r6, lsl #3
 8002ad6:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8002ada:	431c      	orrs	r4, r3
 8002adc:	60ac      	str	r4, [r5, #8]
  }
}
 8002ade:	b006      	add	sp, #24
 8002ae0:	bd70      	pop	{r4, r5, r6, pc}
    __MCO1_CLK_ENABLE();
 8002ae2:	4d0d      	ldr	r5, [pc, #52]	; (8002b18 <HAL_RCC_MCOConfig+0x78>)
 8002ae4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002ae6:	f043 0301 	orr.w	r3, r3, #1
 8002aea:	632b      	str	r3, [r5, #48]	; 0x30
    GPIO_InitStruct.Pin = MCO1_PIN;
 8002aec:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002af0:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002af2:	2302      	movs	r3, #2
 8002af4:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002af6:	2303      	movs	r3, #3
 8002af8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002afa:	2300      	movs	r3, #0
 8002afc:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8002afe:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8002b00:	a901      	add	r1, sp, #4
 8002b02:	4807      	ldr	r0, [pc, #28]	; (8002b20 <HAL_RCC_MCOConfig+0x80>)
 8002b04:	f7ff fbf4 	bl	80022f0 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 8002b08:	68aa      	ldr	r2, [r5, #8]
 8002b0a:	f022 62ec 	bic.w	r2, r2, #123731968	; 0x7600000
 8002b0e:	4332      	orrs	r2, r6
 8002b10:	4314      	orrs	r4, r2
 8002b12:	60ac      	str	r4, [r5, #8]
 8002b14:	e7e3      	b.n	8002ade <HAL_RCC_MCOConfig+0x3e>
 8002b16:	bf00      	nop
 8002b18:	40023800 	.word	0x40023800
 8002b1c:	40020800 	.word	0x40020800
 8002b20:	40020000 	.word	0x40020000

08002b24 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002b24:	4b1b      	ldr	r3, [pc, #108]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b26:	689b      	ldr	r3, [r3, #8]
 8002b28:	f003 030c 	and.w	r3, r3, #12
 8002b2c:	2b04      	cmp	r3, #4
 8002b2e:	d003      	beq.n	8002b38 <HAL_RCC_GetSysClockFreq+0x14>
 8002b30:	2b08      	cmp	r3, #8
 8002b32:	d003      	beq.n	8002b3c <HAL_RCC_GetSysClockFreq+0x18>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8002b34:	4818      	ldr	r0, [pc, #96]	; (8002b98 <HAL_RCC_GetSysClockFreq+0x74>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002b36:	4770      	bx	lr
      sysclockfreq = HSE_VALUE;
 8002b38:	4818      	ldr	r0, [pc, #96]	; (8002b9c <HAL_RCC_GetSysClockFreq+0x78>)
 8002b3a:	4770      	bx	lr
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002b3c:	4a15      	ldr	r2, [pc, #84]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b3e:	6853      	ldr	r3, [r2, #4]
 8002b40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002b44:	6852      	ldr	r2, [r2, #4]
 8002b46:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8002b4a:	4a12      	ldr	r2, [pc, #72]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b4c:	6850      	ldr	r0, [r2, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002b4e:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8002b52:	fa91 f2a1 	rbit	r2, r1
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002b56:	fab2 f282 	clz	r2, r2
 8002b5a:	ea00 0001 	and.w	r0, r0, r1
 8002b5e:	b2d2      	uxtb	r2, r2
 8002b60:	fa20 f202 	lsr.w	r2, r0, r2
 8002b64:	bf14      	ite	ne
 8002b66:	480d      	ldrne	r0, [pc, #52]	; (8002b9c <HAL_RCC_GetSysClockFreq+0x78>)
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8002b68:	480b      	ldreq	r0, [pc, #44]	; (8002b98 <HAL_RCC_GetSysClockFreq+0x74>)
 8002b6a:	fbb0 f0f3 	udiv	r0, r0, r3
 8002b6e:	fb00 f002 	mul.w	r0, r0, r2
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8002b72:	4b08      	ldr	r3, [pc, #32]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b74:	685b      	ldr	r3, [r3, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002b76:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8002b7a:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002b7e:	fab2 f282 	clz	r2, r2
 8002b82:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002b86:	b2d2      	uxtb	r2, r2
 8002b88:	40d3      	lsrs	r3, r2
 8002b8a:	3301      	adds	r3, #1
 8002b8c:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8002b8e:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 8002b92:	4770      	bx	lr
 8002b94:	40023800 	.word	0x40023800
 8002b98:	00f42400 	.word	0x00f42400
 8002b9c:	017d7840 	.word	0x017d7840

08002ba0 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002ba0:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8002ba2:	f7ff ffbf 	bl	8002b24 <HAL_RCC_GetSysClockFreq>
 8002ba6:	4b09      	ldr	r3, [pc, #36]	; (8002bcc <HAL_RCC_GetHCLKFreq+0x2c>)
 8002ba8:	689a      	ldr	r2, [r3, #8]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002baa:	23f0      	movs	r3, #240	; 0xf0
 8002bac:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002bb0:	fab3 f383 	clz	r3, r3
 8002bb4:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8002bb8:	b2db      	uxtb	r3, r3
 8002bba:	fa22 f303 	lsr.w	r3, r2, r3
 8002bbe:	4a04      	ldr	r2, [pc, #16]	; (8002bd0 <HAL_RCC_GetHCLKFreq+0x30>)
 8002bc0:	5cd3      	ldrb	r3, [r2, r3]
 8002bc2:	40d8      	lsrs	r0, r3
 8002bc4:	4b03      	ldr	r3, [pc, #12]	; (8002bd4 <HAL_RCC_GetHCLKFreq+0x34>)
 8002bc6:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8002bc8:	bd08      	pop	{r3, pc}
 8002bca:	bf00      	nop
 8002bcc:	40023800 	.word	0x40023800
 8002bd0:	0800c2e4 	.word	0x0800c2e4
 8002bd4:	20000000 	.word	0x20000000

08002bd8 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002bd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002bda:	4605      	mov	r5, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8002bdc:	6803      	ldr	r3, [r0, #0]
 8002bde:	f013 0f01 	tst.w	r3, #1
 8002be2:	d105      	bne.n	8002bf0 <HAL_RCCEx_PeriphCLKConfig+0x18>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8002be4:	682b      	ldr	r3, [r5, #0]
 8002be6:	f013 0f02 	tst.w	r3, #2
 8002bea:	d13d      	bne.n	8002c68 <HAL_RCCEx_PeriphCLKConfig+0x90>
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  return HAL_OK;
 8002bec:	2000      	movs	r0, #0
 8002bee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 8002bf0:	2200      	movs	r2, #0
 8002bf2:	4b4d      	ldr	r3, [pc, #308]	; (8002d28 <HAL_RCCEx_PeriphCLKConfig+0x150>)
 8002bf4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002bf6:	f7fd fd13 	bl	8000620 <HAL_GetTick>
 8002bfa:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002bfc:	4c4b      	ldr	r4, [pc, #300]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002bfe:	6823      	ldr	r3, [r4, #0]
 8002c00:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002c04:	d006      	beq.n	8002c14 <HAL_RCCEx_PeriphCLKConfig+0x3c>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8002c06:	f7fd fd0b 	bl	8000620 <HAL_GetTick>
 8002c0a:	1b80      	subs	r0, r0, r6
 8002c0c:	2864      	cmp	r0, #100	; 0x64
 8002c0e:	d9f6      	bls.n	8002bfe <HAL_RCCEx_PeriphCLKConfig+0x26>
        return HAL_TIMEOUT;
 8002c10:	2003      	movs	r0, #3
 8002c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002c14:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8002c18:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002c1c:	fab2 f282 	clz	r2, r2
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002c20:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8002c24:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002c28:	fab3 f383 	clz	r3, r3
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8002c2c:	b2d2      	uxtb	r2, r2
 8002c2e:	6869      	ldr	r1, [r5, #4]
 8002c30:	fa01 f202 	lsl.w	r2, r1, r2
 8002c34:	b2db      	uxtb	r3, r3
 8002c36:	68a9      	ldr	r1, [r5, #8]
 8002c38:	fa01 f303 	lsl.w	r3, r1, r3
 8002c3c:	4313      	orrs	r3, r2
 8002c3e:	4a3b      	ldr	r2, [pc, #236]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c40:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8002c44:	2201      	movs	r2, #1
 8002c46:	4b38      	ldr	r3, [pc, #224]	; (8002d28 <HAL_RCCEx_PeriphCLKConfig+0x150>)
 8002c48:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002c4a:	f7fd fce9 	bl	8000620 <HAL_GetTick>
 8002c4e:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002c50:	4c36      	ldr	r4, [pc, #216]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c52:	6823      	ldr	r3, [r4, #0]
 8002c54:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002c58:	d1c4      	bne.n	8002be4 <HAL_RCCEx_PeriphCLKConfig+0xc>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8002c5a:	f7fd fce1 	bl	8000620 <HAL_GetTick>
 8002c5e:	1b80      	subs	r0, r0, r6
 8002c60:	2864      	cmp	r0, #100	; 0x64
 8002c62:	d9f6      	bls.n	8002c52 <HAL_RCCEx_PeriphCLKConfig+0x7a>
        return HAL_TIMEOUT;
 8002c64:	2003      	movs	r0, #3
 8002c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8002c68:	4a30      	ldr	r2, [pc, #192]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c6a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8002c6c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002c70:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_DBP;
 8002c72:	f5a2 32e4 	sub.w	r2, r2, #116736	; 0x1c800
 8002c76:	6813      	ldr	r3, [r2, #0]
 8002c78:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c7c:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002c7e:	f7fd fccf 	bl	8000620 <HAL_GetTick>
 8002c82:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8002c84:	4c2a      	ldr	r4, [pc, #168]	; (8002d30 <HAL_RCCEx_PeriphCLKConfig+0x158>)
 8002c86:	6823      	ldr	r3, [r4, #0]
 8002c88:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002c8c:	d106      	bne.n	8002c9c <HAL_RCCEx_PeriphCLKConfig+0xc4>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002c8e:	f7fd fcc7 	bl	8000620 <HAL_GetTick>
 8002c92:	1b80      	subs	r0, r0, r6
 8002c94:	2864      	cmp	r0, #100	; 0x64
 8002c96:	d9f6      	bls.n	8002c86 <HAL_RCCEx_PeriphCLKConfig+0xae>
        return HAL_TIMEOUT;
 8002c98:	2003      	movs	r0, #3
 8002c9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8002c9c:	4b23      	ldr	r3, [pc, #140]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c9e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002ca0:	68ea      	ldr	r2, [r5, #12]
 8002ca2:	4053      	eors	r3, r2
 8002ca4:	f413 7f40 	tst.w	r3, #768	; 0x300
 8002ca8:	d009      	beq.n	8002cbe <HAL_RCCEx_PeriphCLKConfig+0xe6>
      tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002caa:	4a20      	ldr	r2, [pc, #128]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002cac:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8002cae:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002cb2:	4920      	ldr	r1, [pc, #128]	; (8002d34 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 8002cb4:	2001      	movs	r0, #1
 8002cb6:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002cb8:	2000      	movs	r0, #0
 8002cba:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg;
 8002cbc:	6713      	str	r3, [r2, #112]	; 0x70
    if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 8002cbe:	68eb      	ldr	r3, [r5, #12]
 8002cc0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002cc4:	d013      	beq.n	8002cee <HAL_RCCEx_PeriphCLKConfig+0x116>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002cc6:	68eb      	ldr	r3, [r5, #12]
 8002cc8:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8002ccc:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8002cd0:	d01e      	beq.n	8002d10 <HAL_RCCEx_PeriphCLKConfig+0x138>
 8002cd2:	4a16      	ldr	r2, [pc, #88]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002cd4:	6893      	ldr	r3, [r2, #8]
 8002cd6:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8002cda:	6093      	str	r3, [r2, #8]
 8002cdc:	4a13      	ldr	r2, [pc, #76]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002cde:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002ce0:	68eb      	ldr	r3, [r5, #12]
 8002ce2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002ce6:	430b      	orrs	r3, r1
 8002ce8:	6713      	str	r3, [r2, #112]	; 0x70
  return HAL_OK;
 8002cea:	2000      	movs	r0, #0
 8002cec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tickstart = HAL_GetTick();
 8002cee:	f7fd fc97 	bl	8000620 <HAL_GetTick>
 8002cf2:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002cf4:	4c0d      	ldr	r4, [pc, #52]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002cf6:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002cfa:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8002cfc:	f013 0f02 	tst.w	r3, #2
 8002d00:	d1e1      	bne.n	8002cc6 <HAL_RCCEx_PeriphCLKConfig+0xee>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002d02:	f7fd fc8d 	bl	8000620 <HAL_GetTick>
 8002d06:	1bc0      	subs	r0, r0, r7
 8002d08:	42b0      	cmp	r0, r6
 8002d0a:	d9f6      	bls.n	8002cfa <HAL_RCCEx_PeriphCLKConfig+0x122>
          return HAL_TIMEOUT;
 8002d0c:	2003      	movs	r0, #3
}
 8002d0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002d10:	4906      	ldr	r1, [pc, #24]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002d12:	688a      	ldr	r2, [r1, #8]
 8002d14:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8002d18:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8002d1c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002d20:	4313      	orrs	r3, r2
 8002d22:	608b      	str	r3, [r1, #8]
 8002d24:	e7da      	b.n	8002cdc <HAL_RCCEx_PeriphCLKConfig+0x104>
 8002d26:	bf00      	nop
 8002d28:	42470068 	.word	0x42470068
 8002d2c:	40023800 	.word	0x40023800
 8002d30:	40007000 	.word	0x40007000
 8002d34:	42470e40 	.word	0x42470e40

08002d38 <HAL_RNG_MspInit>:
  * @param  hrng: pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval None
  */
__weak void HAL_RNG_MspInit(RNG_HandleTypeDef *hrng)
{
 8002d38:	4770      	bx	lr

08002d3a <HAL_RNG_Init>:
  if(hrng == NULL)
 8002d3a:	b1b8      	cbz	r0, 8002d6c <HAL_RNG_Init+0x32>
{
 8002d3c:	b510      	push	{r4, lr}
 8002d3e:	4604      	mov	r4, r0
  __HAL_LOCK(hrng);
 8002d40:	7903      	ldrb	r3, [r0, #4]
 8002d42:	2b01      	cmp	r3, #1
 8002d44:	d014      	beq.n	8002d70 <HAL_RNG_Init+0x36>
 8002d46:	2301      	movs	r3, #1
 8002d48:	7103      	strb	r3, [r0, #4]
  if(hrng->State == HAL_RNG_STATE_RESET)
 8002d4a:	7943      	ldrb	r3, [r0, #5]
 8002d4c:	b15b      	cbz	r3, 8002d66 <HAL_RNG_Init+0x2c>
  hrng->State = HAL_RNG_STATE_BUSY;
 8002d4e:	2302      	movs	r3, #2
 8002d50:	7163      	strb	r3, [r4, #5]
  __HAL_RNG_ENABLE(hrng);
 8002d52:	6822      	ldr	r2, [r4, #0]
 8002d54:	6813      	ldr	r3, [r2, #0]
 8002d56:	f043 0304 	orr.w	r3, r3, #4
 8002d5a:	6013      	str	r3, [r2, #0]
  hrng->State = HAL_RNG_STATE_READY;
 8002d5c:	2301      	movs	r3, #1
 8002d5e:	7163      	strb	r3, [r4, #5]
  __HAL_UNLOCK(hrng);
 8002d60:	2000      	movs	r0, #0
 8002d62:	7120      	strb	r0, [r4, #4]
  return HAL_OK;
 8002d64:	bd10      	pop	{r4, pc}
    HAL_RNG_MspInit(hrng);
 8002d66:	f7ff ffe7 	bl	8002d38 <HAL_RNG_MspInit>
 8002d6a:	e7f0      	b.n	8002d4e <HAL_RNG_Init+0x14>
    return HAL_ERROR;
 8002d6c:	2001      	movs	r0, #1
 8002d6e:	4770      	bx	lr
  __HAL_LOCK(hrng);
 8002d70:	2002      	movs	r0, #2
}
 8002d72:	bd10      	pop	{r4, pc}

08002d74 <HAL_RNG_GenerateRandomNumber>:
{
  uint32_t tickstart = 0;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 8002d74:	7903      	ldrb	r3, [r0, #4]
 8002d76:	2b01      	cmp	r3, #1
 8002d78:	d028      	beq.n	8002dcc <HAL_RNG_GenerateRandomNumber+0x58>
{
 8002d7a:	b570      	push	{r4, r5, r6, lr}
 8002d7c:	460d      	mov	r5, r1
 8002d7e:	4604      	mov	r4, r0
  __HAL_LOCK(hrng);
 8002d80:	2301      	movs	r3, #1
 8002d82:	7103      	strb	r3, [r0, #4]

  /* Check RNG peripheral state */
  if(hrng->State == HAL_RNG_STATE_READY)
 8002d84:	7943      	ldrb	r3, [r0, #5]
 8002d86:	b2db      	uxtb	r3, r3
 8002d88:	2b01      	cmp	r3, #1
 8002d8a:	d003      	beq.n	8002d94 <HAL_RNG_GenerateRandomNumber+0x20>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    status = HAL_ERROR;
 8002d8c:	2001      	movs	r0, #1
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8002d8e:	2300      	movs	r3, #0
 8002d90:	7123      	strb	r3, [r4, #4]

  return status;
 8002d92:	bd70      	pop	{r4, r5, r6, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
 8002d94:	2302      	movs	r3, #2
 8002d96:	7143      	strb	r3, [r0, #5]
    tickstart = HAL_GetTick();
 8002d98:	f7fd fc42 	bl	8000620 <HAL_GetTick>
 8002d9c:	4606      	mov	r6, r0
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8002d9e:	6823      	ldr	r3, [r4, #0]
 8002da0:	685a      	ldr	r2, [r3, #4]
 8002da2:	f012 0f01 	tst.w	r2, #1
 8002da6:	d10a      	bne.n	8002dbe <HAL_RNG_GenerateRandomNumber+0x4a>
      if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 8002da8:	f7fd fc3a 	bl	8000620 <HAL_GetTick>
 8002dac:	1b80      	subs	r0, r0, r6
 8002dae:	2802      	cmp	r0, #2
 8002db0:	d9f5      	bls.n	8002d9e <HAL_RNG_GenerateRandomNumber+0x2a>
        hrng->State = HAL_RNG_STATE_ERROR;
 8002db2:	2304      	movs	r3, #4
 8002db4:	7163      	strb	r3, [r4, #5]
        __HAL_UNLOCK(hrng);
 8002db6:	2300      	movs	r3, #0
 8002db8:	7123      	strb	r3, [r4, #4]
        return HAL_TIMEOUT;
 8002dba:	2003      	movs	r0, #3
 8002dbc:	bd70      	pop	{r4, r5, r6, pc}
    hrng->RandomNumber = hrng->Instance->DR;
 8002dbe:	689b      	ldr	r3, [r3, #8]
 8002dc0:	60a3      	str	r3, [r4, #8]
    *random32bit = hrng->RandomNumber;
 8002dc2:	602b      	str	r3, [r5, #0]
    hrng->State = HAL_RNG_STATE_READY;
 8002dc4:	2301      	movs	r3, #1
 8002dc6:	7163      	strb	r3, [r4, #5]
  HAL_StatusTypeDef status = HAL_OK;
 8002dc8:	2000      	movs	r0, #0
 8002dca:	e7e0      	b.n	8002d8e <HAL_RNG_GenerateRandomNumber+0x1a>
  __HAL_LOCK(hrng);
 8002dcc:	2002      	movs	r0, #2
 8002dce:	4770      	bx	lr

08002dd0 <HAL_TIM_Base_MspInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 8002dd0:	4770      	bx	lr

08002dd2 <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002dd2:	6802      	ldr	r2, [r0, #0]
 8002dd4:	68d3      	ldr	r3, [r2, #12]
 8002dd6:	f043 0301 	orr.w	r3, r3, #1
 8002dda:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8002ddc:	6802      	ldr	r2, [r0, #0]
 8002dde:	6813      	ldr	r3, [r2, #0]
 8002de0:	f043 0301 	orr.w	r3, r3, #1
 8002de4:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
}
 8002de6:	2000      	movs	r0, #0
 8002de8:	4770      	bx	lr
	...

08002dec <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 8002dec:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)
 8002dee:	4a31      	ldr	r2, [pc, #196]	; (8002eb4 <TIM_Base_SetConfig+0xc8>)
 8002df0:	4290      	cmp	r0, r2
 8002df2:	d02f      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002df4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002df8:	d02c      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002dfa:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8002dfe:	4290      	cmp	r0, r2
 8002e00:	d028      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002e02:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e06:	4290      	cmp	r0, r2
 8002e08:	d024      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002e0a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e0e:	4290      	cmp	r0, r2
 8002e10:	d020      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002e12:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002e16:	4290      	cmp	r0, r2
 8002e18:	d01c      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)
 8002e1a:	4a27      	ldr	r2, [pc, #156]	; (8002eb8 <TIM_Base_SetConfig+0xcc>)
 8002e1c:	4290      	cmp	r0, r2
 8002e1e:	d02f      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e20:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e24:	4290      	cmp	r0, r2
 8002e26:	d02b      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e28:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e2c:	4290      	cmp	r0, r2
 8002e2e:	d027      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e30:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8002e34:	4290      	cmp	r0, r2
 8002e36:	d023      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e38:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e3c:	4290      	cmp	r0, r2
 8002e3e:	d01f      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e40:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e44:	4290      	cmp	r0, r2
 8002e46:	d01b      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 8002e48:	6003      	str	r3, [r0, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002e4a:	688b      	ldr	r3, [r1, #8]
 8002e4c:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002e4e:	680b      	ldr	r3, [r1, #0]
 8002e50:	6283      	str	r3, [r0, #40]	; 0x28
 8002e52:	e021      	b.n	8002e98 <TIM_Base_SetConfig+0xac>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002e54:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002e58:	684a      	ldr	r2, [r1, #4]
 8002e5a:	4313      	orrs	r3, r2
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)
 8002e5c:	4a15      	ldr	r2, [pc, #84]	; (8002eb4 <TIM_Base_SetConfig+0xc8>)
 8002e5e:	4290      	cmp	r0, r2
 8002e60:	d00e      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e62:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002e66:	d00b      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e68:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8002e6c:	4290      	cmp	r0, r2
 8002e6e:	d007      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e70:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e74:	4290      	cmp	r0, r2
 8002e76:	d003      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e78:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e7c:	4290      	cmp	r0, r2
 8002e7e:	d113      	bne.n	8002ea8 <TIM_Base_SetConfig+0xbc>
    tmpcr1 &= ~TIM_CR1_CKD;
 8002e80:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002e84:	68ca      	ldr	r2, [r1, #12]
 8002e86:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8002e88:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002e8a:	688b      	ldr	r3, [r1, #8]
 8002e8c:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002e8e:	680b      	ldr	r3, [r1, #0]
 8002e90:	6283      	str	r3, [r0, #40]	; 0x28

  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8002e92:	4b08      	ldr	r3, [pc, #32]	; (8002eb4 <TIM_Base_SetConfig+0xc8>)
 8002e94:	4298      	cmp	r0, r3
 8002e96:	d002      	beq.n	8002e9e <TIM_Base_SetConfig+0xb2>
 8002e98:	4b08      	ldr	r3, [pc, #32]	; (8002ebc <TIM_Base_SetConfig+0xd0>)
 8002e9a:	4298      	cmp	r0, r3
 8002e9c:	d101      	bne.n	8002ea2 <TIM_Base_SetConfig+0xb6>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8002e9e:	690b      	ldr	r3, [r1, #16]
 8002ea0:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002ea2:	2301      	movs	r3, #1
 8002ea4:	6143      	str	r3, [r0, #20]
}
 8002ea6:	4770      	bx	lr
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)
 8002ea8:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002eac:	4290      	cmp	r0, r2
 8002eae:	d0e7      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002eb0:	e7b3      	b.n	8002e1a <TIM_Base_SetConfig+0x2e>
 8002eb2:	bf00      	nop
 8002eb4:	40010000 	.word	0x40010000
 8002eb8:	40014000 	.word	0x40014000
 8002ebc:	40010400 	.word	0x40010400

08002ec0 <HAL_TIM_Base_Init>:
  if(htim == NULL)
 8002ec0:	b198      	cbz	r0, 8002eea <HAL_TIM_Base_Init+0x2a>
{
 8002ec2:	b510      	push	{r4, lr}
 8002ec4:	4604      	mov	r4, r0
  if(htim->State == HAL_TIM_STATE_RESET)
 8002ec6:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002eca:	b15b      	cbz	r3, 8002ee4 <HAL_TIM_Base_Init+0x24>
  htim->State= HAL_TIM_STATE_BUSY;
 8002ecc:	2302      	movs	r3, #2
 8002ece:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002ed2:	1d21      	adds	r1, r4, #4
 8002ed4:	6820      	ldr	r0, [r4, #0]
 8002ed6:	f7ff ff89 	bl	8002dec <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8002eda:	2301      	movs	r3, #1
 8002edc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8002ee0:	2000      	movs	r0, #0
 8002ee2:	bd10      	pop	{r4, pc}
    HAL_TIM_Base_MspInit(htim);
 8002ee4:	f7ff ff74 	bl	8002dd0 <HAL_TIM_Base_MspInit>
 8002ee8:	e7f0      	b.n	8002ecc <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8002eea:	2001      	movs	r0, #1
 8002eec:	4770      	bx	lr
	...

08002ef0 <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvHelpCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 8002ef0:	b538      	push	{r3, r4, r5, lr}
 8002ef2:	460a      	mov	r2, r1
static const CLI_Definition_List_Item_t * pxCommand = NULL;
BaseType_t xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
 8002ef4:	4b09      	ldr	r3, [pc, #36]	; (8002f1c <prvHelpCommand+0x2c>)
 8002ef6:	681b      	ldr	r3, [r3, #0]
 8002ef8:	b15b      	cbz	r3, 8002f12 <prvHelpCommand+0x22>
		pxCommand = &xRegisteredCommands;
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( pcWriteBuffer, pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
 8002efa:	4c08      	ldr	r4, [pc, #32]	; (8002f1c <prvHelpCommand+0x2c>)
 8002efc:	6825      	ldr	r5, [r4, #0]
 8002efe:	682b      	ldr	r3, [r5, #0]
 8002f00:	6859      	ldr	r1, [r3, #4]
 8002f02:	f009 f905 	bl	800c110 <strncpy>
	pxCommand = pxCommand->pxNext;
 8002f06:	6868      	ldr	r0, [r5, #4]
 8002f08:	6020      	str	r0, [r4, #0]
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
 8002f0a:	3000      	adds	r0, #0
 8002f0c:	bf18      	it	ne
 8002f0e:	2001      	movne	r0, #1
 8002f10:	bd38      	pop	{r3, r4, r5, pc}
		pxCommand = &xRegisteredCommands;
 8002f12:	4903      	ldr	r1, [pc, #12]	; (8002f20 <prvHelpCommand+0x30>)
 8002f14:	4b01      	ldr	r3, [pc, #4]	; (8002f1c <prvHelpCommand+0x2c>)
 8002f16:	6019      	str	r1, [r3, #0]
 8002f18:	e7ef      	b.n	8002efa <prvHelpCommand+0xa>
 8002f1a:	bf00      	nop
 8002f1c:	2000036c 	.word	0x2000036c
 8002f20:	20000008 	.word	0x20000008

08002f24 <FreeRTOS_CLIRegisterCommand>:
{
 8002f24:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxCommandToRegister );
 8002f26:	4605      	mov	r5, r0
 8002f28:	b188      	cbz	r0, 8002f4e <FreeRTOS_CLIRegisterCommand+0x2a>
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
 8002f2a:	2008      	movs	r0, #8
 8002f2c:	f005 fe6c 	bl	8008c08 <pvPortMalloc>
	configASSERT( pxNewListItem );
 8002f30:	4604      	mov	r4, r0
 8002f32:	b188      	cbz	r0, 8002f58 <FreeRTOS_CLIRegisterCommand+0x34>
		taskENTER_CRITICAL();
 8002f34:	f005 fcde 	bl	80088f4 <vPortEnterCritical>
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
 8002f38:	6025      	str	r5, [r4, #0]
			pxNewListItem->pxNext = NULL;
 8002f3a:	2300      	movs	r3, #0
 8002f3c:	6063      	str	r3, [r4, #4]
			pxLastCommandInList->pxNext = pxNewListItem;
 8002f3e:	4b09      	ldr	r3, [pc, #36]	; (8002f64 <FreeRTOS_CLIRegisterCommand+0x40>)
 8002f40:	681a      	ldr	r2, [r3, #0]
 8002f42:	6054      	str	r4, [r2, #4]
			pxLastCommandInList = pxNewListItem;
 8002f44:	601c      	str	r4, [r3, #0]
		taskEXIT_CRITICAL();
 8002f46:	f005 fcf7 	bl	8008938 <vPortExitCritical>
		xReturn = pdPASS;
 8002f4a:	2001      	movs	r0, #1
}
 8002f4c:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxCommandToRegister );
 8002f4e:	216c      	movs	r1, #108	; 0x6c
 8002f50:	4805      	ldr	r0, [pc, #20]	; (8002f68 <FreeRTOS_CLIRegisterCommand+0x44>)
 8002f52:	f008 fedb 	bl	800bd0c <vAssertCalled>
 8002f56:	e7e8      	b.n	8002f2a <FreeRTOS_CLIRegisterCommand+0x6>
	configASSERT( pxNewListItem );
 8002f58:	2170      	movs	r1, #112	; 0x70
 8002f5a:	4803      	ldr	r0, [pc, #12]	; (8002f68 <FreeRTOS_CLIRegisterCommand+0x44>)
 8002f5c:	f008 fed6 	bl	800bd0c <vAssertCalled>
BaseType_t xReturn = pdFAIL;
 8002f60:	2000      	movs	r0, #0
	return xReturn;
 8002f62:	bd38      	pop	{r3, r4, r5, pc}
 8002f64:	20000004 	.word	0x20000004
 8002f68:	0800c39c 	.word	0x0800c39c

08002f6c <FreeRTOS_CLIProcessCommand>:
{
 8002f6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002f70:	4606      	mov	r6, r0
 8002f72:	4688      	mov	r8, r1
 8002f74:	4691      	mov	r9, r2
	if( pxCommand == NULL )
 8002f76:	4b31      	ldr	r3, [pc, #196]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8002f78:	681b      	ldr	r3, [r3, #0]
 8002f7a:	b16b      	cbz	r3, 8002f98 <FreeRTOS_CLIProcessCommand+0x2c>
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
 8002f7c:	681b      	ldr	r3, [r3, #0]
 8002f7e:	689b      	ldr	r3, [r3, #8]
 8002f80:	4632      	mov	r2, r6
 8002f82:	4649      	mov	r1, r9
 8002f84:	4640      	mov	r0, r8
 8002f86:	4798      	blx	r3
		if( xReturn == pdFALSE )
 8002f88:	4603      	mov	r3, r0
 8002f8a:	b910      	cbnz	r0, 8002f92 <FreeRTOS_CLIProcessCommand+0x26>
			pxCommand = NULL;
 8002f8c:	2100      	movs	r1, #0
 8002f8e:	4a2b      	ldr	r2, [pc, #172]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8002f90:	6011      	str	r1, [r2, #0]
}
 8002f92:	4618      	mov	r0, r3
 8002f94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 8002f98:	4c29      	ldr	r4, [pc, #164]	; (8003040 <FreeRTOS_CLIProcessCommand+0xd4>)
 8002f9a:	4a28      	ldr	r2, [pc, #160]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8002f9c:	6014      	str	r4, [r2, #0]
 8002f9e:	4617      	mov	r7, r2
 8002fa0:	e009      	b.n	8002fb6 <FreeRTOS_CLIProcessCommand+0x4a>
				if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
 8002fa2:	4602      	mov	r2, r0
 8002fa4:	4629      	mov	r1, r5
 8002fa6:	4630      	mov	r0, r6
 8002fa8:	f009 f8a0 	bl	800c0ec <strncmp>
 8002fac:	b178      	cbz	r0, 8002fce <FreeRTOS_CLIProcessCommand+0x62>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 8002fae:	6864      	ldr	r4, [r4, #4]
 8002fb0:	603c      	str	r4, [r7, #0]
 8002fb2:	2c00      	cmp	r4, #0
 8002fb4:	d03b      	beq.n	800302e <FreeRTOS_CLIProcessCommand+0xc2>
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
 8002fb6:	f8d4 a000 	ldr.w	sl, [r4]
 8002fba:	f8da 5000 	ldr.w	r5, [sl]
			xCommandStringLength = strlen( pcRegisteredCommandString );
 8002fbe:	4628      	mov	r0, r5
 8002fc0:	f7fd f906 	bl	80001d0 <strlen>
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 8002fc4:	5c33      	ldrb	r3, [r6, r0]
 8002fc6:	f013 0fdf 	tst.w	r3, #223	; 0xdf
 8002fca:	d1f0      	bne.n	8002fae <FreeRTOS_CLIProcessCommand+0x42>
 8002fcc:	e7e9      	b.n	8002fa2 <FreeRTOS_CLIProcessCommand+0x36>
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
 8002fce:	f99a 500c 	ldrsb.w	r5, [sl, #12]
 8002fd2:	2d00      	cmp	r5, #0
 8002fd4:	db27      	blt.n	8003026 <FreeRTOS_CLIProcessCommand+0xba>
{
int8_t cParameters = 0;
BaseType_t xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
 8002fd6:	7833      	ldrb	r3, [r6, #0]
 8002fd8:	b31b      	cbz	r3, 8003022 <FreeRTOS_CLIProcessCommand+0xb6>
 8002fda:	4632      	mov	r2, r6
 8002fdc:	4601      	mov	r1, r0
				xLastCharacterWasSpace = pdTRUE;
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
 8002fde:	4604      	mov	r4, r0
			if( xLastCharacterWasSpace != pdTRUE )
 8002fe0:	2701      	movs	r7, #1
 8002fe2:	e006      	b.n	8002ff2 <FreeRTOS_CLIProcessCommand+0x86>
 8002fe4:	b949      	cbnz	r1, 8002ffa <FreeRTOS_CLIProcessCommand+0x8e>
				cParameters++;
 8002fe6:	3001      	adds	r0, #1
 8002fe8:	b240      	sxtb	r0, r0
				xLastCharacterWasSpace = pdTRUE;
 8002fea:	4639      	mov	r1, r7
	while( *pcCommandString != 0x00 )
 8002fec:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8002ff0:	b12b      	cbz	r3, 8002ffe <FreeRTOS_CLIProcessCommand+0x92>
		if( ( *pcCommandString ) == ' ' )
 8002ff2:	2b20      	cmp	r3, #32
 8002ff4:	d0f6      	beq.n	8002fe4 <FreeRTOS_CLIProcessCommand+0x78>
			xLastCharacterWasSpace = pdFALSE;
 8002ff6:	4621      	mov	r1, r4
 8002ff8:	e7f8      	b.n	8002fec <FreeRTOS_CLIProcessCommand+0x80>
			if( xLastCharacterWasSpace != pdTRUE )
 8002ffa:	4639      	mov	r1, r7
 8002ffc:	e7f6      	b.n	8002fec <FreeRTOS_CLIProcessCommand+0x80>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
 8002ffe:	b969      	cbnz	r1, 800301c <FreeRTOS_CLIProcessCommand+0xb0>
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 8003000:	4b0e      	ldr	r3, [pc, #56]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8003002:	681b      	ldr	r3, [r3, #0]
 8003004:	b19b      	cbz	r3, 800302e <FreeRTOS_CLIProcessCommand+0xc2>
 8003006:	4285      	cmp	r5, r0
 8003008:	d0b8      	beq.n	8002f7c <FreeRTOS_CLIProcessCommand+0x10>
		strncpy( pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 800300a:	464a      	mov	r2, r9
 800300c:	490d      	ldr	r1, [pc, #52]	; (8003044 <FreeRTOS_CLIProcessCommand+0xd8>)
 800300e:	4640      	mov	r0, r8
 8003010:	f009 f87e 	bl	800c110 <strncpy>
		pxCommand = NULL;
 8003014:	2300      	movs	r3, #0
 8003016:	4a09      	ldr	r2, [pc, #36]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8003018:	6013      	str	r3, [r2, #0]
 800301a:	e7ba      	b.n	8002f92 <FreeRTOS_CLIProcessCommand+0x26>
	{
		cParameters--;
 800301c:	3801      	subs	r0, #1
 800301e:	b240      	sxtb	r0, r0
 8003020:	e7ee      	b.n	8003000 <FreeRTOS_CLIProcessCommand+0x94>
	while( *pcCommandString != 0x00 )
 8003022:	2000      	movs	r0, #0
 8003024:	e7ec      	b.n	8003000 <FreeRTOS_CLIProcessCommand+0x94>
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 8003026:	4b05      	ldr	r3, [pc, #20]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8003028:	681b      	ldr	r3, [r3, #0]
 800302a:	2b00      	cmp	r3, #0
 800302c:	d1a6      	bne.n	8002f7c <FreeRTOS_CLIProcessCommand+0x10>
		strncpy( pcWriteBuffer, "Command not recognised.  Enter 'help' to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 800302e:	464a      	mov	r2, r9
 8003030:	4905      	ldr	r1, [pc, #20]	; (8003048 <FreeRTOS_CLIProcessCommand+0xdc>)
 8003032:	4640      	mov	r0, r8
 8003034:	f009 f86c 	bl	800c110 <strncpy>
		xReturn = pdFALSE;
 8003038:	2300      	movs	r3, #0
	return xReturn;
 800303a:	e7aa      	b.n	8002f92 <FreeRTOS_CLIProcessCommand+0x26>
 800303c:	20000368 	.word	0x20000368
 8003040:	20000008 	.word	0x20000008
 8003044:	0800c2f4 	.word	0x0800c2f4
 8003048:	0800c34c 	.word	0x0800c34c

0800304c <FreeRTOS_CLIGetParameter>:
	*pxParameterStringLength = 0;
 800304c:	2300      	movs	r3, #0
 800304e:	6013      	str	r3, [r2, #0]
	while( uxParametersFound < uxWantedParameter )
 8003050:	b119      	cbz	r1, 800305a <FreeRTOS_CLIGetParameter+0xe>
{
 8003052:	b410      	push	{r4}
 8003054:	460c      	mov	r4, r1
	while( uxParametersFound < uxWantedParameter )
 8003056:	2100      	movs	r1, #0
 8003058:	e009      	b.n	800306e <FreeRTOS_CLIGetParameter+0x22>
const char *pcReturn = NULL;
 800305a:	4618      	mov	r0, r3
 800305c:	4770      	bx	lr
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
 800305e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8003062:	2b20      	cmp	r3, #32
 8003064:	d0fb      	beq.n	800305e <FreeRTOS_CLIGetParameter+0x12>
		if( *pcCommandString != 0x00 )
 8003066:	b1eb      	cbz	r3, 80030a4 <FreeRTOS_CLIGetParameter+0x58>
			uxParametersFound++;
 8003068:	3101      	adds	r1, #1
			if( uxParametersFound == uxWantedParameter )
 800306a:	428c      	cmp	r4, r1
 800306c:	d009      	beq.n	8003082 <FreeRTOS_CLIGetParameter+0x36>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 800306e:	7803      	ldrb	r3, [r0, #0]
 8003070:	b1f3      	cbz	r3, 80030b0 <FreeRTOS_CLIGetParameter+0x64>
 8003072:	2b20      	cmp	r3, #32
 8003074:	d0f3      	beq.n	800305e <FreeRTOS_CLIGetParameter+0x12>
 8003076:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800307a:	b1cb      	cbz	r3, 80030b0 <FreeRTOS_CLIGetParameter+0x64>
 800307c:	2b20      	cmp	r3, #32
 800307e:	d1fa      	bne.n	8003076 <FreeRTOS_CLIGetParameter+0x2a>
 8003080:	e7ed      	b.n	800305e <FreeRTOS_CLIGetParameter+0x12>
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 8003082:	7803      	ldrb	r3, [r0, #0]
 8003084:	f013 0fdf 	tst.w	r3, #223	; 0xdf
 8003088:	d010      	beq.n	80030ac <FreeRTOS_CLIGetParameter+0x60>
 800308a:	4601      	mov	r1, r0
					( *pxParameterStringLength )++;
 800308c:	6813      	ldr	r3, [r2, #0]
 800308e:	3301      	adds	r3, #1
 8003090:	6013      	str	r3, [r2, #0]
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 8003092:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8003096:	f014 0fdf 	tst.w	r4, #223	; 0xdf
 800309a:	d1f7      	bne.n	800308c <FreeRTOS_CLIGetParameter+0x40>
					pcReturn = NULL;
 800309c:	2b00      	cmp	r3, #0
 800309e:	bf08      	it	eq
 80030a0:	2000      	moveq	r0, #0
 80030a2:	e000      	b.n	80030a6 <FreeRTOS_CLIGetParameter+0x5a>
const char *pcReturn = NULL;
 80030a4:	2000      	movs	r0, #0
}
 80030a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80030aa:	4770      	bx	lr
					pcReturn = NULL;
 80030ac:	2000      	movs	r0, #0
 80030ae:	e7fa      	b.n	80030a6 <FreeRTOS_CLIGetParameter+0x5a>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
 80030b0:	7803      	ldrb	r3, [r0, #0]
 80030b2:	e7d8      	b.n	8003066 <FreeRTOS_CLIGetParameter+0x1a>

080030b4 <strcasecmp>:

		return cReturnChar;
	}

	int strcasecmp( const char *pcString1, const char *pcString2 )
	{
 80030b4:	b410      	push	{r4}
		unsigned char c1,c2;
		do
		{
			c1 = *pcString1++;
 80030b6:	f810 3b01 	ldrb.w	r3, [r0], #1
			c2 = *pcString2++;
 80030ba:	f811 2b01 	ldrb.w	r2, [r1], #1
		if( c >= 'A' && c <= 'Z' )
 80030be:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 80030c2:	b2e4      	uxtb	r4, r4
 80030c4:	2c19      	cmp	r4, #25
			cReturnChar = c + 0x20;
 80030c6:	bf9c      	itt	ls
 80030c8:	3320      	addls	r3, #32
 80030ca:	b2db      	uxtbls	r3, r3
		if( c >= 'A' && c <= 'Z' )
 80030cc:	f1a2 0441 	sub.w	r4, r2, #65	; 0x41
 80030d0:	b2e4      	uxtb	r4, r4
 80030d2:	2c19      	cmp	r4, #25
			cReturnChar = c + 0x20;
 80030d4:	bf9c      	itt	ls
 80030d6:	3220      	addls	r2, #32
 80030d8:	b2d2      	uxtbls	r2, r2
			c1 = ( unsigned char ) prvToLower( ( unsigned char ) c1 );
			c2 = ( unsigned char ) prvToLower( ( unsigned char ) c2 );
		}
		while( ( c1 == c2 ) && ( c1 != '\0' ) );
 80030da:	429a      	cmp	r2, r3
 80030dc:	d102      	bne.n	80030e4 <strcasecmp+0x30>
 80030de:	2b00      	cmp	r3, #0
 80030e0:	d1e9      	bne.n	80030b6 <strcasecmp+0x2>
 80030e2:	461a      	mov	r2, r3

		return ( int ) c1 - c2;
	}	/* strcasecmp() */
 80030e4:	1a98      	subs	r0, r3, r2
 80030e6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80030ea:	4770      	bx	lr

080030ec <SDIO_IRQHandler>:
#endif	/* SDIO_USES_DMA */
/*-----------------------------------------------------------*/

#if( SDIO_USES_DMA != 0 )
	void SDIO_IRQHandler(void)
	{
 80030ec:	b500      	push	{lr}
 80030ee:	b083      	sub	sp, #12
	BaseType_t xHigherPriorityTaskWoken = 0;
 80030f0:	2300      	movs	r3, #0
 80030f2:	9301      	str	r3, [sp, #4]

		HAL_SD_IRQHandler( &xSDHandle );
 80030f4:	480a      	ldr	r0, [pc, #40]	; (8003120 <SDIO_IRQHandler+0x34>)
 80030f6:	f000 f881 	bl	80031fc <HAL_SD_IRQHandler>
		if( xSDCardSemaphore != NULL )
 80030fa:	4b0a      	ldr	r3, [pc, #40]	; (8003124 <SDIO_IRQHandler+0x38>)
 80030fc:	6818      	ldr	r0, [r3, #0]
 80030fe:	b110      	cbz	r0, 8003106 <SDIO_IRQHandler+0x1a>
		{
			xSemaphoreGiveFromISR( xSDCardSemaphore, &xHigherPriorityTaskWoken );
 8003100:	a901      	add	r1, sp, #4
 8003102:	f006 f889 	bl	8009218 <xQueueGiveFromISR>
		}
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8003106:	9b01      	ldr	r3, [sp, #4]
 8003108:	b13b      	cbz	r3, 800311a <SDIO_IRQHandler+0x2e>
 800310a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800310e:	4b06      	ldr	r3, [pc, #24]	; (8003128 <SDIO_IRQHandler+0x3c>)
 8003110:	601a      	str	r2, [r3, #0]
 8003112:	f3bf 8f4f 	dsb	sy
 8003116:	f3bf 8f6f 	isb	sy
	}
 800311a:	b003      	add	sp, #12
 800311c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003120:	20000374 	.word	0x20000374
 8003124:	20000370 	.word	0x20000370
 8003128:	e000ed04 	.word	0xe000ed04

0800312c <DMA2_Stream6_IRQHandler>:
/*-----------------------------------------------------------*/

#if( SDIO_USES_DMA != 0 )

	void DMA2_Stream6_IRQHandler(void)
	{
 800312c:	b500      	push	{lr}
 800312e:	b083      	sub	sp, #12
	BaseType_t xHigherPriorityTaskWoken = 0;
 8003130:	2300      	movs	r3, #0
 8003132:	9301      	str	r3, [sp, #4]

		/* DMA SDIO-TX interrupt handler. */
		HAL_DMA_IRQHandler (xSDHandle.hdmatx);
 8003134:	4b0b      	ldr	r3, [pc, #44]	; (8003164 <DMA2_Stream6_IRQHandler+0x38>)
 8003136:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8003138:	f7fd faea 	bl	8000710 <HAL_DMA_IRQHandler>
		if( xSDCardSemaphore != NULL )
 800313c:	4b0a      	ldr	r3, [pc, #40]	; (8003168 <DMA2_Stream6_IRQHandler+0x3c>)
 800313e:	6818      	ldr	r0, [r3, #0]
 8003140:	b110      	cbz	r0, 8003148 <DMA2_Stream6_IRQHandler+0x1c>
		{
			xSemaphoreGiveFromISR( xSDCardSemaphore, &xHigherPriorityTaskWoken );
 8003142:	a901      	add	r1, sp, #4
 8003144:	f006 f868 	bl	8009218 <xQueueGiveFromISR>
		}
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8003148:	9b01      	ldr	r3, [sp, #4]
 800314a:	b13b      	cbz	r3, 800315c <DMA2_Stream6_IRQHandler+0x30>
 800314c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003150:	4b06      	ldr	r3, [pc, #24]	; (800316c <DMA2_Stream6_IRQHandler+0x40>)
 8003152:	601a      	str	r2, [r3, #0]
 8003154:	f3bf 8f4f 	dsb	sy
 8003158:	f3bf 8f6f 	isb	sy
	}
 800315c:	b003      	add	sp, #12
 800315e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003162:	bf00      	nop
 8003164:	20000374 	.word	0x20000374
 8003168:	20000370 	.word	0x20000370
 800316c:	e000ed04 	.word	0xe000ed04

08003170 <DMA2_Stream3_IRQHandler>:
/*-----------------------------------------------------------*/

#if( SDIO_USES_DMA != 0 )

	void DMA2_Stream3_IRQHandler(void)
	{
 8003170:	b500      	push	{lr}
 8003172:	b083      	sub	sp, #12
	BaseType_t xHigherPriorityTaskWoken = 0;
 8003174:	2300      	movs	r3, #0
 8003176:	9301      	str	r3, [sp, #4]

		/* DMA SDIO-RX interrupt handler. */
		HAL_DMA_IRQHandler (xSDHandle.hdmarx);
 8003178:	4b0b      	ldr	r3, [pc, #44]	; (80031a8 <DMA2_Stream3_IRQHandler+0x38>)
 800317a:	6d98      	ldr	r0, [r3, #88]	; 0x58
 800317c:	f7fd fac8 	bl	8000710 <HAL_DMA_IRQHandler>
		if( xSDCardSemaphore != NULL )
 8003180:	4b0a      	ldr	r3, [pc, #40]	; (80031ac <DMA2_Stream3_IRQHandler+0x3c>)
 8003182:	6818      	ldr	r0, [r3, #0]
 8003184:	b110      	cbz	r0, 800318c <DMA2_Stream3_IRQHandler+0x1c>
		{
			xSemaphoreGiveFromISR( xSDCardSemaphore, &xHigherPriorityTaskWoken );
 8003186:	a901      	add	r1, sp, #4
 8003188:	f006 f846 	bl	8009218 <xQueueGiveFromISR>
		}
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 800318c:	9b01      	ldr	r3, [sp, #4]
 800318e:	b13b      	cbz	r3, 80031a0 <DMA2_Stream3_IRQHandler+0x30>
 8003190:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003194:	4b06      	ldr	r3, [pc, #24]	; (80031b0 <DMA2_Stream3_IRQHandler+0x40>)
 8003196:	601a      	str	r2, [r3, #0]
 8003198:	f3bf 8f4f 	dsb	sy
 800319c:	f3bf 8f6f 	isb	sy
	}
 80031a0:	b003      	add	sp, #12
 80031a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80031a6:	bf00      	nop
 80031a8:	20000374 	.word	0x20000374
 80031ac:	20000370 	.word	0x20000370
 80031b0:	e000ed04 	.word	0xe000ed04

080031b4 <HAL_GPIO_EXTI_Callback>:

#endif	/* SDIO_USES_DMA != 0 */
/*-----------------------------------------------------------*/

void HAL_GPIO_EXTI_Callback( uint16_t GPIO_Pin )
{
 80031b4:	b500      	push	{lr}
 80031b6:	b083      	sub	sp, #12
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 80031b8:	2300      	movs	r3, #0
 80031ba:	9301      	str	r3, [sp, #4]

	if( GPIO_Pin == configSD_DETECT_PIN )
 80031bc:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 80031c0:	d002      	beq.n	80031c8 <HAL_GPIO_EXTI_Callback+0x14>
	{
		vApplicationCardDetectChangeHookFromISR( &xHigherPriorityTaskWoken );
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}
}
 80031c2:	b003      	add	sp, #12
 80031c4:	f85d fb04 	ldr.w	pc, [sp], #4
		vApplicationCardDetectChangeHookFromISR( &xHigherPriorityTaskWoken );
 80031c8:	a801      	add	r0, sp, #4
 80031ca:	f008 fdcd 	bl	800bd68 <vApplicationCardDetectChangeHookFromISR>
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	2b00      	cmp	r3, #0
 80031d2:	d0f6      	beq.n	80031c2 <HAL_GPIO_EXTI_Callback+0xe>
 80031d4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80031d8:	4b03      	ldr	r3, [pc, #12]	; (80031e8 <HAL_GPIO_EXTI_Callback+0x34>)
 80031da:	601a      	str	r2, [r3, #0]
 80031dc:	f3bf 8f4f 	dsb	sy
 80031e0:	f3bf 8f6f 	isb	sy
}
 80031e4:	e7ed      	b.n	80031c2 <HAL_GPIO_EXTI_Callback+0xe>
 80031e6:	bf00      	nop
 80031e8:	e000ed04 	.word	0xe000ed04

080031ec <EXTI15_10_IRQHandler>:
/*-----------------------------------------------------------*/

void EXTI15_10_IRQHandler( void )
{
 80031ec:	b508      	push	{r3, lr}
	HAL_GPIO_EXTI_IRQHandler( configSD_DETECT_PIN );	/* GPIO PIN H.13 */
 80031ee:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80031f2:	f7ff f963 	bl	80024bc <HAL_GPIO_EXTI_IRQHandler>
 80031f6:	bd08      	pop	{r3, pc}

080031f8 <HAL_SD_XferCpltCallback>:
  * @brief  SD end of transfer callback.
  * @param  hsd: SD handle
  * @retval None
  */
__weak void HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd)
{
 80031f8:	4770      	bx	lr

080031fa <HAL_SD_XferErrorCallback>:
  * @brief  SD Transfer Error callback.
  * @param  hsd: SD handle
  * @retval None
  */
__weak void HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd)
{
 80031fa:	4770      	bx	lr

080031fc <HAL_SD_IRQHandler>:
{
 80031fc:	b510      	push	{r4, lr}
 80031fe:	4604      	mov	r4, r0
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
 8003200:	6803      	ldr	r3, [r0, #0]
 8003202:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003204:	f412 7f80 	tst.w	r2, #256	; 0x100
 8003208:	d11b      	bne.n	8003242 <HAL_SD_IRQHandler+0x46>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DCRCFAIL))
 800320a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800320c:	f012 0f02 	tst.w	r2, #2
 8003210:	d128      	bne.n	8003264 <HAL_SD_IRQHandler+0x68>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DTIMEOUT))
 8003212:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003214:	f012 0f08 	tst.w	r2, #8
 8003218:	d12a      	bne.n	8003270 <HAL_SD_IRQHandler+0x74>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_RXOVERR))
 800321a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800321c:	f012 0f20 	tst.w	r2, #32
 8003220:	d12d      	bne.n	800327e <HAL_SD_IRQHandler+0x82>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_TXUNDERR))
 8003222:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003224:	f012 0f10 	tst.w	r2, #16
 8003228:	d130      	bne.n	800328c <HAL_SD_IRQHandler+0x90>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_STBITERR))
 800322a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800322c:	f412 7f00 	tst.w	r2, #512	; 0x200
 8003230:	d010      	beq.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8003232:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003236:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_START_BIT_ERR;
 8003238:	2307      	movs	r3, #7
 800323a:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 800323c:	f7ff ffdd 	bl	80031fa <HAL_SD_XferErrorCallback>
 8003240:	e008      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_IT_DATAEND);
 8003242:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003246:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferCplt = 1;
 8003248:	2301      	movs	r3, #1
 800324a:	6483      	str	r3, [r0, #72]	; 0x48
    hsd->SdTransferErr  = SD_OK;
 800324c:	2300      	movs	r3, #0
 800324e:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferCpltCallback(hsd);
 8003250:	f7ff ffd2 	bl	80031f8 <HAL_SD_XferCpltCallback>
  __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
 8003254:	6822      	ldr	r2, [r4, #0]
 8003256:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8003258:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 800325c:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
 8003260:	63d3      	str	r3, [r2, #60]	; 0x3c
 8003262:	bd10      	pop	{r4, pc}
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8003264:	2202      	movs	r2, #2
 8003266:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_DATA_CRC_FAIL;
 8003268:	64c2      	str	r2, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 800326a:	f7ff ffc6 	bl	80031fa <HAL_SD_XferErrorCallback>
 800326e:	e7f1      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8003270:	2208      	movs	r2, #8
 8003272:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_DATA_TIMEOUT;
 8003274:	2304      	movs	r3, #4
 8003276:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 8003278:	f7ff ffbf 	bl	80031fa <HAL_SD_XferErrorCallback>
 800327c:	e7ea      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 800327e:	2220      	movs	r2, #32
 8003280:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_RX_OVERRUN;
 8003282:	2306      	movs	r3, #6
 8003284:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 8003286:	f7ff ffb8 	bl	80031fa <HAL_SD_XferErrorCallback>
 800328a:	e7e3      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 800328c:	2210      	movs	r2, #16
 800328e:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_TX_UNDERRUN;
 8003290:	2305      	movs	r3, #5
 8003292:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 8003294:	f7ff ffb1 	bl	80031fa <HAL_SD_XferErrorCallback>
 8003298:	e7dc      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
	...

0800329c <vARPRefreshCacheEntry>:

#endif	/* ipconfigUSE_ARP_REMOVE_ENTRY != 0 */
/*-----------------------------------------------------------*/

void vARPRefreshCacheEntry( const MACAddress_t * pxMACAddress, const uint32_t ulIPAddress )
{
 800329c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032a0:	b083      	sub	sp, #12

	#if( ipconfigARP_STORES_REMOTE_ADDRESSES == 0 )
		/* Only process the IP address if it is on the local network.
		Unless: when '*ipLOCAL_IP_ADDRESS_POINTER' equals zero, the IP-address
		and netmask are still unknown. */
		if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
 80032a2:	4b46      	ldr	r3, [pc, #280]	; (80033bc <vARPRefreshCacheEntry+0x120>)
 80032a4:	695b      	ldr	r3, [r3, #20]
 80032a6:	ea83 0401 	eor.w	r4, r3, r1
 80032aa:	4a45      	ldr	r2, [pc, #276]	; (80033c0 <vARPRefreshCacheEntry+0x124>)
 80032ac:	6852      	ldr	r2, [r2, #4]
 80032ae:	4214      	tst	r4, r2
 80032b0:	d001      	beq.n	80032b6 <vARPRefreshCacheEntry+0x1a>
 80032b2:	2b00      	cmp	r3, #0
 80032b4:	d164      	bne.n	8003380 <vARPRefreshCacheEntry+0xe4>
 80032b6:	4688      	mov	r8, r1
 80032b8:	4606      	mov	r6, r0
 80032ba:	4c42      	ldr	r4, [pc, #264]	; (80033c4 <vARPRefreshCacheEntry+0x128>)
{
 80032bc:	f04f 0bff 	mov.w	fp, #255	; 0xff
 80032c0:	2300      	movs	r3, #0
 80032c2:	9301      	str	r3, [sp, #4]
 80032c4:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 80032c8:	46ca      	mov	sl, r9
 80032ca:	461d      	mov	r5, r3
 80032cc:	e017      	b.n	80032fe <vARPRefreshCacheEntry+0x62>
		{
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
			{
				if( pxMACAddress == NULL )
 80032ce:	b34e      	cbz	r6, 8003324 <vARPRefreshCacheEntry+0x88>
					xIpEntry = x;
					break;
				}

				/* See if the MAC-address also matches. */
				if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 80032d0:	2206      	movs	r2, #6
 80032d2:	4631      	mov	r1, r6
 80032d4:	4620      	mov	r0, r4
 80032d6:	f008 feb1 	bl	800c03c <memcmp>
 80032da:	b108      	cbz	r0, 80032e0 <vARPRefreshCacheEntry+0x44>
 80032dc:	46aa      	mov	sl, r5
 80032de:	e00a      	b.n	80032f6 <vARPRefreshCacheEntry+0x5a>
				{
					/* This function will be called for each received packet
					As this is by far the most common path the coding standard
					is relaxed in this case and a return is permitted as an
					optimisation. */
					xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 80032e0:	4b39      	ldr	r3, [pc, #228]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 80032e2:	006a      	lsls	r2, r5, #1
 80032e4:	1951      	adds	r1, r2, r5
 80032e6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80032ea:	2096      	movs	r0, #150	; 0x96
 80032ec:	7288      	strb	r0, [r1, #10]
					xARPCache[ x ].ucValid = ( uint8_t ) pdTRUE;
 80032ee:	2201      	movs	r2, #1
 80032f0:	72ca      	strb	r2, [r1, #11]
					return;
 80032f2:	e045      	b.n	8003380 <vARPRefreshCacheEntry+0xe4>
 80032f4:	46a9      	mov	r9, r5
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80032f6:	3501      	adds	r5, #1
 80032f8:	340c      	adds	r4, #12
 80032fa:	2d06      	cmp	r5, #6
 80032fc:	d013      	beq.n	8003326 <vARPRefreshCacheEntry+0x8a>
 80032fe:	4627      	mov	r7, r4
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 8003300:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8003304:	4598      	cmp	r8, r3
 8003306:	d0e2      	beq.n	80032ce <vARPRefreshCacheEntry+0x32>
				for an ARP reply.  Still want to see if there is match with the
				given MAC address.ucBytes.  If found, either of the two entries
				must be cleared. */
				xIpEntry = x;
			}
			else if( ( pxMACAddress != NULL ) && ( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 ) )
 8003308:	b136      	cbz	r6, 8003318 <vARPRefreshCacheEntry+0x7c>
 800330a:	2206      	movs	r2, #6
 800330c:	4631      	mov	r1, r6
 800330e:	4620      	mov	r0, r4
 8003310:	f008 fe94 	bl	800c03c <memcmp>
 8003314:	2800      	cmp	r0, #0
 8003316:	d0ed      	beq.n	80032f4 <vARPRefreshCacheEntry+0x58>
				xMacEntry = x;
	#endif
			}
			/* _HT_
			Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8003318:	79bb      	ldrb	r3, [r7, #6]
 800331a:	455b      	cmp	r3, fp
 800331c:	d2eb      	bcs.n	80032f6 <vARPRefreshCacheEntry+0x5a>
			{
				/* As the table is traversed, remember the table row that
				contains the oldest entry (the lowest age count, as ages are
				decremented to zero) so the row can be re-used if this function
				needs to add an entry that does not already exist. */
				ucMinAgeFound = xARPCache[ x ].ucAge;
 800331e:	469b      	mov	fp, r3
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8003320:	9501      	str	r5, [sp, #4]
 8003322:	e7e8      	b.n	80032f6 <vARPRefreshCacheEntry+0x5a>
 8003324:	46aa      	mov	sl, r5
				xUseEntry = x;
			}
		}

		if( xMacEntry >= 0 )
 8003326:	f1b9 0f00 	cmp.w	r9, #0
 800332a:	db2c      	blt.n	8003386 <vARPRefreshCacheEntry+0xea>
		{
			xUseEntry = xMacEntry;

			if( xIpEntry >= 0 )
 800332c:	f1ba 0f00 	cmp.w	sl, #0
 8003330:	db30      	blt.n	8003394 <vARPRefreshCacheEntry+0xf8>
			{
				/* Both the MAC address as well as the IP address were found in
				different locations: clear the entry which matches the
				IP-address */
				memset( &xARPCache[ xIpEntry ], '\0', sizeof( xARPCache[ xIpEntry ] ) );
 8003332:	4925      	ldr	r1, [pc, #148]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 8003334:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
 8003338:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800333c:	eb01 020a 	add.w	r2, r1, sl
 8003340:	2300      	movs	r3, #0
 8003342:	f841 300a 	str.w	r3, [r1, sl]
 8003346:	6053      	str	r3, [r2, #4]
 8003348:	6093      	str	r3, [r2, #8]
			/* An entry containing the IP-address was found, but it had a different MAC address */
			xUseEntry = xIpEntry;
		}

		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 800334a:	eb09 0349 	add.w	r3, r9, r9, lsl #1
 800334e:	4a1e      	ldr	r2, [pc, #120]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 8003350:	f842 8023 	str.w	r8, [r2, r3, lsl #2]

		if( pxMACAddress != NULL )
 8003354:	b1a6      	cbz	r6, 8003380 <vARPRefreshCacheEntry+0xe4>
		{
			memcpy( xARPCache[ xUseEntry ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) );
 8003356:	4b1c      	ldr	r3, [pc, #112]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 8003358:	ea4f 0149 	mov.w	r1, r9, lsl #1
 800335c:	eb01 0209 	add.w	r2, r1, r9
 8003360:	0092      	lsls	r2, r2, #2
 8003362:	3204      	adds	r2, #4
 8003364:	189c      	adds	r4, r3, r2
 8003366:	6830      	ldr	r0, [r6, #0]
 8003368:	5098      	str	r0, [r3, r2]
 800336a:	88b2      	ldrh	r2, [r6, #4]
 800336c:	80a2      	strh	r2, [r4, #4]

			iptraceARP_TABLE_ENTRY_CREATED( ulIPAddress, (*pxMACAddress) );
			/* And this entry does not need immediate attention */
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 800336e:	eb01 0209 	add.w	r2, r1, r9
 8003372:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8003376:	2096      	movs	r0, #150	; 0x96
 8003378:	7290      	strb	r0, [r2, #10]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdTRUE;
 800337a:	4613      	mov	r3, r2
 800337c:	2201      	movs	r2, #1
 800337e:	72da      	strb	r2, [r3, #11]
		{
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
		}
	}
}
 8003380:	b003      	add	sp, #12
 8003382:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		else if( xIpEntry >= 0 )
 8003386:	f1ba 0f00 	cmp.w	sl, #0
 800338a:	db01      	blt.n	8003390 <vARPRefreshCacheEntry+0xf4>
			xUseEntry = xIpEntry;
 800338c:	46d1      	mov	r9, sl
 800338e:	e7dc      	b.n	800334a <vARPRefreshCacheEntry+0xae>
 8003390:	f8dd 9004 	ldr.w	r9, [sp, #4]
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 8003394:	eb09 0349 	add.w	r3, r9, r9, lsl #1
 8003398:	4a0b      	ldr	r2, [pc, #44]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 800339a:	f842 8023 	str.w	r8, [r2, r3, lsl #2]
		if( pxMACAddress != NULL )
 800339e:	2e00      	cmp	r6, #0
 80033a0:	d1d9      	bne.n	8003356 <vARPRefreshCacheEntry+0xba>
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
 80033a2:	4b09      	ldr	r3, [pc, #36]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 80033a4:	ea4f 0249 	mov.w	r2, r9, lsl #1
 80033a8:	eb02 0109 	add.w	r1, r2, r9
 80033ac:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80033b0:	2005      	movs	r0, #5
 80033b2:	7288      	strb	r0, [r1, #10]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
 80033b4:	2200      	movs	r2, #0
 80033b6:	72ca      	strb	r2, [r1, #11]
 80033b8:	e7e2      	b.n	8003380 <vARPRefreshCacheEntry+0xe4>
 80033ba:	bf00      	nop
 80033bc:	20000010 	.word	0x20000010
 80033c0:	200004f8 	.word	0x200004f8
 80033c4:	200003e0 	.word	0x200003e0
 80033c8:	200003dc 	.word	0x200003dc

080033cc <eARPProcessPacket>:
{
 80033cc:	b538      	push	{r3, r4, r5, lr}
	if( *ipLOCAL_IP_ADDRESS_POINTER != 0UL )
 80033ce:	4b26      	ldr	r3, [pc, #152]	; (8003468 <eARPProcessPacket+0x9c>)
 80033d0:	695b      	ldr	r3, [r3, #20]
 80033d2:	2b00      	cmp	r3, #0
 80033d4:	d046      	beq.n	8003464 <eARPProcessPacket+0x98>
 80033d6:	4604      	mov	r4, r0
		switch( pxARPHeader->usOperation )
 80033d8:	8a82      	ldrh	r2, [r0, #20]
 80033da:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80033de:	d004      	beq.n	80033ea <eARPProcessPacket+0x1e>
 80033e0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80033e4:	d038      	beq.n	8003458 <eARPProcessPacket+0x8c>
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 80033e6:	2000      	movs	r0, #0
 80033e8:	bd38      	pop	{r3, r4, r5, pc}
				if( pxARPHeader->ulTargetProtocolAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 80033ea:	f8d0 2026 	ldr.w	r2, [r0, #38]	; 0x26
 80033ee:	4293      	cmp	r3, r2
 80033f0:	d001      	beq.n	80033f6 <eARPProcessPacket+0x2a>
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 80033f2:	2000      	movs	r0, #0
}
 80033f4:	bd38      	pop	{r3, r4, r5, pc}
					vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), pxARPHeader->ulSenderProtocolAddress );
 80033f6:	f100 0516 	add.w	r5, r0, #22
 80033fa:	69c1      	ldr	r1, [r0, #28]
 80033fc:	4628      	mov	r0, r5
 80033fe:	f7ff ff4d 	bl	800329c <vARPRefreshCacheEntry>
					pxARPHeader->usOperation = ( uint16_t ) ipARP_REPLY;
 8003402:	2300      	movs	r3, #0
 8003404:	7523      	strb	r3, [r4, #20]
 8003406:	2302      	movs	r3, #2
 8003408:	7563      	strb	r3, [r4, #21]
					if( pxARPHeader->ulTargetProtocolAddress == pxARPHeader->ulSenderProtocolAddress )
 800340a:	69e3      	ldr	r3, [r4, #28]
 800340c:	f8d4 2026 	ldr.w	r2, [r4, #38]	; 0x26
 8003410:	429a      	cmp	r2, r3
 8003412:	d00f      	beq.n	8003434 <eARPProcessPacket+0x68>
						memcpy( pxARPHeader->xTargetHardwareAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( MACAddress_t ) );
 8003414:	682a      	ldr	r2, [r5, #0]
 8003416:	6222      	str	r2, [r4, #32]
 8003418:	88aa      	ldrh	r2, [r5, #4]
 800341a:	84a2      	strh	r2, [r4, #36]	; 0x24
						pxARPHeader->ulTargetProtocolAddress = pxARPHeader->ulSenderProtocolAddress;
 800341c:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
					memcpy( pxARPHeader->xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) );
 8003420:	4b11      	ldr	r3, [pc, #68]	; (8003468 <eARPProcessPacket+0x9c>)
 8003422:	6818      	ldr	r0, [r3, #0]
 8003424:	f8c4 0016 	str.w	r0, [r4, #22]
 8003428:	889a      	ldrh	r2, [r3, #4]
 800342a:	80aa      	strh	r2, [r5, #4]
					pxARPHeader->ulSenderProtocolAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800342c:	695b      	ldr	r3, [r3, #20]
 800342e:	61e3      	str	r3, [r4, #28]
					eReturn = eReturnEthernetFrame;
 8003430:	2002      	movs	r0, #2
 8003432:	bd38      	pop	{r3, r4, r5, pc}
						memcpy( pxARPFrame->xEthernetHeader.xSourceAddress.ucBytes, xBroadcastMACAddress.ucBytes, sizeof( xBroadcastMACAddress ) );
 8003434:	4b0d      	ldr	r3, [pc, #52]	; (800346c <eARPProcessPacket+0xa0>)
 8003436:	681a      	ldr	r2, [r3, #0]
 8003438:	f8c4 2006 	str.w	r2, [r4, #6]
 800343c:	889b      	ldrh	r3, [r3, #4]
 800343e:	8163      	strh	r3, [r4, #10]
						memset( pxARPHeader->xTargetHardwareAddress.ucBytes, '\0', sizeof( MACAddress_t ) );
 8003440:	2300      	movs	r3, #0
 8003442:	6223      	str	r3, [r4, #32]
 8003444:	84a3      	strh	r3, [r4, #36]	; 0x24
						pxARPHeader->ulTargetProtocolAddress = 0UL;
 8003446:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
 800344a:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
 800344e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
 8003452:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
 8003456:	e7e3      	b.n	8003420 <eARPProcessPacket+0x54>
				vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), pxARPHeader->ulSenderProtocolAddress );
 8003458:	69c1      	ldr	r1, [r0, #28]
 800345a:	3016      	adds	r0, #22
 800345c:	f7ff ff1e 	bl	800329c <vARPRefreshCacheEntry>
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8003460:	2000      	movs	r0, #0
				break;
 8003462:	bd38      	pop	{r3, r4, r5, pc}
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8003464:	2000      	movs	r0, #0
 8003466:	bd38      	pop	{r3, r4, r5, pc}
 8003468:	20000010 	.word	0x20000010
 800346c:	0800c494 	.word	0x0800c494

08003470 <eARPGetCacheEntry>:
{
eARPLookupResult_t eReturn;
uint32_t ulAddressToLookup;

#if( ipconfigUSE_LLMNR == 1 )
	if( *pulIPAddress == ipLLMNR_IP_ADDR )	/* Is in network byte order */
 8003470:	6803      	ldr	r3, [r0, #0]
 8003472:	4a27      	ldr	r2, [pc, #156]	; (8003510 <eARPGetCacheEntry+0xa0>)
 8003474:	4293      	cmp	r3, r2
 8003476:	d00b      	beq.n	8003490 <eARPGetCacheEntry+0x20>
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else
#endif
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 8003478:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800347c:	d00f      	beq.n	800349e <eARPGetCacheEntry+0x2e>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
 800347e:	4a25      	ldr	r2, [pc, #148]	; (8003514 <eARPGetCacheEntry+0xa4>)
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 8003480:	6912      	ldr	r2, [r2, #16]
 8003482:	4293      	cmp	r3, r2
 8003484:	d00b      	beq.n	800349e <eARPGetCacheEntry+0x2e>
	{
		/* This is a broadcast so uses the broadcast MAC address. */
		memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else if( *ipLOCAL_IP_ADDRESS_POINTER == 0UL )
 8003486:	4a24      	ldr	r2, [pc, #144]	; (8003518 <eARPGetCacheEntry+0xa8>)
 8003488:	6952      	ldr	r2, [r2, #20]
 800348a:	b97a      	cbnz	r2, 80034ac <eARPGetCacheEntry+0x3c>
	{
		/* The IP address has not yet been assigned, so there is nothing that
		can be done. */
		eReturn = eCantSendPacket;
 800348c:	2002      	movs	r0, #2
 800348e:	4770      	bx	lr
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
 8003490:	4b22      	ldr	r3, [pc, #136]	; (800351c <eARPGetCacheEntry+0xac>)
 8003492:	681a      	ldr	r2, [r3, #0]
 8003494:	600a      	str	r2, [r1, #0]
 8003496:	889b      	ldrh	r3, [r3, #4]
 8003498:	808b      	strh	r3, [r1, #4]
		eReturn = eARPCacheHit;
 800349a:	2001      	movs	r0, #1
 800349c:	4770      	bx	lr
		memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
 800349e:	4b20      	ldr	r3, [pc, #128]	; (8003520 <eARPGetCacheEntry+0xb0>)
 80034a0:	681a      	ldr	r2, [r3, #0]
 80034a2:	600a      	str	r2, [r1, #0]
 80034a4:	889b      	ldrh	r3, [r3, #4]
 80034a6:	808b      	strh	r3, [r1, #4]
		eReturn = eARPCacheHit;
 80034a8:	2001      	movs	r0, #1
 80034aa:	4770      	bx	lr
{
 80034ac:	b430      	push	{r4, r5}
	}
	else
	{
		eReturn = eARPCacheMiss;

		if( ( *pulIPAddress & xNetworkAddressing.ulNetMask ) != ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) )
 80034ae:	405a      	eors	r2, r3
 80034b0:	4c18      	ldr	r4, [pc, #96]	; (8003514 <eARPGetCacheEntry+0xa4>)
 80034b2:	6864      	ldr	r4, [r4, #4]
 80034b4:	4222      	tst	r2, r4
			else
#endif
			{
				/* The IP address is off the local network, so look up the
				hardware address of the router, if any. */
				ulAddressToLookup = xNetworkAddressing.ulGatewayAddress;
 80034b6:	bf1c      	itt	ne
 80034b8:	4b16      	ldrne	r3, [pc, #88]	; (8003514 <eARPGetCacheEntry+0xa4>)
 80034ba:	689b      	ldrne	r3, [r3, #8]
			ulAddressToLookup = *pulIPAddress;
		}

		if( eReturn == eARPCacheMiss )
		{
			if( ulAddressToLookup == 0UL )
 80034bc:	b913      	cbnz	r3, 80034c4 <eARPGetCacheEntry+0x54>
			{
				/* The address is not on the local network, and there is not a
				router. */
				eReturn = eCantSendPacket;
 80034be:	2002      	movs	r0, #2
			}
		}
	}

	return eReturn;
}
 80034c0:	bc30      	pop	{r4, r5}
 80034c2:	4770      	bx	lr
	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
	{
		/* Does this row in the ARP cache table hold an entry for the IP address
		being queried? */
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80034c4:	4a17      	ldr	r2, [pc, #92]	; (8003524 <eARPGetCacheEntry+0xb4>)
 80034c6:	6812      	ldr	r2, [r2, #0]
 80034c8:	4293      	cmp	r3, r2
 80034ca:	d00b      	beq.n	80034e4 <eARPGetCacheEntry+0x74>
 80034cc:	4c15      	ldr	r4, [pc, #84]	; (8003524 <eARPGetCacheEntry+0xb4>)
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80034ce:	2201      	movs	r2, #1
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80034d0:	68e5      	ldr	r5, [r4, #12]
 80034d2:	42ab      	cmp	r3, r5
 80034d4:	d007      	beq.n	80034e6 <eARPGetCacheEntry+0x76>
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80034d6:	3201      	adds	r2, #1
 80034d8:	340c      	adds	r4, #12
 80034da:	2a06      	cmp	r2, #6
 80034dc:	d1f8      	bne.n	80034d0 <eARPGetCacheEntry+0x60>
					*pulIPAddress = ulAddressToLookup;
 80034de:	6003      	str	r3, [r0, #0]
				eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress );
 80034e0:	2000      	movs	r0, #0
 80034e2:	e7ed      	b.n	80034c0 <eARPGetCacheEntry+0x50>
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80034e4:	2200      	movs	r2, #0
		{
			/* A matching valid entry was found. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 80034e6:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80034ea:	480e      	ldr	r0, [pc, #56]	; (8003524 <eARPGetCacheEntry+0xb4>)
 80034ec:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80034f0:	7adb      	ldrb	r3, [r3, #11]
 80034f2:	b90b      	cbnz	r3, 80034f8 <eARPGetCacheEntry+0x88>
			{
				/* This entry is waiting an ARP reply, so is not valid. */
				eReturn = eCantSendPacket;
 80034f4:	2002      	movs	r0, #2
	return eReturn;
 80034f6:	e7e3      	b.n	80034c0 <eARPGetCacheEntry+0x50>
			}
			else
			{
				/* A valid entry was found. */
				memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 80034f8:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80034fc:	009b      	lsls	r3, r3, #2
 80034fe:	3304      	adds	r3, #4
 8003500:	18c2      	adds	r2, r0, r3
 8003502:	58c0      	ldr	r0, [r0, r3]
 8003504:	6008      	str	r0, [r1, #0]
 8003506:	8893      	ldrh	r3, [r2, #4]
 8003508:	808b      	strh	r3, [r1, #4]
				eReturn = eARPCacheHit;
 800350a:	2001      	movs	r0, #1
 800350c:	e7d8      	b.n	80034c0 <eARPGetCacheEntry+0x50>
 800350e:	bf00      	nop
 8003510:	fc0000e0 	.word	0xfc0000e0
 8003514:	200004f8 	.word	0x200004f8
 8003518:	20000010 	.word	0x20000010
 800351c:	0800c44c 	.word	0x0800c44c
 8003520:	0800c494 	.word	0x0800c494
 8003524:	200003dc 	.word	0x200003dc

08003528 <vARPGenerateRequestPacket>:
		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
	}
}

void vARPGenerateRequestPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8003528:	b5f0      	push	{r4, r5, r6, r7, lr}
 800352a:	4686      	mov	lr, r0
ARPPacket_t *pxARPPacket;

	pxARPPacket = ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
 800352c:	6987      	ldr	r7, [r0, #24]
		xARPHeader.ucHardwareAddressLength;
		xARPHeader.ucProtocolAddressLength;
		xARPHeader.usOperation;
		xARPHeader.xTargetHardwareAddress;
	*/
	memcpy( ( void * ) &( pxARPPacket->xEthernetHeader ), ( void * ) xDefaultPartARPPacketHeader, sizeof( xDefaultPartARPPacketHeader ) );
 800352e:	4e12      	ldr	r6, [pc, #72]	; (8003578 <vARPGenerateRequestPacket+0x50>)
 8003530:	463c      	mov	r4, r7
 8003532:	f106 0c20 	add.w	ip, r6, #32
 8003536:	4635      	mov	r5, r6
 8003538:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800353a:	6020      	str	r0, [r4, #0]
 800353c:	6061      	str	r1, [r4, #4]
 800353e:	60a2      	str	r2, [r4, #8]
 8003540:	60e3      	str	r3, [r4, #12]
 8003542:	462e      	mov	r6, r5
 8003544:	3410      	adds	r4, #16
 8003546:	4565      	cmp	r5, ip
 8003548:	d1f5      	bne.n	8003536 <vARPGenerateRequestPacket+0xe>
 800354a:	6828      	ldr	r0, [r5, #0]
 800354c:	6020      	str	r0, [r4, #0]
 800354e:	88ab      	ldrh	r3, [r5, #4]
 8003550:	80a3      	strh	r3, [r4, #4]
	memcpy( ( void * ) pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8003552:	4b0a      	ldr	r3, [pc, #40]	; (800357c <vARPGenerateRequestPacket+0x54>)
 8003554:	6818      	ldr	r0, [r3, #0]
 8003556:	f8c7 0006 	str.w	r0, [r7, #6]
 800355a:	889a      	ldrh	r2, [r3, #4]
 800355c:	817a      	strh	r2, [r7, #10]
	memcpy( ( void * ) pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800355e:	f8c7 0016 	str.w	r0, [r7, #22]
 8003562:	837a      	strh	r2, [r7, #26]
	/* HT:endian: network to network */
	pxARPPacket->xARPHeader.ulSenderProtocolAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8003564:	695b      	ldr	r3, [r3, #20]
 8003566:	61fb      	str	r3, [r7, #28]
	pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->ulIPAddress;
 8003568:	f8de 3014 	ldr.w	r3, [lr, #20]
 800356c:	f8c7 3026 	str.w	r3, [r7, #38]	; 0x26

	pxNetworkBuffer->xDataLength = sizeof( ARPPacket_t );
 8003570:	232a      	movs	r3, #42	; 0x2a
 8003572:	f8ce 301c 	str.w	r3, [lr, #28]
 8003576:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003578:	0800c418 	.word	0x0800c418
 800357c:	20000010 	.word	0x20000010

08003580 <FreeRTOS_OutputARPRequest>:
{
 8003580:	b538      	push	{r3, r4, r5, lr}
 8003582:	4605      	mov	r5, r0
	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( ARPPacket_t ), ( TickType_t ) 0 );
 8003584:	2100      	movs	r1, #0
 8003586:	202a      	movs	r0, #42	; 0x2a
 8003588:	f004 fc94 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>
	if( pxNetworkBuffer != NULL )
 800358c:	b138      	cbz	r0, 800359e <FreeRTOS_OutputARPRequest+0x1e>
 800358e:	4604      	mov	r4, r0
		pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8003590:	6145      	str	r5, [r0, #20]
		vARPGenerateRequestPacket( pxNetworkBuffer );
 8003592:	f7ff ffc9 	bl	8003528 <vARPGenerateRequestPacket>
		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 8003596:	2101      	movs	r1, #1
 8003598:	4620      	mov	r0, r4
 800359a:	f004 ff27 	bl	80083ec <xNetworkInterfaceOutput>
 800359e:	bd38      	pop	{r3, r4, r5, pc}

080035a0 <vARPAgeCache>:
{
 80035a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80035a4:	4c1b      	ldr	r4, [pc, #108]	; (8003614 <vARPAgeCache+0x74>)
 80035a6:	f104 0648 	add.w	r6, r4, #72	; 0x48
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
 80035aa:	2700      	movs	r7, #0
 80035ac:	f04f 0807 	mov.w	r8, #7
 80035b0:	e007      	b.n	80035c2 <vARPAgeCache+0x22>
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 80035b2:	6820      	ldr	r0, [r4, #0]
 80035b4:	f7ff ffe4 	bl	8003580 <FreeRTOS_OutputARPRequest>
			if( xARPCache[ x ].ucAge == 0u )
 80035b8:	7aab      	ldrb	r3, [r5, #10]
 80035ba:	b193      	cbz	r3, 80035e2 <vARPAgeCache+0x42>
 80035bc:	340c      	adds	r4, #12
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80035be:	42b4      	cmp	r4, r6
 80035c0:	d015      	beq.n	80035ee <vARPAgeCache+0x4e>
 80035c2:	4625      	mov	r5, r4
		if( xARPCache[ x ].ucAge > 0U )
 80035c4:	7aa3      	ldrb	r3, [r4, #10]
 80035c6:	2b00      	cmp	r3, #0
 80035c8:	d0f8      	beq.n	80035bc <vARPAgeCache+0x1c>
			( xARPCache[ x ].ucAge )--;
 80035ca:	3b01      	subs	r3, #1
 80035cc:	b2db      	uxtb	r3, r3
 80035ce:	72a3      	strb	r3, [r4, #10]
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 80035d0:	7ae2      	ldrb	r2, [r4, #11]
 80035d2:	2a00      	cmp	r2, #0
 80035d4:	d0ed      	beq.n	80035b2 <vARPAgeCache+0x12>
			else if( xARPCache[ x ].ucAge <= ( uint8_t ) arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST )
 80035d6:	2b03      	cmp	r3, #3
 80035d8:	d8ee      	bhi.n	80035b8 <vARPAgeCache+0x18>
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 80035da:	6820      	ldr	r0, [r4, #0]
 80035dc:	f7ff ffd0 	bl	8003580 <FreeRTOS_OutputARPRequest>
 80035e0:	e7ea      	b.n	80035b8 <vARPAgeCache+0x18>
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
 80035e2:	4639      	mov	r1, r7
 80035e4:	4640      	mov	r0, r8
 80035e6:	f007 fdfb 	bl	800b1e0 <vExampleDebugStatUpdate>
				xARPCache[ x ].ulIPAddress = 0UL;
 80035ea:	602f      	str	r7, [r5, #0]
 80035ec:	e7e6      	b.n	80035bc <vARPAgeCache+0x1c>
	xTimeNow = xTaskGetTickCount ();
 80035ee:	f006 f9e7 	bl	80099c0 <xTaskGetTickCount>
 80035f2:	4604      	mov	r4, r0
	if( ( xLastGratuitousARPTime == ( TickType_t ) 0 ) || ( ( xTimeNow - xLastGratuitousARPTime ) > ( TickType_t ) arpGRATUITOUS_ARP_PERIOD ) )
 80035f4:	4b08      	ldr	r3, [pc, #32]	; (8003618 <vARPAgeCache+0x78>)
 80035f6:	681b      	ldr	r3, [r3, #0]
 80035f8:	b123      	cbz	r3, 8003604 <vARPAgeCache+0x64>
 80035fa:	1ac3      	subs	r3, r0, r3
 80035fc:	f644 6220 	movw	r2, #20000	; 0x4e20
 8003600:	4293      	cmp	r3, r2
 8003602:	d905      	bls.n	8003610 <vARPAgeCache+0x70>
		FreeRTOS_OutputARPRequest( *ipLOCAL_IP_ADDRESS_POINTER );
 8003604:	4b05      	ldr	r3, [pc, #20]	; (800361c <vARPAgeCache+0x7c>)
 8003606:	6958      	ldr	r0, [r3, #20]
 8003608:	f7ff ffba 	bl	8003580 <FreeRTOS_OutputARPRequest>
		xLastGratuitousARPTime = xTimeNow;
 800360c:	4b02      	ldr	r3, [pc, #8]	; (8003618 <vARPAgeCache+0x78>)
 800360e:	601c      	str	r4, [r3, #0]
 8003610:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003614:	200003dc 	.word	0x200003dc
 8003618:	20000424 	.word	0x20000424
 800361c:	20000010 	.word	0x20000010

08003620 <prvSkipNameField>:

static uint8_t *prvSkipNameField( uint8_t *pucByte )
{
	/* Determine if the name is the fully coded name, or an offset to the name
	elsewhere in the message. */
	if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8003620:	7803      	ldrb	r3, [r0, #0]
 8003622:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
 8003626:	2ac0      	cmp	r2, #192	; 0xc0
 8003628:	d007      	beq.n	800363a <prvSkipNameField+0x1a>

	}
	else
	{
		/* pucByte points to the full name.  Walk over the string. */
		while( *pucByte != 0x00 )
 800362a:	b123      	cbz	r3, 8003636 <prvSkipNameField+0x16>
		{
			/* The number of bytes to jump for each name section is stored in the byte
			before the name section. */
			pucByte += ( *pucByte + 1 );
 800362c:	3301      	adds	r3, #1
 800362e:	4418      	add	r0, r3
		while( *pucByte != 0x00 )
 8003630:	7803      	ldrb	r3, [r0, #0]
 8003632:	2b00      	cmp	r3, #0
 8003634:	d1fa      	bne.n	800362c <prvSkipNameField+0xc>
		}

		pucByte++;
 8003636:	3001      	adds	r0, #1
	}

	return pucByte;
}
 8003638:	4770      	bx	lr
		pucByte += sizeof( uint16_t );
 800363a:	3002      	adds	r0, #2
 800363c:	4770      	bx	lr
	...

08003640 <prvParseDNSReply>:

#endif /* ipconfigUSE_NBNS */
/*-----------------------------------------------------------*/

static uint32_t prvParseDNSReply( uint8_t *pucUDPPayloadBuffer, TickType_t xIdentifier )
{
 8003640:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003644:	b0a0      	sub	sp, #128	; 0x80
 8003646:	4607      	mov	r7, r0
 8003648:	460c      	mov	r4, r1
uint16_t x, usDataLength, usQuestions;
#if( ipconfigUSE_LLMNR == 1 )
	uint16_t usType = 0, usClass = 0;
#endif
#if( ipconfigUSE_DNS_CACHE == 1 )
	char pcName[128] = ""; /*_RB_ What is the significance of 128?  Probably too big to go on the stack for a small MCU but don't know how else it could be made re-entrant.  Might be necessary. */
 800364a:	2100      	movs	r1, #0
 800364c:	9100      	str	r1, [sp, #0]
 800364e:	227c      	movs	r2, #124	; 0x7c
 8003650:	a801      	add	r0, sp, #4
 8003652:	f008 fd27 	bl	800c0a4 <memset>
#endif

	pxDNSMessageHeader = ( DNSMessage_t * ) pucUDPPayloadBuffer;

	if( pxDNSMessageHeader->usIdentifier == ( uint16_t ) xIdentifier )
 8003656:	883b      	ldrh	r3, [r7, #0]
 8003658:	b2a4      	uxth	r4, r4
 800365a:	42a3      	cmp	r3, r4
 800365c:	d003      	beq.n	8003666 <prvParseDNSReply+0x26>
uint32_t ulIPAddress = 0UL;
 800365e:	2000      	movs	r0, #0
		}
#endif /* ipconfigUSE_LLMNR == 1 */
	}

	return ulIPAddress;
}
 8003660:	b020      	add	sp, #128	; 0x80
 8003662:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pucByte = pucUDPPayloadBuffer + sizeof( DNSMessage_t );
 8003666:	f107 050c 	add.w	r5, r7, #12
		usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );
 800366a:	88bb      	ldrh	r3, [r7, #4]
 800366c:	0a1e      	lsrs	r6, r3, #8
 800366e:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
 8003672:	b2b6      	uxth	r6, r6
		for( x = 0; x < usQuestions; x++ )
 8003674:	2e00      	cmp	r6, #0
 8003676:	d05c      	beq.n	8003732 <prvParseDNSReply+0xf2>
 8003678:	2400      	movs	r4, #0
 800367a:	46a2      	mov	sl, r4
		if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 800367c:	46a1      	mov	r9, r4
					pcName[xNameLen++] = '.';
 800367e:	f04f 082e 	mov.w	r8, #46	; 0x2e
				if( x == 0 )
 8003682:	2c00      	cmp	r4, #0
 8003684:	f000 816c 	beq.w	8003960 <prvParseDNSReply+0x320>
				pucByte = prvSkipNameField( pucByte );
 8003688:	4628      	mov	r0, r5
 800368a:	f7ff ffc9 	bl	8003620 <prvSkipNameField>
			pucByte += sizeof( uint32_t );
 800368e:	1d05      	adds	r5, r0, #4
		for( x = 0; x < usQuestions; x++ )
 8003690:	3401      	adds	r4, #1
 8003692:	b2a4      	uxth	r4, r4
 8003694:	42a6      	cmp	r6, r4
 8003696:	d1f4      	bne.n	8003682 <prvParseDNSReply+0x42>

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 8003698:	7803      	ldrb	r3, [r0, #0]
			  ( ( ( uint32_t )apChr[1] ) ) );
 800369a:	7842      	ldrb	r2, [r0, #1]
	return ( uint16_t )
 800369c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 80036a0:	7881      	ldrb	r1, [r0, #2]
			  ( ( ( uint32_t )apChr[1] ) ) );
 80036a2:	78c3      	ldrb	r3, [r0, #3]
	return ( uint16_t )
 80036a4:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
		pxDNSMessageHeader->usAnswers = FreeRTOS_ntohs( pxDNSMessageHeader->usAnswers );
 80036a8:	88fb      	ldrh	r3, [r7, #6]
 80036aa:	0a1c      	lsrs	r4, r3, #8
 80036ac:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80036b0:	b2a4      	uxth	r4, r4
 80036b2:	80fc      	strh	r4, [r7, #6]
		if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
 80036b4:	887b      	ldrh	r3, [r7, #2]
 80036b6:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
 80036ba:	2b80      	cmp	r3, #128	; 0x80
 80036bc:	d03e      	beq.n	800373c <prvParseDNSReply+0xfc>
		else if( usQuestions && ( usType == dnsTYPE_A_HOST ) && ( usClass == dnsCLASS_IN ) )
 80036be:	2e00      	cmp	r6, #0
 80036c0:	f000 8148 	beq.w	8003954 <prvParseDNSReply+0x314>
 80036c4:	2a01      	cmp	r2, #1
 80036c6:	f000 80b8 	beq.w	800383a <prvParseDNSReply+0x1fa>
uint32_t ulIPAddress = 0UL;
 80036ca:	2000      	movs	r0, #0
 80036cc:	e7c8      	b.n	8003660 <prvParseDNSReply+0x20>
			pucByte += sizeof( uint16_t );
 80036ce:	1ca8      	adds	r0, r5, #2
 80036d0:	46aa      	mov	sl, r5
 80036d2:	e7dc      	b.n	800368e <prvParseDNSReply+0x4e>
				for( xCount = *(pucByte++); xCount--; pucByte++ )
 80036d4:	3201      	adds	r2, #1
 80036d6:	4293      	cmp	r3, r2
 80036d8:	d00a      	beq.n	80036f0 <prvParseDNSReply+0xb0>
					if( xNameLen < xLen - 1 )
 80036da:	f1ba 0f7e 	cmp.w	sl, #126	; 0x7e
 80036de:	dcf9      	bgt.n	80036d4 <prvParseDNSReply+0x94>
						pcName[xNameLen++] = *( ( char * ) pucByte );
 80036e0:	7810      	ldrb	r0, [r2, #0]
 80036e2:	a920      	add	r1, sp, #128	; 0x80
 80036e4:	4451      	add	r1, sl
 80036e6:	f801 0c80 	strb.w	r0, [r1, #-128]
 80036ea:	f10a 0a01 	add.w	sl, sl, #1
 80036ee:	e7f1      	b.n	80036d4 <prvParseDNSReply+0x94>
 80036f0:	eb0c 030e 	add.w	r3, ip, lr
			while( *pucByte != 0x00 )
 80036f4:	781a      	ldrb	r2, [r3, #0]
 80036f6:	b1ca      	cbz	r2, 800372c <prvParseDNSReply+0xec>
				if( xNameLen && xNameLen < xLen - 1 )
 80036f8:	f1ba 0f00 	cmp.w	sl, #0
 80036fc:	d008      	beq.n	8003710 <prvParseDNSReply+0xd0>
 80036fe:	f1ba 0f7e 	cmp.w	sl, #126	; 0x7e
 8003702:	dc05      	bgt.n	8003710 <prvParseDNSReply+0xd0>
					pcName[xNameLen++] = '.';
 8003704:	aa20      	add	r2, sp, #128	; 0x80
 8003706:	4452      	add	r2, sl
 8003708:	f802 8c80 	strb.w	r8, [r2, #-128]
 800370c:	f10a 0a01 	add.w	sl, sl, #1
				for( xCount = *(pucByte++); xCount--; pucByte++ )
 8003710:	f103 0c01 	add.w	ip, r3, #1
 8003714:	f893 e000 	ldrb.w	lr, [r3]
 8003718:	f1be 0f00 	cmp.w	lr, #0
 800371c:	d004      	beq.n	8003728 <prvParseDNSReply+0xe8>
 800371e:	f10e 0201 	add.w	r2, lr, #1
 8003722:	4413      	add	r3, r2
 8003724:	4662      	mov	r2, ip
 8003726:	e7d8      	b.n	80036da <prvParseDNSReply+0x9a>
 8003728:	4663      	mov	r3, ip
 800372a:	e7e3      	b.n	80036f4 <prvParseDNSReply+0xb4>
			pucByte++;
 800372c:	1c58      	adds	r0, r3, #1
 800372e:	46aa      	mov	sl, r5
 8003730:	e7ad      	b.n	800368e <prvParseDNSReply+0x4e>
	uint16_t usType = 0, usClass = 0;
 8003732:	4631      	mov	r1, r6
 8003734:	4632      	mov	r2, r6
	char *pcRequestedName = NULL;
 8003736:	f04f 0a00 	mov.w	sl, #0
 800373a:	e7b5      	b.n	80036a8 <prvParseDNSReply+0x68>
			for( x = 0; x < pxDNSMessageHeader->usAnswers; x++ )
 800373c:	2c00      	cmp	r4, #0
 800373e:	f000 8107 	beq.w	8003950 <prvParseDNSReply+0x310>
 8003742:	2600      	movs	r6, #0
				pucByte = prvSkipNameField( pucByte );
 8003744:	4628      	mov	r0, r5
 8003746:	f7ff ff6b 	bl	8003620 <prvSkipNameField>
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 800374a:	7802      	ldrb	r2, [r0, #0]
			  ( ( ( uint32_t )apChr[1] ) ) );
 800374c:	7843      	ldrb	r3, [r0, #1]
				if( usChar2u16( pucByte ) == dnsTYPE_A_HOST )
 800374e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003752:	2b01      	cmp	r3, #1
 8003754:	d00c      	beq.n	8003770 <prvParseDNSReply+0x130>
					memcpy( ( void * ) &usDataLength, ( void * ) pucByte, sizeof( uint16_t ) );
 8003756:	8905      	ldrh	r5, [r0, #8]
					usDataLength = FreeRTOS_ntohs( usDataLength );
 8003758:	0a2b      	lsrs	r3, r5, #8
 800375a:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
					pucByte += usDataLength + sizeof( uint16_t );
 800375e:	b29b      	uxth	r3, r3
 8003760:	330a      	adds	r3, #10
 8003762:	18c5      	adds	r5, r0, r3
			for( x = 0; x < pxDNSMessageHeader->usAnswers; x++ )
 8003764:	3601      	adds	r6, #1
 8003766:	b2b6      	uxth	r6, r6
 8003768:	42b4      	cmp	r4, r6
 800376a:	d1eb      	bne.n	8003744 <prvParseDNSReply+0x104>
uint32_t ulIPAddress = 0UL;
 800376c:	2000      	movs	r0, #0
 800376e:	e777      	b.n	8003660 <prvParseDNSReply+0x20>
					if( ( size_t ) *pucByte == sizeof( uint32_t ) )
 8003770:	7a43      	ldrb	r3, [r0, #9]
 8003772:	2b04      	cmp	r3, #4
 8003774:	d001      	beq.n	800377a <prvParseDNSReply+0x13a>
uint32_t ulIPAddress = 0UL;
 8003776:	2000      	movs	r0, #0
 8003778:	e772      	b.n	8003660 <prvParseDNSReply+0x20>
						memcpy( ( void * ) &ulIPAddress, ( void * ) pucByte, sizeof( uint32_t ) );
 800377a:	f8d0 400a 	ldr.w	r4, [r0, #10]
	static BaseType_t xFreeEntry = 0;

		/* For each entry in the DNS cache table. */
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
		{
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 800377e:	4b7e      	ldr	r3, [pc, #504]	; (8003978 <prvParseDNSReply+0x338>)
 8003780:	791b      	ldrb	r3, [r3, #4]
 8003782:	b18b      	cbz	r3, 80037a8 <prvParseDNSReply+0x168>
 8003784:	4e7d      	ldr	r6, [pc, #500]	; (800397c <prvParseDNSReply+0x33c>)
 8003786:	2500      	movs	r5, #0
			{
				break;
			}

			if( strncmp( xDNSCache[ x ].pcName, pcName, sizeof( xDNSCache[ x ].pcName ) ) == 0 )
 8003788:	f04f 0810 	mov.w	r8, #16
 800378c:	4642      	mov	r2, r8
 800378e:	4669      	mov	r1, sp
 8003790:	4630      	mov	r0, r6
 8003792:	f008 fcab 	bl	800c0ec <strncmp>
 8003796:	2800      	cmp	r0, #0
 8003798:	d041      	beq.n	800381e <prvParseDNSReply+0x1de>
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 800379a:	3501      	adds	r5, #1
 800379c:	2d04      	cmp	r5, #4
 800379e:	d003      	beq.n	80037a8 <prvParseDNSReply+0x168>
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 80037a0:	f816 3f18 	ldrb.w	r3, [r6, #24]!
 80037a4:	2b00      	cmp	r3, #0
 80037a6:	d1f1      	bne.n	800378c <prvParseDNSReply+0x14c>
				*pulIP = 0;
			}
			else
			{
				/* Called to add or update an item */
				strncpy( xDNSCache[ xFreeEntry ].pcName, pcName, sizeof( xDNSCache[ xFreeEntry ].pcName ) );
 80037a8:	4b75      	ldr	r3, [pc, #468]	; (8003980 <prvParseDNSReply+0x340>)
 80037aa:	681d      	ldr	r5, [r3, #0]
 80037ac:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 8003978 <prvParseDNSReply+0x338>
 80037b0:	006e      	lsls	r6, r5, #1
 80037b2:	1970      	adds	r0, r6, r5
 80037b4:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
 80037b8:	2210      	movs	r2, #16
 80037ba:	4669      	mov	r1, sp
 80037bc:	3004      	adds	r0, #4
 80037be:	f008 fca7 	bl	800c110 <strncpy>
				xDNSCache[ xFreeEntry ].ulIPAddress = *pulIP;
 80037c2:	442e      	add	r6, r5
 80037c4:	f848 4036 	str.w	r4, [r8, r6, lsl #3]

				xFreeEntry++;
 80037c8:	3501      	adds	r5, #1
				if( xFreeEntry == ipconfigDNS_CACHE_ENTRIES )
 80037ca:	2d04      	cmp	r5, #4
 80037cc:	d02d      	beq.n	800382a <prvParseDNSReply+0x1ea>
				xFreeEntry++;
 80037ce:	4b6c      	ldr	r3, [pc, #432]	; (8003980 <prvParseDNSReply+0x340>)
 80037d0:	601d      	str	r5, [r3, #0]
							vDNSDoCallback( ( TickType_t ) pxDNSMessageHeader->usIdentifier, pcName, ulIPAddress );
 80037d2:	883d      	ldrh	r5, [r7, #0]
		vTaskSuspendAll();
 80037d4:	f006 f8ec 	bl	80099b0 <vTaskSuspendAll>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 80037d8:	4a6a      	ldr	r2, [pc, #424]	; (8003984 <prvParseDNSReply+0x344>)
 80037da:	68d3      	ldr	r3, [r2, #12]
 80037dc:	3208      	adds	r2, #8
 80037de:	4293      	cmp	r3, r2
 80037e0:	d019      	beq.n	8003816 <prvParseDNSReply+0x1d6>
				if( listGET_LIST_ITEM_VALUE( pxIterator ) == xIdentifier )
 80037e2:	681a      	ldr	r2, [r3, #0]
 80037e4:	4295      	cmp	r5, r2
 80037e6:	d006      	beq.n	80037f6 <prvParseDNSReply+0x1b6>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 80037e8:	4967      	ldr	r1, [pc, #412]	; (8003988 <prvParseDNSReply+0x348>)
				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 80037ea:	685b      	ldr	r3, [r3, #4]
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 80037ec:	428b      	cmp	r3, r1
 80037ee:	d012      	beq.n	8003816 <prvParseDNSReply+0x1d6>
				if( listGET_LIST_ITEM_VALUE( pxIterator ) == xIdentifier )
 80037f0:	681a      	ldr	r2, [r3, #0]
 80037f2:	4295      	cmp	r5, r2
 80037f4:	d1f9      	bne.n	80037ea <prvParseDNSReply+0x1aa>
					DNSCallback_t *pxCallback = ( DNSCallback_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 80037f6:	68dd      	ldr	r5, [r3, #12]
					pxCallback->pCallbackFunction( pcName, pxCallback->pvSearchID, ulIPAddress );
 80037f8:	686b      	ldr	r3, [r5, #4]
 80037fa:	4622      	mov	r2, r4
 80037fc:	6929      	ldr	r1, [r5, #16]
 80037fe:	4668      	mov	r0, sp
 8003800:	4798      	blx	r3
					uxListRemove( &pxCallback->xListItem );
 8003802:	f105 0014 	add.w	r0, r5, #20
 8003806:	f005 f81f 	bl	8008848 <uxListRemove>
					vPortFree( pxCallback );
 800380a:	4628      	mov	r0, r5
 800380c:	f005 fa62 	bl	8008cd4 <vPortFree>
					if( listLIST_IS_EMPTY( &xCallbackList ) )
 8003810:	4b5c      	ldr	r3, [pc, #368]	; (8003984 <prvParseDNSReply+0x344>)
 8003812:	681b      	ldr	r3, [r3, #0]
 8003814:	b16b      	cbz	r3, 8003832 <prvParseDNSReply+0x1f2>
		xTaskResumeAll();
 8003816:	f006 f9a5 	bl	8009b64 <xTaskResumeAll>
						memcpy( ( void * ) &ulIPAddress, ( void * ) pucByte, sizeof( uint32_t ) );
 800381a:	4620      	mov	r0, r4
 800381c:	e720      	b.n	8003660 <prvParseDNSReply+0x20>
					xDNSCache[ x ].ulIPAddress = *pulIP;
 800381e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8003822:	4b55      	ldr	r3, [pc, #340]	; (8003978 <prvParseDNSReply+0x338>)
 8003824:	f843 4035 	str.w	r4, [r3, r5, lsl #3]
 8003828:	e7d3      	b.n	80037d2 <prvParseDNSReply+0x192>
				{
					xFreeEntry = 0;
 800382a:	2200      	movs	r2, #0
 800382c:	4b54      	ldr	r3, [pc, #336]	; (8003980 <prvParseDNSReply+0x340>)
 800382e:	601a      	str	r2, [r3, #0]
 8003830:	e7cf      	b.n	80037d2 <prvParseDNSReply+0x192>
						vIPSetDnsTimerEnableState( pdFALSE );
 8003832:	2000      	movs	r0, #0
 8003834:	f000 fece 	bl	80045d4 <vIPSetDnsTimerEnableState>
 8003838:	e7ed      	b.n	8003816 <prvParseDNSReply+0x1d6>
		else if( usQuestions && ( usType == dnsTYPE_A_HOST ) && ( usClass == dnsCLASS_IN ) )
 800383a:	2901      	cmp	r1, #1
 800383c:	d001      	beq.n	8003842 <prvParseDNSReply+0x202>
uint32_t ulIPAddress = 0UL;
 800383e:	2000      	movs	r0, #0
 8003840:	e70e      	b.n	8003660 <prvParseDNSReply+0x20>
			if( xApplicationDNSQueryHook ( ( pcRequestedName + 1 ) ) )
 8003842:	f10a 0001 	add.w	r0, sl, #1
 8003846:	f008 fb53 	bl	800bef0 <xApplicationDNSQueryHook>
 800384a:	b908      	cbnz	r0, 8003850 <prvParseDNSReply+0x210>
uint32_t ulIPAddress = 0UL;
 800384c:	2000      	movs	r0, #0
 800384e:	e707      	b.n	8003660 <prvParseDNSReply+0x20>
			NetworkBufferDescriptor_t *pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pucUDPPayloadBuffer );
 8003850:	4638      	mov	r0, r7
 8003852:	f000 fab1 	bl	8003db8 <pxUDPPayloadBuffer_to_NetworkBuffer>
				if( ( xBufferAllocFixedSize == pdFALSE ) && ( pxNetworkBuffer != NULL ) )
 8003856:	4b4d      	ldr	r3, [pc, #308]	; (800398c <prvParseDNSReply+0x34c>)
 8003858:	681b      	ldr	r3, [r3, #0]
 800385a:	b9b3      	cbnz	r3, 800388a <prvParseDNSReply+0x24a>
 800385c:	2800      	cmp	r0, #0
 800385e:	f000 8088 	beq.w	8003972 <prvParseDNSReply+0x332>
					sizeof( EthernetHeader_t ) + sizeof( IPHeader_t );
 8003862:	69c1      	ldr	r1, [r0, #28]
 8003864:	f101 032a 	add.w	r3, r1, #42	; 0x2a
					pxNetworkBuffer->xDataLength = xDataLength;
 8003868:	61c3      	str	r3, [r0, #28]
					pxNewBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, xDataLength + 16 );
 800386a:	313a      	adds	r1, #58	; 0x3a
 800386c:	f000 fa8f 	bl	8003d8e <pxDuplicateNetworkBufferWithDescriptor>
					if( pxNewBuffer != NULL )
 8003870:	4604      	mov	r4, r0
 8003872:	2800      	cmp	r0, #0
 8003874:	d07d      	beq.n	8003972 <prvParseDNSReply+0x332>
						xOffset1 = ( BaseType_t ) ( pucByte - pucUDPPayloadBuffer );
 8003876:	463a      	mov	r2, r7
						pucUDPPayloadBuffer = pxNetworkBuffer->pucEthernetBuffer + ipUDP_PAYLOAD_OFFSET_IPv4;
 8003878:	6983      	ldr	r3, [r0, #24]
 800387a:	f103 072a 	add.w	r7, r3, #42	; 0x2a
						xOffset1 = ( BaseType_t ) ( pucByte - pucUDPPayloadBuffer );
 800387e:	1aad      	subs	r5, r5, r2
						pucByte = pucUDPPayloadBuffer + xOffset1;
 8003880:	443d      	add	r5, r7
						xOffset2 = ( BaseType_t ) ( ( ( uint8_t * ) pcRequestedName ) - pucUDPPayloadBuffer );
 8003882:	ebaa 0a02 	sub.w	sl, sl, r2
						pcRequestedName = ( char * ) ( pucUDPPayloadBuffer + xOffset2 );
 8003886:	44ba      	add	sl, r7
 8003888:	e002      	b.n	8003890 <prvParseDNSReply+0x250>
				if( pxNetworkBuffer != NULL )
 800388a:	2800      	cmp	r0, #0
 800388c:	d064      	beq.n	8003958 <prvParseDNSReply+0x318>
			NetworkBufferDescriptor_t *pxNewBuffer = NULL;
 800388e:	2400      	movs	r4, #0
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usFlags, dnsLLMNR_FLAGS_IS_REPONSE );	/* Set the response flag */
 8003890:	f04f 0e80 	mov.w	lr, #128	; 0x80
 8003894:	f887 e002 	strb.w	lr, [r7, #2]
 8003898:	2100      	movs	r1, #0
 800389a:	70f9      	strb	r1, [r7, #3]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAnswers, 1 );	/* Provide a single answer */
 800389c:	71b9      	strb	r1, [r7, #6]
 800389e:	2301      	movs	r3, #1
 80038a0:	71fb      	strb	r3, [r7, #7]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAuthorityRRs, 0 );	/* No authority */
 80038a2:	7239      	strb	r1, [r7, #8]
 80038a4:	7279      	strb	r1, [r7, #9]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAdditionalRRs, 0 );	/* No additional info */
 80038a6:	72b9      	strb	r1, [r7, #10]
 80038a8:	72f9      	strb	r1, [r7, #11]
					pxAnswer->ucNameCode = dnsNAME_IS_OFFSET;
 80038aa:	22c0      	movs	r2, #192	; 0xc0
 80038ac:	702a      	strb	r2, [r5, #0]
					pxAnswer->ucNameOffset = ( uint8_t )( pcRequestedName - ( char * ) pucUDPPayloadBuffer );
 80038ae:	ebaa 0a07 	sub.w	sl, sl, r7
 80038b2:	f885 a001 	strb.w	sl, [r5, #1]
					vSetField16( pxAnswer, LLMNRAnswer_t, usType, dnsTYPE_A_HOST );	/* Type A: host */
 80038b6:	70a9      	strb	r1, [r5, #2]
 80038b8:	70eb      	strb	r3, [r5, #3]
					vSetField16( pxAnswer, LLMNRAnswer_t, usClass, dnsCLASS_IN );	/* 1: Class IN */
 80038ba:	7129      	strb	r1, [r5, #4]
 80038bc:	716b      	strb	r3, [r5, #5]
					vSetField32( pxAnswer, LLMNRAnswer_t, ulTTL, dnsLLMNR_TTL_VALUE );
 80038be:	71a9      	strb	r1, [r5, #6]
 80038c0:	2304      	movs	r3, #4
 80038c2:	71eb      	strb	r3, [r5, #7]
 80038c4:	2293      	movs	r2, #147	; 0x93
 80038c6:	722a      	strb	r2, [r5, #8]
 80038c8:	22e0      	movs	r2, #224	; 0xe0
 80038ca:	726a      	strb	r2, [r5, #9]
					vSetField16( pxAnswer, LLMNRAnswer_t, usDataLength, 4 );
 80038cc:	72a9      	strb	r1, [r5, #10]
 80038ce:	72eb      	strb	r3, [r5, #11]
					vSetField32( pxAnswer, LLMNRAnswer_t, ulIPAddress, FreeRTOS_ntohl( *ipLOCAL_IP_ADDRESS_POINTER ) );
 80038d0:	4a2f      	ldr	r2, [pc, #188]	; (8003990 <prvParseDNSReply+0x350>)
 80038d2:	7d13      	ldrb	r3, [r2, #20]
 80038d4:	732b      	strb	r3, [r5, #12]
 80038d6:	7d53      	ldrb	r3, [r2, #21]
 80038d8:	736b      	strb	r3, [r5, #13]
 80038da:	7d93      	ldrb	r3, [r2, #22]
 80038dc:	73ab      	strb	r3, [r5, #14]
 80038de:	7dd3      	ldrb	r3, [r2, #23]
 80038e0:	73eb      	strb	r3, [r5, #15]
					usLength = ( int16_t ) ( sizeof( *pxAnswer ) + ( size_t ) ( pucByte - pucUDPPayloadBuffer ) );
 80038e2:	1beb      	subs	r3, r5, r7
 80038e4:	b29b      	uxth	r3, r3
		pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
 80038e6:	6985      	ldr	r5, [r0, #24]
					usLength = ( int16_t ) ( sizeof( *pxAnswer ) + ( size_t ) ( pucByte - pucUDPPayloadBuffer ) );
 80038e8:	f103 0610 	add.w	r6, r3, #16
		pxIPHeader->usLength               = FreeRTOS_htons( lNetLength + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER );
 80038ec:	b236      	sxth	r6, r6
 80038ee:	f103 0c2c 	add.w	ip, r3, #44	; 0x2c
 80038f2:	f106 071c 	add.w	r7, r6, #28
 80038f6:	0a3f      	lsrs	r7, r7, #8
 80038f8:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
 80038fc:	822f      	strh	r7, [r5, #16]
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 80038fe:	f8d5 701a 	ldr.w	r7, [r5, #26]
 8003902:	f8c5 701e 	str.w	r7, [r5, #30]
		pxIPHeader->ulSourceIPAddress      = *ipLOCAL_IP_ADDRESS_POINTER;
 8003906:	6952      	ldr	r2, [r2, #20]
 8003908:	f8c5 201a 	str.w	r2, [r5, #26]
		pxIPHeader->ucTimeToLive           = ipconfigUDP_TIME_TO_LIVE;
 800390c:	f885 e016 	strb.w	lr, [r5, #22]
		pxIPHeader->usIdentification       = FreeRTOS_htons( usPacketIdentifier );
 8003910:	f8df e080 	ldr.w	lr, [pc, #128]	; 8003994 <prvParseDNSReply+0x354>
 8003914:	f8be 2000 	ldrh.w	r2, [lr]
 8003918:	0a17      	lsrs	r7, r2, #8
 800391a:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
 800391e:	826f      	strh	r7, [r5, #18]
		usPacketIdentifier++;
 8003920:	3201      	adds	r2, #1
 8003922:	f8ae 2000 	strh.w	r2, [lr]
		pxUDPHeader->usLength              = FreeRTOS_htons( lNetLength + ipSIZE_OF_UDP_HEADER );
 8003926:	3318      	adds	r3, #24
 8003928:	f106 0208 	add.w	r2, r6, #8
 800392c:	0a12      	lsrs	r2, r2, #8
 800392e:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8003932:	84ea      	strh	r2, [r5, #38]	; 0x26
		vFlip_16( pxUDPPacket->xUDPHeader.usSourcePort, pxUDPPacket->xUDPHeader.usDestinationPort );
 8003934:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
 8003936:	8caa      	ldrh	r2, [r5, #36]	; 0x24
 8003938:	846a      	strh	r2, [r5, #34]	; 0x22
 800393a:	84ab      	strh	r3, [r5, #36]	; 0x24
		pxNetworkBuffer->xDataLength = ( size_t ) ( lNetLength + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER + ipSIZE_OF_ETH_HEADER );
 800393c:	362a      	adds	r6, #42	; 0x2a
 800393e:	61c6      	str	r6, [r0, #28]
		vReturnEthernetFrame( pxNetworkBuffer, pdFALSE );
 8003940:	f000 fbe8 	bl	8004114 <vReturnEthernetFrame>
					if( pxNewBuffer != NULL )
 8003944:	b154      	cbz	r4, 800395c <prvParseDNSReply+0x31c>
						vReleaseNetworkBufferAndDescriptor( pxNewBuffer );
 8003946:	4620      	mov	r0, r4
 8003948:	f004 fa8e 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
uint32_t ulIPAddress = 0UL;
 800394c:	2000      	movs	r0, #0
 800394e:	e687      	b.n	8003660 <prvParseDNSReply+0x20>
 8003950:	2000      	movs	r0, #0
 8003952:	e685      	b.n	8003660 <prvParseDNSReply+0x20>
 8003954:	2000      	movs	r0, #0
 8003956:	e683      	b.n	8003660 <prvParseDNSReply+0x20>
 8003958:	2000      	movs	r0, #0
 800395a:	e681      	b.n	8003660 <prvParseDNSReply+0x20>
 800395c:	2000      	movs	r0, #0
	return ulIPAddress;
 800395e:	e67f      	b.n	8003660 <prvParseDNSReply+0x20>
		if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8003960:	782b      	ldrb	r3, [r5, #0]
 8003962:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8003966:	2bc0      	cmp	r3, #192	; 0xc0
 8003968:	f43f aeb1 	beq.w	80036ce <prvParseDNSReply+0x8e>
 800396c:	462b      	mov	r3, r5
 800396e:	46ca      	mov	sl, r9
 8003970:	e6c0      	b.n	80036f4 <prvParseDNSReply+0xb4>
uint32_t ulIPAddress = 0UL;
 8003972:	2000      	movs	r0, #0
 8003974:	e674      	b.n	8003660 <prvParseDNSReply+0x20>
 8003976:	bf00      	nop
 8003978:	20000444 	.word	0x20000444
 800397c:	20000448 	.word	0x20000448
 8003980:	200004a4 	.word	0x200004a4
 8003984:	20000430 	.word	0x20000430
 8003988:	20000438 	.word	0x20000438
 800398c:	0800c73c 	.word	0x0800c73c
 8003990:	20000010 	.word	0x20000010
 8003994:	200004ac 	.word	0x200004ac

08003998 <FreeRTOS_dnslookup>:
	{
 8003998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 800399a:	4b10      	ldr	r3, [pc, #64]	; (80039dc <FreeRTOS_dnslookup+0x44>)
 800399c:	791b      	ldrb	r3, [r3, #4]
 800399e:	b1d3      	cbz	r3, 80039d6 <FreeRTOS_dnslookup+0x3e>
 80039a0:	4606      	mov	r6, r0
 80039a2:	4d0f      	ldr	r5, [pc, #60]	; (80039e0 <FreeRTOS_dnslookup+0x48>)
 80039a4:	2400      	movs	r4, #0
			if( strncmp( xDNSCache[ x ].pcName, pcName, sizeof( xDNSCache[ x ].pcName ) ) == 0 )
 80039a6:	2710      	movs	r7, #16
 80039a8:	463a      	mov	r2, r7
 80039aa:	4631      	mov	r1, r6
 80039ac:	4628      	mov	r0, r5
 80039ae:	f008 fb9d 	bl	800c0ec <strncmp>
 80039b2:	b140      	cbz	r0, 80039c6 <FreeRTOS_dnslookup+0x2e>
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 80039b4:	3401      	adds	r4, #1
 80039b6:	2c04      	cmp	r4, #4
 80039b8:	d00b      	beq.n	80039d2 <FreeRTOS_dnslookup+0x3a>
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 80039ba:	f815 3f18 	ldrb.w	r3, [r5, #24]!
 80039be:	2b00      	cmp	r3, #0
 80039c0:	d1f2      	bne.n	80039a8 <FreeRTOS_dnslookup+0x10>
				*pulIP = 0;
 80039c2:	2000      	movs	r0, #0
	}
 80039c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					*pulIP = xDNSCache[ x ].ulIPAddress;
 80039c6:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80039ca:	4b04      	ldr	r3, [pc, #16]	; (80039dc <FreeRTOS_dnslookup+0x44>)
 80039cc:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 80039d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				*pulIP = 0;
 80039d2:	2000      	movs	r0, #0
 80039d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80039d6:	2000      	movs	r0, #0
 80039d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80039da:	bf00      	nop
 80039dc:	20000444 	.word	0x20000444
 80039e0:	20000448 	.word	0x20000448

080039e4 <vDNSInitialise>:
	{
 80039e4:	b508      	push	{r3, lr}
		vListInitialise( &xCallbackList );
 80039e6:	4802      	ldr	r0, [pc, #8]	; (80039f0 <vDNSInitialise+0xc>)
 80039e8:	f004 fefa 	bl	80087e0 <vListInitialise>
 80039ec:	bd08      	pop	{r3, pc}
 80039ee:	bf00      	nop
 80039f0:	20000430 	.word	0x20000430

080039f4 <vDNSCheckCallBack>:
	{
 80039f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80039f8:	4606      	mov	r6, r0
		vTaskSuspendAll();
 80039fa:	f005 ffd9 	bl	80099b0 <vTaskSuspendAll>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 80039fe:	4b1c      	ldr	r3, [pc, #112]	; (8003a70 <vDNSCheckCallBack+0x7c>)
 8003a00:	68dd      	ldr	r5, [r3, #12]
 8003a02:	3308      	adds	r3, #8
 8003a04:	429d      	cmp	r5, r3
 8003a06:	d027      	beq.n	8003a58 <vDNSCheckCallBack+0x64>
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 8003a08:	f04f 0800 	mov.w	r8, #0
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8003a0c:	461f      	mov	r7, r3
 8003a0e:	e008      	b.n	8003a22 <vDNSCheckCallBack+0x2e>
					uxListRemove( &pxCallback->xListItem );
 8003a10:	f104 0014 	add.w	r0, r4, #20
 8003a14:	f004 ff18 	bl	8008848 <uxListRemove>
					vPortFree( pxCallback );
 8003a18:	4620      	mov	r0, r4
 8003a1a:	f005 f95b 	bl	8008cd4 <vPortFree>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8003a1e:	42bd      	cmp	r5, r7
 8003a20:	d01a      	beq.n	8003a58 <vDNSCheckCallBack+0x64>
				DNSCallback_t *pxCallback = ( DNSCallback_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8003a22:	68ec      	ldr	r4, [r5, #12]
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 8003a24:	686d      	ldr	r5, [r5, #4]
				if( ( pvSearchID != NULL ) && ( pvSearchID == pxCallback->pvSearchID ) )
 8003a26:	b116      	cbz	r6, 8003a2e <vDNSCheckCallBack+0x3a>
 8003a28:	6923      	ldr	r3, [r4, #16]
 8003a2a:	429e      	cmp	r6, r3
 8003a2c:	d0f0      	beq.n	8003a10 <vDNSCheckCallBack+0x1c>
				else if( xTaskCheckForTimeOut( &pxCallback->xTimeoutState, &pxCallback->xRemaningTime ) != pdFALSE )
 8003a2e:	4621      	mov	r1, r4
 8003a30:	f104 0008 	add.w	r0, r4, #8
 8003a34:	f006 face 	bl	8009fd4 <xTaskCheckForTimeOut>
 8003a38:	2800      	cmp	r0, #0
 8003a3a:	d0f0      	beq.n	8003a1e <vDNSCheckCallBack+0x2a>
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 8003a3c:	6863      	ldr	r3, [r4, #4]
 8003a3e:	4642      	mov	r2, r8
 8003a40:	6921      	ldr	r1, [r4, #16]
 8003a42:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8003a46:	4798      	blx	r3
					uxListRemove( &pxCallback->xListItem );
 8003a48:	f104 0014 	add.w	r0, r4, #20
 8003a4c:	f004 fefc 	bl	8008848 <uxListRemove>
					vPortFree( ( void * ) pxCallback );
 8003a50:	4620      	mov	r0, r4
 8003a52:	f005 f93f 	bl	8008cd4 <vPortFree>
 8003a56:	e7e2      	b.n	8003a1e <vDNSCheckCallBack+0x2a>
		xTaskResumeAll();
 8003a58:	f006 f884 	bl	8009b64 <xTaskResumeAll>
		if( listLIST_IS_EMPTY( &xCallbackList ) )
 8003a5c:	4b04      	ldr	r3, [pc, #16]	; (8003a70 <vDNSCheckCallBack+0x7c>)
 8003a5e:	681b      	ldr	r3, [r3, #0]
 8003a60:	b10b      	cbz	r3, 8003a66 <vDNSCheckCallBack+0x72>
 8003a62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			vIPSetDnsTimerEnableState( pdFALSE );
 8003a66:	2000      	movs	r0, #0
 8003a68:	f000 fdb4 	bl	80045d4 <vIPSetDnsTimerEnableState>
	}
 8003a6c:	e7f9      	b.n	8003a62 <vDNSCheckCallBack+0x6e>
 8003a6e:	bf00      	nop
 8003a70:	20000430 	.word	0x20000430

08003a74 <FreeRTOS_gethostbyname_a>:
{
 8003a74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003a78:	b08b      	sub	sp, #44	; 0x2c
 8003a7a:	4606      	mov	r6, r0
 8003a7c:	460d      	mov	r5, r1
 8003a7e:	4617      	mov	r7, r2
 8003a80:	4699      	mov	r9, r3
TickType_t xIdentifier = ( TickType_t )usIdentifier++;
 8003a82:	4b93      	ldr	r3, [pc, #588]	; (8003cd0 <FreeRTOS_gethostbyname_a+0x25c>)
 8003a84:	f8b3 8000 	ldrh.w	r8, [r3]
 8003a88:	f108 0201 	add.w	r2, r8, #1
 8003a8c:	801a      	strh	r2, [r3, #0]
 8003a8e:	f8cd 800c 	str.w	r8, [sp, #12]
		ulIPAddress = FreeRTOS_dnslookup( pcHostName );
 8003a92:	f7ff ff81 	bl	8003998 <FreeRTOS_dnslookup>
 8003a96:	4604      	mov	r4, r0
		if( pCallback != NULL )
 8003a98:	2d00      	cmp	r5, #0
 8003a9a:	d048      	beq.n	8003b2e <FreeRTOS_gethostbyname_a+0xba>
			if( ulIPAddress == 0UL )
 8003a9c:	2800      	cmp	r0, #0
 8003a9e:	d13e      	bne.n	8003b1e <FreeRTOS_gethostbyname_a+0xaa>
		size_t lLength = strlen( pcHostName );
 8003aa0:	4630      	mov	r0, r6
 8003aa2:	f7fc fb95 	bl	80001d0 <strlen>
		DNSCallback_t *pxCallback = ( DNSCallback_t * )pvPortMalloc( sizeof( *pxCallback ) + lLength );
 8003aa6:	302c      	adds	r0, #44	; 0x2c
 8003aa8:	f005 f8ae 	bl	8008c08 <pvPortMalloc>
		if( pxCallback != NULL )
 8003aac:	4604      	mov	r4, r0
 8003aae:	b1c8      	cbz	r0, 8003ae4 <FreeRTOS_gethostbyname_a+0x70>
			if( listLIST_IS_EMPTY( &xCallbackList ) )
 8003ab0:	4b88      	ldr	r3, [pc, #544]	; (8003cd4 <FreeRTOS_gethostbyname_a+0x260>)
 8003ab2:	681b      	ldr	r3, [r3, #0]
 8003ab4:	b353      	cbz	r3, 8003b0c <FreeRTOS_gethostbyname_a+0x98>
			strcpy( pxCallback->pcName, pcHostName );
 8003ab6:	4631      	mov	r1, r6
 8003ab8:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8003abc:	f008 fafa 	bl	800c0b4 <strcpy>
			pxCallback->pCallbackFunction = pCallbackFunction;
 8003ac0:	6065      	str	r5, [r4, #4]
			pxCallback->pvSearchID = pvSearchID;
 8003ac2:	6127      	str	r7, [r4, #16]
			pxCallback->xRemaningTime = xTimeout;
 8003ac4:	4620      	mov	r0, r4
 8003ac6:	f840 9b08 	str.w	r9, [r0], #8
			vTaskSetTimeOutState( &pxCallback->xTimeoutState );
 8003aca:	f006 fa6d 	bl	8009fa8 <vTaskSetTimeOutState>
			listSET_LIST_ITEM_OWNER( &( pxCallback->xListItem ), ( void* ) pxCallback );
 8003ace:	6224      	str	r4, [r4, #32]
			listSET_LIST_ITEM_VALUE( &( pxCallback->xListItem ), xIdentifier );
 8003ad0:	f844 8f14 	str.w	r8, [r4, #20]!
			vTaskSuspendAll();
 8003ad4:	f005 ff6c 	bl	80099b0 <vTaskSuspendAll>
				vListInsertEnd( &xCallbackList, &pxCallback->xListItem );
 8003ad8:	4621      	mov	r1, r4
 8003ada:	487e      	ldr	r0, [pc, #504]	; (8003cd4 <FreeRTOS_gethostbyname_a+0x260>)
 8003adc:	f004 fe8e 	bl	80087fc <vListInsertEnd>
			xTaskResumeAll();
 8003ae0:	f006 f840 	bl	8009b64 <xTaskResumeAll>
TickType_t xReadTimeOut_ms = 1200U;
 8003ae4:	2300      	movs	r3, #0
 8003ae6:	9304      	str	r3, [sp, #16]
uint32_t ulIPAddress = 0UL;
 8003ae8:	2300      	movs	r3, #0
 8003aea:	9305      	str	r3, [sp, #20]
TickType_t xWriteTimeOut_ms = 100U;
 8003aec:	2364      	movs	r3, #100	; 0x64
 8003aee:	9306      	str	r3, [sp, #24]
		for( pucPtr = pcHostName; *pucPtr; pucPtr++ )
 8003af0:	7833      	ldrb	r3, [r6, #0]
 8003af2:	2b00      	cmp	r3, #0
 8003af4:	d05e      	beq.n	8003bb4 <FreeRTOS_gethostbyname_a+0x140>
			if( *pucPtr == '.' )
 8003af6:	2b2e      	cmp	r3, #46	; 0x2e
 8003af8:	d05f      	beq.n	8003bba <FreeRTOS_gethostbyname_a+0x146>
 8003afa:	4632      	mov	r2, r6
		for( pucPtr = pcHostName; *pucPtr; pucPtr++ )
 8003afc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003b00:	b1d3      	cbz	r3, 8003b38 <FreeRTOS_gethostbyname_a+0xc4>
			if( *pucPtr == '.' )
 8003b02:	2b2e      	cmp	r3, #46	; 0x2e
 8003b04:	d1fa      	bne.n	8003afc <FreeRTOS_gethostbyname_a+0x88>
				bHasDot = pdTRUE;
 8003b06:	f04f 0b01 	mov.w	fp, #1
 8003b0a:	e017      	b.n	8003b3c <FreeRTOS_gethostbyname_a+0xc8>
				vIPReloadDNSTimer( FreeRTOS_min_uint32( 1000U, xTimeout ) );
 8003b0c:	4648      	mov	r0, r9
 8003b0e:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 8003b12:	bf28      	it	cs
 8003b14:	f44f 707a 	movcs.w	r0, #1000	; 0x3e8
 8003b18:	f000 fd6c 	bl	80045f4 <vIPReloadDNSTimer>
 8003b1c:	e7cb      	b.n	8003ab6 <FreeRTOS_gethostbyname_a+0x42>
				pCallback( pcHostName, pvSearchID, ulIPAddress );
 8003b1e:	4602      	mov	r2, r0
 8003b20:	4639      	mov	r1, r7
 8003b22:	4630      	mov	r0, r6
 8003b24:	47a8      	blx	r5
}
 8003b26:	4620      	mov	r0, r4
 8003b28:	b00b      	add	sp, #44	; 0x2c
 8003b2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if( ulIPAddress == 0UL)
 8003b2e:	2800      	cmp	r0, #0
 8003b30:	d1f9      	bne.n	8003b26 <FreeRTOS_gethostbyname_a+0xb2>
TickType_t xReadTimeOut_ms = 1200U;
 8003b32:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8003b36:	e7d6      	b.n	8003ae6 <FreeRTOS_gethostbyname_a+0x72>
	BaseType_t bHasDot = pdFALSE;
 8003b38:	f04f 0b00 	mov.w	fp, #0
	xExpectedPayloadLength = sizeof( DNSMessage_t ) + strlen( pcHostName ) + sizeof( uint16_t ) + sizeof( uint16_t ) + 2u;
 8003b3c:	4630      	mov	r0, r6
 8003b3e:	f7fc fb47 	bl	80001d0 <strlen>
 8003b42:	f100 0312 	add.w	r3, r0, #18
 8003b46:	9302      	str	r3, [sp, #8]
TickType_t xTimeoutTime = pdMS_TO_TICKS( 200 );
 8003b48:	23c8      	movs	r3, #200	; 0xc8
 8003b4a:	9307      	str	r3, [sp, #28]
	xSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 8003b4c:	2211      	movs	r2, #17
 8003b4e:	2102      	movs	r1, #2
 8003b50:	4608      	mov	r0, r1
 8003b52:	f000 fdd3 	bl	80046fc <FreeRTOS_socket>
 8003b56:	4b60      	ldr	r3, [pc, #384]	; (8003cd8 <FreeRTOS_gethostbyname_a+0x264>)
 8003b58:	6018      	str	r0, [r3, #0]
	xAddress.sin_port = 0u;
 8003b5a:	2300      	movs	r3, #0
 8003b5c:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	xReturn = FreeRTOS_bind( xSocket, &xAddress, sizeof( xAddress ) );
 8003b60:	2208      	movs	r2, #8
 8003b62:	a908      	add	r1, sp, #32
 8003b64:	f000 fef1 	bl	800494a <FreeRTOS_bind>
	if( xReturn != 0 )
 8003b68:	bb50      	cbnz	r0, 8003bc0 <FreeRTOS_gethostbyname_a+0x14c>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVTIMEO, ( void * ) &xTimeoutTime, sizeof( TickType_t ) );
 8003b6a:	4c5b      	ldr	r4, [pc, #364]	; (8003cd8 <FreeRTOS_gethostbyname_a+0x264>)
 8003b6c:	2504      	movs	r5, #4
 8003b6e:	9500      	str	r5, [sp, #0]
 8003b70:	ab07      	add	r3, sp, #28
 8003b72:	2200      	movs	r2, #0
 8003b74:	4611      	mov	r1, r2
 8003b76:	6820      	ldr	r0, [r4, #0]
 8003b78:	f001 fcc6 	bl	8005508 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDTIMEO, ( void * ) &xTimeoutTime, sizeof( TickType_t ) );
 8003b7c:	9500      	str	r5, [sp, #0]
 8003b7e:	ab07      	add	r3, sp, #28
 8003b80:	2201      	movs	r2, #1
 8003b82:	2100      	movs	r1, #0
 8003b84:	6820      	ldr	r0, [r4, #0]
 8003b86:	f001 fcbf 	bl	8005508 <FreeRTOS_setsockopt>
	return xSocket;
 8003b8a:	f8d4 a000 	ldr.w	sl, [r4]
	if( xDNSSocket != NULL )
 8003b8e:	f1ba 0f00 	cmp.w	sl, #0
 8003b92:	d070      	beq.n	8003c76 <FreeRTOS_gethostbyname_a+0x202>
		FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_SNDTIMEO, ( void * ) &xWriteTimeOut_ms, sizeof( TickType_t ) );
 8003b94:	462f      	mov	r7, r5
 8003b96:	9500      	str	r5, [sp, #0]
 8003b98:	ab06      	add	r3, sp, #24
 8003b9a:	2201      	movs	r2, #1
 8003b9c:	2100      	movs	r1, #0
 8003b9e:	4650      	mov	r0, sl
 8003ba0:	f001 fcb2 	bl	8005508 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_RCVTIMEO, ( void * ) &xReadTimeOut_ms,  sizeof( TickType_t ) );
 8003ba4:	9500      	str	r5, [sp, #0]
 8003ba6:	ab04      	add	r3, sp, #16
 8003ba8:	2200      	movs	r2, #0
 8003baa:	4611      	mov	r1, r2
 8003bac:	4650      	mov	r0, sl
 8003bae:	f001 fcab 	bl	8005508 <FreeRTOS_setsockopt>
 8003bb2:	e06e      	b.n	8003c92 <FreeRTOS_gethostbyname_a+0x21e>
	BaseType_t bHasDot = pdFALSE;
 8003bb4:	f04f 0b00 	mov.w	fp, #0
 8003bb8:	e7c0      	b.n	8003b3c <FreeRTOS_gethostbyname_a+0xc8>
				bHasDot = pdTRUE;
 8003bba:	f04f 0b01 	mov.w	fp, #1
 8003bbe:	e7bd      	b.n	8003b3c <FreeRTOS_gethostbyname_a+0xc8>
		FreeRTOS_closesocket( xSocket );
 8003bc0:	4c45      	ldr	r4, [pc, #276]	; (8003cd8 <FreeRTOS_gethostbyname_a+0x264>)
 8003bc2:	6820      	ldr	r0, [r4, #0]
 8003bc4:	f000 fffc 	bl	8004bc0 <FreeRTOS_closesocket>
		xSocket = NULL;
 8003bc8:	2300      	movs	r3, #0
 8003bca:	6023      	str	r3, [r4, #0]
 8003bcc:	e053      	b.n	8003c76 <FreeRTOS_gethostbyname_a+0x202>
		*pucStart = ( uint8_t ) ( ( uint32_t ) pucByte - ( uint32_t ) pucStart );
 8003bce:	1b13      	subs	r3, r2, r4
		( *pucStart )--;
 8003bd0:	3b01      	subs	r3, #1
 8003bd2:	7023      	strb	r3, [r4, #0]
 8003bd4:	4614      	mov	r4, r2
	} while( *pucByte != 0x00 );
 8003bd6:	7813      	ldrb	r3, [r2, #0]
 8003bd8:	b163      	cbz	r3, 8003bf4 <FreeRTOS_gethostbyname_a+0x180>
		pucByte++;
 8003bda:	1c62      	adds	r2, r4, #1
		while( ( *pucByte != 0x00 ) && ( *pucByte != '.' ) )
 8003bdc:	7863      	ldrb	r3, [r4, #1]
 8003bde:	2b00      	cmp	r3, #0
 8003be0:	d0f5      	beq.n	8003bce <FreeRTOS_gethostbyname_a+0x15a>
 8003be2:	2b2e      	cmp	r3, #46	; 0x2e
 8003be4:	d0f3      	beq.n	8003bce <FreeRTOS_gethostbyname_a+0x15a>
 8003be6:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003bea:	2b00      	cmp	r3, #0
 8003bec:	d0ef      	beq.n	8003bce <FreeRTOS_gethostbyname_a+0x15a>
 8003bee:	2b2e      	cmp	r3, #46	; 0x2e
 8003bf0:	d1f9      	bne.n	8003be6 <FreeRTOS_gethostbyname_a+0x172>
 8003bf2:	e7ec      	b.n	8003bce <FreeRTOS_gethostbyname_a+0x15a>
	vSetField16( pxTail, DNSTail_t, usType, dnsTYPE_A_HOST );	/* Type A: host */
 8003bf4:	2000      	movs	r0, #0
 8003bf6:	7050      	strb	r0, [r2, #1]
 8003bf8:	2301      	movs	r3, #1
 8003bfa:	7093      	strb	r3, [r2, #2]
	vSetField16( pxTail, DNSTail_t, usClass, dnsCLASS_IN );	/* 1: Class IN */
 8003bfc:	70d0      	strb	r0, [r2, #3]
 8003bfe:	7113      	strb	r3, [r2, #4]
	return ( ( uint32_t ) pucByte - ( uint32_t ) pucUDPPayloadBuffer + 1 ) + sizeof( *pxTail );
 8003c00:	f1c5 0405 	rsb	r4, r5, #5
 8003c04:	4414      	add	r4, r2
				FreeRTOS_GetAddressConfiguration( NULL, NULL, NULL, &ulIPAddress );
 8003c06:	ab05      	add	r3, sp, #20
 8003c08:	4602      	mov	r2, r0
 8003c0a:	4601      	mov	r1, r0
 8003c0c:	f000 f99c 	bl	8003f48 <FreeRTOS_GetAddressConfiguration>
				if( bHasDot == pdFALSE )
 8003c10:	f1bb 0f00 	cmp.w	fp, #0
 8003c14:	d131      	bne.n	8003c7a <FreeRTOS_gethostbyname_a+0x206>
					( ( DNSMessage_t * ) pucUDPPayloadBuffer) -> usFlags = 0;
 8003c16:	9b07      	ldr	r3, [sp, #28]
 8003c18:	2200      	movs	r2, #0
 8003c1a:	709a      	strb	r2, [r3, #2]
 8003c1c:	70da      	strb	r2, [r3, #3]
					xAddress.sin_addr = ipLLMNR_IP_ADDR;	/* Is in network byte order. */
 8003c1e:	4b2f      	ldr	r3, [pc, #188]	; (8003cdc <FreeRTOS_gethostbyname_a+0x268>)
 8003c20:	9309      	str	r3, [sp, #36]	; 0x24
					xAddress.sin_port = FreeRTOS_ntohs( ipLLMNR_PORT );
 8003c22:	f64e 3314 	movw	r3, #60180	; 0xeb14
 8003c26:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
				ulIPAddress = 0UL;
 8003c2a:	2300      	movs	r3, #0
 8003c2c:	9305      	str	r3, [sp, #20]
				if( FreeRTOS_sendto( xDNSSocket, pucUDPPayloadBuffer, xPayloadLength, FREERTOS_ZERO_COPY, &xAddress, sizeof( xAddress ) ) != 0 )
 8003c2e:	2308      	movs	r3, #8
 8003c30:	9301      	str	r3, [sp, #4]
 8003c32:	ab08      	add	r3, sp, #32
 8003c34:	9300      	str	r3, [sp, #0]
 8003c36:	2301      	movs	r3, #1
 8003c38:	4622      	mov	r2, r4
 8003c3a:	9907      	ldr	r1, [sp, #28]
 8003c3c:	4650      	mov	r0, sl
 8003c3e:	f000 febb 	bl	80049b8 <FreeRTOS_sendto>
 8003c42:	b308      	cbz	r0, 8003c88 <FreeRTOS_gethostbyname_a+0x214>
					lBytes = FreeRTOS_recvfrom( xDNSSocket, &pucUDPPayloadBuffer, 0, FREERTOS_ZERO_COPY, &xAddress, &ulAddressLength );
 8003c44:	4b26      	ldr	r3, [pc, #152]	; (8003ce0 <FreeRTOS_gethostbyname_a+0x26c>)
 8003c46:	9301      	str	r3, [sp, #4]
 8003c48:	ab08      	add	r3, sp, #32
 8003c4a:	9300      	str	r3, [sp, #0]
 8003c4c:	2301      	movs	r3, #1
 8003c4e:	2200      	movs	r2, #0
 8003c50:	a907      	add	r1, sp, #28
 8003c52:	4650      	mov	r0, sl
 8003c54:	f000 fdea 	bl	800482c <FreeRTOS_recvfrom>
					if( lBytes > 0 )
 8003c58:	2800      	cmp	r0, #0
 8003c5a:	dd18      	ble.n	8003c8e <FreeRTOS_gethostbyname_a+0x21a>
						ulIPAddress = prvParseDNSReply( pucUDPPayloadBuffer, xIdentifier );
 8003c5c:	9903      	ldr	r1, [sp, #12]
 8003c5e:	9807      	ldr	r0, [sp, #28]
 8003c60:	f7ff fcee 	bl	8003640 <prvParseDNSReply>
 8003c64:	9005      	str	r0, [sp, #20]
						FreeRTOS_ReleaseUDPPayloadBuffer( ( void * ) pucUDPPayloadBuffer );
 8003c66:	9807      	ldr	r0, [sp, #28]
 8003c68:	f000 f8b1 	bl	8003dce <FreeRTOS_ReleaseUDPPayloadBuffer>
						if( ulIPAddress != 0UL )
 8003c6c:	9b05      	ldr	r3, [sp, #20]
 8003c6e:	b173      	cbz	r3, 8003c8e <FreeRTOS_gethostbyname_a+0x21a>
		FreeRTOS_closesocket( xDNSSocket );
 8003c70:	4650      	mov	r0, sl
 8003c72:	f000 ffa5 	bl	8004bc0 <FreeRTOS_closesocket>
	return ulIPAddress;
 8003c76:	9c05      	ldr	r4, [sp, #20]
	return ulIPAddress;
 8003c78:	e755      	b.n	8003b26 <FreeRTOS_gethostbyname_a+0xb2>
					xAddress.sin_addr = ulIPAddress;
 8003c7a:	9b05      	ldr	r3, [sp, #20]
 8003c7c:	9309      	str	r3, [sp, #36]	; 0x24
					xAddress.sin_port = dnsDNS_PORT;
 8003c7e:	f44f 5354 	mov.w	r3, #13568	; 0x3500
 8003c82:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
 8003c86:	e7d0      	b.n	8003c2a <FreeRTOS_gethostbyname_a+0x1b6>
					FreeRTOS_ReleaseUDPPayloadBuffer( ( void * ) pucUDPPayloadBuffer );
 8003c88:	9807      	ldr	r0, [sp, #28]
 8003c8a:	f000 f8a0 	bl	8003dce <FreeRTOS_ReleaseUDPPayloadBuffer>
		for( xAttempt = 0; xAttempt < ipconfigDNS_REQUEST_ATTEMPTS; xAttempt++ )
 8003c8e:	3f01      	subs	r7, #1
 8003c90:	d0ee      	beq.n	8003c70 <FreeRTOS_gethostbyname_a+0x1fc>
			pucUDPPayloadBuffer = ( uint8_t * ) FreeRTOS_GetUDPPayloadBuffer( xExpectedPayloadLength, portMAX_DELAY );
 8003c92:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003c96:	9802      	ldr	r0, [sp, #8]
 8003c98:	f000 f86a 	bl	8003d70 <FreeRTOS_GetUDPPayloadBuffer>
 8003c9c:	4605      	mov	r5, r0
 8003c9e:	9007      	str	r0, [sp, #28]
			if( pucUDPPayloadBuffer != NULL )
 8003ca0:	2800      	cmp	r0, #0
 8003ca2:	d0f4      	beq.n	8003c8e <FreeRTOS_gethostbyname_a+0x21a>
	memcpy( ( void * ) pucUDPPayloadBuffer, ( void * ) &xDefaultPartDNSHeader, sizeof( xDefaultPartDNSHeader ) );
 8003ca4:	4b0f      	ldr	r3, [pc, #60]	; (8003ce4 <FreeRTOS_gethostbyname_a+0x270>)
 8003ca6:	cb07      	ldmia	r3!, {r0, r1, r2}
 8003ca8:	6028      	str	r0, [r5, #0]
 8003caa:	6069      	str	r1, [r5, #4]
 8003cac:	60aa      	str	r2, [r5, #8]
	pxDNSMessageHeader->usIdentifier = ( uint16_t ) xIdentifier;
 8003cae:	462c      	mov	r4, r5
 8003cb0:	f824 8b0c 	strh.w	r8, [r4], #12
	pucByte = pucStart + 1;
 8003cb4:	f105 090d 	add.w	r9, r5, #13
	strcpy( ( char * ) pucByte, pcHostName );
 8003cb8:	4631      	mov	r1, r6
 8003cba:	4648      	mov	r0, r9
 8003cbc:	f008 f9fa 	bl	800c0b4 <strcpy>
	pucByte += strlen( pcHostName );
 8003cc0:	4630      	mov	r0, r6
 8003cc2:	f7fc fa85 	bl	80001d0 <strlen>
	*pucByte = 0x00u;
 8003cc6:	2300      	movs	r3, #0
 8003cc8:	f809 3000 	strb.w	r3, [r9, r0]
 8003ccc:	e785      	b.n	8003bda <FreeRTOS_gethostbyname_a+0x166>
 8003cce:	bf00      	nop
 8003cd0:	2000042c 	.word	0x2000042c
 8003cd4:	20000430 	.word	0x20000430
 8003cd8:	200004a8 	.word	0x200004a8
 8003cdc:	fc0000e0 	.word	0xfc0000e0
 8003ce0:	20000428 	.word	0x20000428
 8003ce4:	0800c440 	.word	0x0800c440

08003ce8 <FreeRTOS_gethostbyname>:
	{
 8003ce8:	b508      	push	{r3, lr}
		return FreeRTOS_gethostbyname_a( pcHostName, ( FOnDNSEvent ) NULL, ( void* )NULL, 0 );
 8003cea:	2300      	movs	r3, #0
 8003cec:	461a      	mov	r2, r3
 8003cee:	4619      	mov	r1, r3
 8003cf0:	f7ff fec0 	bl	8003a74 <FreeRTOS_gethostbyname_a>
	}
 8003cf4:	bd08      	pop	{r3, pc}

08003cf6 <ulDNSHandlePacket>:
{
 8003cf6:	b508      	push	{r3, lr}
	prvParseDNSReply( pucUDPPayloadBuffer, ( uint32_t ) pxDNSMessageHeader->usIdentifier );
 8003cf8:	6980      	ldr	r0, [r0, #24]
 8003cfa:	f830 1f2a 	ldrh.w	r1, [r0, #42]!
 8003cfe:	f7ff fc9f 	bl	8003640 <prvParseDNSReply>
}
 8003d02:	2000      	movs	r0, #0
 8003d04:	bd08      	pop	{r3, pc}

08003d06 <prvIPTimerCheck>:
	prvIPTimerStart( pxTimer, xTime );
}
/*-----------------------------------------------------------*/

static BaseType_t prvIPTimerCheck( IPTimer_t *pxTimer )
{
 8003d06:	b538      	push	{r3, r4, r5, lr}
BaseType_t xReturn;

	if( pxTimer->bActive == pdFALSE_UNSIGNED )
 8003d08:	7803      	ldrb	r3, [r0, #0]
 8003d0a:	f013 0f01 	tst.w	r3, #1
 8003d0e:	d01e      	beq.n	8003d4e <prvIPTimerCheck+0x48>
 8003d10:	4604      	mov	r4, r0
	}
	else
	{
		/* The timer might have set the bExpired flag already, if not, check the
		value of xTimeOut against ulRemainingTime. */
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
 8003d12:	f013 0f02 	tst.w	r3, #2
 8003d16:	d105      	bne.n	8003d24 <prvIPTimerCheck+0x1e>
			( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE ) )
 8003d18:	f100 010c 	add.w	r1, r0, #12
 8003d1c:	3004      	adds	r0, #4
 8003d1e:	f006 f959 	bl	8009fd4 <xTaskCheckForTimeOut>
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
 8003d22:	b1b0      	cbz	r0, 8003d52 <prvIPTimerCheck+0x4c>
		{
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
 8003d24:	6925      	ldr	r5, [r4, #16]
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 8003d26:	1d20      	adds	r0, r4, #4
 8003d28:	f006 f93e 	bl	8009fa8 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8003d2c:	60e5      	str	r5, [r4, #12]
	if( xTime == ( TickType_t ) 0 )
 8003d2e:	b14d      	cbz	r5, 8003d44 <prvIPTimerCheck+0x3e>
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8003d30:	7823      	ldrb	r3, [r4, #0]
 8003d32:	f36f 0341 	bfc	r3, #1, #1
 8003d36:	7023      	strb	r3, [r4, #0]
	pxTimer->bActive = pdTRUE_UNSIGNED;
 8003d38:	7823      	ldrb	r3, [r4, #0]
 8003d3a:	f043 0301 	orr.w	r3, r3, #1
 8003d3e:	7023      	strb	r3, [r4, #0]
			xReturn = pdTRUE;
 8003d40:	2001      	movs	r0, #1
 8003d42:	bd38      	pop	{r3, r4, r5, pc}
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 8003d44:	7823      	ldrb	r3, [r4, #0]
 8003d46:	f043 0302 	orr.w	r3, r3, #2
 8003d4a:	7023      	strb	r3, [r4, #0]
 8003d4c:	e7f4      	b.n	8003d38 <prvIPTimerCheck+0x32>
		xReturn = pdFALSE;
 8003d4e:	2000      	movs	r0, #0
 8003d50:	bd38      	pop	{r3, r4, r5, pc}
		}
		else
		{
			xReturn = pdFALSE;
 8003d52:	2000      	movs	r0, #0
		}
	}

	return xReturn;
}
 8003d54:	bd38      	pop	{r3, r4, r5, pc}
	...

08003d58 <xIsCallingFromIPTask>:
{
 8003d58:	b508      	push	{r3, lr}
	if( xTaskGetCurrentTaskHandle() == xIPTaskHandle )
 8003d5a:	f006 fa57 	bl	800a20c <xTaskGetCurrentTaskHandle>
 8003d5e:	4b03      	ldr	r3, [pc, #12]	; (8003d6c <xIsCallingFromIPTask+0x14>)
 8003d60:	681b      	ldr	r3, [r3, #0]
}
 8003d62:	4283      	cmp	r3, r0
 8003d64:	bf14      	ite	ne
 8003d66:	2000      	movne	r0, #0
 8003d68:	2001      	moveq	r0, #1
 8003d6a:	bd08      	pop	{r3, pc}
 8003d6c:	200004f0 	.word	0x200004f0

08003d70 <FreeRTOS_GetUDPPayloadBuffer>:
	return xHigherPriorityTaskWoken;
}
/*-----------------------------------------------------------*/

void *FreeRTOS_GetUDPPayloadBuffer( size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks )
{
 8003d70:	b508      	push	{r3, lr}
	{
		xBlockTimeTicks = ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS;
	}

	/* Obtain a network buffer with the required amount of storage. */
	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( UDPPacket_t ) + xRequestedSizeBytes, xBlockTimeTicks );
 8003d72:	f241 3388 	movw	r3, #5000	; 0x1388
 8003d76:	4299      	cmp	r1, r3
 8003d78:	bf28      	it	cs
 8003d7a:	4619      	movcs	r1, r3
 8003d7c:	302a      	adds	r0, #42	; 0x2a
 8003d7e:	f004 f899 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>

	if( pxNetworkBuffer != NULL )
 8003d82:	b110      	cbz	r0, 8003d8a <FreeRTOS_GetUDPPayloadBuffer+0x1a>
	{
		/* Leave space for the UPD header. */
		pvReturn = ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] );
 8003d84:	6980      	ldr	r0, [r0, #24]
 8003d86:	302a      	adds	r0, #42	; 0x2a
 8003d88:	bd08      	pop	{r3, pc}
	}
	else
	{
		pvReturn = NULL;
 8003d8a:	2000      	movs	r0, #0
	}

	return ( void * ) pvReturn;
}
 8003d8c:	bd08      	pop	{r3, pc}

08003d8e <pxDuplicateNetworkBufferWithDescriptor>:
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxDuplicateNetworkBufferWithDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer,
	BaseType_t xNewLength )
{
 8003d8e:	b538      	push	{r3, r4, r5, lr}
 8003d90:	4605      	mov	r5, r0
 8003d92:	4608      	mov	r0, r1
NetworkBufferDescriptor_t * pxNewBuffer;

	/* This function is only used when 'ipconfigZERO_COPY_TX_DRIVER' is set to 1.
	The transmit routine wants to have ownership of the network buffer
	descriptor, because it will pass the buffer straight to DMA. */
	pxNewBuffer = pxGetNetworkBufferWithDescriptor( ( size_t ) xNewLength, ( TickType_t ) 0 );
 8003d94:	2100      	movs	r1, #0
 8003d96:	f004 f88d 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>

	if( pxNewBuffer != NULL )
 8003d9a:	4604      	mov	r4, r0
 8003d9c:	b150      	cbz	r0, 8003db4 <pxDuplicateNetworkBufferWithDescriptor+0x26>
	{
		pxNewBuffer->ulIPAddress = pxNetworkBuffer->ulIPAddress;
 8003d9e:	696b      	ldr	r3, [r5, #20]
 8003da0:	6143      	str	r3, [r0, #20]
		pxNewBuffer->usPort = pxNetworkBuffer->usPort;
 8003da2:	8c2b      	ldrh	r3, [r5, #32]
 8003da4:	8403      	strh	r3, [r0, #32]
		pxNewBuffer->usBoundPort = pxNetworkBuffer->usBoundPort;
 8003da6:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
 8003da8:	8443      	strh	r3, [r0, #34]	; 0x22
		memcpy( pxNewBuffer->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 8003daa:	69ea      	ldr	r2, [r5, #28]
 8003dac:	69a9      	ldr	r1, [r5, #24]
 8003dae:	6980      	ldr	r0, [r0, #24]
 8003db0:	f008 f953 	bl	800c05a <memcpy>
	}

	return pxNewBuffer;
}
 8003db4:	4620      	mov	r0, r4
 8003db6:	bd38      	pop	{r3, r4, r5, pc}

08003db8 <pxUDPPayloadBuffer_to_NetworkBuffer>:
NetworkBufferDescriptor_t *pxUDPPayloadBuffer_to_NetworkBuffer( void *pvBuffer )
{
uint8_t *pucBuffer;
NetworkBufferDescriptor_t *pxResult;

	if( pvBuffer == NULL )
 8003db8:	b128      	cbz	r0, 8003dc6 <pxUDPPayloadBuffer_to_NetworkBuffer+0xe>
		the network buffer, usually 8 + 2 bytes. */
		pucBuffer -= ( sizeof( UDPPacket_t ) + ipBUFFER_PADDING );

		/* Here a pointer was placed to the network descriptor,
		As a pointer is dereferenced, make sure it is well aligned */
		if( ( ( ( uint32_t ) pucBuffer ) & ( sizeof( pucBuffer ) - 1 ) ) == 0 )
 8003dba:	f010 0f03 	tst.w	r0, #3
 8003dbe:	d104      	bne.n	8003dca <pxUDPPayloadBuffer_to_NetworkBuffer+0x12>
		{
			/* The following statement may trigger a:
			warning: cast increases required alignment of target type [-Wcast-align].
			It has been confirmed though that the alignment is suitable. */
			pxResult = * ( ( NetworkBufferDescriptor_t ** ) pucBuffer );
 8003dc0:	f850 0c34 	ldr.w	r0, [r0, #-52]
 8003dc4:	4770      	bx	lr
		pxResult = NULL;
 8003dc6:	2000      	movs	r0, #0
 8003dc8:	4770      	bx	lr
		}
		else
		{
			pxResult = NULL;
 8003dca:	2000      	movs	r0, #0
		}
	}

	return pxResult;
}
 8003dcc:	4770      	bx	lr

08003dce <FreeRTOS_ReleaseUDPPayloadBuffer>:
/*-----------------------------------------------------------*/

void FreeRTOS_ReleaseUDPPayloadBuffer( void *pvBuffer )
{
 8003dce:	b508      	push	{r3, lr}
	vReleaseNetworkBufferAndDescriptor( pxUDPPayloadBuffer_to_NetworkBuffer( pvBuffer ) );
 8003dd0:	f7ff fff2 	bl	8003db8 <pxUDPPayloadBuffer_to_NetworkBuffer>
 8003dd4:	f004 f848 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
 8003dd8:	bd08      	pop	{r3, pc}
	...

08003ddc <FreeRTOS_IPInit>:
/*_RB_ Should we add an error or assert if the task priorities are set such that the servers won't function as expected? */
/*_HT_ There was a bug in FreeRTOS_TCP_IP.c that only occurred when the applications' priority was too high.
 As that bug has been repaired, there is not an urgent reason to warn.
 It is better though to use the advised priority scheme. */
BaseType_t FreeRTOS_IPInit( const uint8_t ucIPAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucNetMask[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucGatewayAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucDNSServerAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucMACAddress[ ipMAC_ADDRESS_LENGTH_BYTES ] )
{
 8003ddc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003de0:	b083      	sub	sp, #12
 8003de2:	4605      	mov	r5, r0
 8003de4:	460f      	mov	r7, r1
 8003de6:	4691      	mov	r9, r2
 8003de8:	4698      	mov	r8, r3
#endif /* ipconfigDNS_USE_CALLBACKS != 0 */
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
	return xIPTaskInitialised;
 8003dea:	4b4d      	ldr	r3, [pc, #308]	; (8003f20 <FreeRTOS_IPInit+0x144>)
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 8003dec:	681b      	ldr	r3, [r3, #0]
 8003dee:	bb3b      	cbnz	r3, 8003e40 <FreeRTOS_IPInit+0x64>
	configASSERT( xNetworkEventQueue == NULL );
 8003df0:	4b4c      	ldr	r3, [pc, #304]	; (8003f24 <FreeRTOS_IPInit+0x148>)
 8003df2:	681b      	ldr	r3, [r3, #0]
 8003df4:	b123      	cbz	r3, 8003e00 <FreeRTOS_IPInit+0x24>
 8003df6:	f240 31d6 	movw	r1, #982	; 0x3d6
 8003dfa:	484b      	ldr	r0, [pc, #300]	; (8003f28 <FreeRTOS_IPInit+0x14c>)
 8003dfc:	f007 ff86 	bl	800bd0c <vAssertCalled>
	configASSERT( xIPTaskHandle == NULL );
 8003e00:	4b4a      	ldr	r3, [pc, #296]	; (8003f2c <FreeRTOS_IPInit+0x150>)
 8003e02:	681b      	ldr	r3, [r3, #0]
 8003e04:	b123      	cbz	r3, 8003e10 <FreeRTOS_IPInit+0x34>
 8003e06:	f240 31d7 	movw	r1, #983	; 0x3d7
 8003e0a:	4847      	ldr	r0, [pc, #284]	; (8003f28 <FreeRTOS_IPInit+0x14c>)
 8003e0c:	f007 ff7e 	bl	800bd0c <vAssertCalled>
	xNetworkEventQueue = xQueueCreate( ( UBaseType_t ) ipconfigEVENT_QUEUE_LENGTH, ( UBaseType_t ) sizeof( IPStackEvent_t ) );
 8003e10:	2200      	movs	r2, #0
 8003e12:	2108      	movs	r1, #8
 8003e14:	201e      	movs	r0, #30
 8003e16:	f005 f901 	bl	800901c <xQueueGenericCreate>
 8003e1a:	4b42      	ldr	r3, [pc, #264]	; (8003f24 <FreeRTOS_IPInit+0x148>)
 8003e1c:	6018      	str	r0, [r3, #0]
	configASSERT( xNetworkEventQueue );
 8003e1e:	b1a8      	cbz	r0, 8003e4c <FreeRTOS_IPInit+0x70>
			vQueueAddToRegistry( xNetworkEventQueue, "NetEvnt" );
 8003e20:	4943      	ldr	r1, [pc, #268]	; (8003f30 <FreeRTOS_IPInit+0x154>)
 8003e22:	f005 fb31 	bl	8009488 <vQueueAddToRegistry>
		if( xNetworkBuffersInitialise() == pdPASS )
 8003e26:	f003 ffd5 	bl	8007dd4 <xNetworkBuffersInitialise>
 8003e2a:	2801      	cmp	r0, #1
 8003e2c:	d019      	beq.n	8003e62 <FreeRTOS_IPInit+0x86>
			vQueueDelete( xNetworkEventQueue );
 8003e2e:	4c3d      	ldr	r4, [pc, #244]	; (8003f24 <FreeRTOS_IPInit+0x148>)
 8003e30:	6820      	ldr	r0, [r4, #0]
 8003e32:	f005 fb5d 	bl	80094f0 <vQueueDelete>
			xNetworkEventQueue = NULL;
 8003e36:	2000      	movs	r0, #0
 8003e38:	6020      	str	r0, [r4, #0]
}
 8003e3a:	b003      	add	sp, #12
 8003e3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 8003e40:	f240 31d5 	movw	r1, #981	; 0x3d5
 8003e44:	4838      	ldr	r0, [pc, #224]	; (8003f28 <FreeRTOS_IPInit+0x14c>)
 8003e46:	f007 ff61 	bl	800bd0c <vAssertCalled>
 8003e4a:	e7d1      	b.n	8003df0 <FreeRTOS_IPInit+0x14>
	configASSERT( xNetworkEventQueue );
 8003e4c:	f240 31e2 	movw	r1, #994	; 0x3e2
 8003e50:	4835      	ldr	r0, [pc, #212]	; (8003f28 <FreeRTOS_IPInit+0x14c>)
 8003e52:	f007 ff5b 	bl	800bd0c <vAssertCalled>
	if( xNetworkEventQueue != NULL )
 8003e56:	4b33      	ldr	r3, [pc, #204]	; (8003f24 <FreeRTOS_IPInit+0x148>)
 8003e58:	6818      	ldr	r0, [r3, #0]
 8003e5a:	2800      	cmp	r0, #0
 8003e5c:	d1e0      	bne.n	8003e20 <FreeRTOS_IPInit+0x44>
BaseType_t xReturn = pdFALSE;
 8003e5e:	2000      	movs	r0, #0
	return xReturn;
 8003e60:	e7eb      	b.n	8003e3a <FreeRTOS_IPInit+0x5e>
			xNetworkAddressing.ulDefaultIPAddress = FreeRTOS_inet_addr_quick( ucIPAddress[ 0 ], ucIPAddress[ 1 ], ucIPAddress[ 2 ], ucIPAddress[ 3 ] );
 8003e62:	78eb      	ldrb	r3, [r5, #3]
 8003e64:	78ac      	ldrb	r4, [r5, #2]
 8003e66:	0424      	lsls	r4, r4, #16
 8003e68:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
 8003e6c:	782b      	ldrb	r3, [r5, #0]
 8003e6e:	431c      	orrs	r4, r3
 8003e70:	786b      	ldrb	r3, [r5, #1]
 8003e72:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8003e76:	4d2f      	ldr	r5, [pc, #188]	; (8003f34 <FreeRTOS_IPInit+0x158>)
 8003e78:	602c      	str	r4, [r5, #0]
			xNetworkAddressing.ulNetMask = FreeRTOS_inet_addr_quick( ucNetMask[ 0 ], ucNetMask[ 1 ], ucNetMask[ 2 ], ucNetMask[ 3 ] );
 8003e7a:	78fb      	ldrb	r3, [r7, #3]
 8003e7c:	78be      	ldrb	r6, [r7, #2]
 8003e7e:	0436      	lsls	r6, r6, #16
 8003e80:	ea46 6603 	orr.w	r6, r6, r3, lsl #24
 8003e84:	783b      	ldrb	r3, [r7, #0]
 8003e86:	431e      	orrs	r6, r3
 8003e88:	787b      	ldrb	r3, [r7, #1]
 8003e8a:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
 8003e8e:	606e      	str	r6, [r5, #4]
			xNetworkAddressing.ulGatewayAddress = FreeRTOS_inet_addr_quick( ucGatewayAddress[ 0 ], ucGatewayAddress[ 1 ], ucGatewayAddress[ 2 ], ucGatewayAddress[ 3 ] );
 8003e90:	f899 3003 	ldrb.w	r3, [r9, #3]
 8003e94:	f899 7002 	ldrb.w	r7, [r9, #2]
 8003e98:	043f      	lsls	r7, r7, #16
 8003e9a:	ea47 6703 	orr.w	r7, r7, r3, lsl #24
 8003e9e:	f899 3000 	ldrb.w	r3, [r9]
 8003ea2:	431f      	orrs	r7, r3
 8003ea4:	f899 3001 	ldrb.w	r3, [r9, #1]
 8003ea8:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
 8003eac:	60af      	str	r7, [r5, #8]
			xNetworkAddressing.ulDNSServerAddress = FreeRTOS_inet_addr_quick( ucDNSServerAddress[ 0 ], ucDNSServerAddress[ 1 ], ucDNSServerAddress[ 2 ], ucDNSServerAddress[ 3 ] );
 8003eae:	f898 2003 	ldrb.w	r2, [r8, #3]
 8003eb2:	f898 3002 	ldrb.w	r3, [r8, #2]
 8003eb6:	041b      	lsls	r3, r3, #16
 8003eb8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8003ebc:	f898 2000 	ldrb.w	r2, [r8]
 8003ec0:	4313      	orrs	r3, r2
 8003ec2:	f898 2001 	ldrb.w	r2, [r8, #1]
 8003ec6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003eca:	60eb      	str	r3, [r5, #12]
			xNetworkAddressing.ulBroadcastAddress = ( xNetworkAddressing.ulDefaultIPAddress & xNetworkAddressing.ulNetMask ) |  ~xNetworkAddressing.ulNetMask;
 8003ecc:	ea64 0c06 	orn	ip, r4, r6
 8003ed0:	f8c5 c010 	str.w	ip, [r5, #16]
			memcpy( &xDefaultAddressing, &xNetworkAddressing, sizeof( xDefaultAddressing ) );
 8003ed4:	f8df e06c 	ldr.w	lr, [pc, #108]	; 8003f44 <FreeRTOS_IPInit+0x168>
 8003ed8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003eda:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8003ede:	f8ce c000 	str.w	ip, [lr]
				*ipLOCAL_IP_ADDRESS_POINTER = xNetworkAddressing.ulDefaultIPAddress;
 8003ee2:	4b15      	ldr	r3, [pc, #84]	; (8003f38 <FreeRTOS_IPInit+0x15c>)
 8003ee4:	615c      	str	r4, [r3, #20]
				configASSERT( ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) == ( xNetworkAddressing.ulGatewayAddress & xNetworkAddressing.ulNetMask ) );
 8003ee6:	407c      	eors	r4, r7
 8003ee8:	4234      	tst	r4, r6
 8003eea:	d113      	bne.n	8003f14 <FreeRTOS_IPInit+0x138>
			memcpy( ( void * ) ipLOCAL_MAC_ADDRESS, ( void * ) ucMACAddress, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8003eec:	4b12      	ldr	r3, [pc, #72]	; (8003f38 <FreeRTOS_IPInit+0x15c>)
 8003eee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8003ef0:	6810      	ldr	r0, [r2, #0]
 8003ef2:	6018      	str	r0, [r3, #0]
 8003ef4:	8892      	ldrh	r2, [r2, #4]
 8003ef6:	809a      	strh	r2, [r3, #4]
			vNetworkSocketsInit();
 8003ef8:	f000 fbd0 	bl	800469c <vNetworkSocketsInit>
			xReturn = xTaskCreate( prvIPTask, "IP-task", ( uint16_t ) ipconfigIP_TASK_STACK_SIZE_WORDS, NULL, ( UBaseType_t ) ipconfigIP_TASK_PRIORITY, &xIPTaskHandle );
 8003efc:	4b0b      	ldr	r3, [pc, #44]	; (8003f2c <FreeRTOS_IPInit+0x150>)
 8003efe:	9301      	str	r3, [sp, #4]
 8003f00:	2305      	movs	r3, #5
 8003f02:	9300      	str	r3, [sp, #0]
 8003f04:	2300      	movs	r3, #0
 8003f06:	f44f 7220 	mov.w	r2, #640	; 0x280
 8003f0a:	490c      	ldr	r1, [pc, #48]	; (8003f3c <FreeRTOS_IPInit+0x160>)
 8003f0c:	480c      	ldr	r0, [pc, #48]	; (8003f40 <FreeRTOS_IPInit+0x164>)
 8003f0e:	f005 fb79 	bl	8009604 <xTaskCreate>
 8003f12:	e792      	b.n	8003e3a <FreeRTOS_IPInit+0x5e>
				configASSERT( ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) == ( xNetworkAddressing.ulGatewayAddress & xNetworkAddressing.ulNetMask ) );
 8003f14:	f240 4106 	movw	r1, #1030	; 0x406
 8003f18:	4803      	ldr	r0, [pc, #12]	; (8003f28 <FreeRTOS_IPInit+0x14c>)
 8003f1a:	f007 fef7 	bl	800bd0c <vAssertCalled>
 8003f1e:	e7e5      	b.n	8003eec <FreeRTOS_IPInit+0x110>
 8003f20:	200004f4 	.word	0x200004f4
 8003f24:	20000510 	.word	0x20000510
 8003f28:	0800c454 	.word	0x0800c454
 8003f2c:	200004f0 	.word	0x200004f0
 8003f30:	0800c484 	.word	0x0800c484
 8003f34:	200004f8 	.word	0x200004f8
 8003f38:	20000010 	.word	0x20000010
 8003f3c:	0800c48c 	.word	0x0800c48c
 8003f40:	08004141 	.word	0x08004141
 8003f44:	200004dc 	.word	0x200004dc

08003f48 <FreeRTOS_GetAddressConfiguration>:
	if( pulIPAddress != NULL )
 8003f48:	b198      	cbz	r0, 8003f72 <FreeRTOS_GetAddressConfiguration+0x2a>
{
 8003f4a:	b410      	push	{r4}
 8003f4c:	4604      	mov	r4, r0
		*pulIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8003f4e:	4810      	ldr	r0, [pc, #64]	; (8003f90 <FreeRTOS_GetAddressConfiguration+0x48>)
 8003f50:	6940      	ldr	r0, [r0, #20]
 8003f52:	6020      	str	r0, [r4, #0]
	if( pulNetMask != NULL )
 8003f54:	b111      	cbz	r1, 8003f5c <FreeRTOS_GetAddressConfiguration+0x14>
		*pulNetMask = xNetworkAddressing.ulNetMask;
 8003f56:	480f      	ldr	r0, [pc, #60]	; (8003f94 <FreeRTOS_GetAddressConfiguration+0x4c>)
 8003f58:	6840      	ldr	r0, [r0, #4]
 8003f5a:	6008      	str	r0, [r1, #0]
	if( pulGatewayAddress != NULL )
 8003f5c:	b112      	cbz	r2, 8003f64 <FreeRTOS_GetAddressConfiguration+0x1c>
		*pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;
 8003f5e:	490d      	ldr	r1, [pc, #52]	; (8003f94 <FreeRTOS_GetAddressConfiguration+0x4c>)
 8003f60:	6889      	ldr	r1, [r1, #8]
 8003f62:	6011      	str	r1, [r2, #0]
	if( pulDNSServerAddress != NULL )
 8003f64:	b113      	cbz	r3, 8003f6c <FreeRTOS_GetAddressConfiguration+0x24>
		*pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;
 8003f66:	4a0b      	ldr	r2, [pc, #44]	; (8003f94 <FreeRTOS_GetAddressConfiguration+0x4c>)
 8003f68:	68d2      	ldr	r2, [r2, #12]
 8003f6a:	601a      	str	r2, [r3, #0]
}
 8003f6c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003f70:	4770      	bx	lr
	if( pulNetMask != NULL )
 8003f72:	b111      	cbz	r1, 8003f7a <FreeRTOS_GetAddressConfiguration+0x32>
		*pulNetMask = xNetworkAddressing.ulNetMask;
 8003f74:	4807      	ldr	r0, [pc, #28]	; (8003f94 <FreeRTOS_GetAddressConfiguration+0x4c>)
 8003f76:	6840      	ldr	r0, [r0, #4]
 8003f78:	6008      	str	r0, [r1, #0]
	if( pulGatewayAddress != NULL )
 8003f7a:	b112      	cbz	r2, 8003f82 <FreeRTOS_GetAddressConfiguration+0x3a>
		*pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;
 8003f7c:	4905      	ldr	r1, [pc, #20]	; (8003f94 <FreeRTOS_GetAddressConfiguration+0x4c>)
 8003f7e:	6889      	ldr	r1, [r1, #8]
 8003f80:	6011      	str	r1, [r2, #0]
	if( pulDNSServerAddress != NULL )
 8003f82:	2b00      	cmp	r3, #0
 8003f84:	d0f4      	beq.n	8003f70 <FreeRTOS_GetAddressConfiguration+0x28>
		*pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;
 8003f86:	4a03      	ldr	r2, [pc, #12]	; (8003f94 <FreeRTOS_GetAddressConfiguration+0x4c>)
 8003f88:	68d2      	ldr	r2, [r2, #12]
 8003f8a:	601a      	str	r2, [r3, #0]
 8003f8c:	4770      	bx	lr
 8003f8e:	bf00      	nop
 8003f90:	20000010 	.word	0x20000010
 8003f94:	200004f8 	.word	0x200004f8

08003f98 <xSendEventStructToIPTask>:
{
 8003f98:	b538      	push	{r3, r4, r5, lr}
 8003f9a:	4604      	mov	r4, r0
 8003f9c:	460d      	mov	r5, r1
	return xIPTaskInitialised;
 8003f9e:	4b17      	ldr	r3, [pc, #92]	; (8003ffc <xSendEventStructToIPTask+0x64>)
	if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
 8003fa0:	681b      	ldr	r3, [r3, #0]
 8003fa2:	b92b      	cbnz	r3, 8003fb0 <xSendEventStructToIPTask+0x18>
 8003fa4:	f990 3000 	ldrsb.w	r3, [r0]
 8003fa8:	b133      	cbz	r3, 8003fb8 <xSendEventStructToIPTask+0x20>
		xReturn = pdFAIL;
 8003faa:	2400      	movs	r4, #0
}
 8003fac:	4620      	mov	r0, r4
 8003fae:	bd38      	pop	{r3, r4, r5, pc}
			if( pxEvent->eEventType == eTCPTimerEvent )
 8003fb0:	f990 3000 	ldrsb.w	r3, [r0]
 8003fb4:	2b05      	cmp	r3, #5
 8003fb6:	d014      	beq.n	8003fe2 <xSendEventStructToIPTask+0x4a>
			if( ( xIsCallingFromIPTask() == pdTRUE ) && ( xTimeout > ( TickType_t ) 0 ) )
 8003fb8:	f7ff fece 	bl	8003d58 <xIsCallingFromIPTask>
 8003fbc:	2801      	cmp	r0, #1
			xReturn = xQueueSendToBack( xNetworkEventQueue, pxEvent, xTimeout );
 8003fbe:	f04f 0300 	mov.w	r3, #0
 8003fc2:	bf14      	ite	ne
 8003fc4:	462a      	movne	r2, r5
 8003fc6:	461a      	moveq	r2, r3
 8003fc8:	4621      	mov	r1, r4
 8003fca:	480d      	ldr	r0, [pc, #52]	; (8004000 <xSendEventStructToIPTask+0x68>)
 8003fcc:	6800      	ldr	r0, [r0, #0]
 8003fce:	f005 f867 	bl	80090a0 <xQueueGenericSend>
			if( xReturn == pdFAIL )
 8003fd2:	4604      	mov	r4, r0
 8003fd4:	2800      	cmp	r0, #0
 8003fd6:	d1e9      	bne.n	8003fac <xSendEventStructToIPTask+0x14>
				iptraceSTACK_TX_EVENT_LOST( pxEvent->eEventType );
 8003fd8:	2100      	movs	r1, #0
 8003fda:	200b      	movs	r0, #11
 8003fdc:	f007 f900 	bl	800b1e0 <vExampleDebugStatUpdate>
 8003fe0:	e7e4      	b.n	8003fac <xSendEventStructToIPTask+0x14>
				xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 8003fe2:	4a08      	ldr	r2, [pc, #32]	; (8004004 <xSendEventStructToIPTask+0x6c>)
 8003fe4:	7813      	ldrb	r3, [r2, #0]
 8003fe6:	f043 0302 	orr.w	r3, r3, #2
 8003fea:	7013      	strb	r3, [r2, #0]
				if( uxQueueMessagesWaiting( xNetworkEventQueue ) != 0u )
 8003fec:	4b04      	ldr	r3, [pc, #16]	; (8004000 <xSendEventStructToIPTask+0x68>)
 8003fee:	6818      	ldr	r0, [r3, #0]
 8003ff0:	f005 fa38 	bl	8009464 <uxQueueMessagesWaiting>
		if( xSendMessage != pdFALSE )
 8003ff4:	2800      	cmp	r0, #0
 8003ff6:	d0df      	beq.n	8003fb8 <xSendEventStructToIPTask+0x20>
			xReturn = pdPASS;
 8003ff8:	2401      	movs	r4, #1
	return xReturn;
 8003ffa:	e7d7      	b.n	8003fac <xSendEventStructToIPTask+0x14>
 8003ffc:	200004f4 	.word	0x200004f4
 8004000:	20000510 	.word	0x20000510
 8004004:	20000520 	.word	0x20000520

08004008 <FreeRTOS_NetworkDown>:
{
 8004008:	b508      	push	{r3, lr}
	if( xSendEventStructToIPTask( &xNetworkDownEvent, xDontBlock ) != pdPASS )
 800400a:	2100      	movs	r1, #0
 800400c:	4804      	ldr	r0, [pc, #16]	; (8004020 <FreeRTOS_NetworkDown+0x18>)
 800400e:	f7ff ffc3 	bl	8003f98 <xSendEventStructToIPTask>
 8004012:	2801      	cmp	r0, #1
		xNetworkDownEventPending = pdTRUE;
 8004014:	bf14      	ite	ne
 8004016:	2201      	movne	r2, #1
		xNetworkDownEventPending = pdFALSE;
 8004018:	2200      	moveq	r2, #0
 800401a:	4b02      	ldr	r3, [pc, #8]	; (8004024 <FreeRTOS_NetworkDown+0x1c>)
 800401c:	601a      	str	r2, [r3, #0]
 800401e:	bd08      	pop	{r3, pc}
 8004020:	0800c49c 	.word	0x0800c49c
 8004024:	2000050c 	.word	0x2000050c

08004028 <FreeRTOS_SendPingRequest>:
	{
 8004028:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800402c:	b082      	sub	sp, #8
	IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 800402e:	2303      	movs	r3, #3
 8004030:	f88d 3000 	strb.w	r3, [sp]
 8004034:	2300      	movs	r3, #0
 8004036:	9301      	str	r3, [sp, #4]
		if( xNumberOfBytesToSend < ( ( ipconfigNETWORK_MTU - sizeof( IPHeader_t ) ) - sizeof( ICMPHeader_t ) ) )
 8004038:	f5b1 6fb8 	cmp.w	r1, #1472	; 0x5c0
 800403c:	d303      	bcc.n	8004046 <FreeRTOS_SendPingRequest+0x1e>
	BaseType_t xReturn = pdFAIL;
 800403e:	2000      	movs	r0, #0
	}
 8004040:	b002      	add	sp, #8
 8004042:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
 8004046:	4616      	mov	r6, r2
 8004048:	460c      	mov	r4, r1
 800404a:	4680      	mov	r8, r0
			pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( xNumberOfBytesToSend + sizeof( ICMPPacket_t ), xBlockTimeTicks );
 800404c:	4611      	mov	r1, r2
 800404e:	f104 002a 	add.w	r0, r4, #42	; 0x2a
 8004052:	f003 ff2f 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>
			if( pxNetworkBuffer != NULL )
 8004056:	4605      	mov	r5, r0
 8004058:	b380      	cbz	r0, 80040bc <FreeRTOS_SendPingRequest+0x94>
				pxICMPHeader = ( ICMPHeader_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipIP_PAYLOAD_OFFSET ] );
 800405a:	6980      	ldr	r0, [r0, #24]
				usSequenceNumber++;
 800405c:	4918      	ldr	r1, [pc, #96]	; (80040c0 <FreeRTOS_SendPingRequest+0x98>)
 800405e:	880b      	ldrh	r3, [r1, #0]
 8004060:	3301      	adds	r3, #1
 8004062:	b29b      	uxth	r3, r3
 8004064:	461a      	mov	r2, r3
 8004066:	800b      	strh	r3, [r1, #0]
				pxICMPHeader->ucTypeOfMessage = ipICMP_ECHO_REQUEST;
 8004068:	2308      	movs	r3, #8
 800406a:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
				pxICMPHeader->ucTypeOfService = 0;
 800406e:	f04f 0900 	mov.w	r9, #0
 8004072:	f880 9023 	strb.w	r9, [r0, #35]	; 0x23
				pxICMPHeader->usIdentifier = usSequenceNumber;
 8004076:	84c2      	strh	r2, [r0, #38]	; 0x26
				pxICMPHeader->usSequenceNumber = usSequenceNumber;
 8004078:	8502      	strh	r2, [r0, #40]	; 0x28
				memset( ( void * ) pucChar, ( int ) ipECHO_DATA_FILL_BYTE, xNumberOfBytesToSend );
 800407a:	4622      	mov	r2, r4
 800407c:	2178      	movs	r1, #120	; 0x78
 800407e:	302a      	adds	r0, #42	; 0x2a
 8004080:	f008 f810 	bl	800c0a4 <memset>
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = FREERTOS_SO_UDPCKSUM_OUT;
 8004084:	69ab      	ldr	r3, [r5, #24]
 8004086:	2202      	movs	r2, #2
 8004088:	719a      	strb	r2, [r3, #6]
				pxNetworkBuffer->ulIPAddress = ulIPAddress;
 800408a:	f8c5 8014 	str.w	r8, [r5, #20]
				pxNetworkBuffer->usPort = ipPACKET_CONTAINS_ICMP_DATA;
 800408e:	f8a5 9020 	strh.w	r9, [r5, #32]
				pxNetworkBuffer->xDataLength = xNumberOfBytesToSend + sizeof( ICMPHeader_t );
 8004092:	3408      	adds	r4, #8
 8004094:	61ec      	str	r4, [r5, #28]
				xStackTxEvent.pvData = pxNetworkBuffer;
 8004096:	9501      	str	r5, [sp, #4]
				if( xSendEventStructToIPTask( &xStackTxEvent, xBlockTimeTicks) != pdPASS )
 8004098:	4631      	mov	r1, r6
 800409a:	4668      	mov	r0, sp
 800409c:	f7ff ff7c 	bl	8003f98 <xSendEventStructToIPTask>
 80040a0:	2801      	cmp	r0, #1
 80040a2:	d102      	bne.n	80040aa <FreeRTOS_SendPingRequest+0x82>
					xReturn = usSequenceNumber;
 80040a4:	4b06      	ldr	r3, [pc, #24]	; (80040c0 <FreeRTOS_SendPingRequest+0x98>)
 80040a6:	8818      	ldrh	r0, [r3, #0]
 80040a8:	e7ca      	b.n	8004040 <FreeRTOS_SendPingRequest+0x18>
					vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80040aa:	4628      	mov	r0, r5
 80040ac:	f003 fedc 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
					iptraceSTACK_TX_EVENT_LOST( ipSTACK_TX_EVENT );
 80040b0:	4649      	mov	r1, r9
 80040b2:	200b      	movs	r0, #11
 80040b4:	f007 f894 	bl	800b1e0 <vExampleDebugStatUpdate>
	BaseType_t xReturn = pdFAIL;
 80040b8:	4648      	mov	r0, r9
 80040ba:	e7c1      	b.n	8004040 <FreeRTOS_SendPingRequest+0x18>
 80040bc:	2000      	movs	r0, #0
		return xReturn;
 80040be:	e7bf      	b.n	8004040 <FreeRTOS_SendPingRequest+0x18>
 80040c0:	200004ae 	.word	0x200004ae

080040c4 <xSendEventToIPTask>:
{
 80040c4:	b500      	push	{lr}
 80040c6:	b083      	sub	sp, #12
	xEventMessage.eEventType = eEvent;
 80040c8:	f88d 0000 	strb.w	r0, [sp]
	xEventMessage.pvData = ( void* )NULL;
 80040cc:	2100      	movs	r1, #0
 80040ce:	9101      	str	r1, [sp, #4]
	return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
 80040d0:	4668      	mov	r0, sp
 80040d2:	f7ff ff61 	bl	8003f98 <xSendEventStructToIPTask>
}
 80040d6:	b003      	add	sp, #12
 80040d8:	f85d fb04 	ldr.w	pc, [sp], #4

080040dc <vIPNetworkUpCalls>:
{
 80040dc:	b538      	push	{r3, r4, r5, lr}
	xNetworkUp = pdTRUE;
 80040de:	2201      	movs	r2, #1
 80040e0:	4b0a      	ldr	r3, [pc, #40]	; (800410c <vIPNetworkUpCalls+0x30>)
 80040e2:	601a      	str	r2, [r3, #0]
		vApplicationIPNetworkEventHook( eNetworkUp );
 80040e4:	2000      	movs	r0, #0
 80040e6:	f007 fe41 	bl	800bd6c <vApplicationIPNetworkEventHook>
		vDNSInitialise();
 80040ea:	f7ff fc7b 	bl	80039e4 <vDNSInitialise>
	pxTimer->ulReloadTime = xTime;
 80040ee:	4c08      	ldr	r4, [pc, #32]	; (8004110 <vIPNetworkUpCalls+0x34>)
 80040f0:	f242 7510 	movw	r5, #10000	; 0x2710
 80040f4:	6125      	str	r5, [r4, #16]
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 80040f6:	1d20      	adds	r0, r4, #4
 80040f8:	f005 ff56 	bl	8009fa8 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 80040fc:	60e5      	str	r5, [r4, #12]
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 80040fe:	7823      	ldrb	r3, [r4, #0]
	pxTimer->bActive = pdTRUE_UNSIGNED;
 8004100:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 8004104:	f043 0301 	orr.w	r3, r3, #1
 8004108:	7023      	strb	r3, [r4, #0]
 800410a:	bd38      	pop	{r3, r4, r5, pc}
 800410c:	20000514 	.word	0x20000514
 8004110:	200004b0 	.word	0x200004b0

08004114 <vReturnEthernetFrame>:
{
 8004114:	b538      	push	{r3, r4, r5, lr}
 8004116:	4604      	mov	r4, r0
		pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8004118:	6982      	ldr	r2, [r0, #24]
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ), sizeof( pxEthernetHeader->xDestinationAddress ) );
 800411a:	4613      	mov	r3, r2
 800411c:	f853 0f06 	ldr.w	r0, [r3, #6]!
 8004120:	6010      	str	r0, [r2, #0]
 8004122:	8898      	ldrh	r0, [r3, #4]
 8004124:	8090      	strh	r0, [r2, #4]
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8004126:	4d05      	ldr	r5, [pc, #20]	; (800413c <vReturnEthernetFrame+0x28>)
 8004128:	6828      	ldr	r0, [r5, #0]
 800412a:	f8c2 0006 	str.w	r0, [r2, #6]
 800412e:	88aa      	ldrh	r2, [r5, #4]
 8004130:	809a      	strh	r2, [r3, #4]
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 8004132:	4620      	mov	r0, r4
 8004134:	f004 f95a 	bl	80083ec <xNetworkInterfaceOutput>
 8004138:	bd38      	pop	{r3, r4, r5, pc}
 800413a:	bf00      	nop
 800413c:	20000010 	.word	0x20000010

08004140 <prvIPTask>:
{
 8004140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004144:	b089      	sub	sp, #36	; 0x24
	FreeRTOS_NetworkDown();
 8004146:	f7ff ff5f 	bl	8004008 <FreeRTOS_NetworkDown>
	pxTimer->ulReloadTime = xTime;
 800414a:	4cc1      	ldr	r4, [pc, #772]	; (8004450 <prvIPTask+0x310>)
 800414c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8004150:	6125      	str	r5, [r4, #16]
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 8004152:	1d20      	adds	r0, r4, #4
 8004154:	f005 ff28 	bl	8009fa8 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8004158:	60e5      	str	r5, [r4, #12]
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 800415a:	7823      	ldrb	r3, [r4, #0]
	pxTimer->bActive = pdTRUE_UNSIGNED;
 800415c:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 8004160:	f043 0301 	orr.w	r3, r3, #1
 8004164:	7023      	strb	r3, [r4, #0]
	xIPTaskInitialised = pdTRUE;
 8004166:	2201      	movs	r2, #1
 8004168:	4bba      	ldr	r3, [pc, #744]	; (8004454 <prvIPTask+0x314>)
 800416a:	601a      	str	r2, [r3, #0]
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 800416c:	4eba      	ldr	r6, [pc, #744]	; (8004458 <prvIPTask+0x318>)
		if( xStart != ( TickType_t ) 0 )
 800416e:	f8df 8308 	ldr.w	r8, [pc, #776]	; 8004478 <prvIPTask+0x338>
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 8004172:	f104 0904 	add.w	r9, r4, #4
 8004176:	e21a      	b.n	80045ae <prvIPTask+0x46e>
		xSendEventToIPTask( eARPTimerEvent );
 8004178:	2002      	movs	r0, #2
 800417a:	f7ff ffa3 	bl	80040c4 <xSendEventToIPTask>
 800417e:	e19e      	b.n	80044be <prvIPTask+0x37e>
			vDNSCheckCallBack( NULL );
 8004180:	2000      	movs	r0, #0
 8004182:	f7ff fc37 	bl	80039f4 <vDNSCheckCallBack>
 8004186:	e1a0      	b.n	80044ca <prvIPTask+0x38a>
			xNextTime = xTCPTimerCheck( xWillSleep );
 8004188:	faba f08a 	clz	r0, sl
 800418c:	0940      	lsrs	r0, r0, #5
 800418e:	f001 f8ab 	bl	80052e8 <xTCPTimerCheck>
 8004192:	4682      	mov	sl, r0
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 8004194:	4648      	mov	r0, r9
 8004196:	f005 ff07 	bl	8009fa8 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 800419a:	f8c4 a00c 	str.w	sl, [r4, #12]
	if( xTime == ( TickType_t ) 0 )
 800419e:	f1ba 0f00 	cmp.w	sl, #0
 80041a2:	d00b      	beq.n	80041bc <prvIPTask+0x7c>
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 80041a4:	7823      	ldrb	r3, [r4, #0]
 80041a6:	f36f 0341 	bfc	r3, #1, #1
 80041aa:	7023      	strb	r3, [r4, #0]
	pxTimer->bActive = pdTRUE_UNSIGNED;
 80041ac:	7823      	ldrb	r3, [r4, #0]
 80041ae:	f043 0301 	orr.w	r3, r3, #1
 80041b2:	7023      	strb	r3, [r4, #0]
			xProcessedTCPMessage = 0;
 80041b4:	2200      	movs	r2, #0
 80041b6:	4ba9      	ldr	r3, [pc, #676]	; (800445c <prvIPTask+0x31c>)
 80041b8:	601a      	str	r2, [r3, #0]
 80041ba:	e1a4      	b.n	8004506 <prvIPTask+0x3c6>
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 80041bc:	7823      	ldrb	r3, [r4, #0]
 80041be:	f043 0302 	orr.w	r3, r3, #2
 80041c2:	7023      	strb	r3, [r4, #0]
 80041c4:	e7f2      	b.n	80041ac <prvIPTask+0x6c>
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 80041c6:	f242 7210 	movw	r2, #10000	; 0x2710
 80041ca:	68e3      	ldr	r3, [r4, #12]
 80041cc:	429a      	cmp	r2, r3
 80041ce:	bf28      	it	cs
 80041d0:	461a      	movcs	r2, r3
		if( xDNSTimer.bActive != pdFALSE )
 80041d2:	783b      	ldrb	r3, [r7, #0]
 80041d4:	f013 0f01 	tst.w	r3, #1
 80041d8:	d003      	beq.n	80041e2 <prvIPTask+0xa2>
 80041da:	68fb      	ldr	r3, [r7, #12]
 80041dc:	429a      	cmp	r2, r3
 80041de:	bf28      	it	cs
 80041e0:	461a      	movcs	r2, r3
		xReceivedEvent.eEventType = eNoEvent;
 80041e2:	a908      	add	r1, sp, #32
 80041e4:	23ff      	movs	r3, #255	; 0xff
 80041e6:	f801 3d08 	strb.w	r3, [r1, #-8]!
		xQueueReceive( xNetworkEventQueue, ( void * ) &xReceivedEvent, xNextIPSleep );
 80041ea:	2300      	movs	r3, #0
 80041ec:	6828      	ldr	r0, [r5, #0]
 80041ee:	f005 f865 	bl	80092bc <xQueueGenericReceive>
		iptraceNETWORK_EVENT_RECEIVED( xReceivedEvent.eEventType );
 80041f2:	6828      	ldr	r0, [r5, #0]
 80041f4:	f005 f936 	bl	8009464 <uxQueueMessagesWaiting>
 80041f8:	f1c0 011d 	rsb	r1, r0, #29
 80041fc:	b289      	uxth	r1, r1
 80041fe:	2005      	movs	r0, #5
 8004200:	f006 ffee 	bl	800b1e0 <vExampleDebugStatUpdate>
		switch( xReceivedEvent.eEventType )
 8004204:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 8004208:	2b0b      	cmp	r3, #11
 800420a:	f200 814e 	bhi.w	80044aa <prvIPTask+0x36a>
 800420e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004212:	000f      	.short	0x000f
 8004214:	014a002f 	.word	0x014a002f
 8004218:	014c01a7 	.word	0x014c01a7
 800421c:	01b801b3 	.word	0x01b801b3
 8004220:	018701c9 	.word	0x018701c9
 8004224:	01ab01a3 	.word	0x01ab01a3
 8004228:	01af      	.short	0x01af
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 800422a:	f242 7210 	movw	r2, #10000	; 0x2710
 800422e:	e7cc      	b.n	80041ca <prvIPTask+0x8a>
				xNetworkUp = pdFALSE;
 8004230:	2200      	movs	r2, #0
 8004232:	4b8b      	ldr	r3, [pc, #556]	; (8004460 <prvIPTask+0x320>)
 8004234:	601a      	str	r2, [r3, #0]
	xARPTimer.bActive = pdFALSE_UNSIGNED;
 8004236:	7833      	ldrb	r3, [r6, #0]
 8004238:	f362 0300 	bfi	r3, r2, #0, #1
 800423c:	7033      	strb	r3, [r6, #0]
		if( xCallEventHook == pdTRUE )
 800423e:	4b89      	ldr	r3, [pc, #548]	; (8004464 <prvIPTask+0x324>)
 8004240:	681b      	ldr	r3, [r3, #0]
 8004242:	2b01      	cmp	r3, #1
 8004244:	d00d      	beq.n	8004262 <prvIPTask+0x122>
		xCallEventHook = pdTRUE;
 8004246:	2201      	movs	r2, #1
 8004248:	4b86      	ldr	r3, [pc, #536]	; (8004464 <prvIPTask+0x324>)
 800424a:	601a      	str	r2, [r3, #0]
	if( xNetworkInterfaceInitialise() != pdPASS )
 800424c:	f004 f862 	bl	8008314 <xNetworkInterfaceInitialise>
 8004250:	2801      	cmp	r0, #1
 8004252:	d00a      	beq.n	800426a <prvIPTask+0x12a>
		vTaskDelay( ipINITIALISATION_RETRY_DELAY );
 8004254:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8004258:	f005 fd04 	bl	8009c64 <vTaskDelay>
		FreeRTOS_NetworkDown();
 800425c:	f7ff fed4 	bl	8004008 <FreeRTOS_NetworkDown>
 8004260:	e123      	b.n	80044aa <prvIPTask+0x36a>
			vApplicationIPNetworkEventHook( eNetworkDown );
 8004262:	2001      	movs	r0, #1
 8004264:	f007 fd82 	bl	800bd6c <vApplicationIPNetworkEventHook>
 8004268:	e7ed      	b.n	8004246 <prvIPTask+0x106>
			vIPNetworkUpCalls();
 800426a:	f7ff ff37 	bl	80040dc <vIPNetworkUpCalls>
 800426e:	e11c      	b.n	80044aa <prvIPTask+0x36a>
				prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
 8004270:	f8dd a01c 	ldr.w	sl, [sp, #28]
	configASSERT( pxNetworkBuffer );
 8004274:	f1ba 0f00 	cmp.w	sl, #0
 8004278:	d014      	beq.n	80042a4 <prvIPTask+0x164>
	eReturned = ipCONSIDER_FRAME_FOR_PROCESSING( pxNetworkBuffer->pucEthernetBuffer );
 800427a:	2301      	movs	r3, #1
 800427c:	f88d 300f 	strb.w	r3, [sp, #15]
	if( eReturned == eProcessBuffer )
 8004280:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8004284:	b2db      	uxtb	r3, r3
 8004286:	2b01      	cmp	r3, #1
 8004288:	d012      	beq.n	80042b0 <prvIPTask+0x170>
	switch( eReturned )
 800428a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800428e:	b2db      	uxtb	r3, r3
 8004290:	2b02      	cmp	r3, #2
 8004292:	f000 8103 	beq.w	800449c <prvIPTask+0x35c>
 8004296:	2b03      	cmp	r3, #3
 8004298:	f000 8107 	beq.w	80044aa <prvIPTask+0x36a>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800429c:	4650      	mov	r0, sl
 800429e:	f003 fde3 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
 80042a2:	e102      	b.n	80044aa <prvIPTask+0x36a>
	configASSERT( pxNetworkBuffer );
 80042a4:	f240 516c 	movw	r1, #1388	; 0x56c
 80042a8:	486f      	ldr	r0, [pc, #444]	; (8004468 <prvIPTask+0x328>)
 80042aa:	f007 fd2f 	bl	800bd0c <vAssertCalled>
 80042ae:	e7e4      	b.n	800427a <prvIPTask+0x13a>
	pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80042b0:	f8da b018 	ldr.w	fp, [sl, #24]
		switch( pxEthernetHeader->usFrameType )
 80042b4:	f8bb 300c 	ldrh.w	r3, [fp, #12]
 80042b8:	2b08      	cmp	r3, #8
 80042ba:	d009      	beq.n	80042d0 <prvIPTask+0x190>
 80042bc:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
 80042c0:	f040 80e8 	bne.w	8004494 <prvIPTask+0x354>
				eReturned = eARPProcessPacket( ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80042c4:	4658      	mov	r0, fp
 80042c6:	f7ff f881 	bl	80033cc <eARPProcessPacket>
 80042ca:	f88d 000f 	strb.w	r0, [sp, #15]
 80042ce:	e7dc      	b.n	800428a <prvIPTask+0x14a>
			if( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U )
 80042d0:	f8bb 3014 	ldrh.w	r3, [fp, #20]
 80042d4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80042d8:	b29b      	uxth	r3, r3
 80042da:	2b00      	cmp	r3, #0
 80042dc:	f040 80ce 	bne.w	800447c <prvIPTask+0x33c>
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0x0Fu ) << 2 );
 80042e0:	f89b 300e 	ldrb.w	r3, [fp, #14]
			else if( ( pxIPHeader->ucVersionHeaderLength < 0x45u ) || ( pxIPHeader->ucVersionHeaderLength > 0x4Fu ) )
 80042e4:	f1a3 0245 	sub.w	r2, r3, #69	; 0x45
 80042e8:	b2d2      	uxtb	r2, r2
 80042ea:	2a0a      	cmp	r2, #10
 80042ec:	f200 80ca 	bhi.w	8004484 <prvIPTask+0x344>
		uint32_t ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;
 80042f0:	f8db 201e 	ldr.w	r2, [fp, #30]
			else if( ( ulDestinationIPAddress != *ipLOCAL_IP_ADDRESS_POINTER ) &&
 80042f4:	495d      	ldr	r1, [pc, #372]	; (800446c <prvIPTask+0x32c>)
 80042f6:	6949      	ldr	r1, [r1, #20]
 80042f8:	428a      	cmp	r2, r1
 80042fa:	d00c      	beq.n	8004316 <prvIPTask+0x1d6>
 80042fc:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
 8004300:	d009      	beq.n	8004316 <prvIPTask+0x1d6>
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 8004302:	485b      	ldr	r0, [pc, #364]	; (8004470 <prvIPTask+0x330>)
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
 8004304:	6900      	ldr	r0, [r0, #16]
 8004306:	4282      	cmp	r2, r0
 8004308:	d005      	beq.n	8004316 <prvIPTask+0x1d6>
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 800430a:	485a      	ldr	r0, [pc, #360]	; (8004474 <prvIPTask+0x334>)
 800430c:	4282      	cmp	r2, r0
 800430e:	d002      	beq.n	8004316 <prvIPTask+0x1d6>
	if( eReturn == eProcessBuffer )
 8004310:	2900      	cmp	r1, #0
 8004312:	f040 80b9 	bne.w	8004488 <prvIPTask+0x348>
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0x0Fu ) << 2 );
 8004316:	009b      	lsls	r3, r3, #2
 8004318:	f003 033c 	and.w	r3, r3, #60	; 0x3c
	ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
 800431c:	f89b 2017 	ldrb.w	r2, [fp, #23]
 8004320:	9200      	str	r2, [sp, #0]
		if( uxHeaderLength > ipSIZE_OF_IPv4_HEADER )
 8004322:	2b14      	cmp	r3, #20
 8004324:	d818      	bhi.n	8004358 <prvIPTask+0x218>
		if( ucProtocol != ( uint8_t ) ipPROTOCOL_UDP )
 8004326:	9b00      	ldr	r3, [sp, #0]
 8004328:	2b11      	cmp	r3, #17
 800432a:	d06a      	beq.n	8004402 <prvIPTask+0x2c2>
			vARPRefreshCacheEntry( &( pxIPPacket->xEthernetHeader.xSourceAddress ), pxIPHeader->ulSourceIPAddress );
 800432c:	f8db 101a 	ldr.w	r1, [fp, #26]
 8004330:	f10b 0006 	add.w	r0, fp, #6
 8004334:	f7fe ffb2 	bl	800329c <vARPRefreshCacheEntry>
		switch( ucProtocol )
 8004338:	9b00      	ldr	r3, [sp, #0]
 800433a:	2b06      	cmp	r3, #6
 800433c:	d07b      	beq.n	8004436 <prvIPTask+0x2f6>
 800433e:	2b11      	cmp	r3, #17
 8004340:	d05f      	beq.n	8004402 <prvIPTask+0x2c2>
 8004342:	2b01      	cmp	r3, #1
 8004344:	f040 80a2 	bne.w	800448c <prvIPTask+0x34c>
					if( pxIPHeader->ulDestinationIPAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 8004348:	f8db 301e 	ldr.w	r3, [fp, #30]
 800434c:	4a47      	ldr	r2, [pc, #284]	; (800446c <prvIPTask+0x32c>)
 800434e:	6952      	ldr	r2, [r2, #20]
 8004350:	4293      	cmp	r3, r2
 8004352:	d017      	beq.n	8004384 <prvIPTask+0x244>
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8004354:	2301      	movs	r3, #1
 8004356:	e092      	b.n	800447e <prvIPTask+0x33e>
			const size_t optlen = ( ( size_t ) uxHeaderLength ) - ipSIZE_OF_IPv4_HEADER;
 8004358:	f1a3 0214 	sub.w	r2, r3, #20
 800435c:	4610      	mov	r0, r2
			const size_t  xMoveLen = pxNetworkBuffer->xDataLength - optlen - ipSIZE_OF_IPv4_HEADER - ipSIZE_OF_ETH_HEADER;
 800435e:	f8da 201c 	ldr.w	r2, [sl, #28]
 8004362:	3a22      	subs	r2, #34	; 0x22
const IPHeader_t * pxIPHeader = &( pxIPPacket->xIPHeader );
 8004364:	f10b 010e 	add.w	r1, fp, #14
			memmove( pucTarget, pucSource, xMoveLen );
 8004368:	9001      	str	r0, [sp, #4]
 800436a:	1a12      	subs	r2, r2, r0
 800436c:	4419      	add	r1, r3
 800436e:	f10b 0022 	add.w	r0, fp, #34	; 0x22
 8004372:	f007 fe7d 	bl	800c070 <memmove>
			pxNetworkBuffer->xDataLength -= optlen;
 8004376:	f8da 301c 	ldr.w	r3, [sl, #28]
 800437a:	9a01      	ldr	r2, [sp, #4]
 800437c:	1a9b      	subs	r3, r3, r2
 800437e:	f8ca 301c 	str.w	r3, [sl, #28]
 8004382:	e7d0      	b.n	8004326 <prvIPTask+0x1e6>
					ICMPPacket_t *pxICMPPacket = ( ICMPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8004384:	f8da 2018 	ldr.w	r2, [sl, #24]
		switch( pxICMPPacket->xICMPHeader.ucTypeOfMessage )
 8004388:	f892 1022 	ldrb.w	r1, [r2, #34]	; 0x22
 800438c:	b1a9      	cbz	r1, 80043ba <prvIPTask+0x27a>
 800438e:	2908      	cmp	r1, #8
 8004390:	d17e      	bne.n	8004490 <prvIPTask+0x350>
		pxICMPHeader->ucTypeOfMessage = ( uint8_t ) ipICMP_ECHO_REPLY;
 8004392:	2100      	movs	r1, #0
 8004394:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 8004398:	f8d2 101a 	ldr.w	r1, [r2, #26]
 800439c:	f8c2 101e 	str.w	r1, [r2, #30]
		pxIPHeader->ulSourceIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 80043a0:	f8c2 301a 	str.w	r3, [r2, #26]
		if( pxICMPHeader->usChecksum >= FreeRTOS_htons( 0xFFFFu - usRequest ) )
 80043a4:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 80043a6:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 80043aa:	428b      	cmp	r3, r1
			pxICMPHeader->usChecksum = ( uint16_t )
 80043ac:	bf8c      	ite	hi
 80043ae:	f503 7384 	addhi.w	r3, r3, #264	; 0x108
			pxICMPHeader->usChecksum = ( uint16_t )
 80043b2:	3308      	addls	r3, #8
 80043b4:	8493      	strh	r3, [r2, #36]	; 0x24
					eReturn = prvProcessICMPEchoRequest( pxICMPPacket );
 80043b6:	2302      	movs	r3, #2
 80043b8:	e061      	b.n	800447e <prvIPTask+0x33e>
		usDataLength = pxICMPPacket->xIPHeader.usLength;
 80043ba:	8a11      	ldrh	r1, [r2, #16]
		usDataLength = FreeRTOS_ntohs( usDataLength );
 80043bc:	0a0b      	lsrs	r3, r1, #8
 80043be:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80043c2:	b29b      	uxth	r3, r3
		pucByte += sizeof( ICMPPacket_t );
 80043c4:	f102 012a 	add.w	r1, r2, #42	; 0x2a
		for( usCount = 0; usCount < usDataLength; usCount++ )
 80043c8:	2b1c      	cmp	r3, #28
 80043ca:	d014      	beq.n	80043f6 <prvIPTask+0x2b6>
			if( *pucByte != ipECHO_DATA_FILL_BYTE )
 80043cc:	f892 002a 	ldrb.w	r0, [r2, #42]	; 0x2a
 80043d0:	2878      	cmp	r0, #120	; 0x78
 80043d2:	d112      	bne.n	80043fa <prvIPTask+0x2ba>
 80043d4:	3b1d      	subs	r3, #29
 80043d6:	b29b      	uxth	r3, r3
 80043d8:	332a      	adds	r3, #42	; 0x2a
 80043da:	4413      	add	r3, r2
 80043dc:	e003      	b.n	80043e6 <prvIPTask+0x2a6>
 80043de:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 80043e2:	2878      	cmp	r0, #120	; 0x78
 80043e4:	d10b      	bne.n	80043fe <prvIPTask+0x2be>
		for( usCount = 0; usCount < usDataLength; usCount++ )
 80043e6:	428b      	cmp	r3, r1
 80043e8:	d1f9      	bne.n	80043de <prvIPTask+0x29e>
	ePingReplyStatus_t eStatus = eSuccess;
 80043ea:	2000      	movs	r0, #0
		vApplicationPingReplyHook( eStatus, pxICMPPacket->xICMPHeader.usIdentifier );
 80043ec:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
 80043ee:	f007 fd7d 	bl	800beec <vApplicationPingReplyHook>
	eFrameProcessingResult_t eReturn = eReleaseBuffer;
 80043f2:	2300      	movs	r3, #0
 80043f4:	e043      	b.n	800447e <prvIPTask+0x33e>
	ePingReplyStatus_t eStatus = eSuccess;
 80043f6:	2000      	movs	r0, #0
 80043f8:	e7f8      	b.n	80043ec <prvIPTask+0x2ac>
				eStatus = eInvalidData;
 80043fa:	2002      	movs	r0, #2
 80043fc:	e7f6      	b.n	80043ec <prvIPTask+0x2ac>
 80043fe:	2002      	movs	r0, #2
 8004400:	e7f4      	b.n	80043ec <prvIPTask+0x2ac>
					UDPPacket_t *pxUDPPacket = ( UDPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8004402:	f8da 2018 	ldr.w	r2, [sl, #24]
					pxNetworkBuffer->xDataLength = FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usLength ) - sizeof( UDPHeader_t );
 8004406:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
 8004408:	0a0b      	lsrs	r3, r1, #8
 800440a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800440e:	b29b      	uxth	r3, r3
 8004410:	3b08      	subs	r3, #8
 8004412:	f8ca 301c 	str.w	r3, [sl, #28]
					pxNetworkBuffer->usPort = pxUDPPacket->xUDPHeader.usSourcePort;
 8004416:	8c53      	ldrh	r3, [r2, #34]	; 0x22
 8004418:	f8aa 3020 	strh.w	r3, [sl, #32]
					pxNetworkBuffer->ulIPAddress = pxUDPPacket->xIPHeader.ulSourceIPAddress;
 800441c:	f8d2 301a 	ldr.w	r3, [r2, #26]
 8004420:	f8ca 3014 	str.w	r3, [sl, #20]
					if( xProcessReceivedUDPPacket( pxNetworkBuffer, pxUDPPacket->xUDPHeader.usDestinationPort ) == pdPASS )
 8004424:	8c91      	ldrh	r1, [r2, #36]	; 0x24
 8004426:	4650      	mov	r0, sl
 8004428:	f003 fc82 	bl	8007d30 <xProcessReceivedUDPPacket>
						eReturn = eFrameConsumed;
 800442c:	2801      	cmp	r0, #1
 800442e:	bf14      	ite	ne
 8004430:	2301      	movne	r3, #1
 8004432:	2303      	moveq	r3, #3
 8004434:	e023      	b.n	800447e <prvIPTask+0x33e>
					if( xProcessReceivedTCPPacket( pxNetworkBuffer ) == pdPASS )
 8004436:	4650      	mov	r0, sl
 8004438:	f002 fa84 	bl	8006944 <xProcessReceivedTCPPacket>
						eReturn = eFrameConsumed;
 800443c:	2801      	cmp	r0, #1
 800443e:	bf14      	ite	ne
 8004440:	2301      	movne	r3, #1
 8004442:	2303      	moveq	r3, #3
					xProcessedTCPMessage++;
 8004444:	4905      	ldr	r1, [pc, #20]	; (800445c <prvIPTask+0x31c>)
 8004446:	680a      	ldr	r2, [r1, #0]
 8004448:	3201      	adds	r2, #1
 800444a:	600a      	str	r2, [r1, #0]
 800444c:	e017      	b.n	800447e <prvIPTask+0x33e>
 800444e:	bf00      	nop
 8004450:	20000520 	.word	0x20000520
 8004454:	200004f4 	.word	0x200004f4
 8004458:	200004b0 	.word	0x200004b0
 800445c:	20000518 	.word	0x20000518
 8004460:	20000514 	.word	0x20000514
 8004464:	200004c4 	.word	0x200004c4
 8004468:	0800c454 	.word	0x0800c454
 800446c:	20000010 	.word	0x20000010
 8004470:	200004f8 	.word	0x200004f8
 8004474:	fc0000e0 	.word	0xfc0000e0
 8004478:	2000051c 	.word	0x2000051c
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 800447c:	2300      	movs	r3, #0
				eReturned = prvProcessIPPacket( ( IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer );
 800447e:	f88d 300f 	strb.w	r3, [sp, #15]
 8004482:	e702      	b.n	800428a <prvIPTask+0x14a>
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8004484:	2300      	movs	r3, #0
 8004486:	e7fa      	b.n	800447e <prvIPTask+0x33e>
 8004488:	2300      	movs	r3, #0
 800448a:	e7f8      	b.n	800447e <prvIPTask+0x33e>
 800448c:	2301      	movs	r3, #1
 800448e:	e7f6      	b.n	800447e <prvIPTask+0x33e>
	eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8004490:	2300      	movs	r3, #0
 8004492:	e7f4      	b.n	800447e <prvIPTask+0x33e>
				eReturned = eReleaseBuffer;
 8004494:	2300      	movs	r3, #0
 8004496:	f88d 300f 	strb.w	r3, [sp, #15]
 800449a:	e6f6      	b.n	800428a <prvIPTask+0x14a>
			vReturnEthernetFrame( pxNetworkBuffer, pdTRUE );
 800449c:	2101      	movs	r1, #1
 800449e:	4650      	mov	r0, sl
 80044a0:	f7ff fe38 	bl	8004114 <vReturnEthernetFrame>
 80044a4:	e001      	b.n	80044aa <prvIPTask+0x36a>
				vARPAgeCache();
 80044a6:	f7ff f87b 	bl	80035a0 <vARPAgeCache>
		if( xNetworkDownEventPending != pdFALSE )
 80044aa:	4b42      	ldr	r3, [pc, #264]	; (80045b4 <prvIPTask+0x474>)
 80044ac:	681b      	ldr	r3, [r3, #0]
 80044ae:	2b00      	cmp	r3, #0
 80044b0:	d17b      	bne.n	80045aa <prvIPTask+0x46a>
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 80044b2:	4630      	mov	r0, r6
 80044b4:	f7ff fc27 	bl	8003d06 <prvIPTimerCheck>
 80044b8:	2800      	cmp	r0, #0
 80044ba:	f47f ae5d 	bne.w	8004178 <prvIPTask+0x38>
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 80044be:	4638      	mov	r0, r7
 80044c0:	f7ff fc21 	bl	8003d06 <prvIPTimerCheck>
 80044c4:	2800      	cmp	r0, #0
 80044c6:	f47f ae5b 	bne.w	8004180 <prvIPTask+0x40>
		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0u )
 80044ca:	6828      	ldr	r0, [r5, #0]
 80044cc:	f004 ffca 	bl	8009464 <uxQueueMessagesWaiting>
 80044d0:	4682      	mov	sl, r0
		xTimeNow = xTaskGetTickCount();
 80044d2:	f005 fa75 	bl	80099c0 <xTaskGetTickCount>
		if( xStart != ( TickType_t ) 0 )
 80044d6:	f8d8 3000 	ldr.w	r3, [r8]
 80044da:	b12b      	cbz	r3, 80044e8 <prvIPTask+0x3a8>
			ulNextInitialSequenceNumber += ipINITIAL_SEQUENCE_NUMBER_FACTOR * ( ( xTimeNow - xStart ) * portTICK_PERIOD_MS );
 80044dc:	4936      	ldr	r1, [pc, #216]	; (80045b8 <prvIPTask+0x478>)
 80044de:	1ac3      	subs	r3, r0, r3
 80044e0:	680a      	ldr	r2, [r1, #0]
 80044e2:	eb02 2303 	add.w	r3, r2, r3, lsl #8
 80044e6:	600b      	str	r3, [r1, #0]
		xStart = xTimeNow;
 80044e8:	f8c8 0000 	str.w	r0, [r8]
		xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
 80044ec:	4620      	mov	r0, r4
 80044ee:	f7ff fc0a 	bl	8003d06 <prvIPTimerCheck>
		if( ( xProcessedTCPMessage != pdFALSE ) && ( xWillSleep != pdFALSE ) )
 80044f2:	4b32      	ldr	r3, [pc, #200]	; (80045bc <prvIPTask+0x47c>)
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	b11b      	cbz	r3, 8004500 <prvIPTask+0x3c0>
 80044f8:	f1ba 0f00 	cmp.w	sl, #0
 80044fc:	f43f ae44 	beq.w	8004188 <prvIPTask+0x48>
		if( xCheckTCPSockets != pdFALSE )
 8004500:	2800      	cmp	r0, #0
 8004502:	f47f ae41 	bne.w	8004188 <prvIPTask+0x48>
	if( xARPTimer.bActive != pdFALSE_UNSIGNED )
 8004506:	7833      	ldrb	r3, [r6, #0]
 8004508:	f013 0f01 	tst.w	r3, #1
 800450c:	f43f ae5b 	beq.w	80041c6 <prvIPTask+0x86>
		if( xARPTimer.ulRemainingTime < xMaximumSleepTime )
 8004510:	68f2      	ldr	r2, [r6, #12]
 8004512:	f242 730f 	movw	r3, #9999	; 0x270f
 8004516:	429a      	cmp	r2, r3
 8004518:	f63f ae87 	bhi.w	800422a <prvIPTask+0xea>
			xMaximumSleepTime = xARPTimer.ulReloadTime;
 800451c:	6932      	ldr	r2, [r6, #16]
 800451e:	e654      	b.n	80041ca <prvIPTask+0x8a>
				pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
 8004520:	f8dd a01c 	ldr.w	sl, [sp, #28]
				xAddress.sin_addr = 0u;	/* For the moment. */
 8004524:	2300      	movs	r3, #0
 8004526:	9305      	str	r3, [sp, #20]
				xAddress.sin_port = FreeRTOS_ntohs( pxSocket->usLocalPort );
 8004528:	f8ba 1024 	ldrh.w	r1, [sl, #36]	; 0x24
 800452c:	0a0a      	lsrs	r2, r1, #8
 800452e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8004532:	f8ad 2012 	strh.w	r2, [sp, #18]
				pxSocket->usLocalPort = 0u;
 8004536:	f8aa 3024 	strh.w	r3, [sl, #36]	; 0x24
				vSocketBind( pxSocket, &xAddress, sizeof( xAddress ), pdFALSE );
 800453a:	2208      	movs	r2, #8
 800453c:	a904      	add	r1, sp, #16
 800453e:	4650      	mov	r0, sl
 8004540:	f000 faba 	bl	8004ab8 <vSocketBind>
				pxSocket->xEventBits |= eSOCKET_BOUND;
 8004544:	f8da 3000 	ldr.w	r3, [sl]
 8004548:	f043 0310 	orr.w	r3, r3, #16
 800454c:	f8ca 3000 	str.w	r3, [sl]
				vSocketWakeUpUser( pxSocket );
 8004550:	4650      	mov	r0, sl
 8004552:	f000 fc0b 	bl	8004d6c <vSocketWakeUpUser>
				break;
 8004556:	e7a8      	b.n	80044aa <prvIPTask+0x36a>
				vSocketClose( ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData ) );
 8004558:	9807      	ldr	r0, [sp, #28]
 800455a:	f000 fb49 	bl	8004bf0 <vSocketClose>
				break;
 800455e:	e7a4      	b.n	80044aa <prvIPTask+0x36a>
				vProcessGeneratedUDPPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
 8004560:	9807      	ldr	r0, [sp, #28]
 8004562:	f003 fb7d 	bl	8007c60 <vProcessGeneratedUDPPacket>
				break;
 8004566:	e7a0      	b.n	80044aa <prvIPTask+0x36a>
					vSocketSelect( ( SocketSelect_t * ) ( xReceivedEvent.pvData ) );
 8004568:	9807      	ldr	r0, [sp, #28]
 800456a:	f001 fa59 	bl	8005a20 <vSocketSelect>
				break;
 800456e:	e79c      	b.n	80044aa <prvIPTask+0x36a>
					FreeRTOS_SignalSocket( ( Socket_t ) xReceivedEvent.pvData );
 8004570:	9807      	ldr	r0, [sp, #28]
 8004572:	f001 fb09 	bl	8005b88 <FreeRTOS_SignalSocket>
				break;
 8004576:	e798      	b.n	80044aa <prvIPTask+0x36a>
					xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 8004578:	7823      	ldrb	r3, [r4, #0]
 800457a:	f043 0302 	orr.w	r3, r3, #2
 800457e:	7023      	strb	r3, [r4, #0]
				break;
 8004580:	e793      	b.n	80044aa <prvIPTask+0x36a>
					pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
 8004582:	f8dd a01c 	ldr.w	sl, [sp, #28]
					if( xTCPCheckNewClient( pxSocket ) != pdFALSE )
 8004586:	4650      	mov	r0, sl
 8004588:	f002 ff3a 	bl	8007400 <xTCPCheckNewClient>
 800458c:	2800      	cmp	r0, #0
 800458e:	d08c      	beq.n	80044aa <prvIPTask+0x36a>
						pxSocket->xEventBits |= eSOCKET_ACCEPT;
 8004590:	f8da 3000 	ldr.w	r3, [sl]
 8004594:	f043 0304 	orr.w	r3, r3, #4
 8004598:	f8ca 3000 	str.w	r3, [sl]
						vSocketWakeUpUser( pxSocket );
 800459c:	4650      	mov	r0, sl
 800459e:	f000 fbe5 	bl	8004d6c <vSocketWakeUpUser>
 80045a2:	e782      	b.n	80044aa <prvIPTask+0x36a>
					vTCPNetStat();
 80045a4:	f001 f9a4 	bl	80058f0 <vTCPNetStat>
				break;
 80045a8:	e77f      	b.n	80044aa <prvIPTask+0x36a>
			FreeRTOS_NetworkDown();
 80045aa:	f7ff fd2d 	bl	8004008 <FreeRTOS_NetworkDown>
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 80045ae:	4f04      	ldr	r7, [pc, #16]	; (80045c0 <prvIPTask+0x480>)
		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0u )
 80045b0:	4d04      	ldr	r5, [pc, #16]	; (80045c4 <prvIPTask+0x484>)
 80045b2:	e77e      	b.n	80044b2 <prvIPTask+0x372>
 80045b4:	2000050c 	.word	0x2000050c
 80045b8:	2000053c 	.word	0x2000053c
 80045bc:	20000518 	.word	0x20000518
 80045c0:	200004c8 	.word	0x200004c8
 80045c4:	20000510 	.word	0x20000510

080045c8 <FreeRTOS_GetIPAddress>:
}
 80045c8:	4b01      	ldr	r3, [pc, #4]	; (80045d0 <FreeRTOS_GetIPAddress+0x8>)
 80045ca:	6958      	ldr	r0, [r3, #20]
 80045cc:	4770      	bx	lr
 80045ce:	bf00      	nop
 80045d0:	20000010 	.word	0x20000010

080045d4 <vIPSetDnsTimerEnableState>:
		if( xEnableState != 0 )
 80045d4:	b928      	cbnz	r0, 80045e2 <vIPSetDnsTimerEnableState+0xe>
			xDNSTimer.bActive = pdFALSE;
 80045d6:	4b06      	ldr	r3, [pc, #24]	; (80045f0 <vIPSetDnsTimerEnableState+0x1c>)
 80045d8:	781a      	ldrb	r2, [r3, #0]
 80045da:	f36f 0200 	bfc	r2, #0, #1
 80045de:	701a      	strb	r2, [r3, #0]
 80045e0:	4770      	bx	lr
			xDNSTimer.bActive = pdTRUE;
 80045e2:	4a03      	ldr	r2, [pc, #12]	; (80045f0 <vIPSetDnsTimerEnableState+0x1c>)
 80045e4:	7813      	ldrb	r3, [r2, #0]
 80045e6:	f043 0301 	orr.w	r3, r3, #1
 80045ea:	7013      	strb	r3, [r2, #0]
 80045ec:	4770      	bx	lr
 80045ee:	bf00      	nop
 80045f0:	200004c8 	.word	0x200004c8

080045f4 <vIPReloadDNSTimer>:
	{
 80045f4:	b538      	push	{r3, r4, r5, lr}
 80045f6:	4604      	mov	r4, r0
	pxTimer->ulReloadTime = xTime;
 80045f8:	4d0b      	ldr	r5, [pc, #44]	; (8004628 <vIPReloadDNSTimer+0x34>)
 80045fa:	6128      	str	r0, [r5, #16]
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 80045fc:	1d28      	adds	r0, r5, #4
 80045fe:	f005 fcd3 	bl	8009fa8 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8004602:	60ec      	str	r4, [r5, #12]
	if( xTime == ( TickType_t ) 0 )
 8004604:	b154      	cbz	r4, 800461c <vIPReloadDNSTimer+0x28>
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8004606:	4b08      	ldr	r3, [pc, #32]	; (8004628 <vIPReloadDNSTimer+0x34>)
 8004608:	781a      	ldrb	r2, [r3, #0]
 800460a:	f36f 0241 	bfc	r2, #1, #1
 800460e:	701a      	strb	r2, [r3, #0]
	pxTimer->bActive = pdTRUE_UNSIGNED;
 8004610:	4a05      	ldr	r2, [pc, #20]	; (8004628 <vIPReloadDNSTimer+0x34>)
 8004612:	7813      	ldrb	r3, [r2, #0]
 8004614:	f043 0301 	orr.w	r3, r3, #1
 8004618:	7013      	strb	r3, [r2, #0]
 800461a:	bd38      	pop	{r3, r4, r5, pc}
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 800461c:	782b      	ldrb	r3, [r5, #0]
 800461e:	f043 0302 	orr.w	r3, r3, #2
 8004622:	702b      	strb	r3, [r5, #0]
 8004624:	e7f4      	b.n	8004610 <vIPReloadDNSTimer+0x1c>
 8004626:	bf00      	nop
 8004628:	200004c8 	.word	0x200004c8

0800462c <xIPIsNetworkTaskReady>:
}
 800462c:	4b01      	ldr	r3, [pc, #4]	; (8004634 <xIPIsNetworkTaskReady+0x8>)
 800462e:	6818      	ldr	r0, [r3, #0]
 8004630:	4770      	bx	lr
 8004632:	bf00      	nop
 8004634:	200004f4 	.word	0x200004f4

08004638 <prvValidSocket>:

static BaseType_t prvValidSocket( FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound )
{
BaseType_t xReturn = pdTRUE;

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8004638:	1e43      	subs	r3, r0, #1
 800463a:	f113 0f03 	cmn.w	r3, #3
 800463e:	d80a      	bhi.n	8004656 <prvValidSocket+0x1e>
	{
		xReturn = pdFALSE;
	}
	else if( ( xIsBound != pdFALSE ) && ( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE ) )
 8004640:	b10a      	cbz	r2, 8004646 <prvValidSocket+0xe>
 8004642:	6983      	ldr	r3, [r0, #24]
 8004644:	b14b      	cbz	r3, 800465a <prvValidSocket+0x22>
	{
		/* The caller expects the socket to be bound, but it isn't. */
		xReturn = pdFALSE;
	}
	else if( pxSocket->ucProtocol != ( uint8_t ) xProtocol )
 8004646:	f890 0027 	ldrb.w	r0, [r0, #39]	; 0x27
 800464a:	b2c9      	uxtb	r1, r1
 800464c:	4288      	cmp	r0, r1
 800464e:	bf14      	ite	ne
 8004650:	2000      	movne	r0, #0
 8004652:	2001      	moveq	r0, #1
 8004654:	4770      	bx	lr
		xReturn = pdFALSE;
 8004656:	2000      	movs	r0, #0
 8004658:	4770      	bx	lr
		xReturn = pdFALSE;
 800465a:	2000      	movs	r0, #0
		/* Socket has a wrong type (UDP != TCP). */
		xReturn = pdFALSE;
	}

	return xReturn;
}
 800465c:	4770      	bx	lr

0800465e <pxListFindListItemWithValue>:
/*-----------------------------------------------------------*/

/* pxListFindListItemWithValue: find a list item in a bound socket list
'xWantedItemValue' refers to a port number */
static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItemValue )
{
 800465e:	b538      	push	{r3, r4, r5, lr}
 8004660:	4605      	mov	r5, r0
 8004662:	460c      	mov	r4, r1
const ListItem_t * pxResult = NULL;

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
 8004664:	f7ff ffe2 	bl	800462c <xIPIsNetworkTaskReady>
 8004668:	b190      	cbz	r0, 8004690 <pxListFindListItemWithValue+0x32>
 800466a:	b19d      	cbz	r5, 8004694 <pxListFindListItemWithValue+0x36>
	{
		const ListItem_t *pxIterator;
		const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( pxList );
 800466c:	f105 0208 	add.w	r2, r5, #8
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8004670:	68e8      	ldr	r0, [r5, #12]
 8004672:	4282      	cmp	r2, r0
 8004674:	d010      	beq.n	8004698 <pxListFindListItemWithValue+0x3a>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 8004676:	6803      	ldr	r3, [r0, #0]
 8004678:	429c      	cmp	r4, r3
 800467a:	d006      	beq.n	800468a <pxListFindListItemWithValue+0x2c>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 800467c:	6840      	ldr	r0, [r0, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800467e:	4282      	cmp	r2, r0
 8004680:	d004      	beq.n	800468c <pxListFindListItemWithValue+0x2e>
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 8004682:	6803      	ldr	r3, [r0, #0]
 8004684:	42a3      	cmp	r3, r4
 8004686:	d1f9      	bne.n	800467c <pxListFindListItemWithValue+0x1e>
			}
		}
	}

	return pxResult;
} /* Tested */
 8004688:	bd38      	pop	{r3, r4, r5, pc}
 800468a:	bd38      	pop	{r3, r4, r5, pc}
const ListItem_t * pxResult = NULL;
 800468c:	2000      	movs	r0, #0
 800468e:	bd38      	pop	{r3, r4, r5, pc}
 8004690:	2000      	movs	r0, #0
 8004692:	bd38      	pop	{r3, r4, r5, pc}
 8004694:	2000      	movs	r0, #0
 8004696:	bd38      	pop	{r3, r4, r5, pc}
 8004698:	2000      	movs	r0, #0
	return pxResult;
 800469a:	e7f5      	b.n	8004688 <pxListFindListItemWithValue+0x2a>

0800469c <vNetworkSocketsInit>:
{
 800469c:	b538      	push	{r3, r4, r5, lr}
	vListInitialise( &xBoundUDPSocketsList );
 800469e:	4812      	ldr	r0, [pc, #72]	; (80046e8 <vNetworkSocketsInit+0x4c>)
 80046a0:	f004 f89e 	bl	80087e0 <vListInitialise>
	ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 80046a4:	f007 fbf8 	bl	800be98 <uxRand>
	usNextPortToUse[ socketNEXT_UDP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 80046a8:	4c10      	ldr	r4, [pc, #64]	; (80046ec <vNetworkSocketsInit+0x50>)
	ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 80046aa:	0a43      	lsrs	r3, r0, #9
 80046ac:	4d10      	ldr	r5, [pc, #64]	; (80046f0 <vNetworkSocketsInit+0x54>)
 80046ae:	fba5 2303 	umull	r2, r3, r5, r3
 80046b2:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80046b6:	eba0 2043 	sub.w	r0, r0, r3, lsl #9
 80046ba:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
	usNextPortToUse[ socketNEXT_UDP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 80046be:	8020      	strh	r0, [r4, #0]
		ulNextInitialSequenceNumber = ipconfigRAND32();
 80046c0:	f007 fbea 	bl	800be98 <uxRand>
 80046c4:	4b0b      	ldr	r3, [pc, #44]	; (80046f4 <vNetworkSocketsInit+0x58>)
 80046c6:	6018      	str	r0, [r3, #0]
		ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 80046c8:	f007 fbe6 	bl	800be98 <uxRand>
 80046cc:	0a43      	lsrs	r3, r0, #9
 80046ce:	fba5 2303 	umull	r2, r3, r5, r3
 80046d2:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80046d6:	eba0 2043 	sub.w	r0, r0, r3, lsl #9
 80046da:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
		usNextPortToUse[ socketNEXT_TCP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 80046de:	8060      	strh	r0, [r4, #2]
		vListInitialise( &xBoundTCPSocketsList );
 80046e0:	4805      	ldr	r0, [pc, #20]	; (80046f8 <vNetworkSocketsInit+0x5c>)
 80046e2:	f004 f87d 	bl	80087e0 <vListInitialise>
 80046e6:	bd38      	pop	{r3, r4, r5, pc}
 80046e8:	20002818 	.word	0x20002818
 80046ec:	20000534 	.word	0x20000534
 80046f0:	08421094 	.word	0x08421094
 80046f4:	2000053c 	.word	0x2000053c
 80046f8:	20002804 	.word	0x20002804

080046fc <FreeRTOS_socket>:
{
 80046fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80046fe:	4606      	mov	r6, r0
 8004700:	460c      	mov	r4, r1
 8004702:	4615      	mov	r5, r2
	if( xIPIsNetworkTaskReady() == pdFALSE )
 8004704:	f7ff ff92 	bl	800462c <xIPIsNetworkTaskReady>
 8004708:	b1f0      	cbz	r0, 8004748 <FreeRTOS_socket+0x4c>
		configASSERT( xDomain == FREERTOS_AF_INET );
 800470a:	2e02      	cmp	r6, #2
 800470c:	d004      	beq.n	8004718 <FreeRTOS_socket+0x1c>
 800470e:	f44f 718c 	mov.w	r1, #280	; 0x118
 8004712:	4843      	ldr	r0, [pc, #268]	; (8004820 <FreeRTOS_socket+0x124>)
 8004714:	f007 fafa 	bl	800bd0c <vAssertCalled>
		configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
 8004718:	4b42      	ldr	r3, [pc, #264]	; (8004824 <FreeRTOS_socket+0x128>)
 800471a:	689b      	ldr	r3, [r3, #8]
 800471c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004720:	d004      	beq.n	800472c <FreeRTOS_socket+0x30>
 8004722:	f240 111b 	movw	r1, #283	; 0x11b
 8004726:	483e      	ldr	r0, [pc, #248]	; (8004820 <FreeRTOS_socket+0x124>)
 8004728:	f007 faf0 	bl	800bd0c <vAssertCalled>
			configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
 800472c:	4b3e      	ldr	r3, [pc, #248]	; (8004828 <FreeRTOS_socket+0x12c>)
 800472e:	689b      	ldr	r3, [r3, #8]
 8004730:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004734:	d004      	beq.n	8004740 <FreeRTOS_socket+0x44>
 8004736:	f240 111f 	movw	r1, #287	; 0x11f
 800473a:	4839      	ldr	r0, [pc, #228]	; (8004820 <FreeRTOS_socket+0x124>)
 800473c:	f007 fae6 	bl	800bd0c <vAssertCalled>
		if( xProtocol == FREERTOS_IPPROTO_UDP )
 8004740:	2d11      	cmp	r5, #17
 8004742:	d004      	beq.n	800474e <FreeRTOS_socket+0x52>
		else if( xProtocol == FREERTOS_IPPROTO_TCP )
 8004744:	2d06      	cmp	r5, #6
 8004746:	d02c      	beq.n	80047a2 <FreeRTOS_socket+0xa6>
		xReturn = FREERTOS_INVALID_SOCKET;
 8004748:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800474c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xType != FREERTOS_SOCK_DGRAM )
 800474e:	2c02      	cmp	r4, #2
 8004750:	bf14      	ite	ne
 8004752:	2400      	movne	r4, #0
 8004754:	2401      	moveq	r4, #1
			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
 8004756:	264c      	movs	r6, #76	; 0x4c
	if( prvDetermineSocketSize( xDomain, xType, xProtocol, &uxSocketSize ) == pdFAIL )
 8004758:	2c00      	cmp	r4, #0
 800475a:	d05e      	beq.n	800481a <FreeRTOS_socket+0x11e>
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 800475c:	4630      	mov	r0, r6
 800475e:	f004 fa53 	bl	8008c08 <pvPortMalloc>
		if( pxSocket == NULL )
 8004762:	4604      	mov	r4, r0
 8004764:	b320      	cbz	r0, 80047b0 <FreeRTOS_socket+0xb4>
		else if( ( xEventGroup = xEventGroupCreate() ) == NULL )
 8004766:	f003 ff19 	bl	800859c <xEventGroupCreate>
 800476a:	4607      	mov	r7, r0
 800476c:	b338      	cbz	r0, 80047be <FreeRTOS_socket+0xc2>
			memset( pxSocket, '\0', uxSocketSize );
 800476e:	4632      	mov	r2, r6
 8004770:	2100      	movs	r1, #0
 8004772:	4620      	mov	r0, r4
 8004774:	f007 fc96 	bl	800c0a4 <memset>
			pxSocket->xEventGroup = xEventGroup;
 8004778:	6067      	str	r7, [r4, #4]
			if( xProtocol == FREERTOS_IPPROTO_UDP )
 800477a:	2d11      	cmp	r5, #17
 800477c:	d025      	beq.n	80047ca <FreeRTOS_socket+0xce>
			vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 800477e:	f104 0008 	add.w	r0, r4, #8
 8004782:	f004 f838 	bl	80087f6 <vListInitialiseItem>
			listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
 8004786:	6164      	str	r4, [r4, #20]
			pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 8004788:	f241 3388 	movw	r3, #5000	; 0x1388
 800478c:	61e3      	str	r3, [r4, #28]
			pxSocket->xSendBlockTime    = ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 800478e:	6223      	str	r3, [r4, #32]
			pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8004790:	2302      	movs	r3, #2
 8004792:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			pxSocket->ucProtocol        = ( uint8_t ) xProtocol; /* protocol: UDP or TCP */
 8004796:	f884 5027 	strb.w	r5, [r4, #39]	; 0x27
				if( xProtocol == FREERTOS_IPPROTO_TCP )
 800479a:	2d06      	cmp	r5, #6
 800479c:	d02a      	beq.n	80047f4 <FreeRTOS_socket+0xf8>
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 800479e:	4620      	mov	r0, r4
	return xReturn;
 80047a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xType != FREERTOS_SOCK_STREAM )
 80047a2:	2c01      	cmp	r4, #1
 80047a4:	bf14      	ite	ne
 80047a6:	2400      	movne	r4, #0
 80047a8:	2401      	moveq	r4, #1
			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
 80047aa:	f44f 76d0 	mov.w	r6, #416	; 0x1a0
 80047ae:	e7d3      	b.n	8004758 <FreeRTOS_socket+0x5c>
			iptraceFAILED_TO_CREATE_SOCKET();
 80047b0:	2100      	movs	r1, #0
 80047b2:	2008      	movs	r0, #8
 80047b4:	f006 fd14 	bl	800b1e0 <vExampleDebugStatUpdate>
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 80047b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80047bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vPortFreeSocket( pxSocket );
 80047be:	4620      	mov	r0, r4
 80047c0:	f004 fa88 	bl	8008cd4 <vPortFree>
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 80047c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80047c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 80047ca:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80047ce:	f004 f807 	bl	80087e0 <vListInitialise>
			vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 80047d2:	f104 0008 	add.w	r0, r4, #8
 80047d6:	f004 f80e 	bl	80087f6 <vListInitialiseItem>
			listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
 80047da:	6164      	str	r4, [r4, #20]
			pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 80047dc:	f241 3388 	movw	r3, #5000	; 0x1388
 80047e0:	61e3      	str	r3, [r4, #28]
			pxSocket->xSendBlockTime    = ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 80047e2:	6223      	str	r3, [r4, #32]
			pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 80047e4:	2302      	movs	r3, #2
 80047e6:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			pxSocket->ucProtocol        = ( uint8_t ) xProtocol; /* protocol: UDP or TCP */
 80047ea:	2311      	movs	r3, #17
 80047ec:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 80047f0:	4620      	mov	r0, r4
 80047f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					pxSocket->u.xTCP.usInitMSS    = pxSocket->u.xTCP.usCurMSS = ipconfigTCP_MSS;
 80047f4:	f240 53b4 	movw	r3, #1460	; 0x5b4
 80047f8:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
 80047fc:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
					pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 8004800:	f241 131c 	movw	r3, #4380	; 0x111c
 8004804:	66e3      	str	r3, [r4, #108]	; 0x6c
					pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH, ipconfigTCP_MSS );
 8004806:	f640 3368 	movw	r3, #2920	; 0xb68
 800480a:	6723      	str	r3, [r4, #112]	; 0x70
						pxSocket->u.xTCP.uxRxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxRxStreamSize / 2 ) / ipconfigTCP_MSS );
 800480c:	2301      	movs	r3, #1
 800480e:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
						pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxTxStreamSize / 2 ) / ipconfigTCP_MSS );
 8004812:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 8004816:	4620      	mov	r0, r4
 8004818:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		xReturn = FREERTOS_INVALID_SOCKET;
 800481a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800481e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004820:	0800c4a4 	.word	0x0800c4a4
 8004824:	20002818 	.word	0x20002818
 8004828:	20002804 	.word	0x20002804

0800482c <FreeRTOS_recvfrom>:
{
 800482c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004830:	b086      	sub	sp, #24
 8004832:	4604      	mov	r4, r0
 8004834:	4689      	mov	r9, r1
 8004836:	4692      	mov	sl, r2
 8004838:	4698      	mov	r8, r3
TickType_t xRemainingTime = ( TickType_t ) 0; /* Obsolete assignment, but some compilers output a warning if its not done. */
 800483a:	2300      	movs	r3, #0
 800483c:	9305      	str	r3, [sp, #20]
	if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE )
 800483e:	2201      	movs	r2, #1
 8004840:	2111      	movs	r1, #17
 8004842:	f7ff fef9 	bl	8004638 <prvValidSocket>
 8004846:	2800      	cmp	r0, #0
 8004848:	d05a      	beq.n	8004900 <FreeRTOS_recvfrom+0xd4>
	lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 800484a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	while( lPacketCount == 0 )
 800484c:	2d00      	cmp	r5, #0
 800484e:	d15a      	bne.n	8004906 <FreeRTOS_recvfrom+0xda>
 8004850:	2300      	movs	r3, #0
			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8004852:	f008 0710 	and.w	r7, r8, #16
		xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_RECEIVE | eSOCKET_INTR,
 8004856:	461e      	mov	r6, r3
 8004858:	e025      	b.n	80048a6 <FreeRTOS_recvfrom+0x7a>
					xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_INTR,
 800485a:	6860      	ldr	r0, [r4, #4]
 800485c:	9300      	str	r3, [sp, #0]
 800485e:	2201      	movs	r2, #1
 8004860:	2140      	movs	r1, #64	; 0x40
 8004862:	f003 fea9 	bl	80085b8 <xEventGroupWaitBits>
 8004866:	4605      	mov	r5, r0
	else if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004868:	f015 0f40 	tst.w	r5, #64	; 0x40
		lReturn = -pdFREERTOS_ERRNO_EINTR;
 800486c:	bf18      	it	ne
 800486e:	f06f 0403 	mvnne.w	r4, #3
	else if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004872:	d03e      	beq.n	80048f2 <FreeRTOS_recvfrom+0xc6>
}
 8004874:	4620      	mov	r0, r4
 8004876:	b006      	add	sp, #24
 8004878:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_RECEIVE | eSOCKET_INTR,
 800487c:	9b05      	ldr	r3, [sp, #20]
 800487e:	9300      	str	r3, [sp, #0]
 8004880:	4633      	mov	r3, r6
 8004882:	2201      	movs	r2, #1
 8004884:	2141      	movs	r1, #65	; 0x41
 8004886:	6860      	ldr	r0, [r4, #4]
 8004888:	f003 fe96 	bl	80085b8 <xEventGroupWaitBits>
 800488c:	4605      	mov	r5, r0
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 800488e:	f010 0f40 	tst.w	r0, #64	; 0x40
 8004892:	d114      	bne.n	80048be <FreeRTOS_recvfrom+0x92>
		if( lPacketCount != 0 )
 8004894:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004896:	2b00      	cmp	r3, #0
 8004898:	d135      	bne.n	8004906 <FreeRTOS_recvfrom+0xda>
		if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) )
 800489a:	a905      	add	r1, sp, #20
 800489c:	a803      	add	r0, sp, #12
 800489e:	f005 fb99 	bl	8009fd4 <xTaskCheckForTimeOut>
 80048a2:	2301      	movs	r3, #1
 80048a4:	bb28      	cbnz	r0, 80048f2 <FreeRTOS_recvfrom+0xc6>
		if( xTimed == pdFALSE )
 80048a6:	2b00      	cmp	r3, #0
 80048a8:	d1e8      	bne.n	800487c <FreeRTOS_recvfrom+0x50>
			xRemainingTime = pxSocket->xReceiveBlockTime;
 80048aa:	69e3      	ldr	r3, [r4, #28]
 80048ac:	9305      	str	r3, [sp, #20]
			if( xRemainingTime == ( TickType_t ) 0 )
 80048ae:	2b00      	cmp	r3, #0
 80048b0:	d0d3      	beq.n	800485a <FreeRTOS_recvfrom+0x2e>
			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 80048b2:	2f00      	cmp	r7, #0
 80048b4:	d1d8      	bne.n	8004868 <FreeRTOS_recvfrom+0x3c>
			vTaskSetTimeOutState( &xTimeOut );
 80048b6:	a803      	add	r0, sp, #12
 80048b8:	f005 fb76 	bl	8009fa8 <vTaskSetTimeOutState>
 80048bc:	e7de      	b.n	800487c <FreeRTOS_recvfrom+0x50>
				if( ( xEventBits & eSOCKET_RECEIVE ) != 0 )
 80048be:	f010 0f01 	tst.w	r0, #1
 80048c2:	d102      	bne.n	80048ca <FreeRTOS_recvfrom+0x9e>
		lReturn = -pdFREERTOS_ERRNO_EINTR;
 80048c4:	f06f 0403 	mvn.w	r4, #3
 80048c8:	e7d4      	b.n	8004874 <FreeRTOS_recvfrom+0x48>
					xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_RECEIVE );
 80048ca:	2101      	movs	r1, #1
 80048cc:	6860      	ldr	r0, [r4, #4]
 80048ce:	f003 ff17 	bl	8008700 <xEventGroupSetBits>
 80048d2:	e7f7      	b.n	80048c4 <FreeRTOS_recvfrom+0x98>
				uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 80048d4:	4628      	mov	r0, r5
 80048d6:	f003 ffb7 	bl	8008848 <uxListRemove>
 80048da:	e01b      	b.n	8004914 <FreeRTOS_recvfrom+0xe8>
				iptraceRECVFROM_DISCARDING_BYTES( ( xBufferLength - lReturn ) );
 80048dc:	2100      	movs	r1, #0
 80048de:	2009      	movs	r0, #9
 80048e0:	f006 fc7e 	bl	800b1e0 <vExampleDebugStatUpdate>
				lReturn = ( int32_t )xBufferLength;
 80048e4:	4654      	mov	r4, sl
 80048e6:	e024      	b.n	8004932 <FreeRTOS_recvfrom+0x106>
			*( ( void** ) pvBuffer ) = ( void * ) ( &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ) );
 80048e8:	69ab      	ldr	r3, [r5, #24]
 80048ea:	332a      	adds	r3, #42	; 0x2a
 80048ec:	f8c9 3000 	str.w	r3, [r9]
 80048f0:	e7c0      	b.n	8004874 <FreeRTOS_recvfrom+0x48>
		iptraceRECVFROM_TIMEOUT();
 80048f2:	2100      	movs	r1, #0
 80048f4:	200d      	movs	r0, #13
 80048f6:	f006 fc73 	bl	800b1e0 <vExampleDebugStatUpdate>
		lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 80048fa:	f06f 040a 	mvn.w	r4, #10
 80048fe:	e7b9      	b.n	8004874 <FreeRTOS_recvfrom+0x48>
		return -pdFREERTOS_ERRNO_EINVAL;
 8004900:	f06f 0415 	mvn.w	r4, #21
 8004904:	e7b6      	b.n	8004874 <FreeRTOS_recvfrom+0x48>
		taskENTER_CRITICAL();
 8004906:	f003 fff5 	bl	80088f4 <vPortEnterCritical>
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 800490a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800490c:	68dd      	ldr	r5, [r3, #12]
			if( ( xFlags & FREERTOS_MSG_PEEK ) == 0 )
 800490e:	f018 0604 	ands.w	r6, r8, #4
 8004912:	d0df      	beq.n	80048d4 <FreeRTOS_recvfrom+0xa8>
		taskEXIT_CRITICAL();
 8004914:	f004 f810 	bl	8008938 <vPortExitCritical>
		lReturn = ( int32_t ) pxNetworkBuffer->xDataLength;
 8004918:	69ec      	ldr	r4, [r5, #28]
		if( pxSourceAddress != NULL )
 800491a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800491c:	b123      	cbz	r3, 8004928 <FreeRTOS_recvfrom+0xfc>
			pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
 800491e:	8c2b      	ldrh	r3, [r5, #32]
 8004920:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8004922:	8053      	strh	r3, [r2, #2]
			pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
 8004924:	696b      	ldr	r3, [r5, #20]
 8004926:	6053      	str	r3, [r2, #4]
		if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8004928:	f018 0f01 	tst.w	r8, #1
 800492c:	d1dc      	bne.n	80048e8 <FreeRTOS_recvfrom+0xbc>
			if( lReturn > ( int32_t ) xBufferLength )
 800492e:	4554      	cmp	r4, sl
 8004930:	dcd4      	bgt.n	80048dc <FreeRTOS_recvfrom+0xb0>
			memcpy( pvBuffer, ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( size_t )lReturn );
 8004932:	69a9      	ldr	r1, [r5, #24]
 8004934:	4622      	mov	r2, r4
 8004936:	312a      	adds	r1, #42	; 0x2a
 8004938:	4648      	mov	r0, r9
 800493a:	f007 fb8e 	bl	800c05a <memcpy>
			if( ( xFlags & FREERTOS_MSG_PEEK ) == 0 )
 800493e:	2e00      	cmp	r6, #0
 8004940:	d198      	bne.n	8004874 <FreeRTOS_recvfrom+0x48>
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8004942:	4628      	mov	r0, r5
 8004944:	f003 fa90 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
 8004948:	e794      	b.n	8004874 <FreeRTOS_recvfrom+0x48>

0800494a <FreeRTOS_bind>:
	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 800494a:	1e43      	subs	r3, r0, #1
 800494c:	f113 0f03 	cmn.w	r3, #3
 8004950:	d829      	bhi.n	80049a6 <FreeRTOS_bind+0x5c>
	else if( socketSOCKET_IS_BOUND( pxSocket) != pdFALSE )
 8004952:	6983      	ldr	r3, [r0, #24]
 8004954:	bb53      	cbnz	r3, 80049ac <FreeRTOS_bind+0x62>
{
 8004956:	b510      	push	{r4, lr}
 8004958:	b084      	sub	sp, #16
		xBindEvent.eEventType = eSocketBindEvent;
 800495a:	2308      	movs	r3, #8
 800495c:	f88d 3008 	strb.w	r3, [sp, #8]
		xBindEvent.pvData = ( void * ) xSocket;
 8004960:	9003      	str	r0, [sp, #12]
		if( pxAddress != NULL )
 8004962:	b1e9      	cbz	r1, 80049a0 <FreeRTOS_bind+0x56>
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 8004964:	884a      	ldrh	r2, [r1, #2]
 8004966:	fa22 f303 	lsr.w	r3, r2, r3
 800496a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800496e:	8483      	strh	r3, [r0, #36]	; 0x24
 8004970:	4604      	mov	r4, r0
		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 8004972:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004976:	a802      	add	r0, sp, #8
 8004978:	f7ff fb0e 	bl	8003f98 <xSendEventStructToIPTask>
 800497c:	b1c8      	cbz	r0, 80049b2 <FreeRTOS_bind+0x68>
			xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_BOUND, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, portMAX_DELAY );
 800497e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004982:	9300      	str	r3, [sp, #0]
 8004984:	2300      	movs	r3, #0
 8004986:	2201      	movs	r2, #1
 8004988:	2110      	movs	r1, #16
 800498a:	6860      	ldr	r0, [r4, #4]
 800498c:	f003 fe14 	bl	80085b8 <xEventGroupWaitBits>
			if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
 8004990:	69a3      	ldr	r3, [r4, #24]
				xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8004992:	2b00      	cmp	r3, #0
 8004994:	bf14      	ite	ne
 8004996:	2000      	movne	r0, #0
 8004998:	f06f 0015 	mvneq.w	r0, #21
}
 800499c:	b004      	add	sp, #16
 800499e:	bd10      	pop	{r4, pc}
			pxSocket->usLocalPort = 0u;
 80049a0:	2300      	movs	r3, #0
 80049a2:	8483      	strh	r3, [r0, #36]	; 0x24
 80049a4:	e7e4      	b.n	8004970 <FreeRTOS_bind+0x26>
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 80049a6:	f06f 0015 	mvn.w	r0, #21
 80049aa:	4770      	bx	lr
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 80049ac:	f06f 0015 	mvn.w	r0, #21
 80049b0:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_ECANCELED;
 80049b2:	f06f 008b 	mvn.w	r0, #139	; 0x8b
 80049b6:	e7f1      	b.n	800499c <FreeRTOS_bind+0x52>

080049b8 <FreeRTOS_sendto>:
{
 80049b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80049bc:	b087      	sub	sp, #28
 80049be:	4607      	mov	r7, r0
 80049c0:	4614      	mov	r4, r2
 80049c2:	461e      	mov	r6, r3
 80049c4:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 80049c8:	2303      	movs	r3, #3
 80049ca:	f88d 3010 	strb.w	r3, [sp, #16]
 80049ce:	2300      	movs	r3, #0
 80049d0:	9305      	str	r3, [sp, #20]
	configASSERT( pvBuffer );
 80049d2:	4689      	mov	r9, r1
 80049d4:	b339      	cbz	r1, 8004a26 <FreeRTOS_sendto+0x6e>
	if( xTotalDataLength <= ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH )
 80049d6:	f5b4 6fb8 	cmp.w	r4, #1472	; 0x5c0
 80049da:	d865      	bhi.n	8004aa8 <FreeRTOS_sendto+0xf0>
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
 80049dc:	69bb      	ldr	r3, [r7, #24]
 80049de:	b343      	cbz	r3, 8004a32 <FreeRTOS_sendto+0x7a>
			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 80049e0:	f016 0f10 	tst.w	r6, #16
			xTicksToWait = pxSocket->xSendBlockTime;
 80049e4:	bf0c      	ite	eq
 80049e6:	6a3b      	ldreq	r3, [r7, #32]
				xTicksToWait = ( TickType_t ) 0;
 80049e8:	2300      	movne	r3, #0
 80049ea:	9301      	str	r3, [sp, #4]
			if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 80049ec:	f016 0601 	ands.w	r6, r6, #1
 80049f0:	d12c      	bne.n	8004a4c <FreeRTOS_sendto+0x94>
				vTaskSetTimeOutState( &xTimeOut );
 80049f2:	a802      	add	r0, sp, #8
 80049f4:	f005 fad8 	bl	8009fa8 <vTaskSetTimeOutState>
				pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( xTotalDataLength + sizeof( UDPPacket_t ), xTicksToWait );
 80049f8:	9901      	ldr	r1, [sp, #4]
 80049fa:	f104 002a 	add.w	r0, r4, #42	; 0x2a
 80049fe:	f003 fa59 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>
				if( pxNetworkBuffer != NULL )
 8004a02:	4605      	mov	r5, r0
 8004a04:	2800      	cmp	r0, #0
 8004a06:	d049      	beq.n	8004a9c <FreeRTOS_sendto+0xe4>
					memcpy( ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( void * ) pvBuffer, xTotalDataLength );
 8004a08:	6980      	ldr	r0, [r0, #24]
 8004a0a:	4622      	mov	r2, r4
 8004a0c:	4649      	mov	r1, r9
 8004a0e:	302a      	adds	r0, #42	; 0x2a
 8004a10:	f007 fb23 	bl	800c05a <memcpy>
					if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
 8004a14:	a901      	add	r1, sp, #4
 8004a16:	a802      	add	r0, sp, #8
 8004a18:	f005 fadc 	bl	8009fd4 <xTaskCheckForTimeOut>
 8004a1c:	2801      	cmp	r0, #1
 8004a1e:	d11a      	bne.n	8004a56 <FreeRTOS_sendto+0x9e>
						xTicksToWait = ( TickType_t ) 0;
 8004a20:	2300      	movs	r3, #0
 8004a22:	9301      	str	r3, [sp, #4]
 8004a24:	e017      	b.n	8004a56 <FreeRTOS_sendto+0x9e>
	configASSERT( pvBuffer );
 8004a26:	f240 313d 	movw	r1, #829	; 0x33d
 8004a2a:	4822      	ldr	r0, [pc, #136]	; (8004ab4 <FreeRTOS_sendto+0xfc>)
 8004a2c:	f007 f96e 	bl	800bd0c <vAssertCalled>
 8004a30:	e7d1      	b.n	80049d6 <FreeRTOS_sendto+0x1e>
			( FreeRTOS_bind( xSocket, NULL, 0u ) == 0 ) )
 8004a32:	2200      	movs	r2, #0
 8004a34:	4611      	mov	r1, r2
 8004a36:	4638      	mov	r0, r7
 8004a38:	f7ff ff87 	bl	800494a <FreeRTOS_bind>
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
 8004a3c:	2800      	cmp	r0, #0
 8004a3e:	d0cf      	beq.n	80049e0 <FreeRTOS_sendto+0x28>
			iptraceSENDTO_SOCKET_NOT_BOUND();
 8004a40:	2100      	movs	r1, #0
 8004a42:	200f      	movs	r0, #15
 8004a44:	f006 fbcc 	bl	800b1e0 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 8004a48:	2000      	movs	r0, #0
 8004a4a:	e01e      	b.n	8004a8a <FreeRTOS_sendto+0xd2>
				pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( (void*)pvBuffer );
 8004a4c:	4648      	mov	r0, r9
 8004a4e:	f7ff f9b3 	bl	8003db8 <pxUDPPayloadBuffer_to_NetworkBuffer>
			if( pxNetworkBuffer != NULL )
 8004a52:	4605      	mov	r5, r0
 8004a54:	b310      	cbz	r0, 8004a9c <FreeRTOS_sendto+0xe4>
				pxNetworkBuffer->xDataLength = xTotalDataLength;
 8004a56:	61ec      	str	r4, [r5, #28]
				pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
 8004a58:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 8004a5c:	842b      	strh	r3, [r5, #32]
				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
 8004a5e:	68bb      	ldr	r3, [r7, #8]
 8004a60:	846b      	strh	r3, [r5, #34]	; 0x22
				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
 8004a62:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8004a66:	616b      	str	r3, [r5, #20]
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
 8004a68:	69ab      	ldr	r3, [r5, #24]
 8004a6a:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 8004a6e:	719a      	strb	r2, [r3, #6]
				xStackTxEvent.pvData = pxNetworkBuffer;
 8004a70:	9505      	str	r5, [sp, #20]
				if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
 8004a72:	9901      	ldr	r1, [sp, #4]
 8004a74:	a804      	add	r0, sp, #16
 8004a76:	f7ff fa8f 	bl	8003f98 <xSendEventStructToIPTask>
 8004a7a:	2801      	cmp	r0, #1
 8004a7c:	d008      	beq.n	8004a90 <FreeRTOS_sendto+0xd8>
					if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8004a7e:	b14e      	cbz	r6, 8004a94 <FreeRTOS_sendto+0xdc>
					iptraceSTACK_TX_EVENT_LOST( ipSTACK_TX_EVENT );
 8004a80:	2100      	movs	r1, #0
 8004a82:	200b      	movs	r0, #11
 8004a84:	f006 fbac 	bl	800b1e0 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 8004a88:	2000      	movs	r0, #0
} /* Tested */
 8004a8a:	b007      	add	sp, #28
 8004a8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					lReturn = ( int32_t ) xTotalDataLength;
 8004a90:	4620      	mov	r0, r4
 8004a92:	e7fa      	b.n	8004a8a <FreeRTOS_sendto+0xd2>
						vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8004a94:	4628      	mov	r0, r5
 8004a96:	f003 f9e7 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
 8004a9a:	e7f1      	b.n	8004a80 <FreeRTOS_sendto+0xc8>
				iptraceNO_BUFFER_FOR_SENDTO();
 8004a9c:	2100      	movs	r1, #0
 8004a9e:	2010      	movs	r0, #16
 8004aa0:	f006 fb9e 	bl	800b1e0 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 8004aa4:	2000      	movs	r0, #0
 8004aa6:	e7f0      	b.n	8004a8a <FreeRTOS_sendto+0xd2>
		iptraceSENDTO_DATA_TOO_LONG();
 8004aa8:	2100      	movs	r1, #0
 8004aaa:	200e      	movs	r0, #14
 8004aac:	f006 fb98 	bl	800b1e0 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 8004ab0:	2000      	movs	r0, #0
	return lReturn;
 8004ab2:	e7ea      	b.n	8004a8a <FreeRTOS_sendto+0xd2>
 8004ab4:	0800c4a4 	.word	0x0800c4a4

08004ab8 <vSocketBind>:
{
 8004ab8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004abc:	b085      	sub	sp, #20
 8004abe:	4607      	mov	r7, r0
 8004ac0:	4688      	mov	r8, r1
 8004ac2:	469a      	mov	sl, r3
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8004ac4:	f890 9027 	ldrb.w	r9, [r0, #39]	; 0x27
		pxSocketList = &xBoundUDPSocketsList;
 8004ac8:	4b39      	ldr	r3, [pc, #228]	; (8004bb0 <vSocketBind+0xf8>)
 8004aca:	4a3a      	ldr	r2, [pc, #232]	; (8004bb4 <vSocketBind+0xfc>)
 8004acc:	f1b9 0f06 	cmp.w	r9, #6
 8004ad0:	bf0c      	ite	eq
 8004ad2:	4691      	moveq	r9, r2
 8004ad4:	4699      	movne	r9, r3
	configASSERT( pxSocket );
 8004ad6:	b340      	cbz	r0, 8004b2a <vSocketBind+0x72>
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 8004ad8:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8004adc:	d02b      	beq.n	8004b36 <vSocketBind+0x7e>
		if( pxAddress == NULL )
 8004ade:	f1b8 0f00 	cmp.w	r8, #0
 8004ae2:	d02e      	beq.n	8004b42 <vSocketBind+0x8a>
		if( pxAddress->sin_port == 0u )
 8004ae4:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 8004ae8:	b38b      	cbz	r3, 8004b4e <vSocketBind+0x96>
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 8004aea:	f1ba 0f00 	cmp.w	sl, #0
 8004aee:	d003      	beq.n	8004af8 <vSocketBind+0x40>
 8004af0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8004af4:	2b06      	cmp	r3, #6
 8004af6:	d006      	beq.n	8004b06 <vSocketBind+0x4e>
			( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 8004af8:	f8b8 1002 	ldrh.w	r1, [r8, #2]
 8004afc:	4648      	mov	r0, r9
 8004afe:	f7ff fdae 	bl	800465e <pxListFindListItemWithValue>
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 8004b02:	2800      	cmp	r0, #0
 8004b04:	d14c      	bne.n	8004ba0 <vSocketBind+0xe8>
			socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
 8004b06:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 8004b0a:	60bb      	str	r3, [r7, #8]
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 8004b0c:	f8b8 2002 	ldrh.w	r2, [r8, #2]
 8004b10:	0a13      	lsrs	r3, r2, #8
 8004b12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004b16:	84bb      	strh	r3, [r7, #36]	; 0x24
				vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
 8004b18:	f107 0108 	add.w	r1, r7, #8
 8004b1c:	4648      	mov	r0, r9
 8004b1e:	f003 fe6d 	bl	80087fc <vListInsertEnd>
BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
 8004b22:	2000      	movs	r0, #0
} /* Tested */
 8004b24:	b005      	add	sp, #20
 8004b26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	configASSERT( pxSocket );
 8004b2a:	f240 4115 	movw	r1, #1045	; 0x415
 8004b2e:	4822      	ldr	r0, [pc, #136]	; (8004bb8 <vSocketBind+0x100>)
 8004b30:	f007 f8ec 	bl	800bd0c <vAssertCalled>
 8004b34:	e7d3      	b.n	8004ade <vSocketBind+0x26>
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 8004b36:	f240 4116 	movw	r1, #1046	; 0x416
 8004b3a:	481f      	ldr	r0, [pc, #124]	; (8004bb8 <vSocketBind+0x100>)
 8004b3c:	f007 f8e6 	bl	800bd0c <vAssertCalled>
 8004b40:	e7cd      	b.n	8004ade <vSocketBind+0x26>
			pxAddress->sin_port = 0u;
 8004b42:	2300      	movs	r3, #0
 8004b44:	f8ad 300a 	strh.w	r3, [sp, #10]
			pxAddress = &xAddress;
 8004b48:	f10d 0808 	add.w	r8, sp, #8
 8004b4c:	e7ca      	b.n	8004ae4 <vSocketBind+0x2c>
	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
 8004b4e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
		pxList = &xBoundUDPSocketsList;
 8004b52:	4a17      	ldr	r2, [pc, #92]	; (8004bb0 <vSocketBind+0xf8>)
 8004b54:	4917      	ldr	r1, [pc, #92]	; (8004bb4 <vSocketBind+0xfc>)
 8004b56:	2b06      	cmp	r3, #6
 8004b58:	bf18      	it	ne
 8004b5a:	4611      	movne	r1, r2
 8004b5c:	9101      	str	r1, [sp, #4]
 8004b5e:	2b06      	cmp	r3, #6
 8004b60:	bf0c      	ite	eq
 8004b62:	2601      	moveq	r6, #1
 8004b64:	2600      	movne	r6, #0
		++( usNextPortToUse[ xIndex ] );
 8004b66:	4d15      	ldr	r5, [pc, #84]	; (8004bbc <vSocketBind+0x104>)
			usNextPortToUse[ xIndex ] = socketAUTO_PORT_ALLOCATION_RESET_NUMBER;
 8004b68:	f44f 4b41 	mov.w	fp, #49408	; 0xc100
		++( usNextPortToUse[ xIndex ] );
 8004b6c:	f835 3016 	ldrh.w	r3, [r5, r6, lsl #1]
 8004b70:	3301      	adds	r3, #1
 8004b72:	b29b      	uxth	r3, r3
		if( usNextPortToUse[ xIndex ] >= socketAUTO_PORT_ALLOCATION_MAX_NUMBER )
 8004b74:	f5b3 4f7f 	cmp.w	r3, #65280	; 0xff00
		++( usNextPortToUse[ xIndex ] );
 8004b78:	bf34      	ite	cc
 8004b7a:	f825 3016 	strhcc.w	r3, [r5, r6, lsl #1]
			usNextPortToUse[ xIndex ] = socketAUTO_PORT_ALLOCATION_RESET_NUMBER;
 8004b7e:	f825 b016 	strhcs.w	fp, [r5, r6, lsl #1]
		usResult = FreeRTOS_htons( usNextPortToUse[ xIndex ] );
 8004b82:	f835 3016 	ldrh.w	r3, [r5, r6, lsl #1]
 8004b86:	0a1c      	lsrs	r4, r3, #8
 8004b88:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8004b8c:	b2a4      	uxth	r4, r4
		if( pxListFindListItemWithValue( pxList, ( TickType_t ) usResult ) == NULL )
 8004b8e:	4621      	mov	r1, r4
 8004b90:	9801      	ldr	r0, [sp, #4]
 8004b92:	f7ff fd64 	bl	800465e <pxListFindListItemWithValue>
 8004b96:	2800      	cmp	r0, #0
 8004b98:	d1e8      	bne.n	8004b6c <vSocketBind+0xb4>
			pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
 8004b9a:	f8a8 4002 	strh.w	r4, [r8, #2]
 8004b9e:	e7a4      	b.n	8004aea <vSocketBind+0x32>
		iptraceBIND_FAILED( xSocket, ( FreeRTOS_ntohs( pxAddress->sin_port ) ) );
 8004ba0:	2100      	movs	r1, #0
 8004ba2:	200c      	movs	r0, #12
 8004ba4:	f006 fb1c 	bl	800b1e0 <vExampleDebugStatUpdate>
 8004ba8:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 8004bac:	e7ba      	b.n	8004b24 <vSocketBind+0x6c>
 8004bae:	bf00      	nop
 8004bb0:	20002818 	.word	0x20002818
 8004bb4:	20002804 	.word	0x20002804
 8004bb8:	0800c4a4 	.word	0x0800c4a4
 8004bbc:	20000534 	.word	0x20000534

08004bc0 <FreeRTOS_closesocket>:
{
 8004bc0:	b500      	push	{lr}
 8004bc2:	b083      	sub	sp, #12
xCloseEvent.eEventType = eSocketCloseEvent;
 8004bc4:	2309      	movs	r3, #9
 8004bc6:	f88d 3000 	strb.w	r3, [sp]
xCloseEvent.pvData = ( void * ) xSocket;
 8004bca:	9001      	str	r0, [sp, #4]
	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
 8004bcc:	3801      	subs	r0, #1
 8004bce:	f110 0f03 	cmn.w	r0, #3
 8004bd2:	d903      	bls.n	8004bdc <FreeRTOS_closesocket+0x1c>
		xResult = 0;
 8004bd4:	2000      	movs	r0, #0
}
 8004bd6:	b003      	add	sp, #12
 8004bd8:	f85d fb04 	ldr.w	pc, [sp], #4
		if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) 0 ) == pdFAIL )
 8004bdc:	2100      	movs	r1, #0
 8004bde:	4668      	mov	r0, sp
 8004be0:	f7ff f9da 	bl	8003f98 <xSendEventStructToIPTask>
 8004be4:	2800      	cmp	r0, #0
			xResult = 1;
 8004be6:	bf0c      	ite	eq
 8004be8:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
 8004bec:	2001      	movne	r0, #1
 8004bee:	e7f2      	b.n	8004bd6 <FreeRTOS_closesocket+0x16>

08004bf0 <vSocketClose>:
{
 8004bf0:	b538      	push	{r3, r4, r5, lr}
 8004bf2:	4604      	mov	r4, r0
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8004bf4:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8004bf8:	2b06      	cmp	r3, #6
 8004bfa:	d00f      	beq.n	8004c1c <vSocketClose+0x2c>
	if( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE )
 8004bfc:	69a3      	ldr	r3, [r4, #24]
 8004bfe:	2b00      	cmp	r3, #0
 8004c00:	d137      	bne.n	8004c72 <vSocketClose+0x82>
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8004c02:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8004c06:	2b11      	cmp	r3, #17
 8004c08:	d038      	beq.n	8004c7c <vSocketClose+0x8c>
	if( pxSocket->xEventGroup )
 8004c0a:	6860      	ldr	r0, [r4, #4]
 8004c0c:	b108      	cbz	r0, 8004c12 <vSocketClose+0x22>
		vEventGroupDelete( pxSocket->xEventGroup );
 8004c0e:	f003 fdc3 	bl	8008798 <vEventGroupDelete>
	vPortFreeSocket( pxSocket );
 8004c12:	4620      	mov	r0, r4
 8004c14:	f004 f85e 	bl	8008cd4 <vPortFree>
} /* Tested */
 8004c18:	2000      	movs	r0, #0
 8004c1a:	bd38      	pop	{r3, r4, r5, pc}
				if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8004c1c:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8004c1e:	b108      	cbz	r0, 8004c24 <vSocketClose+0x34>
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8004c20:	f003 f922 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
				vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
 8004c24:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
 8004c28:	f002 fd59 	bl	80076de <vTCPWindowDestroy>
			if( pxSocket->u.xTCP.rxStream != NULL )
 8004c2c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8004c2e:	b108      	cbz	r0, 8004c34 <vSocketClose+0x44>
				vPortFreeLarge( pxSocket->u.xTCP.rxStream );
 8004c30:	f004 f850 	bl	8008cd4 <vPortFree>
			if( pxSocket->u.xTCP.txStream != NULL )
 8004c34:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8004c36:	b108      	cbz	r0, 8004c3c <vSocketClose+0x4c>
				vPortFreeLarge( pxSocket->u.xTCP.txStream );
 8004c38:	f004 f84c 	bl	8008cd4 <vPortFree>
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
 8004c3c:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8004c3e:	4a17      	ldr	r2, [pc, #92]	; (8004c9c <vSocketClose+0xac>)
 8004c40:	68d3      	ldr	r3, [r2, #12]
 8004c42:	3208      	adds	r2, #8
 8004c44:	4293      	cmp	r3, r2
 8004c46:	d0d9      	beq.n	8004bfc <vSocketClose+0xc>
 8004c48:	4610      	mov	r0, r2
 8004c4a:	e002      	b.n	8004c52 <vSocketClose+0x62>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8004c4c:	685b      	ldr	r3, [r3, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8004c4e:	4283      	cmp	r3, r0
 8004c50:	d0d4      	beq.n	8004bfc <vSocketClose+0xc>
			pxOtherSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8004c52:	68da      	ldr	r2, [r3, #12]
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
 8004c54:	f892 1053 	ldrb.w	r1, [r2, #83]	; 0x53
 8004c58:	2901      	cmp	r1, #1
 8004c5a:	d1f7      	bne.n	8004c4c <vSocketClose+0x5c>
 8004c5c:	8c91      	ldrh	r1, [r2, #36]	; 0x24
 8004c5e:	42a9      	cmp	r1, r5
 8004c60:	d1f4      	bne.n	8004c4c <vSocketClose+0x5c>
				( pxOtherSocket->u.xTCP.usChildCount ) )
 8004c62:	f8b2 104e 	ldrh.w	r1, [r2, #78]	; 0x4e
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
 8004c66:	2900      	cmp	r1, #0
 8004c68:	d0f0      	beq.n	8004c4c <vSocketClose+0x5c>
				pxOtherSocket->u.xTCP.usChildCount--;
 8004c6a:	3901      	subs	r1, #1
 8004c6c:	f8a2 104e 	strh.w	r1, [r2, #78]	; 0x4e
 8004c70:	e7c4      	b.n	8004bfc <vSocketClose+0xc>
		uxListRemove( &( pxSocket->xBoundSocketListItem ) );
 8004c72:	f104 0008 	add.w	r0, r4, #8
 8004c76:	f003 fde7 	bl	8008848 <uxListRemove>
 8004c7a:	e7c2      	b.n	8004c02 <vSocketClose+0x12>
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 8004c7c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004c7e:	2b00      	cmp	r3, #0
 8004c80:	d0c3      	beq.n	8004c0a <vSocketClose+0x1a>
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8004c82:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004c84:	68dd      	ldr	r5, [r3, #12]
			uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 8004c86:	4628      	mov	r0, r5
 8004c88:	f003 fdde 	bl	8008848 <uxListRemove>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8004c8c:	4628      	mov	r0, r5
 8004c8e:	f003 f8eb 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 8004c92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004c94:	2b00      	cmp	r3, #0
 8004c96:	d1f4      	bne.n	8004c82 <vSocketClose+0x92>
 8004c98:	e7b7      	b.n	8004c0a <vSocketClose+0x1a>
 8004c9a:	bf00      	nop
 8004c9c:	20002804 	.word	0x20002804

08004ca0 <pxUDPSocketLookup>:

/*-----------------------------------------------------------*/

FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
{
 8004ca0:	b510      	push	{r4, lr}

	/* Looking up a socket is quite simple, find a match with the local port.

	See if there is a list item associated with the port number on the
	list of bound sockets. */
	pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
 8004ca2:	4601      	mov	r1, r0
 8004ca4:	4807      	ldr	r0, [pc, #28]	; (8004cc4 <pxUDPSocketLookup+0x24>)
 8004ca6:	f7ff fcda 	bl	800465e <pxListFindListItemWithValue>

	if( pxListItem != NULL )
 8004caa:	b148      	cbz	r0, 8004cc0 <pxUDPSocketLookup+0x20>
	{
		/* The owner of the list item is the socket itself. */
		pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxListItem );
 8004cac:	68c4      	ldr	r4, [r0, #12]
		configASSERT( pxSocket != NULL );
 8004cae:	b10c      	cbz	r4, 8004cb4 <pxUDPSocketLookup+0x14>
	}
	return pxSocket;
}
 8004cb0:	4620      	mov	r0, r4
 8004cb2:	bd10      	pop	{r4, pc}
		configASSERT( pxSocket != NULL );
 8004cb4:	f240 61d1 	movw	r1, #1745	; 0x6d1
 8004cb8:	4803      	ldr	r0, [pc, #12]	; (8004cc8 <pxUDPSocketLookup+0x28>)
 8004cba:	f007 f827 	bl	800bd0c <vAssertCalled>
 8004cbe:	e7f7      	b.n	8004cb0 <pxUDPSocketLookup+0x10>
FreeRTOS_Socket_t *pxSocket = NULL;
 8004cc0:	2400      	movs	r4, #0
	return pxSocket;
 8004cc2:	e7f5      	b.n	8004cb0 <pxUDPSocketLookup+0x10>
 8004cc4:	20002818 	.word	0x20002818
 8004cc8:	0800c4a4 	.word	0x0800c4a4

08004ccc <FreeRTOS_inet_addr>:
/*-----------------------------------------------------------*/

#if ipconfigINCLUDE_FULL_INET_ADDR == 1

	uint32_t FreeRTOS_inet_addr( const char * pcIPAddress )
	{
 8004ccc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004cce:	b083      	sub	sp, #12
 8004cd0:	ad01      	add	r5, sp, #4
 8004cd2:	4686      	mov	lr, r0
	const char *pcPointerOnEntering;
	uint32_t ulReturn = 0UL, ulValue;
	UBaseType_t uxOctetNumber;
	BaseType_t xResult = pdPASS;

		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 8004cd4:	2400      	movs	r4, #0
		{
			ulValue = 0ul;
			pcPointerOnEntering = pcIPAddress;

			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8004cd6:	4626      	mov	r6, r4
			}

			/* Check characters were read. */
			if( pcIPAddress == pcPointerOnEntering )
			{
				xResult = pdFAIL;
 8004cd8:	4627      	mov	r7, r4
 8004cda:	e004      	b.n	8004ce6 <FreeRTOS_inet_addr+0x1a>
						pcIPAddress++;
					}
				}
			}

			if( xResult == pdFAIL )
 8004cdc:	b381      	cbz	r1, 8004d40 <FreeRTOS_inet_addr+0x74>
		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 8004cde:	3401      	adds	r4, #1
 8004ce0:	2c04      	cmp	r4, #4
 8004ce2:	d02d      	beq.n	8004d40 <FreeRTOS_inet_addr+0x74>
 8004ce4:	4686      	mov	lr, r0
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8004ce6:	7802      	ldrb	r2, [r0, #0]
 8004ce8:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8004cec:	b2db      	uxtb	r3, r3
 8004cee:	2b09      	cmp	r3, #9
 8004cf0:	bf98      	it	ls
 8004cf2:	4633      	movls	r3, r6
 8004cf4:	d819      	bhi.n	8004d2a <FreeRTOS_inet_addr+0x5e>
				ulValue *= ulDecimalBase;
 8004cf6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
				ulValue += ( ( uint32_t ) ( *pcIPAddress ) - ( uint32_t ) '0' );
 8004cfa:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8004cfe:	3b30      	subs	r3, #48	; 0x30
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8004d00:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8004d04:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8004d08:	b2c9      	uxtb	r1, r1
 8004d0a:	2909      	cmp	r1, #9
 8004d0c:	d9f3      	bls.n	8004cf6 <FreeRTOS_inet_addr+0x2a>
			if( pcIPAddress == pcPointerOnEntering )
 8004d0e:	ebb0 010e 	subs.w	r1, r0, lr
 8004d12:	bf18      	it	ne
 8004d14:	2101      	movne	r1, #1
			if( ulValue > 0xffUL )
 8004d16:	2bff      	cmp	r3, #255	; 0xff
 8004d18:	d811      	bhi.n	8004d3e <FreeRTOS_inet_addr+0x72>
				ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
 8004d1a:	f805 3b01 	strb.w	r3, [r5], #1
				if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1u ) )
 8004d1e:	2c02      	cmp	r4, #2
 8004d20:	d8dc      	bhi.n	8004cdc <FreeRTOS_inet_addr+0x10>
					if( *pcIPAddress != '.' )
 8004d22:	2a2e      	cmp	r2, #46	; 0x2e
 8004d24:	d10b      	bne.n	8004d3e <FreeRTOS_inet_addr+0x72>
						pcIPAddress++;
 8004d26:	3001      	adds	r0, #1
 8004d28:	e7d8      	b.n	8004cdc <FreeRTOS_inet_addr+0x10>
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8004d2a:	4633      	mov	r3, r6
				xResult = pdFAIL;
 8004d2c:	4639      	mov	r1, r7
 8004d2e:	e7f4      	b.n	8004d1a <FreeRTOS_inet_addr+0x4e>
	uint32_t ulReturn = 0UL, ulValue;
 8004d30:	2000      	movs	r0, #0
		{
			ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
		}

		return ulReturn;
	}
 8004d32:	b003      	add	sp, #12
 8004d34:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint32_t ulReturn = 0UL, ulValue;
 8004d36:	2000      	movs	r0, #0
 8004d38:	e7fb      	b.n	8004d32 <FreeRTOS_inet_addr+0x66>
 8004d3a:	2000      	movs	r0, #0
		return ulReturn;
 8004d3c:	e7f9      	b.n	8004d32 <FreeRTOS_inet_addr+0x66>
		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 8004d3e:	2100      	movs	r1, #0
		if( *pcIPAddress != ( char ) 0 )
 8004d40:	7803      	ldrb	r3, [r0, #0]
 8004d42:	2b00      	cmp	r3, #0
 8004d44:	d1f4      	bne.n	8004d30 <FreeRTOS_inet_addr+0x64>
		if( uxOctetNumber != socketMAX_IP_ADDRESS_OCTETS )
 8004d46:	2c04      	cmp	r4, #4
 8004d48:	d1f5      	bne.n	8004d36 <FreeRTOS_inet_addr+0x6a>
		if( xResult == pdPASS )
 8004d4a:	2900      	cmp	r1, #0
 8004d4c:	d0f5      	beq.n	8004d3a <FreeRTOS_inet_addr+0x6e>
			ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
 8004d4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d52:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8004d56:	0400      	lsls	r0, r0, #16
 8004d58:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 8004d5c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8004d60:	4318      	orrs	r0, r3
 8004d62:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8004d66:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8004d6a:	e7e2      	b.n	8004d32 <FreeRTOS_inet_addr+0x66>

08004d6c <vSocketWakeUpUser>:
}

/*-----------------------------------------------------------*/

void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket )
{
 8004d6c:	b510      	push	{r4, lr}
 8004d6e:	4604      	mov	r4, r0
	}
	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		if( pxSocket->pxSocketSet != NULL )
 8004d70:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004d72:	b11b      	cbz	r3, 8004d7c <vSocketWakeUpUser+0x10>
		{
			EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & eSELECT_ALL;
 8004d74:	6801      	ldr	r1, [r0, #0]
 8004d76:	f3c1 2103 	ubfx	r1, r1, #8, #4
			if( xSelectBits != 0ul )
 8004d7a:	b949      	cbnz	r1, 8004d90 <vSocketWakeUpUser+0x24>
				pxSocket->xSocketBits |= xSelectBits;
				xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
			}
		}

		pxSocket->xEventBits &= eSOCKET_ALL;
 8004d7c:	6821      	ldr	r1, [r4, #0]
 8004d7e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8004d82:	6021      	str	r1, [r4, #0]
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0u ) )
 8004d84:	6860      	ldr	r0, [r4, #4]
 8004d86:	b100      	cbz	r0, 8004d8a <vSocketWakeUpUser+0x1e>
 8004d88:	b949      	cbnz	r1, 8004d9e <vSocketWakeUpUser+0x32>
	{
		xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
	}

	pxSocket->xEventBits = 0ul;
 8004d8a:	2300      	movs	r3, #0
 8004d8c:	6023      	str	r3, [r4, #0]
 8004d8e:	bd10      	pop	{r4, pc}
				pxSocket->xSocketBits |= xSelectBits;
 8004d90:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8004d92:	430a      	orrs	r2, r1
 8004d94:	6302      	str	r2, [r0, #48]	; 0x30
				xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
 8004d96:	6818      	ldr	r0, [r3, #0]
 8004d98:	f003 fcb2 	bl	8008700 <xEventGroupSetBits>
 8004d9c:	e7ee      	b.n	8004d7c <vSocketWakeUpUser+0x10>
		xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
 8004d9e:	f003 fcaf 	bl	8008700 <xEventGroupSetBits>
 8004da2:	e7f2      	b.n	8004d8a <vSocketWakeUpUser+0x1e>

08004da4 <FreeRTOS_accept>:
	 * if the server socket is in listen mode and receives a connection request
	 * The new socket will be bound already to the same port number as the listing
	 * socket.
	 */
	Socket_t FreeRTOS_accept( Socket_t xServerSocket, struct freertos_sockaddr *pxAddress, socklen_t *pxAddressLength )
	{
 8004da4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004da8:	b08b      	sub	sp, #44	; 0x2c
 8004daa:	4605      	mov	r5, r0
 8004dac:	460e      	mov	r6, r1
 8004dae:	4691      	mov	r9, r2
	TickType_t xRemainingTime;
	BaseType_t xTimed = pdFALSE, xAsk = pdFALSE;
	TimeOut_t xTimeOut;
	IPStackEvent_t xAskEvent;

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8004db0:	2201      	movs	r2, #1
 8004db2:	2106      	movs	r1, #6
 8004db4:	f7ff fc40 	bl	8004638 <prvValidSocket>
 8004db8:	b1d0      	cbz	r0, 8004df0 <FreeRTOS_accept+0x4c>
		{
			/* Not a valid socket or wrong type */
			pxClientSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
		}
		else if( ( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED ) &&
 8004dba:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8004dbe:	f013 0f08 	tst.w	r3, #8
 8004dc2:	d10a      	bne.n	8004dda <FreeRTOS_accept+0x36>
 8004dc4:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 8004dc8:	2b01      	cmp	r3, #1
 8004dca:	d002      	beq.n	8004dd2 <FreeRTOS_accept+0x2e>
				 ( pxSocket->u.xTCP.ucTCPState != eTCP_LISTEN ) )
		{
			/* Parent socket is not in listening mode */
			pxClientSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8004dcc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8004dd0:	e010      	b.n	8004df4 <FreeRTOS_accept+0x50>
 8004dd2:	f04f 0a00 	mov.w	sl, #0
 8004dd6:	4657      	mov	r7, sl
 8004dd8:	e002      	b.n	8004de0 <FreeRTOS_accept+0x3c>
 8004dda:	f04f 0a00 	mov.w	sl, #0
 8004dde:	4657      	mov	r7, sl
					{
						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
					}
					else
					{
						pxClientSocket = pxSocket;
 8004de0:	9503      	str	r5, [sp, #12]
 8004de2:	f04f 0800 	mov.w	r8, #0

				if( xAsk != pdFALSE )
				{
					/* Ask to set an event in 'xEventGroup' as soon as a new
					client gets connected for this listening socket. */
					xAskEvent.eEventType = eTCPAcceptEvent;
 8004de6:	f04f 0b06 	mov.w	fp, #6
 8004dea:	e027      	b.n	8004e3c <FreeRTOS_accept+0x98>
 8004dec:	4644      	mov	r4, r8
 8004dee:	e05d      	b.n	8004eac <FreeRTOS_accept+0x108>
			pxClientSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8004df0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_ACCEPT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
			}
		}

		return ( Socket_t ) pxClientSocket;
	}
 8004df4:	4620      	mov	r0, r4
 8004df6:	b00b      	add	sp, #44	; 0x2c
 8004df8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004dfc:	2400      	movs	r4, #0
 8004dfe:	e7f9      	b.n	8004df4 <FreeRTOS_accept+0x50>
 8004e00:	2400      	movs	r4, #0
 8004e02:	e7f7      	b.n	8004df4 <FreeRTOS_accept+0x50>
				xTaskResumeAll();
 8004e04:	f004 feae 	bl	8009b64 <xTaskResumeAll>
				if( xAsk != pdFALSE )
 8004e08:	f1ba 0f00 	cmp.w	sl, #0
 8004e0c:	d1ee      	bne.n	8004dec <FreeRTOS_accept+0x48>
				if( xTimed == pdFALSE )
 8004e0e:	b937      	cbnz	r7, 8004e1e <FreeRTOS_accept+0x7a>
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8004e10:	69eb      	ldr	r3, [r5, #28]
 8004e12:	9309      	str	r3, [sp, #36]	; 0x24
					if( xRemainingTime == ( TickType_t ) 0 )
 8004e14:	2b00      	cmp	r3, #0
 8004e16:	d0f1      	beq.n	8004dfc <FreeRTOS_accept+0x58>
					vTaskSetTimeOutState( &xTimeOut );
 8004e18:	a807      	add	r0, sp, #28
 8004e1a:	f005 f8c5 	bl	8009fa8 <vTaskSetTimeOutState>
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8004e1e:	a909      	add	r1, sp, #36	; 0x24
 8004e20:	a807      	add	r0, sp, #28
 8004e22:	f005 f8d7 	bl	8009fd4 <xTaskCheckForTimeOut>
 8004e26:	2800      	cmp	r0, #0
 8004e28:	d1ea      	bne.n	8004e00 <FreeRTOS_accept+0x5c>
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_ACCEPT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 8004e2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004e2c:	9300      	str	r3, [sp, #0]
 8004e2e:	4643      	mov	r3, r8
 8004e30:	2201      	movs	r2, #1
 8004e32:	2104      	movs	r1, #4
 8004e34:	6868      	ldr	r0, [r5, #4]
 8004e36:	f003 fbbf 	bl	80085b8 <xEventGroupWaitBits>
 8004e3a:	2701      	movs	r7, #1
				vTaskSuspendAll();
 8004e3c:	f004 fdb8 	bl	80099b0 <vTaskSuspendAll>
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8004e40:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8004e44:	f013 0f08 	tst.w	r3, #8
						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
 8004e48:	bf0c      	ite	eq
 8004e4a:	6d6c      	ldreq	r4, [r5, #84]	; 0x54
						pxClientSocket = pxSocket;
 8004e4c:	9c03      	ldrne	r4, [sp, #12]
					if( pxClientSocket != NULL )
 8004e4e:	2c00      	cmp	r4, #0
 8004e50:	d0d8      	beq.n	8004e04 <FreeRTOS_accept+0x60>
						pxSocket->u.xTCP.pxPeerSocket = NULL;
 8004e52:	f8c5 8054 	str.w	r8, [r5, #84]	; 0x54
						if( pxClientSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED )
 8004e56:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8004e5a:	f013 0f02 	tst.w	r3, #2
 8004e5e:	d0d1      	beq.n	8004e04 <FreeRTOS_accept+0x60>
							pxClientSocket->u.xTCP.bits.bPassAccept = pdFALSE_UNSIGNED;
 8004e60:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8004e64:	f36f 0341 	bfc	r3, #1, #1
 8004e68:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
				xTaskResumeAll();
 8004e6c:	f004 fe7a 	bl	8009b64 <xTaskResumeAll>
					if( pxAddress != NULL )
 8004e70:	b18e      	cbz	r6, 8004e96 <FreeRTOS_accept+0xf2>
						pxAddress->sin_addr = FreeRTOS_ntohl( pxClientSocket->u.xTCP.ulRemoteIP );
 8004e72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004e74:	0e1a      	lsrs	r2, r3, #24
 8004e76:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8004e7a:	0219      	lsls	r1, r3, #8
 8004e7c:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8004e80:	430a      	orrs	r2, r1
 8004e82:	0a1b      	lsrs	r3, r3, #8
 8004e84:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8004e88:	4313      	orrs	r3, r2
 8004e8a:	6073      	str	r3, [r6, #4]
						pxAddress->sin_port = FreeRTOS_ntohs( pxClientSocket->u.xTCP.usRemotePort );
 8004e8c:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8004e8e:	0a13      	lsrs	r3, r2, #8
 8004e90:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004e94:	8073      	strh	r3, [r6, #2]
					if( pxAddressLength != NULL )
 8004e96:	f1b9 0f00 	cmp.w	r9, #0
 8004e9a:	d002      	beq.n	8004ea2 <FreeRTOS_accept+0xfe>
						*pxAddressLength = sizeof( *pxAddress );
 8004e9c:	2308      	movs	r3, #8
 8004e9e:	f8c9 3000 	str.w	r3, [r9]
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8004ea2:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8004ea6:	f013 0f08 	tst.w	r3, #8
 8004eaa:	d10d      	bne.n	8004ec8 <FreeRTOS_accept+0x124>
					xAskEvent.eEventType = eTCPAcceptEvent;
 8004eac:	f88d b014 	strb.w	fp, [sp, #20]
					xAskEvent.pvData = ( void * ) pxSocket;
 8004eb0:	9b03      	ldr	r3, [sp, #12]
 8004eb2:	9306      	str	r3, [sp, #24]
					xSendEventStructToIPTask( &xAskEvent, portMAX_DELAY );
 8004eb4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004eb8:	a805      	add	r0, sp, #20
 8004eba:	f7ff f86d 	bl	8003f98 <xSendEventStructToIPTask>
				if( pxClientSocket != NULL )
 8004ebe:	2c00      	cmp	r4, #0
 8004ec0:	d198      	bne.n	8004df4 <FreeRTOS_accept+0x50>
 8004ec2:	f04f 0a01 	mov.w	sl, #1
 8004ec6:	e7a2      	b.n	8004e0e <FreeRTOS_accept+0x6a>
				if( xAsk != pdFALSE )
 8004ec8:	f1ba 0f00 	cmp.w	sl, #0
 8004ecc:	d1ee      	bne.n	8004eac <FreeRTOS_accept+0x108>
 8004ece:	e791      	b.n	8004df4 <FreeRTOS_accept+0x50>

08004ed0 <FreeRTOS_recv>:
	/*
	 * Read incoming data from a TCP socket
	 * Only after the last byte has been read, a close error might be returned
	 */
	BaseType_t FreeRTOS_recv( Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags )
	{
 8004ed0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004ed4:	b086      	sub	sp, #24
 8004ed6:	4604      	mov	r4, r0
 8004ed8:	4689      	mov	r9, r1
 8004eda:	4692      	mov	sl, r2
 8004edc:	4698      	mov	r8, r3
	TimeOut_t xTimeOut;
	EventBits_t xEventBits = ( EventBits_t ) 0;

		/* Check if the socket is valid, has type TCP and if it is bound to a
		port. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8004ede:	2201      	movs	r2, #1
 8004ee0:	2106      	movs	r1, #6
 8004ee2:	f7ff fba9 	bl	8004638 <prvValidSocket>
 8004ee6:	2800      	cmp	r0, #0
 8004ee8:	f000 80b7 	beq.w	800505a <FreeRTOS_recv+0x18a>
		{
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.rxStream != NULL )
 8004eec:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8004eee:	b16a      	cbz	r2, 8004f0c <FreeRTOS_recv+0x3c>
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 8004ef0:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8004ef2:	6811      	ldr	r1, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8004ef4:	6912      	ldr	r2, [r2, #16]
 8004ef6:	4413      	add	r3, r2
 8004ef8:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 8004efa:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8004efc:	bf98      	it	ls
 8004efe:	1a9b      	subls	r3, r3, r2
			{
				xByteCount = ( BaseType_t )uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 8004f00:	461d      	mov	r5, r3
			else
			{
				xByteCount = 0;
			}

			while( xByteCount == 0 )
 8004f02:	b99b      	cbnz	r3, 8004f2c <FreeRTOS_recv+0x5c>
 8004f04:	2600      	movs	r6, #0
						}
						#endif /* ipconfigSUPPORT_SIGNALS */
						break;
					}

					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8004f06:	f008 0710 	and.w	r7, r8, #16
 8004f0a:	e05b      	b.n	8004fc4 <FreeRTOS_recv+0xf4>
 8004f0c:	2600      	movs	r6, #0
 8004f0e:	4635      	mov	r5, r6
 8004f10:	e7f9      	b.n	8004f06 <FreeRTOS_recv+0x36>
					if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 8004f12:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8004f16:	f003 0308 	and.w	r3, r3, #8
						xByteCount = -pdFREERTOS_ERRNO_ENOTCONN;
 8004f1a:	2b00      	cmp	r3, #0
 8004f1c:	bf14      	ite	ne
 8004f1e:	f06f 050b 	mvnne.w	r5, #11
 8004f22:	f06f 057f 	mvneq.w	r5, #127	; 0x7f
					xByteCount = 0;
				}
			}

		#if( ipconfigSUPPORT_SIGNALS != 0 )
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004f26:	f016 0f40 	tst.w	r6, #64	; 0x40
 8004f2a:	d123      	bne.n	8004f74 <FreeRTOS_recv+0xa4>
				}
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
			}
			else
		#endif /* ipconfigSUPPORT_SIGNALS */
			if( xByteCount > 0 )
 8004f2c:	2d00      	cmp	r5, #0
 8004f2e:	dd26      	ble.n	8004f7e <FreeRTOS_recv+0xae>
			{
				if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8004f30:	f018 0f01 	tst.w	r8, #1
 8004f34:	d063      	beq.n	8004ffe <FreeRTOS_recv+0x12e>
					}
				}
				else
				{
					/* Zero-copy reception of data: pvBuffer is a pointer to a pointer. */
					xByteCount = ( BaseType_t ) uxStreamBufferGetPtr( pxSocket->u.xTCP.rxStream, (uint8_t **)pvBuffer );
 8004f36:	6f62      	ldr	r2, [r4, #116]	; 0x74
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData );
static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData )
{
size_t uxNextTail = pxBuffer->uxTail;
 8004f38:	6810      	ldr	r0, [r2, #0]
size_t uxHead = pxBuffer->uxHead;
 8004f3a:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8004f3c:	6815      	ldr	r5, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8004f3e:	6911      	ldr	r1, [r2, #16]
 8004f40:	440b      	add	r3, r1
 8004f42:	1b5b      	subs	r3, r3, r5
	if ( uxCount >= pxBuffer->LENGTH )
 8004f44:	4299      	cmp	r1, r3
		uxCount -= pxBuffer->LENGTH;
 8004f46:	bf98      	it	ls
 8004f48:	1a5b      	subls	r3, r3, r1
size_t uxSize = uxStreamBufferGetSize( pxBuffer );

	*ppucData = pxBuffer->ucArray + uxNextTail;
 8004f4a:	f102 0114 	add.w	r1, r2, #20
 8004f4e:	4401      	add	r1, r0
 8004f50:	f8c9 1000 	str.w	r1, [r9]

	return FreeRTOS_min_uint32( uxSize, pxBuffer->LENGTH - uxNextTail );
 8004f54:	6915      	ldr	r5, [r2, #16]
 8004f56:	1a2d      	subs	r5, r5, r0


	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return a >= b ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 8004f58:	429d      	cmp	r5, r3
 8004f5a:	bf28      	it	cs
 8004f5c:	461d      	movcs	r5, r3
 8004f5e:	e00e      	b.n	8004f7e <FreeRTOS_recv+0xae>
							xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_INTR,
 8004f60:	9300      	str	r3, [sp, #0]
 8004f62:	2201      	movs	r2, #1
 8004f64:	2140      	movs	r1, #64	; 0x40
 8004f66:	6860      	ldr	r0, [r4, #4]
 8004f68:	f003 fb26 	bl	80085b8 <xEventGroupWaitBits>
 8004f6c:	4606      	mov	r6, r0
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004f6e:	f016 0f40 	tst.w	r6, #64	; 0x40
 8004f72:	d075      	beq.n	8005060 <FreeRTOS_recv+0x190>
				if( ( xEventBits & ( eSOCKET_RECEIVE | eSOCKET_CLOSED ) ) != 0 )
 8004f74:	f016 0f21 	tst.w	r6, #33	; 0x21
 8004f78:	d139      	bne.n	8004fee <FreeRTOS_recv+0x11e>
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 8004f7a:	f06f 0503 	mvn.w	r5, #3
				}
			}
		} /* prvValidSocket() */

		return xByteCount;
	}
 8004f7e:	4628      	mov	r0, r5
 8004f80:	b006      	add	sp, #24
 8004f82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8004f86:	a905      	add	r1, sp, #20
 8004f88:	a803      	add	r0, sp, #12
 8004f8a:	f005 f823 	bl	8009fd4 <xTaskCheckForTimeOut>
 8004f8e:	2800      	cmp	r0, #0
 8004f90:	d1ed      	bne.n	8004f6e <FreeRTOS_recv+0x9e>
				xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup,
 8004f92:	9b05      	ldr	r3, [sp, #20]
 8004f94:	9300      	str	r3, [sp, #0]
 8004f96:	2300      	movs	r3, #0
 8004f98:	2201      	movs	r2, #1
 8004f9a:	2161      	movs	r1, #97	; 0x61
 8004f9c:	6860      	ldr	r0, [r4, #4]
 8004f9e:	f003 fb0b 	bl	80085b8 <xEventGroupWaitBits>
 8004fa2:	4606      	mov	r6, r0
					if( ( xEventBits & eSOCKET_INTR ) != 0u )
 8004fa4:	f010 0f40 	tst.w	r0, #64	; 0x40
 8004fa8:	d1e4      	bne.n	8004f74 <FreeRTOS_recv+0xa4>
				if( pxSocket->u.xTCP.rxStream != NULL )
 8004faa:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8004fac:	2501      	movs	r5, #1
 8004fae:	b14a      	cbz	r2, 8004fc4 <FreeRTOS_recv+0xf4>
size_t uxHead = pxBuffer->uxHead;
 8004fb0:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8004fb2:	6811      	ldr	r1, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8004fb4:	6912      	ldr	r2, [r2, #16]
 8004fb6:	4413      	add	r3, r2
 8004fb8:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 8004fba:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8004fbc:	bf98      	it	ls
 8004fbe:	1a9b      	subls	r3, r3, r2
 8004fc0:	2501      	movs	r5, #1
			while( xByteCount == 0 )
 8004fc2:	b993      	cbnz	r3, 8004fea <FreeRTOS_recv+0x11a>
				switch( pxSocket->u.xTCP.ucTCPState )
 8004fc4:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8004fc8:	2b00      	cmp	r3, #0
 8004fca:	d0a2      	beq.n	8004f12 <FreeRTOS_recv+0x42>
 8004fcc:	3b08      	subs	r3, #8
 8004fce:	2b01      	cmp	r3, #1
 8004fd0:	d99f      	bls.n	8004f12 <FreeRTOS_recv+0x42>
				if( xTimed == pdFALSE )
 8004fd2:	2d00      	cmp	r5, #0
 8004fd4:	d1d7      	bne.n	8004f86 <FreeRTOS_recv+0xb6>
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8004fd6:	69e3      	ldr	r3, [r4, #28]
 8004fd8:	9305      	str	r3, [sp, #20]
					if( xRemainingTime == ( TickType_t ) 0 )
 8004fda:	2b00      	cmp	r3, #0
 8004fdc:	d0c0      	beq.n	8004f60 <FreeRTOS_recv+0x90>
					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8004fde:	2f00      	cmp	r7, #0
 8004fe0:	d1c5      	bne.n	8004f6e <FreeRTOS_recv+0x9e>
					vTaskSetTimeOutState( &xTimeOut );
 8004fe2:	a803      	add	r0, sp, #12
 8004fe4:	f004 ffe0 	bl	8009fa8 <vTaskSetTimeOutState>
 8004fe8:	e7cd      	b.n	8004f86 <FreeRTOS_recv+0xb6>
					xByteCount = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 8004fea:	461d      	mov	r5, r3
 8004fec:	e79e      	b.n	8004f2c <FreeRTOS_recv+0x5c>
					xEventGroupSetBits( pxSocket->xEventGroup, xEventBits );
 8004fee:	f026 0140 	bic.w	r1, r6, #64	; 0x40
 8004ff2:	6860      	ldr	r0, [r4, #4]
 8004ff4:	f003 fb84 	bl	8008700 <xEventGroupSetBits>
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 8004ff8:	f06f 0503 	mvn.w	r5, #3
 8004ffc:	e7bf      	b.n	8004f7e <FreeRTOS_recv+0xae>
					xByteCount = ( BaseType_t ) uxStreamBufferGet( pxSocket->u.xTCP.rxStream, 0ul, ( uint8_t * ) pvBuffer, ( size_t ) xBufferLength, ( xFlags & FREERTOS_MSG_PEEK ) != 0 );
 8004ffe:	f3c8 0380 	ubfx	r3, r8, #2, #1
 8005002:	9300      	str	r3, [sp, #0]
 8005004:	4653      	mov	r3, sl
 8005006:	464a      	mov	r2, r9
 8005008:	2100      	movs	r1, #0
 800500a:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800500c:	f000 fe39 	bl	8005c82 <uxStreamBufferGet>
 8005010:	4605      	mov	r5, r0
					if( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED )
 8005012:	f994 3040 	ldrsb.w	r3, [r4, #64]	; 0x40
 8005016:	2b00      	cmp	r3, #0
 8005018:	dab1      	bge.n	8004f7e <FreeRTOS_recv+0xae>
						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800501a:	6f62      	ldr	r2, [r4, #116]	; 0x74
size_t uxFront = pxBuffer->uxFront;
 800501c:	68d1      	ldr	r1, [r2, #12]
size_t uxTail = pxBuffer->uxTail;
 800501e:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005020:	6912      	ldr	r2, [r2, #16]
 8005022:	4413      	add	r3, r2
 8005024:	3b01      	subs	r3, #1
 8005026:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8005028:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 800502a:	bf98      	it	ls
 800502c:	1a9b      	subls	r3, r3, r2
						if( uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace )
 800502e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8005030:	429a      	cmp	r2, r3
 8005032:	d8a4      	bhi.n	8004f7e <FreeRTOS_recv+0xae>
							pxSocket->u.xTCP.bits.bLowWater = pdFALSE_UNSIGNED;
 8005034:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005038:	f36f 13c7 	bfc	r3, #7, #1
 800503c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
							pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8005040:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8005044:	f043 0301 	orr.w	r3, r3, #1
 8005048:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
							pxSocket->u.xTCP.usTimeout = 1u; /* because bLowWater is cleared. */
 800504c:	2301      	movs	r3, #1
 800504e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
							xSendEventToIPTask( eTCPTimerEvent );
 8005052:	2005      	movs	r0, #5
 8005054:	f7ff f836 	bl	80040c4 <xSendEventToIPTask>
 8005058:	e791      	b.n	8004f7e <FreeRTOS_recv+0xae>
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 800505a:	f06f 0515 	mvn.w	r5, #21
 800505e:	e78e      	b.n	8004f7e <FreeRTOS_recv+0xae>
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8005060:	2500      	movs	r5, #0
 8005062:	e78c      	b.n	8004f7e <FreeRTOS_recv+0xae>

08005064 <FreeRTOS_send>:
	 * Send data using a TCP socket.  It is not necessary to have the socket
	 * connected already.  Outgoing data will be stored and delivered as soon as
	 * the socket gets connected.
	 */
	BaseType_t FreeRTOS_send( Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags )
	{
 8005064:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005068:	b089      	sub	sp, #36	; 0x24
 800506a:	4604      	mov	r4, r0
 800506c:	460f      	mov	r7, r1
 800506e:	4615      	mov	r5, r2
 8005070:	9203      	str	r2, [sp, #12]
 8005072:	469b      	mov	fp, r3
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8005074:	2201      	movs	r2, #1
 8005076:	2106      	movs	r1, #6
 8005078:	f7ff fade 	bl	8004638 <prvValidSocket>
 800507c:	2800      	cmp	r0, #0
 800507e:	f000 80ba 	beq.w	80051f6 <FreeRTOS_send+0x192>
		else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 8005082:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005086:	f013 0f08 	tst.w	r3, #8
 800508a:	f040 80b8 	bne.w	80051fe <FreeRTOS_send+0x19a>
		else if( pxSocket->u.xTCP.ucTCPState == eCLOSED )
 800508e:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005092:	2b00      	cmp	r3, #0
 8005094:	f000 80b7 	beq.w	8005206 <FreeRTOS_send+0x1a2>
		else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 8005098:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800509c:	f013 0f40 	tst.w	r3, #64	; 0x40
 80050a0:	f040 80b5 	bne.w	800520e <FreeRTOS_send+0x1aa>
		else if( xDataLength == 0ul )
 80050a4:	2d00      	cmp	r5, #0
 80050a6:	f000 80b5 	beq.w	8005214 <FreeRTOS_send+0x1b0>
		else if( pxSocket->u.xTCP.txStream == NULL )
 80050aa:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80050ac:	b1a3      	cbz	r3, 80050d8 <FreeRTOS_send+0x74>
		xByteCount = ( BaseType_t ) prvTCPSendCheck( pxSocket, uxDataLength );

		if( xByteCount > 0 )
		{
			/* xBytesLeft is number of bytes to send, will count to zero. */
			xBytesLeft = ( BaseType_t ) uxDataLength;
 80050ae:	9b03      	ldr	r3, [sp, #12]
 80050b0:	9302      	str	r3, [sp, #8]

			/* xByteCount is number of bytes that can be sent now. */
			xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 80050b2:	6fa2      	ldr	r2, [r4, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 80050b4:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 80050b6:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 80050b8:	6912      	ldr	r2, [r2, #16]
 80050ba:	4413      	add	r3, r2
 80050bc:	3b01      	subs	r3, #1
 80050be:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 80050c0:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 80050c2:	bf98      	it	ls
 80050c4:	1a9b      	subls	r3, r3, r2

			/* While there are still bytes to be sent. */
			while( xBytesLeft > 0 )
 80050c6:	9a03      	ldr	r2, [sp, #12]
 80050c8:	2a00      	cmp	r2, #0
 80050ca:	f340 8087 	ble.w	80051dc <FreeRTOS_send+0x178>
 80050ce:	4615      	mov	r5, r2
 80050d0:	f04f 0a00 	mov.w	sl, #0
						xTaskResumeAll();
					}

					/* Send a message to the IP-task so it can work on this
					socket.  Data is sent, let the IP-task work on it. */
					pxSocket->u.xTCP.usTimeout = 1u;
 80050d4:	2601      	movs	r6, #1
 80050d6:	e054      	b.n	8005182 <FreeRTOS_send+0x11e>
				pxSocket->u.xTCP.uxEnoughSpace = ( 4ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why multiply by 4?  Maybe sock80_PERCENT?*/
			}
		}
		else
		{
			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
 80050d8:	6f23      	ldr	r3, [r4, #112]	; 0x70
		}

		/* Add an extra 4 (or 8) bytes. */
		uxLength += sizeof( size_t );
 80050da:	3304      	adds	r3, #4

		/* And make the length a multiple of sizeof( size_t ). */
		uxLength &= ~( sizeof( size_t ) - 1u );
 80050dc:	f023 0503 	bic.w	r5, r3, #3

		uxSize = sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) + uxLength;

		pxBuffer = ( StreamBuffer_t * )pvPortMallocLarge( uxSize );
 80050e0:	f105 0014 	add.w	r0, r5, #20
 80050e4:	f003 fd90 	bl	8008c08 <pvPortMalloc>

		if( pxBuffer == NULL )
 80050e8:	b138      	cbz	r0, 80050fa <FreeRTOS_send+0x96>
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
		}
		else
		{
			/* Clear the markers of the stream */
			memset( pxBuffer, '\0', sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 80050ea:	2200      	movs	r2, #0
 80050ec:	6002      	str	r2, [r0, #0]
 80050ee:	6042      	str	r2, [r0, #4]
 80050f0:	6082      	str	r2, [r0, #8]
 80050f2:	60c2      	str	r2, [r0, #12]
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 80050f4:	6105      	str	r5, [r0, #16]
			{
				pxSocket->u.xTCP.rxStream = pxBuffer;
			}
			else
			{
				pxSocket->u.xTCP.txStream = pxBuffer;
 80050f6:	67a0      	str	r0, [r4, #120]	; 0x78
 80050f8:	e7d9      	b.n	80050ae <FreeRTOS_send+0x4a>
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
 80050fa:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80050fe:	f043 0308 	orr.w	r3, r3, #8
 8005102:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8005106:	2108      	movs	r1, #8
 8005108:	4620      	mov	r0, r4
 800510a:	f000 ffcb 	bl	80060a4 <vTCPStateChange>
			if( pxSocket->u.xTCP.txStream == NULL )
 800510e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005110:	2b00      	cmp	r3, #0
 8005112:	d1cc      	bne.n	80050ae <FreeRTOS_send+0x4a>
				xResult = -pdFREERTOS_ERRNO_ENOMEM;
 8005114:	f06f 030b 	mvn.w	r3, #11
 8005118:	9302      	str	r3, [sp, #8]
 800511a:	e068      	b.n	80051ee <FreeRTOS_send+0x18a>
					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0ul, ( const uint8_t * ) pvBuffer, ( size_t ) xByteCount );
 800511c:	463a      	mov	r2, r7
 800511e:	2100      	movs	r1, #0
 8005120:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8005122:	f000 fd4a 	bl	8005bba <uxStreamBufferAdd>
 8005126:	4681      	mov	r9, r0
 8005128:	4680      	mov	r8, r0
					pxSocket->u.xTCP.usTimeout = 1u;
 800512a:	f8a4 6048 	strh.w	r6, [r4, #72]	; 0x48
					if( xIsCallingFromIPTask() == pdFALSE )
 800512e:	f7fe fe13 	bl	8003d58 <xIsCallingFromIPTask>
 8005132:	2800      	cmp	r0, #0
 8005134:	d044      	beq.n	80051c0 <FreeRTOS_send+0x15c>
					if( xBytesLeft == 0 )
 8005136:	ebb5 0508 	subs.w	r5, r5, r8
 800513a:	d058      	beq.n	80051ee <FreeRTOS_send+0x18a>
					pvBuffer = ( void * ) ( ( ( const uint8_t * ) pvBuffer) + xByteCount );
 800513c:	444f      	add	r7, r9
				if( xTimed == pdFALSE )
 800513e:	f1ba 0f00 	cmp.w	sl, #0
 8005142:	d141      	bne.n	80051c8 <FreeRTOS_send+0x164>
					xRemainingTime = pxSocket->xSendBlockTime;
 8005144:	6a23      	ldr	r3, [r4, #32]
 8005146:	9307      	str	r3, [sp, #28]
					if( xRemainingTime == ( TickType_t ) 0 )
 8005148:	2b00      	cmp	r3, #0
 800514a:	d043      	beq.n	80051d4 <FreeRTOS_send+0x170>
					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 800514c:	f01b 0f10 	tst.w	fp, #16
 8005150:	d140      	bne.n	80051d4 <FreeRTOS_send+0x170>
					vTaskSetTimeOutState( &xTimeOut );
 8005152:	a805      	add	r0, sp, #20
 8005154:	f004 ff28 	bl	8009fa8 <vTaskSetTimeOutState>
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_SEND | eSOCKET_CLOSED,
 8005158:	9b07      	ldr	r3, [sp, #28]
 800515a:	9300      	str	r3, [sp, #0]
 800515c:	2300      	movs	r3, #0
 800515e:	4632      	mov	r2, r6
 8005160:	2122      	movs	r1, #34	; 0x22
 8005162:	6860      	ldr	r0, [r4, #4]
 8005164:	f003 fa28 	bl	80085b8 <xEventGroupWaitBits>
				xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 8005168:	6fa2      	ldr	r2, [r4, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 800516a:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 800516c:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 800516e:	6912      	ldr	r2, [r2, #16]
 8005170:	4413      	add	r3, r2
 8005172:	3b01      	subs	r3, #1
 8005174:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8005176:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8005178:	bf98      	it	ls
 800517a:	1a9b      	subls	r3, r3, r2
 800517c:	46b2      	mov	sl, r6
			while( xBytesLeft > 0 )
 800517e:	2d00      	cmp	r5, #0
 8005180:	dd28      	ble.n	80051d4 <FreeRTOS_send+0x170>
				if( xByteCount > 0 )
 8005182:	2b00      	cmp	r3, #0
 8005184:	dddb      	ble.n	800513e <FreeRTOS_send+0xda>
 8005186:	42ab      	cmp	r3, r5
 8005188:	bfa8      	it	ge
 800518a:	462b      	movge	r3, r5
					if( ( pxSocket->u.xTCP.bits.bCloseAfterSend != pdFALSE_UNSIGNED ) && ( xByteCount == xBytesLeft ) )
 800518c:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8005190:	f012 0f10 	tst.w	r2, #16
 8005194:	d0c2      	beq.n	800511c <FreeRTOS_send+0xb8>
 8005196:	429d      	cmp	r5, r3
 8005198:	d1c0      	bne.n	800511c <FreeRTOS_send+0xb8>
						vTaskSuspendAll();
 800519a:	f004 fc09 	bl	80099b0 <vTaskSuspendAll>
						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE_UNSIGNED;
 800519e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80051a2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80051a6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0ul, ( const uint8_t * ) pvBuffer, ( size_t ) xByteCount );
 80051aa:	462b      	mov	r3, r5
 80051ac:	463a      	mov	r2, r7
 80051ae:	2100      	movs	r1, #0
 80051b0:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 80051b2:	f000 fd02 	bl	8005bba <uxStreamBufferAdd>
 80051b6:	4681      	mov	r9, r0
 80051b8:	4680      	mov	r8, r0
						xTaskResumeAll();
 80051ba:	f004 fcd3 	bl	8009b64 <xTaskResumeAll>
 80051be:	e7b4      	b.n	800512a <FreeRTOS_send+0xc6>
						xSendEventToIPTask( eTCPTimerEvent );
 80051c0:	2005      	movs	r0, #5
 80051c2:	f7fe ff7f 	bl	80040c4 <xSendEventToIPTask>
 80051c6:	e7b6      	b.n	8005136 <FreeRTOS_send+0xd2>
					if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 80051c8:	a907      	add	r1, sp, #28
 80051ca:	a805      	add	r0, sp, #20
 80051cc:	f004 ff02 	bl	8009fd4 <xTaskCheckForTimeOut>
 80051d0:	2800      	cmp	r0, #0
 80051d2:	d0c1      	beq.n	8005158 <FreeRTOS_send+0xf4>
			if( xByteCount == 0 )
 80051d4:	9b03      	ldr	r3, [sp, #12]
 80051d6:	1b5b      	subs	r3, r3, r5
 80051d8:	9302      	str	r3, [sp, #8]
 80051da:	d108      	bne.n	80051ee <FreeRTOS_send+0x18a>
				if( pxSocket->u.xTCP.ucTCPState > eESTABLISHED )
 80051dc:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOSPC;
 80051e0:	2b05      	cmp	r3, #5
 80051e2:	bf8c      	ite	hi
 80051e4:	f06f 037f 	mvnhi.w	r3, #127	; 0x7f
 80051e8:	f06f 031b 	mvnls.w	r3, #27
 80051ec:	9302      	str	r3, [sp, #8]
	}
 80051ee:	9802      	ldr	r0, [sp, #8]
 80051f0:	b009      	add	sp, #36	; 0x24
 80051f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xResult = -pdFREERTOS_ERRNO_EINVAL;
 80051f6:	f06f 0315 	mvn.w	r3, #21
 80051fa:	9302      	str	r3, [sp, #8]
 80051fc:	e7f7      	b.n	80051ee <FreeRTOS_send+0x18a>
			xResult = -pdFREERTOS_ERRNO_ENOMEM;
 80051fe:	f06f 030b 	mvn.w	r3, #11
 8005202:	9302      	str	r3, [sp, #8]
 8005204:	e7f3      	b.n	80051ee <FreeRTOS_send+0x18a>
			xResult = -pdFREERTOS_ERRNO_ENOTCONN;
 8005206:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 800520a:	9302      	str	r3, [sp, #8]
 800520c:	e7ef      	b.n	80051ee <FreeRTOS_send+0x18a>
			xResult = 0;
 800520e:	2300      	movs	r3, #0
 8005210:	9302      	str	r3, [sp, #8]
 8005212:	e7ec      	b.n	80051ee <FreeRTOS_send+0x18a>
			xResult = 0;
 8005214:	2300      	movs	r3, #0
 8005216:	9302      	str	r3, [sp, #8]
 8005218:	e7e9      	b.n	80051ee <FreeRTOS_send+0x18a>

0800521a <FreeRTOS_listen>:
	{
 800521a:	b538      	push	{r3, r4, r5, lr}
 800521c:	4604      	mov	r4, r0
 800521e:	460d      	mov	r5, r1
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8005220:	2201      	movs	r2, #1
 8005222:	2106      	movs	r1, #6
 8005224:	f7ff fa08 	bl	8004638 <prvValidSocket>
 8005228:	2800      	cmp	r0, #0
 800522a:	d038      	beq.n	800529e <FreeRTOS_listen+0x84>
		else if( ( pxSocket->u.xTCP.ucTCPState != eCLOSED ) && ( pxSocket->u.xTCP.ucTCPState != eCLOSE_WAIT ) )
 800522c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005230:	f013 0ff7 	tst.w	r3, #247	; 0xf7
 8005234:	d136      	bne.n	80052a4 <FreeRTOS_listen+0x8a>
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
 8005236:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800523a:	429d      	cmp	r5, r3
 800523c:	bfa8      	it	ge
 800523e:	461d      	movge	r5, r3
			pxSocket->u.xTCP.usBacklog = ( uint16_t )FreeRTOS_min_int32( ( int32_t ) 0xffff, ( int32_t ) xBacklog );
 8005240:	f8a4 5050 	strh.w	r5, [r4, #80]	; 0x50
			if( pxSocket->u.xTCP.bits.bReuseSocket )
 8005244:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005248:	f013 0f08 	tst.w	r3, #8
 800524c:	d021      	beq.n	8005292 <FreeRTOS_listen+0x78>
				if( pxSocket->u.xTCP.rxStream != NULL )
 800524e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8005250:	b123      	cbz	r3, 800525c <FreeRTOS_listen+0x42>
	pxBuffer->uxHead = 0u;
 8005252:	2200      	movs	r2, #0
 8005254:	609a      	str	r2, [r3, #8]
	pxBuffer->uxTail = 0u;
 8005256:	601a      	str	r2, [r3, #0]
	pxBuffer->uxFront = 0u;
 8005258:	60da      	str	r2, [r3, #12]
	pxBuffer->uxMid = 0u;
 800525a:	605a      	str	r2, [r3, #4]
				if( pxSocket->u.xTCP.txStream != NULL )
 800525c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800525e:	b123      	cbz	r3, 800526a <FreeRTOS_listen+0x50>
	pxBuffer->uxHead = 0u;
 8005260:	2200      	movs	r2, #0
 8005262:	609a      	str	r2, [r3, #8]
	pxBuffer->uxTail = 0u;
 8005264:	601a      	str	r2, [r3, #0]
	pxBuffer->uxFront = 0u;
 8005266:	60da      	str	r2, [r3, #12]
	pxBuffer->uxMid = 0u;
 8005268:	605a      	str	r2, [r3, #4]
				memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, '\0', sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800526a:	2246      	movs	r2, #70	; 0x46
 800526c:	2100      	movs	r1, #0
 800526e:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8005272:	f006 ff17 	bl	800c0a4 <memset>
				memset( &pxSocket->u.xTCP.xTCPWindow, '\0', sizeof( pxSocket->u.xTCP.xTCPWindow ) );
 8005276:	22c0      	movs	r2, #192	; 0xc0
 8005278:	2100      	movs	r1, #0
 800527a:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
 800527e:	f006 ff11 	bl	800c0a4 <memset>
				memset( &pxSocket->u.xTCP.bits, '\0', sizeof( pxSocket->u.xTCP.bits ) );
 8005282:	2300      	movs	r3, #0
 8005284:	6423      	str	r3, [r4, #64]	; 0x40
				pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE_UNSIGNED;
 8005286:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800528a:	f043 0308 	orr.w	r3, r3, #8
 800528e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			vTCPStateChange( pxSocket, eTCP_LISTEN );
 8005292:	2101      	movs	r1, #1
 8005294:	4620      	mov	r0, r4
 8005296:	f000 ff05 	bl	80060a4 <vTCPStateChange>
	BaseType_t xResult = 0;
 800529a:	2000      	movs	r0, #0
 800529c:	bd38      	pop	{r3, r4, r5, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 800529e:	f06f 005e 	mvn.w	r0, #94	; 0x5e
 80052a2:	bd38      	pop	{r3, r4, r5, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 80052a4:	f06f 005e 	mvn.w	r0, #94	; 0x5e
	}
 80052a8:	bd38      	pop	{r3, r4, r5, pc}

080052aa <FreeRTOS_shutdown>:
	{
 80052aa:	b510      	push	{r4, lr}
 80052ac:	4604      	mov	r4, r0
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 80052ae:	2201      	movs	r2, #1
 80052b0:	2106      	movs	r1, #6
 80052b2:	f7ff f9c1 	bl	8004638 <prvValidSocket>
 80052b6:	b188      	cbz	r0, 80052dc <FreeRTOS_shutdown+0x32>
		else if ( pxSocket->u.xTCP.ucTCPState != eESTABLISHED )
 80052b8:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80052bc:	2b05      	cmp	r3, #5
 80052be:	d110      	bne.n	80052e2 <FreeRTOS_shutdown+0x38>
			pxSocket->u.xTCP.bits.bUserShutdown = pdTRUE_UNSIGNED;
 80052c0:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80052c4:	f043 0320 	orr.w	r3, r3, #32
 80052c8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			pxSocket->u.xTCP.usTimeout = 1u;
 80052cc:	2301      	movs	r3, #1
 80052ce:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
			xSendEventToIPTask( eTCPTimerEvent );
 80052d2:	2005      	movs	r0, #5
 80052d4:	f7fe fef6 	bl	80040c4 <xSendEventToIPTask>
			xResult = 0;
 80052d8:	2000      	movs	r0, #0
 80052da:	bd10      	pop	{r4, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 80052dc:	f06f 005e 	mvn.w	r0, #94	; 0x5e
 80052e0:	bd10      	pop	{r4, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 80052e2:	f06f 005e 	mvn.w	r0, #94	; 0x5e
	}
 80052e6:	bd10      	pop	{r4, pc}

080052e8 <xTCPTimerCheck>:
	{
 80052e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80052ec:	4681      	mov	r9, r0
	TickType_t xNow = xTaskGetTickCount();
 80052ee:	f004 fb67 	bl	80099c0 <xTaskGetTickCount>
	TickType_t xDelta = xNow - xLastTime;
 80052f2:	4b1f      	ldr	r3, [pc, #124]	; (8005370 <xTCPTimerCheck+0x88>)
 80052f4:	681e      	ldr	r6, [r3, #0]
 80052f6:	1b86      	subs	r6, r0, r6
	ListItem_t *pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 80052f8:	4a1e      	ldr	r2, [pc, #120]	; (8005374 <xTCPTimerCheck+0x8c>)
 80052fa:	68d4      	ldr	r4, [r2, #12]
		xLastTime = xNow;
 80052fc:	6018      	str	r0, [r3, #0]
			xDelta = 1u;
 80052fe:	2e00      	cmp	r6, #0
 8005300:	bf08      	it	eq
 8005302:	2601      	moveq	r6, #1
		while( pxIterator != pxEnd )
 8005304:	f102 0308 	add.w	r3, r2, #8
 8005308:	429c      	cmp	r4, r3
 800530a:	d02c      	beq.n	8005366 <xTCPTimerCheck+0x7e>
 800530c:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
				pxSocket->u.xTCP.usTimeout = 0u;
 8005310:	f04f 0a00 	mov.w	sl, #0
		while( pxIterator != pxEnd )
 8005314:	461f      	mov	r7, r3
 8005316:	e012      	b.n	800533e <xTCPTimerCheck+0x56>
				pxSocket->u.xTCP.usTimeout = 0u;
 8005318:	f8a5 a048 	strh.w	sl, [r5, #72]	; 0x48
				if( xTCPSocketCheck( pxSocket ) < 0 )
 800531c:	4628      	mov	r0, r5
 800531e:	f001 f935 	bl	800658c <xTCPSocketCheck>
 8005322:	2800      	cmp	r0, #0
 8005324:	da16      	bge.n	8005354 <xTCPTimerCheck+0x6c>
 8005326:	e008      	b.n	800533a <xTCPTimerCheck+0x52>
					vSocketWakeUpUser( pxSocket );
 8005328:	4628      	mov	r0, r5
 800532a:	f7ff fd1f 	bl	8004d6c <vSocketWakeUpUser>
			if( ( pxSocket->u.xTCP.usTimeout != 0u ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTimeout ) )
 800532e:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 8005332:	b113      	cbz	r3, 800533a <xTCPTimerCheck+0x52>
 8005334:	4598      	cmp	r8, r3
 8005336:	bf28      	it	cs
 8005338:	4698      	movcs	r8, r3
		while( pxIterator != pxEnd )
 800533a:	42bc      	cmp	r4, r7
 800533c:	d015      	beq.n	800536a <xTCPTimerCheck+0x82>
			pxSocket = ( FreeRTOS_Socket_t * )listGET_LIST_ITEM_OWNER( pxIterator );
 800533e:	68e5      	ldr	r5, [r4, #12]
			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 8005340:	6864      	ldr	r4, [r4, #4]
			if( pxSocket->u.xTCP.usTimeout == 0u )
 8005342:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 8005346:	2b00      	cmp	r3, #0
 8005348:	d0f7      	beq.n	800533a <xTCPTimerCheck+0x52>
			if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
 800534a:	42b3      	cmp	r3, r6
 800534c:	d9e4      	bls.n	8005318 <xTCPTimerCheck+0x30>
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDelta );
 800534e:	1b9b      	subs	r3, r3, r6
 8005350:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
			if( pxSocket->xEventBits != 0u )
 8005354:	682b      	ldr	r3, [r5, #0]
 8005356:	2b00      	cmp	r3, #0
 8005358:	d0e9      	beq.n	800532e <xTCPTimerCheck+0x46>
				if( xWillSleep != pdFALSE )
 800535a:	f1b9 0f00 	cmp.w	r9, #0
 800535e:	d1e3      	bne.n	8005328 <xTCPTimerCheck+0x40>
					xShortest = ( TickType_t ) 0;
 8005360:	f04f 0800 	mov.w	r8, #0
 8005364:	e7e3      	b.n	800532e <xTCPTimerCheck+0x46>
		while( pxIterator != pxEnd )
 8005366:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
	}
 800536a:	4640      	mov	r0, r8
 800536c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005370:	20000538 	.word	0x20000538
 8005374:	20002804 	.word	0x20002804

08005378 <pxTCPSocketLookup>:
	{
 8005378:	b4f0      	push	{r4, r5, r6, r7}
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 800537a:	4811      	ldr	r0, [pc, #68]	; (80053c0 <pxTCPSocketLookup+0x48>)
 800537c:	68c4      	ldr	r4, [r0, #12]
 800537e:	3008      	adds	r0, #8
 8005380:	4284      	cmp	r4, r0
 8005382:	d01b      	beq.n	80053bc <pxTCPSocketLookup+0x44>
 8005384:	2000      	movs	r0, #0
			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 8005386:	b289      	uxth	r1, r1
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 8005388:	b29b      	uxth	r3, r3
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 800538a:	4f0e      	ldr	r7, [pc, #56]	; (80053c4 <pxTCPSocketLookup+0x4c>)
 800538c:	e003      	b.n	8005396 <pxTCPSocketLookup+0x1e>
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800538e:	4628      	mov	r0, r5
			 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8005390:	6864      	ldr	r4, [r4, #4]
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 8005392:	42bc      	cmp	r4, r7
 8005394:	d010      	beq.n	80053b8 <pxTCPSocketLookup+0x40>
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8005396:	68e5      	ldr	r5, [r4, #12]
			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 8005398:	8cae      	ldrh	r6, [r5, #36]	; 0x24
 800539a:	428e      	cmp	r6, r1
 800539c:	d1f8      	bne.n	8005390 <pxTCPSocketLookup+0x18>
				if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 800539e:	f895 6053 	ldrb.w	r6, [r5, #83]	; 0x53
 80053a2:	2e01      	cmp	r6, #1
 80053a4:	d0f3      	beq.n	800538e <pxTCPSocketLookup+0x16>
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 80053a6:	8fae      	ldrh	r6, [r5, #60]	; 0x3c
 80053a8:	429e      	cmp	r6, r3
 80053aa:	d1f1      	bne.n	8005390 <pxTCPSocketLookup+0x18>
 80053ac:	6bae      	ldr	r6, [r5, #56]	; 0x38
 80053ae:	4296      	cmp	r6, r2
 80053b0:	d1ee      	bne.n	8005390 <pxTCPSocketLookup+0x18>
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 80053b2:	2d00      	cmp	r5, #0
 80053b4:	bf18      	it	ne
 80053b6:	4628      	movne	r0, r5
	}
 80053b8:	bcf0      	pop	{r4, r5, r6, r7}
 80053ba:	4770      	bx	lr
	FreeRTOS_Socket_t *pxResult = NULL, *pxListenSocket = NULL;
 80053bc:	2000      	movs	r0, #0
 80053be:	e7fb      	b.n	80053b8 <pxTCPSocketLookup+0x40>
 80053c0:	20002804 	.word	0x20002804
 80053c4:	2000280c 	.word	0x2000280c

080053c8 <lTCPAddRxdata>:
	/*
	 * Add data to the RxStream.  When uxOffset > 0, data has come in out-of-order
	 * and will be put in front of the head so it can not be popped by the user.
	 */
	int32_t lTCPAddRxdata( FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount )
	{
 80053c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80053cc:	4604      	mov	r4, r0
 80053ce:	460e      	mov	r6, r1
 80053d0:	4617      	mov	r7, r2
 80053d2:	4698      	mov	r8, r3
	StreamBuffer_t *pxStream = pxSocket->u.xTCP.rxStream;
 80053d4:	6f45      	ldr	r5, [r0, #116]	; 0x74
		/* int32_t uxStreamBufferAdd( pxBuffer, uxOffset, pucData, aCount )
		if( pucData != NULL ) copy data the the buffer
		if( pucData == NULL ) no copying, just advance rxHead
		if( uxOffset != 0 ) Just store data which has come out-of-order
		if( uxOffset == 0 ) Also advance rxHead */
		if( pxStream == NULL )
 80053d6:	b345      	cbz	r5, 800542a <lTCPAddRxdata+0x62>
				pcData = NULL;
			}
		}
		#endif /* ipconfigUSE_CALLBACKS */

		xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
 80053d8:	4643      	mov	r3, r8
 80053da:	463a      	mov	r2, r7
 80053dc:	4631      	mov	r1, r6
 80053de:	4628      	mov	r0, r5
 80053e0:	f000 fbeb 	bl	8005bba <uxStreamBufferAdd>
 80053e4:	4605      	mov	r5, r0
					pxStream->uxFront ) );
			}
		}
		#endif /* ipconfigHAS_DEBUG_PRINTF */

		if( uxOffset == 0u )
 80053e6:	b9ee      	cbnz	r6, 8005424 <lTCPAddRxdata+0x5c>
					}
				} else
			#endif /* ipconfigUSE_CALLBACKS */
			{
				/* See if running out of space. */
				if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
 80053e8:	f994 3040 	ldrsb.w	r3, [r4, #64]	; 0x40
 80053ec:	2b00      	cmp	r3, #0
 80053ee:	db0c      	blt.n	800540a <lTCPAddRxdata+0x42>
				{
					size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 80053f0:	6f62      	ldr	r2, [r4, #116]	; 0x74
size_t uxFront = pxBuffer->uxFront;
 80053f2:	68d1      	ldr	r1, [r2, #12]
size_t uxTail = pxBuffer->uxTail;
 80053f4:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 80053f6:	6912      	ldr	r2, [r2, #16]
 80053f8:	4413      	add	r3, r2
 80053fa:	3b01      	subs	r3, #1
 80053fc:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 80053fe:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8005400:	bf98      	it	ls
 8005402:	1a9b      	subls	r3, r3, r2
					if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace  )
 8005404:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005406:	429a      	cmp	r2, r3
 8005408:	d23f      	bcs.n	800548a <lTCPAddRxdata+0xc2>
					}
				}

				/* New incoming data is available, wake up the user.   User's
				semaphores will be set just before the IP-task goes asleep. */
				pxSocket->xEventBits |= eSOCKET_RECEIVE;
 800540a:	6823      	ldr	r3, [r4, #0]
 800540c:	f043 0201 	orr.w	r2, r3, #1
 8005410:	6022      	str	r2, [r4, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
 8005412:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005414:	f012 0f01 	tst.w	r2, #1
 8005418:	d004      	beq.n	8005424 <lTCPAddRxdata+0x5c>
					{
						pxSocket->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
 800541a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800541e:	f043 0301 	orr.w	r3, r3, #1
 8005422:	6023      	str	r3, [r4, #0]
				#endif
			}
		}

		return xResult;
	}
 8005424:	4628      	mov	r0, r5
 8005426:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			uxLength = pxSocket->u.xTCP.uxRxStreamSize;
 800542a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
			if( pxSocket->u.xTCP.uxLittleSpace == 0ul )
 800542c:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800542e:	b92a      	cbnz	r2, 800543c <lTCPAddRxdata+0x74>
				pxSocket->u.xTCP.uxLittleSpace  = ( 1ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why divide by 5?  Can this be changed to a #define? */
 8005430:	f1a2 3233 	sub.w	r2, r2, #858993459	; 0x33333333
 8005434:	fba2 1203 	umull	r1, r2, r2, r3
 8005438:	0892      	lsrs	r2, r2, #2
 800543a:	6642      	str	r2, [r0, #100]	; 0x64
			if( pxSocket->u.xTCP.uxEnoughSpace == 0ul )
 800543c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 800543e:	b92a      	cbnz	r2, 800544c <lTCPAddRxdata+0x84>
				pxSocket->u.xTCP.uxEnoughSpace = ( 4ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why multiply by 4?  Maybe sock80_PERCENT?*/
 8005440:	009a      	lsls	r2, r3, #2
 8005442:	491b      	ldr	r1, [pc, #108]	; (80054b0 <lTCPAddRxdata+0xe8>)
 8005444:	fba1 1202 	umull	r1, r2, r1, r2
 8005448:	0892      	lsrs	r2, r2, #2
 800544a:	66a2      	str	r2, [r4, #104]	; 0x68
		uxLength += sizeof( size_t );
 800544c:	3304      	adds	r3, #4
		uxLength &= ~( sizeof( size_t ) - 1u );
 800544e:	f023 0903 	bic.w	r9, r3, #3
		pxBuffer = ( StreamBuffer_t * )pvPortMallocLarge( uxSize );
 8005452:	f109 0014 	add.w	r0, r9, #20
 8005456:	f003 fbd7 	bl	8008c08 <pvPortMalloc>
		if( pxBuffer == NULL )
 800545a:	4605      	mov	r5, r0
 800545c:	b140      	cbz	r0, 8005470 <lTCPAddRxdata+0xa8>
			memset( pxBuffer, '\0', sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 800545e:	2300      	movs	r3, #0
 8005460:	6003      	str	r3, [r0, #0]
 8005462:	6043      	str	r3, [r0, #4]
 8005464:	6083      	str	r3, [r0, #8]
 8005466:	60c3      	str	r3, [r0, #12]
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 8005468:	f8c0 9010 	str.w	r9, [r0, #16]
				pxSocket->u.xTCP.rxStream = pxBuffer;
 800546c:	6760      	str	r0, [r4, #116]	; 0x74
 800546e:	e7b3      	b.n	80053d8 <lTCPAddRxdata+0x10>
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
 8005470:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005474:	f043 0308 	orr.w	r3, r3, #8
 8005478:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800547c:	2108      	movs	r1, #8
 800547e:	4620      	mov	r0, r4
 8005480:	f000 fe10 	bl	80060a4 <vTCPStateChange>
				return -1;
 8005484:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8005488:	e7cc      	b.n	8005424 <lTCPAddRxdata+0x5c>
						pxSocket->u.xTCP.bits.bLowWater = pdTRUE_UNSIGNED;
 800548a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800548e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005492:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
						pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8005496:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800549a:	f043 0301 	orr.w	r3, r3, #1
 800549e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
						pxSocket->u.xTCP.usTimeout = 1u;
 80054a2:	2301      	movs	r3, #1
 80054a4:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
 80054a8:	2005      	movs	r0, #5
 80054aa:	f7fe fe0b 	bl	80040c4 <xSendEventToIPTask>
 80054ae:	e7ac      	b.n	800540a <lTCPAddRxdata+0x42>
 80054b0:	cccccccd 	.word	0xcccccccd

080054b4 <FreeRTOS_tx_space>:
	BaseType_t FreeRTOS_tx_space( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80054b4:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 80054b8:	2b06      	cmp	r3, #6
 80054ba:	d10d      	bne.n	80054d8 <FreeRTOS_tx_space+0x24>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 80054bc:	6f83      	ldr	r3, [r0, #120]	; 0x78
 80054be:	b14b      	cbz	r3, 80054d4 <FreeRTOS_tx_space+0x20>
size_t uxHead = pxBuffer->uxHead;
 80054c0:	689a      	ldr	r2, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 80054c2:	6818      	ldr	r0, [r3, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 80054c4:	691b      	ldr	r3, [r3, #16]
 80054c6:	4418      	add	r0, r3
 80054c8:	3801      	subs	r0, #1
 80054ca:	1a80      	subs	r0, r0, r2
	if( uxCount >= pxBuffer->LENGTH )
 80054cc:	4283      	cmp	r3, r0
 80054ce:	d805      	bhi.n	80054dc <FreeRTOS_tx_space+0x28>
		uxCount -= pxBuffer->LENGTH;
 80054d0:	1ac0      	subs	r0, r0, r3
 80054d2:	4770      	bx	lr
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSpace ( pxSocket->u.xTCP.txStream );
			}
			else
			{
				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 80054d4:	6f00      	ldr	r0, [r0, #112]	; 0x70
 80054d6:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 80054d8:	f06f 0015 	mvn.w	r0, #21
			}
		}

		return xReturn;
	}
 80054dc:	4770      	bx	lr

080054de <FreeRTOS_tx_size>:
	BaseType_t FreeRTOS_tx_size( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80054de:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 80054e2:	2b06      	cmp	r3, #6
 80054e4:	d10a      	bne.n	80054fc <FreeRTOS_tx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 80054e6:	6f83      	ldr	r3, [r0, #120]	; 0x78
 80054e8:	b15b      	cbz	r3, 8005502 <FreeRTOS_tx_size+0x24>
size_t uxHead = pxBuffer->uxHead;
 80054ea:	6898      	ldr	r0, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 80054ec:	681a      	ldr	r2, [r3, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80054ee:	691b      	ldr	r3, [r3, #16]
 80054f0:	4418      	add	r0, r3
 80054f2:	1a80      	subs	r0, r0, r2
	if ( uxCount >= pxBuffer->LENGTH )
 80054f4:	4283      	cmp	r3, r0
 80054f6:	d805      	bhi.n	8005504 <FreeRTOS_tx_size+0x26>
		uxCount -= pxBuffer->LENGTH;
 80054f8:	1ac0      	subs	r0, r0, r3
 80054fa:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 80054fc:	f06f 0015 	mvn.w	r0, #21
 8005500:	4770      	bx	lr
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.txStream );
			}
			else
			{
				xReturn = 0;
 8005502:	2000      	movs	r0, #0
			}
		}

		return xReturn;
	}
 8005504:	4770      	bx	lr
	...

08005508 <FreeRTOS_setsockopt>:
{
 8005508:	b570      	push	{r4, r5, r6, lr}
 800550a:	b082      	sub	sp, #8
 800550c:	4615      	mov	r5, r2
 800550e:	461e      	mov	r6, r3
	configASSERT( xSocket );
 8005510:	4604      	mov	r4, r0
 8005512:	b1a0      	cbz	r0, 800553e <FreeRTOS_setsockopt+0x36>
	switch( lOptionName )
 8005514:	2d0f      	cmp	r5, #15
 8005516:	f200 810c 	bhi.w	8005732 <FreeRTOS_setsockopt+0x22a>
 800551a:	e8df f015 	tbh	[pc, r5, lsl #1]
 800551e:	0016      	.short	0x0016
 8005520:	002c001c 	.word	0x002c001c
 8005524:	003d010a 	.word	0x003d010a
 8005528:	010a003d 	.word	0x010a003d
 800552c:	010a010a 	.word	0x010a010a
 8005530:	010a010a 	.word	0x010a010a
 8005534:	00a70091 	.word	0x00a70091
 8005538:	00bc0060 	.word	0x00bc0060
 800553c:	00e9      	.short	0x00e9
	configASSERT( xSocket );
 800553e:	f44f 61a8 	mov.w	r1, #1344	; 0x540
 8005542:	488f      	ldr	r0, [pc, #572]	; (8005780 <FreeRTOS_setsockopt+0x278>)
 8005544:	f006 fbe2 	bl	800bd0c <vAssertCalled>
 8005548:	e7e4      	b.n	8005514 <FreeRTOS_setsockopt+0xc>
			pxSocket->xReceiveBlockTime = *( ( TickType_t * ) pvOptionValue );
 800554a:	6833      	ldr	r3, [r6, #0]
 800554c:	61e3      	str	r3, [r4, #28]
			xReturn = 0;
 800554e:	2300      	movs	r3, #0
} /* Tested */
 8005550:	4618      	mov	r0, r3
 8005552:	b002      	add	sp, #8
 8005554:	bd70      	pop	{r4, r5, r6, pc}
			pxSocket->xSendBlockTime = *( ( TickType_t * ) pvOptionValue );
 8005556:	6833      	ldr	r3, [r6, #0]
 8005558:	6223      	str	r3, [r4, #32]
			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 800555a:	f894 2027 	ldrb.w	r2, [r4, #39]	; 0x27
 800555e:	2a11      	cmp	r2, #17
 8005560:	d001      	beq.n	8005566 <FreeRTOS_setsockopt+0x5e>
			xReturn = 0;
 8005562:	2300      	movs	r3, #0
 8005564:	e7f4      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
				if( pxSocket->xSendBlockTime > ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS )
 8005566:	f241 3288 	movw	r2, #5000	; 0x1388
 800556a:	4293      	cmp	r3, r2
 800556c:	f240 80e4 	bls.w	8005738 <FreeRTOS_setsockopt+0x230>
					pxSocket->xSendBlockTime = ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS;
 8005570:	6222      	str	r2, [r4, #32]
			xReturn = 0;
 8005572:	2300      	movs	r3, #0
 8005574:	e7ec      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
			lOptionValue = ( BaseType_t ) pvOptionValue;
 8005576:	4633      	mov	r3, r6
			if( lOptionValue == 0 )
 8005578:	b936      	cbnz	r6, 8005588 <FreeRTOS_setsockopt+0x80>
				pxSocket->ucSocketOptions &= ( uint8_t ) ~FREERTOS_SO_UDPCKSUM_OUT;
 800557a:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
 800557e:	f022 0202 	bic.w	r2, r2, #2
 8005582:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
 8005586:	e7e3      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
				pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8005588:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 800558c:	f043 0302 	orr.w	r3, r3, #2
 8005590:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			xReturn = 0;
 8005594:	2300      	movs	r3, #0
 8005596:	e7db      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005598:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 800559c:	2b06      	cmp	r3, #6
 800559e:	f040 80cd 	bne.w	800573c <FreeRTOS_setsockopt+0x234>
					if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 80055a2:	2d04      	cmp	r5, #4
 80055a4:	d005      	beq.n	80055b2 <FreeRTOS_setsockopt+0xaa>
 80055a6:	2d05      	cmp	r5, #5
 80055a8:	d013      	beq.n	80055d2 <FreeRTOS_setsockopt+0xca>
					ulNewValue = *( ( uint32_t * ) pvOptionValue );
 80055aa:	6833      	ldr	r3, [r6, #0]
						pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
 80055ac:	66e3      	str	r3, [r4, #108]	; 0x6c
				xReturn = 0;
 80055ae:	2300      	movs	r3, #0
 80055b0:	e7ce      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
					if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 80055b2:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80055b4:	2b00      	cmp	r3, #0
 80055b6:	f040 80c4 	bne.w	8005742 <FreeRTOS_setsockopt+0x23a>
						ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 80055ba:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d) { return d * ( ( a + d - 1u ) / d ); }
 80055be:	6833      	ldr	r3, [r6, #0]
 80055c0:	3b01      	subs	r3, #1
 80055c2:	4413      	add	r3, r2
 80055c4:	fbb3 f3f2 	udiv	r3, r3, r2
 80055c8:	fb02 f303 	mul.w	r3, r2, r3
						pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 80055cc:	6723      	str	r3, [r4, #112]	; 0x70
				xReturn = 0;
 80055ce:	2300      	movs	r3, #0
 80055d0:	e7be      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
						( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 80055d2:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80055d4:	2b00      	cmp	r3, #0
 80055d6:	f040 80b7 	bne.w	8005748 <FreeRTOS_setsockopt+0x240>
					ulNewValue = *( ( uint32_t * ) pvOptionValue );
 80055da:	6833      	ldr	r3, [r6, #0]
 80055dc:	e7e6      	b.n	80055ac <FreeRTOS_setsockopt+0xa4>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80055de:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 80055e2:	2b06      	cmp	r3, #6
 80055e4:	f040 80b3 	bne.w	800574e <FreeRTOS_setsockopt+0x246>
					if( ( pxSocket->u.xTCP.txStream != NULL ) || ( pxSocket->u.xTCP.rxStream != NULL ) )
 80055e8:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80055ea:	2b00      	cmp	r3, #0
 80055ec:	f040 80b2 	bne.w	8005754 <FreeRTOS_setsockopt+0x24c>
 80055f0:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	f040 80b1 	bne.w	800575a <FreeRTOS_setsockopt+0x252>
					FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDBUF, &( pxProps->lTxBufSize ), sizeof( pxProps->lTxBufSize ) );
 80055f8:	2504      	movs	r5, #4
 80055fa:	9500      	str	r5, [sp, #0]
 80055fc:	4633      	mov	r3, r6
 80055fe:	462a      	mov	r2, r5
 8005600:	2100      	movs	r1, #0
 8005602:	4620      	mov	r0, r4
 8005604:	f7ff ff80 	bl	8005508 <FreeRTOS_setsockopt>
					FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVBUF, &( pxProps->lRxBufSize ), sizeof( pxProps->lRxBufSize ) );
 8005608:	9500      	str	r5, [sp, #0]
 800560a:	f106 0308 	add.w	r3, r6, #8
 800560e:	2205      	movs	r2, #5
 8005610:	2100      	movs	r1, #0
 8005612:	4620      	mov	r0, r4
 8005614:	f7ff ff78 	bl	8005508 <FreeRTOS_setsockopt>
						pxSocket->u.xTCP.uxRxWinSize = ( uint32_t )pxProps->lRxWinSize;	/* Fixed value: size of the TCP reception window */
 8005618:	68f3      	ldr	r3, [r6, #12]
 800561a:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
						pxSocket->u.xTCP.uxTxWinSize = ( uint32_t )pxProps->lTxWinSize;	/* Fixed value: size of the TCP transmit window */
 800561e:	6873      	ldr	r3, [r6, #4]
 8005620:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
					if( pxSocket->u.xTCP.xTCPWindow.u.bits.bHasInit != pdFALSE_UNSIGNED )
 8005624:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
 8005628:	f012 0f01 	tst.w	r2, #1
 800562c:	f000 8098 	beq.w	8005760 <FreeRTOS_setsockopt+0x258>
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxRxWinSize * pxSocket->u.xTCP.usInitMSS;
 8005630:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket->u.xTCP.usInitMSS;
 8005634:	fb03 f302 	mul.w	r3, r3, r2
 8005638:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
				xReturn = 0;
 800563c:	2300      	movs	r3, #0
 800563e:	e787      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005640:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005644:	2b06      	cmp	r3, #6
 8005646:	f040 808d 	bne.w	8005764 <FreeRTOS_setsockopt+0x25c>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 800564a:	6833      	ldr	r3, [r6, #0]
 800564c:	b13b      	cbz	r3, 800565e <FreeRTOS_setsockopt+0x156>
						pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE_UNSIGNED;
 800564e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005652:	f043 0308 	orr.w	r3, r3, #8
 8005656:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
				xReturn = 0;
 800565a:	2300      	movs	r3, #0
 800565c:	e778      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE_UNSIGNED;
 800565e:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8005662:	f36f 02c3 	bfc	r2, #3, #1
 8005666:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 800566a:	e771      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800566c:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005670:	2b06      	cmp	r3, #6
 8005672:	d17a      	bne.n	800576a <FreeRTOS_setsockopt+0x262>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 8005674:	6833      	ldr	r3, [r6, #0]
 8005676:	b13b      	cbz	r3, 8005688 <FreeRTOS_setsockopt+0x180>
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE_UNSIGNED;
 8005678:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800567c:	f043 0310 	orr.w	r3, r3, #16
 8005680:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
				xReturn = 0;
 8005684:	2300      	movs	r3, #0
 8005686:	e763      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE_UNSIGNED;
 8005688:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 800568c:	f36f 1204 	bfc	r2, #4, #1
 8005690:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 8005694:	e75c      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005696:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 800569a:	2b06      	cmp	r3, #6
 800569c:	d168      	bne.n	8005770 <FreeRTOS_setsockopt+0x268>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 800569e:	6833      	ldr	r3, [r6, #0]
 80056a0:	b183      	cbz	r3, 80056c4 <FreeRTOS_setsockopt+0x1bc>
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdTRUE_UNSIGNED;
 80056a2:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 80056a6:	f043 0302 	orr.w	r3, r3, #2
 80056aa:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
 80056ae:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 80056b2:	f013 0f02 	tst.w	r3, #2
 80056b6:	d15e      	bne.n	8005776 <FreeRTOS_setsockopt+0x26e>
 80056b8:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80056bc:	2b04      	cmp	r3, #4
 80056be:	d808      	bhi.n	80056d2 <FreeRTOS_setsockopt+0x1ca>
				xReturn = 0;
 80056c0:	2300      	movs	r3, #0
 80056c2:	e745      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE_UNSIGNED;
 80056c4:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 80056c8:	f36f 0341 	bfc	r3, #1, #1
 80056cc:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
 80056d0:	e7ed      	b.n	80056ae <FreeRTOS_setsockopt+0x1a6>
						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
 80056d2:	4620      	mov	r0, r4
 80056d4:	f7ff ff03 	bl	80054de <FreeRTOS_tx_size>
						( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 80056d8:	4603      	mov	r3, r0
 80056da:	2800      	cmp	r0, #0
 80056dc:	f43f af38 	beq.w	8005550 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.usTimeout = 1u; /* to set/clear bSendFullSize */
 80056e0:	2301      	movs	r3, #1
 80056e2:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
 80056e6:	2005      	movs	r0, #5
 80056e8:	f7fe fcec 	bl	80040c4 <xSendEventToIPTask>
				xReturn = 0;
 80056ec:	2300      	movs	r3, #0
 80056ee:	e72f      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80056f0:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 80056f4:	2b06      	cmp	r3, #6
 80056f6:	d140      	bne.n	800577a <FreeRTOS_setsockopt+0x272>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 80056f8:	6833      	ldr	r3, [r6, #0]
 80056fa:	b19b      	cbz	r3, 8005724 <FreeRTOS_setsockopt+0x21c>
						pxSocket->u.xTCP.bits.bRxStopped = pdTRUE_UNSIGNED;
 80056fc:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005700:	f043 0304 	orr.w	r3, r3, #4
 8005704:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
					pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8005708:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800570c:	f043 0301 	orr.w	r3, r3, #1
 8005710:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = 1u; /* to set/clear bRxStopped */
 8005714:	2301      	movs	r3, #1
 8005716:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
					xSendEventToIPTask( eTCPTimerEvent );
 800571a:	2005      	movs	r0, #5
 800571c:	f7fe fcd2 	bl	80040c4 <xSendEventToIPTask>
				xReturn = 0;
 8005720:	2300      	movs	r3, #0
				break;
 8005722:	e715      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.bits.bRxStopped = pdFALSE_UNSIGNED;
 8005724:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005728:	f36f 0382 	bfc	r3, #2, #1
 800572c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8005730:	e7ea      	b.n	8005708 <FreeRTOS_setsockopt+0x200>
			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
 8005732:	f06f 036c 	mvn.w	r3, #108	; 0x6c
 8005736:	e70b      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
			xReturn = 0;
 8005738:	2300      	movs	r3, #0
 800573a:	e709      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800573c:	f06f 0315 	mvn.w	r3, #21
 8005740:	e706      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 8005742:	f06f 0315 	mvn.w	r3, #21
 8005746:	e703      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 8005748:	f06f 0315 	mvn.w	r3, #21
 800574c:	e700      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 800574e:	f06f 0315 	mvn.w	r3, #21
 8005752:	e6fd      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 8005754:	f06f 0315 	mvn.w	r3, #21
 8005758:	e6fa      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 800575a:	f06f 0315 	mvn.w	r3, #21
 800575e:	e6f7      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
				xReturn = 0;
 8005760:	2300      	movs	r3, #0
 8005762:	e6f5      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005764:	f06f 0315 	mvn.w	r3, #21
 8005768:	e6f2      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 800576a:	f06f 0315 	mvn.w	r3, #21
 800576e:	e6ef      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 8005770:	f06f 0315 	mvn.w	r3, #21
 8005774:	e6ec      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
				xReturn = 0;
 8005776:	2300      	movs	r3, #0
 8005778:	e6ea      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800577a:	f06f 0315 	mvn.w	r3, #21
	return xReturn;
 800577e:	e6e7      	b.n	8005550 <FreeRTOS_setsockopt+0x48>
 8005780:	0800c4a4 	.word	0x0800c4a4

08005784 <FreeRTOS_issocketconnected>:
	BaseType_t FreeRTOS_issocketconnected( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn = pdFALSE;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005784:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005788:	2b06      	cmp	r3, #6
 800578a:	d108      	bne.n	800579e <FreeRTOS_issocketconnected+0x1a>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
 800578c:	f890 0053 	ldrb.w	r0, [r0, #83]	; 0x53
 8005790:	3805      	subs	r0, #5
 8005792:	b2c0      	uxtb	r0, r0
 8005794:	2802      	cmp	r0, #2
 8005796:	bf8c      	ite	hi
 8005798:	2000      	movhi	r0, #0
 800579a:	2001      	movls	r0, #1
 800579c:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800579e:	f06f 0015 	mvn.w	r0, #21
				}
			}
		}

		return xReturn;
	}
 80057a2:	4770      	bx	lr

080057a4 <FreeRTOS_connect>:
	{
 80057a4:	b570      	push	{r4, r5, r6, lr}
 80057a6:	b086      	sub	sp, #24
 80057a8:	4604      	mov	r4, r0
 80057aa:	460d      	mov	r5, r1
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdFALSE )
 80057ac:	2200      	movs	r2, #0
 80057ae:	2106      	movs	r1, #6
 80057b0:	f7fe ff42 	bl	8004638 <prvValidSocket>
 80057b4:	2800      	cmp	r0, #0
 80057b6:	d06c      	beq.n	8005892 <FreeRTOS_connect+0xee>
		else if( FreeRTOS_issocketconnected( pxSocket ) > 0 )
 80057b8:	4620      	mov	r0, r4
 80057ba:	f7ff ffe3 	bl	8005784 <FreeRTOS_issocketconnected>
 80057be:	2800      	cmp	r0, #0
 80057c0:	dd02      	ble.n	80057c8 <FreeRTOS_connect+0x24>
			xResult = -pdFREERTOS_ERRNO_EISCONN;
 80057c2:	f06f 037e 	mvn.w	r3, #126	; 0x7e
 80057c6:	e066      	b.n	8005896 <FreeRTOS_connect+0xf2>
		else if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
 80057c8:	69a3      	ldr	r3, [r4, #24]
 80057ca:	b14b      	cbz	r3, 80057e0 <FreeRTOS_connect+0x3c>
		switch( pxSocket->u.xTCP.ucTCPState )
 80057cc:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80057d0:	2b02      	cmp	r3, #2
 80057d2:	d063      	beq.n	800589c <FreeRTOS_connect+0xf8>
 80057d4:	2b08      	cmp	r3, #8
 80057d6:	d00c      	beq.n	80057f2 <FreeRTOS_connect+0x4e>
 80057d8:	b15b      	cbz	r3, 80057f2 <FreeRTOS_connect+0x4e>
			default:			return -pdFREERTOS_ERRNO_EAGAIN;
 80057da:	f06f 030a 	mvn.w	r3, #10
 80057de:	e05a      	b.n	8005896 <FreeRTOS_connect+0xf2>
			xResult = FreeRTOS_bind( ( Socket_t ) pxSocket, NULL, 0u );
 80057e0:	2200      	movs	r2, #0
 80057e2:	4611      	mov	r1, r2
 80057e4:	4620      	mov	r0, r4
 80057e6:	f7ff f8b0 	bl	800494a <FreeRTOS_bind>
		if( xResult == 0 )
 80057ea:	4603      	mov	r3, r0
 80057ec:	2800      	cmp	r0, #0
 80057ee:	d0ed      	beq.n	80057cc <FreeRTOS_connect+0x28>
 80057f0:	e051      	b.n	8005896 <FreeRTOS_connect+0xf2>
				pxSocket->u.xTCP.bits.bConnPrepared = pdFALSE_UNSIGNED;
 80057f2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80057f6:	f36f 03c3 	bfc	r3, #3, #1
 80057fa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
				pxSocket->u.xTCP.ucRepCount = 0u;
 80057fe:	2300      	movs	r3, #0
 8005800:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
				pxSocket->u.xTCP.usRemotePort = FreeRTOS_ntohs( pxAddress->sin_port );
 8005804:	886a      	ldrh	r2, [r5, #2]
 8005806:	0a13      	lsrs	r3, r2, #8
 8005808:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800580c:	87a3      	strh	r3, [r4, #60]	; 0x3c
				pxSocket->u.xTCP.ulRemoteIP = FreeRTOS_ntohl( pxAddress->sin_addr );
 800580e:	686b      	ldr	r3, [r5, #4]
 8005810:	0e1a      	lsrs	r2, r3, #24
 8005812:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8005816:	0219      	lsls	r1, r3, #8
 8005818:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 800581c:	430a      	orrs	r2, r1
 800581e:	0a1b      	lsrs	r3, r3, #8
 8005820:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005824:	4313      	orrs	r3, r2
 8005826:	63a3      	str	r3, [r4, #56]	; 0x38
				vTCPStateChange( pxSocket, eCONNECT_SYN );
 8005828:	2102      	movs	r1, #2
 800582a:	4620      	mov	r0, r4
 800582c:	f000 fc3a 	bl	80060a4 <vTCPStateChange>
				pxSocket->u.xTCP.usTimeout = 1u;
 8005830:	2301      	movs	r3, #1
 8005832:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
				if( xSendEventToIPTask( eTCPTimerEvent ) != pdPASS )
 8005836:	2005      	movs	r0, #5
 8005838:	f7fe fc44 	bl	80040c4 <xSendEventToIPTask>
 800583c:	4605      	mov	r5, r0
 800583e:	2801      	cmp	r0, #1
 8005840:	d12f      	bne.n	80058a2 <FreeRTOS_connect+0xfe>
 8005842:	2300      	movs	r3, #0
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_CONNECT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 8005844:	461e      	mov	r6, r3
 8005846:	e013      	b.n	8005870 <FreeRTOS_connect+0xcc>
				xResult = FreeRTOS_issocketconnected( pxSocket );
 8005848:	4620      	mov	r0, r4
 800584a:	f7ff ff9b 	bl	8005784 <FreeRTOS_issocketconnected>
				if( xResult < 0 )
 800584e:	1e03      	subs	r3, r0, #0
 8005850:	db21      	blt.n	8005896 <FreeRTOS_connect+0xf2>
				if( xResult > 0 )
 8005852:	dc19      	bgt.n	8005888 <FreeRTOS_connect+0xe4>
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) )
 8005854:	a905      	add	r1, sp, #20
 8005856:	a803      	add	r0, sp, #12
 8005858:	f004 fbbc 	bl	8009fd4 <xTaskCheckForTimeOut>
 800585c:	b9b0      	cbnz	r0, 800588c <FreeRTOS_connect+0xe8>
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_CONNECT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 800585e:	9b05      	ldr	r3, [sp, #20]
 8005860:	9300      	str	r3, [sp, #0]
 8005862:	4633      	mov	r3, r6
 8005864:	2201      	movs	r2, #1
 8005866:	2108      	movs	r1, #8
 8005868:	6860      	ldr	r0, [r4, #4]
 800586a:	f002 fea5 	bl	80085b8 <xEventGroupWaitBits>
 800586e:	462b      	mov	r3, r5
				if( xTimed == pdFALSE )
 8005870:	2b00      	cmp	r3, #0
 8005872:	d1e9      	bne.n	8005848 <FreeRTOS_connect+0xa4>
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8005874:	69e3      	ldr	r3, [r4, #28]
 8005876:	9305      	str	r3, [sp, #20]
					if( xRemainingTime == ( TickType_t )0 )
 8005878:	b11b      	cbz	r3, 8005882 <FreeRTOS_connect+0xde>
					vTaskSetTimeOutState( &xTimeOut );
 800587a:	a803      	add	r0, sp, #12
 800587c:	f004 fb94 	bl	8009fa8 <vTaskSetTimeOutState>
 8005880:	e7e2      	b.n	8005848 <FreeRTOS_connect+0xa4>
						xResult = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 8005882:	f06f 030a 	mvn.w	r3, #10
 8005886:	e006      	b.n	8005896 <FreeRTOS_connect+0xf2>
					xResult = 0;
 8005888:	2300      	movs	r3, #0
 800588a:	e004      	b.n	8005896 <FreeRTOS_connect+0xf2>
					xResult = -pdFREERTOS_ERRNO_ETIMEDOUT;
 800588c:	f06f 0373 	mvn.w	r3, #115	; 0x73
		return xResult;
 8005890:	e001      	b.n	8005896 <FreeRTOS_connect+0xf2>
			xResult = -pdFREERTOS_ERRNO_EBADF;
 8005892:	f06f 0308 	mvn.w	r3, #8
	}
 8005896:	4618      	mov	r0, r3
 8005898:	b006      	add	sp, #24
 800589a:	bd70      	pop	{r4, r5, r6, pc}
			case eCONNECT_SYN:	return -pdFREERTOS_ERRNO_EINPROGRESS;
 800589c:	f06f 0376 	mvn.w	r3, #118	; 0x76
 80058a0:	e7f9      	b.n	8005896 <FreeRTOS_connect+0xf2>
					xResult = -pdFREERTOS_ERRNO_ECANCELED;
 80058a2:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80058a6:	e7f6      	b.n	8005896 <FreeRTOS_connect+0xf2>

080058a8 <FreeRTOS_rx_size>:
	BaseType_t FreeRTOS_rx_size( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80058a8:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 80058ac:	2b06      	cmp	r3, #6
 80058ae:	d10a      	bne.n	80058c6 <FreeRTOS_rx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else if( pxSocket->u.xTCP.rxStream != NULL )
 80058b0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 80058b2:	b15b      	cbz	r3, 80058cc <FreeRTOS_rx_size+0x24>
size_t uxHead = pxBuffer->uxHead;
 80058b4:	6898      	ldr	r0, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 80058b6:	681a      	ldr	r2, [r3, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80058b8:	691b      	ldr	r3, [r3, #16]
 80058ba:	4418      	add	r0, r3
 80058bc:	1a80      	subs	r0, r0, r2
	if ( uxCount >= pxBuffer->LENGTH )
 80058be:	4283      	cmp	r3, r0
 80058c0:	d805      	bhi.n	80058ce <FreeRTOS_rx_size+0x26>
		uxCount -= pxBuffer->LENGTH;
 80058c2:	1ac0      	subs	r0, r0, r3
 80058c4:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 80058c6:	f06f 0015 	mvn.w	r0, #21
 80058ca:	4770      	bx	lr
		{
			xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
		}
		else
		{
			xReturn = 0;
 80058cc:	2000      	movs	r0, #0
		}

		return xReturn;
	}
 80058ce:	4770      	bx	lr

080058d0 <FreeRTOS_netstat>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	void FreeRTOS_netstat( void )
	{
 80058d0:	b500      	push	{lr}
 80058d2:	b083      	sub	sp, #12
	IPStackEvent_t xAskEvent;

		/* Ask the IP-task to call vTCPNetStat()
		 * to avoid accessing xBoundTCPSocketsList
		 */
		xAskEvent.eEventType = eTCPNetStat;
 80058d4:	2307      	movs	r3, #7
 80058d6:	f88d 3000 	strb.w	r3, [sp]
		xAskEvent.pvData = ( void * ) NULL;
 80058da:	2300      	movs	r3, #0
 80058dc:	9301      	str	r3, [sp, #4]
		xSendEventStructToIPTask( &xAskEvent, 1000u );
 80058de:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80058e2:	4668      	mov	r0, sp
 80058e4:	f7fe fb58 	bl	8003f98 <xSendEventStructToIPTask>
	}
 80058e8:	b003      	add	sp, #12
 80058ea:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080058f0 <vTCPNetStat>:
/*-----------------------------------------------------------*/

#if( ( ipconfigHAS_PRINTF != 0 ) && ( ipconfigUSE_TCP == 1 ) )

	void vTCPNetStat( void )
	{
 80058f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80058f4:	b08d      	sub	sp, #52	; 0x34
	/* Show a simple listing of all created sockets and their connections */
	ListItem_t *pxIterator;
	BaseType_t count = 0;

		if( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) == pdFALSE )
 80058f6:	4b40      	ldr	r3, [pc, #256]	; (80059f8 <vTCPNetStat+0x108>)
 80058f8:	689b      	ldr	r3, [r3, #8]
 80058fa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80058fe:	d005      	beq.n	800590c <vTCPNetStat+0x1c>
		{
			FreeRTOS_printf( ( "PLUS-TCP not initialized\n" ) );
 8005900:	483e      	ldr	r0, [pc, #248]	; (80059fc <vTCPNetStat+0x10c>)
 8005902:	f005 fd69 	bl	800b3d8 <lUDPLoggingPrintf>
				count,
				uxGetMinimumFreeNetworkBuffers( ),
				uxGetNumberOfFreeNetworkBuffers( ),
				ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ) );
		}
	}
 8005906:	b00d      	add	sp, #52	; 0x34
 8005908:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			FreeRTOS_printf( ( "Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n" ) );
 800590c:	483c      	ldr	r0, [pc, #240]	; (8005a00 <vTCPNetStat+0x110>)
 800590e:	f005 fd63 	bl	800b3d8 <lUDPLoggingPrintf>
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8005912:	4b39      	ldr	r3, [pc, #228]	; (80059f8 <vTCPNetStat+0x108>)
 8005914:	68de      	ldr	r6, [r3, #12]
 8005916:	3308      	adds	r3, #8
 8005918:	429e      	cmp	r6, r3
 800591a:	d06b      	beq.n	80059f4 <vTCPNetStat+0x104>
 800591c:	2700      	movs	r7, #0
				FreeRTOS_printf( ( "TCP %5d %-16lxip:%5d %d/%d %-13.13s %6lu %6u%s\n",
 800591e:	46b9      	mov	r9, r7
 8005920:	e02d      	b.n	800597e <vTCPNetStat+0x8e>
 8005922:	f8b4 a024 	ldrh.w	sl, [r4, #36]	; 0x24
 8005926:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005928:	9307      	str	r3, [sp, #28]
 800592a:	f8b4 b03c 	ldrh.w	fp, [r4, #60]	; 0x3c
 800592e:	6f67      	ldr	r7, [r4, #116]	; 0x74
 8005930:	3700      	adds	r7, #0
 8005932:	bf18      	it	ne
 8005934:	2701      	movne	r7, #1
 8005936:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005938:	f113 0800 	adds.w	r8, r3, #0
 800593c:	bf18      	it	ne
 800593e:	f04f 0801 	movne.w	r8, #1
 8005942:	f894 0053 	ldrb.w	r0, [r4, #83]	; 0x53
 8005946:	f001 fd51 	bl	80073ec <FreeRTOS_GetTCPStateName>
 800594a:	a908      	add	r1, sp, #32
 800594c:	9105      	str	r1, [sp, #20]
 800594e:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
 8005952:	9304      	str	r3, [sp, #16]
 8005954:	4b2b      	ldr	r3, [pc, #172]	; (8005a04 <vTCPNetStat+0x114>)
 8005956:	429d      	cmp	r5, r3
 8005958:	bf28      	it	cs
 800595a:	461d      	movcs	r5, r3
 800595c:	9503      	str	r5, [sp, #12]
 800595e:	9002      	str	r0, [sp, #8]
 8005960:	f8cd 8004 	str.w	r8, [sp, #4]
 8005964:	9700      	str	r7, [sp, #0]
 8005966:	465b      	mov	r3, fp
 8005968:	9a07      	ldr	r2, [sp, #28]
 800596a:	4651      	mov	r1, sl
 800596c:	4826      	ldr	r0, [pc, #152]	; (8005a08 <vTCPNetStat+0x118>)
 800596e:	f005 fd33 	bl	800b3d8 <lUDPLoggingPrintf>
				count++;
 8005972:	f109 0901 	add.w	r9, r9, #1
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8005976:	6876      	ldr	r6, [r6, #4]
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8005978:	4b24      	ldr	r3, [pc, #144]	; (8005a0c <vTCPNetStat+0x11c>)
 800597a:	429e      	cmp	r6, r3
 800597c:	d018      	beq.n	80059b0 <vTCPNetStat+0xc0>
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800597e:	68f4      	ldr	r4, [r6, #12]
					TickType_t age = xTaskGetTickCount() - pxSocket->u.xTCP.xLastAliveTime;
 8005980:	f004 f81e 	bl	80099c0 <xTaskGetTickCount>
 8005984:	6de5      	ldr	r5, [r4, #92]	; 0x5c
 8005986:	1b45      	subs	r5, r0, r5
				char ucChildText[16] = "";
 8005988:	2300      	movs	r3, #0
 800598a:	9308      	str	r3, [sp, #32]
 800598c:	9309      	str	r3, [sp, #36]	; 0x24
 800598e:	930a      	str	r3, [sp, #40]	; 0x28
 8005990:	930b      	str	r3, [sp, #44]	; 0x2c
				if (pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN)
 8005992:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005996:	2b01      	cmp	r3, #1
 8005998:	d1c3      	bne.n	8005922 <vTCPNetStat+0x32>
					snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
 800599a:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 800599e:	f8b4 2050 	ldrh.w	r2, [r4, #80]	; 0x50
 80059a2:	9200      	str	r2, [sp, #0]
 80059a4:	4a1a      	ldr	r2, [pc, #104]	; (8005a10 <vTCPNetStat+0x120>)
 80059a6:	2110      	movs	r1, #16
 80059a8:	a808      	add	r0, sp, #32
 80059aa:	f006 f852 	bl	800ba52 <snprintf>
 80059ae:	e7b8      	b.n	8005922 <vTCPNetStat+0x32>
 80059b0:	464f      	mov	r7, r9
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 80059b2:	4b18      	ldr	r3, [pc, #96]	; (8005a14 <vTCPNetStat+0x124>)
 80059b4:	68dc      	ldr	r4, [r3, #12]
 80059b6:	3308      	adds	r3, #8
 80059b8:	429c      	cmp	r4, r3
 80059ba:	d00d      	beq.n	80059d8 <vTCPNetStat+0xe8>
				FreeRTOS_printf( ( "UDP Port %5u\n",
 80059bc:	4e16      	ldr	r6, [pc, #88]	; (8005a18 <vTCPNetStat+0x128>)
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 80059be:	461d      	mov	r5, r3
				FreeRTOS_printf( ( "UDP Port %5u\n",
 80059c0:	6823      	ldr	r3, [r4, #0]
 80059c2:	0a19      	lsrs	r1, r3, #8
 80059c4:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 80059c8:	b289      	uxth	r1, r1
 80059ca:	4630      	mov	r0, r6
 80059cc:	f005 fd04 	bl	800b3d8 <lUDPLoggingPrintf>
				count++;
 80059d0:	3701      	adds	r7, #1
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 80059d2:	6864      	ldr	r4, [r4, #4]
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 80059d4:	42ac      	cmp	r4, r5
 80059d6:	d1f3      	bne.n	80059c0 <vTCPNetStat+0xd0>
			FreeRTOS_printf( ( "FreeRTOS_netstat: %lu sockets %lu < %lu < %d buffers free\n",
 80059d8:	f002 face 	bl	8007f78 <uxGetMinimumFreeNetworkBuffers>
 80059dc:	4604      	mov	r4, r0
 80059de:	f002 fac5 	bl	8007f6c <uxGetNumberOfFreeNetworkBuffers>
 80059e2:	2319      	movs	r3, #25
 80059e4:	9300      	str	r3, [sp, #0]
 80059e6:	4603      	mov	r3, r0
 80059e8:	4622      	mov	r2, r4
 80059ea:	4639      	mov	r1, r7
 80059ec:	480b      	ldr	r0, [pc, #44]	; (8005a1c <vTCPNetStat+0x12c>)
 80059ee:	f005 fcf3 	bl	800b3d8 <lUDPLoggingPrintf>
	}
 80059f2:	e788      	b.n	8005906 <vTCPNetStat+0x16>
	BaseType_t count = 0;
 80059f4:	2700      	movs	r7, #0
 80059f6:	e7dc      	b.n	80059b2 <vTCPNetStat+0xc2>
 80059f8:	20002804 	.word	0x20002804
 80059fc:	0800c4dc 	.word	0x0800c4dc
 8005a00:	0800c4f8 	.word	0x0800c4f8
 8005a04:	000f423f 	.word	0x000f423f
 8005a08:	0800c548 	.word	0x0800c548
 8005a0c:	2000280c 	.word	0x2000280c
 8005a10:	0800c540 	.word	0x0800c540
 8005a14:	20002818 	.word	0x20002818
 8005a18:	0800c578 	.word	0x0800c578
 8005a1c:	0800c588 	.word	0x0800c588

08005a20 <vSocketSelect>:
/*-----------------------------------------------------------*/

#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )

	void vSocketSelect( SocketSelect_t *pxSocketSet )
	{
 8005a20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005a24:	b085      	sub	sp, #20
 8005a26:	4606      	mov	r6, r0
		BaseType_t xLastRound = 0;
	#endif

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;
		pxSocketSet->pxSocket = NULL;
 8005a28:	2300      	movs	r3, #0
 8005a2a:	6083      	str	r3, [r0, #8]
 8005a2c:	f04f 0a01 	mov.w	sl, #1
		EventBits_t xGroupBits = 0;
 8005a30:	4698      	mov	r8, r3
			else
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8005a32:	4b51      	ldr	r3, [pc, #324]	; (8005b78 <vSocketSelect+0x158>)
 8005a34:	3308      	adds	r3, #8
 8005a36:	9303      	str	r3, [sp, #12]
 8005a38:	f8df b148 	ldr.w	fp, [pc, #328]	; 8005b84 <vSocketSelect+0x164>
 8005a3c:	f10b 0308 	add.w	r3, fp, #8
 8005a40:	9301      	str	r3, [sp, #4]
 8005a42:	e070      	b.n	8005b26 <vSocketSelect+0x106>
 8005a44:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8005a48:	f003 0306 	and.w	r3, r3, #6
 8005a4c:	9302      	str	r3, [sp, #8]
								bAccepted = pdTRUE;
							}
						}

						/* Is the set owner interested in READ events? */
						if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
 8005a4e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8005a50:	f013 0f01 	tst.w	r3, #1
 8005a54:	d01b      	beq.n	8005a8e <vSocketSelect+0x6e>
						{
							if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 8005a56:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 8005a5a:	2a01      	cmp	r2, #1
 8005a5c:	d004      	beq.n	8005a68 <vSocketSelect+0x48>
								if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != 0 ) )
								{
									xSocketBits |= eSELECT_READ;
								}
							}
							else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 8005a5e:	9b02      	ldr	r3, [sp, #8]
 8005a60:	b15b      	cbz	r3, 8005a7a <vSocketSelect+0x5a>
				xSocketBits = 0;
 8005a62:	f04f 0900 	mov.w	r9, #0
 8005a66:	e014      	b.n	8005a92 <vSocketSelect+0x72>
								if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != 0 ) )
 8005a68:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 8005a6a:	2a00      	cmp	r2, #0
 8005a6c:	f000 8081 	beq.w	8005b72 <vSocketSelect+0x152>
 8005a70:	f892 9040 	ldrb.w	r9, [r2, #64]	; 0x40
 8005a74:	f3c9 0940 	ubfx	r9, r9, #1, #1
 8005a78:	e016      	b.n	8005aa8 <vSocketSelect+0x88>
							else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 8005a7a:	4628      	mov	r0, r5
 8005a7c:	f7ff ff14 	bl	80058a8 <FreeRTOS_rx_size>
 8005a80:	2800      	cmp	r0, #0
 8005a82:	bfd4      	ite	le
 8005a84:	f04f 0900 	movle.w	r9, #0
 8005a88:	f04f 0901 	movgt.w	r9, #1
 8005a8c:	e001      	b.n	8005a92 <vSocketSelect+0x72>
				xSocketBits = 0;
 8005a8e:	f04f 0900 	mov.w	r9, #0
							{
								xSocketBits |= eSELECT_READ;
							}
						}
						/* Is the set owner interested in EXCEPTION events? */
						if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
 8005a92:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8005a94:	f013 0f04 	tst.w	r3, #4
 8005a98:	d006      	beq.n	8005aa8 <vSocketSelect+0x88>
						{
							if( ( pxSocket->u.xTCP.ucTCPState == eCLOSE_WAIT ) || ( pxSocket->u.xTCP.ucTCPState == eCLOSED ) )
 8005a9a:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 8005a9e:	f012 0ff7 	tst.w	r2, #247	; 0xf7
							{
								xSocketBits |= eSELECT_EXCEPT;
 8005aa2:	bf08      	it	eq
 8005aa4:	f049 0904 	orreq.w	r9, r9, #4
							}
						}

						/* Is the set owner interested in WRITE events? */
						if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
 8005aa8:	f013 0f02 	tst.w	r3, #2
 8005aac:	d01c      	beq.n	8005ae8 <vSocketSelect+0xc8>
						{
							BaseType_t bMatch = pdFALSE;

							if( bAccepted != 0 )
 8005aae:	9b02      	ldr	r3, [sp, #8]
 8005ab0:	b183      	cbz	r3, 8005ad4 <vSocketSelect+0xb4>
								}
							}

							if( bMatch == pdFALSE )
							{
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 8005ab2:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8005ab6:	f013 0f08 	tst.w	r3, #8
 8005aba:	d015      	beq.n	8005ae8 <vSocketSelect+0xc8>
 8005abc:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 8005ac0:	2a04      	cmp	r2, #4
 8005ac2:	d911      	bls.n	8005ae8 <vSocketSelect+0xc8>
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8005ac4:	f013 0f10 	tst.w	r3, #16
 8005ac8:	d10e      	bne.n	8005ae8 <vSocketSelect+0xc8>
									( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
								{
									pxSocket->u.xTCP.bits.bConnPassed = pdTRUE_UNSIGNED;
 8005aca:	f043 0310 	orr.w	r3, r3, #16
 8005ace:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 8005ad2:	e004      	b.n	8005ade <vSocketSelect+0xbe>
								if( FreeRTOS_tx_space( pxSocket ) > 0 )
 8005ad4:	4628      	mov	r0, r5
 8005ad6:	f7ff fced 	bl	80054b4 <FreeRTOS_tx_space>
							if( bMatch == pdFALSE )
 8005ada:	2800      	cmp	r0, #0
 8005adc:	dde9      	ble.n	8005ab2 <vSocketSelect+0x92>
								}
							}

							if( bMatch != pdFALSE )
							{
								xSocketBits |= eSELECT_WRITE;
 8005ade:	f049 0902 	orr.w	r9, r9, #2
 8005ae2:	e001      	b.n	8005ae8 <vSocketSelect+0xc8>
				xSocketBits = 0;
 8005ae4:	f04f 0900 	mov.w	r9, #0
					/* The WRITE and EXCEPT bits are not used for UDP */
				}	/* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */

				/* Each socket keeps its own event flags, which are looked-up
				by FreeRTOS_FD_ISSSET() */
				pxSocket->xSocketBits = xSocketBits;
 8005ae8:	f8c5 9030 	str.w	r9, [r5, #48]	; 0x30

				/* The ORed value will be used to set the bits in the event
				group. */
				xGroupBits |= xSocketBits;
 8005aec:	ea48 0809 	orr.w	r8, r8, r9
				 pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8005af0:	6864      	ldr	r4, [r4, #4]
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8005af2:	42bc      	cmp	r4, r7
 8005af4:	d012      	beq.n	8005b1c <vSocketSelect+0xfc>
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8005af6:	68e5      	ldr	r5, [r4, #12]
				if( pxSocket->pxSocketSet != pxSocketSet )
 8005af8:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8005afa:	429e      	cmp	r6, r3
 8005afc:	d1f8      	bne.n	8005af0 <vSocketSelect+0xd0>
					if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP )
 8005afe:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
 8005b02:	2b06      	cmp	r3, #6
 8005b04:	d09e      	beq.n	8005a44 <vSocketSelect+0x24>
					if( ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) &&
 8005b06:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8005b08:	f013 0f01 	tst.w	r3, #1
 8005b0c:	d0ea      	beq.n	8005ae4 <vSocketSelect+0xc4>
 8005b0e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005b10:	f113 0900 	adds.w	r9, r3, #0
 8005b14:	bf18      	it	ne
 8005b16:	f04f 0901 	movne.w	r9, #1
 8005b1a:	e7e5      	b.n	8005ae8 <vSocketSelect+0xc8>
		for( xRound = 0; xRound <= xLastRound; xRound++ )
 8005b1c:	f1ba 0f01 	cmp.w	sl, #1
 8005b20:	dc0b      	bgt.n	8005b3a <vSocketSelect+0x11a>
 8005b22:	f10a 0a01 	add.w	sl, sl, #1
			if( xRound == 0 )
 8005b26:	f1ba 0f01 	cmp.w	sl, #1
 8005b2a:	d01b      	beq.n	8005b64 <vSocketSelect+0x144>
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8005b2c:	f8db 400c 	ldr.w	r4, [fp, #12]
 8005b30:	9b01      	ldr	r3, [sp, #4]
 8005b32:	429c      	cmp	r4, r3
 8005b34:	d0f2      	beq.n	8005b1c <vSocketSelect+0xfc>
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
 8005b36:	4f11      	ldr	r7, [pc, #68]	; (8005b7c <vSocketSelect+0x15c>)
 8005b38:	e7dd      	b.n	8005af6 <vSocketSelect+0xd6>

			}	/* for( pxIterator ... ) */
		}	/* for( xRound = 0; xRound <= xLastRound; xRound++ ) */

		xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 8005b3a:	2100      	movs	r1, #0
 8005b3c:	6830      	ldr	r0, [r6, #0]
 8005b3e:	f002 fdbf 	bl	80086c0 <xEventGroupClearBits>
 8005b42:	f000 0007 	and.w	r0, r0, #7
			and cleared in FreeRTOS_select(). */
			xBitsToClear &= ( EventBits_t ) ~eSELECT_INTR;
		}
		#endif /* ipconfigSUPPORT_SIGNALS */

		if( xBitsToClear != 0 )
 8005b46:	ea30 0108 	bics.w	r1, r0, r8
 8005b4a:	d107      	bne.n	8005b5c <vSocketSelect+0x13c>
		{
			xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
		}

		/* Now include eSELECT_CALL_IP to wakeup the caller. */
		xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | eSELECT_CALL_IP );
 8005b4c:	f048 0110 	orr.w	r1, r8, #16
 8005b50:	6830      	ldr	r0, [r6, #0]
 8005b52:	f002 fdd5 	bl	8008700 <xEventGroupSetBits>
	}
 8005b56:	b005      	add	sp, #20
 8005b58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
 8005b5c:	6830      	ldr	r0, [r6, #0]
 8005b5e:	f002 fdaf 	bl	80086c0 <xEventGroupClearBits>
 8005b62:	e7f3      	b.n	8005b4c <vSocketSelect+0x12c>
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8005b64:	4b04      	ldr	r3, [pc, #16]	; (8005b78 <vSocketSelect+0x158>)
 8005b66:	68dc      	ldr	r4, [r3, #12]
 8005b68:	9b03      	ldr	r3, [sp, #12]
 8005b6a:	429c      	cmp	r4, r3
 8005b6c:	d0d9      	beq.n	8005b22 <vSocketSelect+0x102>
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundUDPSocketsList );
 8005b6e:	4f04      	ldr	r7, [pc, #16]	; (8005b80 <vSocketSelect+0x160>)
 8005b70:	e7c1      	b.n	8005af6 <vSocketSelect+0xd6>
 8005b72:	f04f 0900 	mov.w	r9, #0
 8005b76:	e797      	b.n	8005aa8 <vSocketSelect+0x88>
 8005b78:	20002818 	.word	0x20002818
 8005b7c:	2000280c 	.word	0x2000280c
 8005b80:	20002820 	.word	0x20002820
 8005b84:	20002804 	.word	0x20002804

08005b88 <FreeRTOS_SignalSocket>:
	BaseType_t FreeRTOS_SignalSocket( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket == NULL )
 8005b88:	b188      	cbz	r0, 8005bae <FreeRTOS_SignalSocket+0x26>
	{
 8005b8a:	b508      	push	{r3, lr}
 8005b8c:	4603      	mov	r3, r0
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
		if( ( pxSocket->pxSocketSet != NULL ) && ( pxSocket->pxSocketSet->xSelectGroup != NULL ) )
 8005b8e:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8005b90:	b132      	cbz	r2, 8005ba0 <FreeRTOS_SignalSocket+0x18>
 8005b92:	6810      	ldr	r0, [r2, #0]
 8005b94:	b120      	cbz	r0, 8005ba0 <FreeRTOS_SignalSocket+0x18>
		{
			xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_INTR );
 8005b96:	2108      	movs	r1, #8
 8005b98:	f002 fdb2 	bl	8008700 <xEventGroupSetBits>
			xReturn = 0;
 8005b9c:	2000      	movs	r0, #0
 8005b9e:	bd08      	pop	{r3, pc}
		}
		else
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
		if( pxSocket->xEventGroup != NULL )
 8005ba0:	6858      	ldr	r0, [r3, #4]
 8005ba2:	b138      	cbz	r0, 8005bb4 <FreeRTOS_SignalSocket+0x2c>
		{
			xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_INTR );
 8005ba4:	2140      	movs	r1, #64	; 0x40
 8005ba6:	f002 fdab 	bl	8008700 <xEventGroupSetBits>
			xReturn = 0;
 8005baa:	2000      	movs	r0, #0
 8005bac:	bd08      	pop	{r3, pc}
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005bae:	f06f 0015 	mvn.w	r0, #21
 8005bb2:	4770      	bx	lr
		}
		else
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005bb4:	f06f 0015 	mvn.w	r0, #21
		}

		return xReturn;
	}
 8005bb8:	bd08      	pop	{r3, pc}

08005bba <uxStreamBufferAdd>:
 * an offset from uxHead while uxHead will not be moved yet.  This possibility
 * will be used when TCP data is received while earlier data is still missing.
 * If 'pucData' equals NULL, the function is called to advance 'uxHead' only.
 */
size_t uxStreamBufferAdd( StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxCount )
{
 8005bba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
size_t uxHead = pxBuffer->uxHead;
 8005bbe:	6884      	ldr	r4, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 8005bc0:	6805      	ldr	r5, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005bc2:	6906      	ldr	r6, [r0, #16]
 8005bc4:	4435      	add	r5, r6
 8005bc6:	3d01      	subs	r5, #1
 8005bc8:	1b2c      	subs	r4, r5, r4
	if( uxCount >= pxBuffer->LENGTH )
 8005bca:	42a6      	cmp	r6, r4
		uxCount -= pxBuffer->LENGTH;
 8005bcc:	bf98      	it	ls
 8005bce:	1ba4      	subls	r4, r4, r6
size_t uxSpace, uxNextHead, uxFirst;

	uxSpace = uxStreamBufferGetSpace( pxBuffer );

	/* If uxOffset > 0, items can be placed in front of uxHead */
	if( uxSpace > uxOffset )
 8005bd0:	42a1      	cmp	r1, r4
 8005bd2:	d22d      	bcs.n	8005c30 <uxStreamBufferAdd+0x76>
	{
		uxSpace -= uxOffset;
 8005bd4:	1a64      	subs	r4, r4, r1
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 8005bd6:	429c      	cmp	r4, r3
 8005bd8:	bf28      	it	cs
 8005bda:	461c      	movcs	r4, r3

	/* The number of bytes that can be written is the minimum of the number of
	bytes requested and the number available. */
	uxCount = FreeRTOS_min_uint32( uxSpace, uxCount );

	if( uxCount != 0u )
 8005bdc:	b34c      	cbz	r4, 8005c32 <uxStreamBufferAdd+0x78>
 8005bde:	4691      	mov	r9, r2
 8005be0:	4688      	mov	r8, r1
 8005be2:	4605      	mov	r5, r0
	{
		uxNextHead = pxBuffer->uxHead;
 8005be4:	6887      	ldr	r7, [r0, #8]

		if( uxOffset != 0u )
 8005be6:	b339      	cbz	r1, 8005c38 <uxStreamBufferAdd+0x7e>
		{
			/* ( uxOffset > 0 ) means: write in front if the uxHead marker */
			uxNextHead += uxOffset;
 8005be8:	440f      	add	r7, r1
			if( uxNextHead >= pxBuffer->LENGTH )
 8005bea:	42b7      	cmp	r7, r6
 8005bec:	d300      	bcc.n	8005bf0 <uxStreamBufferAdd+0x36>
			{
				uxNextHead -= pxBuffer->LENGTH;
 8005bee:	1bbf      	subs	r7, r7, r6
			}
		}

		if( pucData != NULL )
 8005bf0:	f1b9 0f00 	cmp.w	r9, #0
 8005bf4:	d035      	beq.n	8005c62 <uxStreamBufferAdd+0xa8>
		{
			/* Calculate the number of bytes that can be added in the first
			write - which may be less than the total number of bytes that need
			to be added if the buffer will wrap back to the beginning. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 8005bf6:	1bf6      	subs	r6, r6, r7
 8005bf8:	42a6      	cmp	r6, r4
 8005bfa:	bf28      	it	cs
 8005bfc:	4626      	movcs	r6, r4

			/* Write as many bytes as can be written in the first write. */
			memcpy( ( void* ) ( pxBuffer->ucArray + uxNextHead ), pucData, uxFirst );
 8005bfe:	f105 0a14 	add.w	sl, r5, #20
 8005c02:	4632      	mov	r2, r6
 8005c04:	4649      	mov	r1, r9
 8005c06:	eb0a 0007 	add.w	r0, sl, r7
 8005c0a:	f006 fa26 	bl	800c05a <memcpy>

			/* If the number of bytes written was less than the number that
			could be written in the first write... */
			if( uxCount > uxFirst )
 8005c0e:	42b4      	cmp	r4, r6
 8005c10:	d927      	bls.n	8005c62 <uxStreamBufferAdd+0xa8>
			{
				/* ...then write the remaining bytes to the start of the
				buffer. */
				memcpy( ( void * )pxBuffer->ucArray, pucData + uxFirst, uxCount - uxFirst );
 8005c12:	1ba2      	subs	r2, r4, r6
 8005c14:	eb09 0106 	add.w	r1, r9, r6
 8005c18:	4650      	mov	r0, sl
 8005c1a:	f006 fa1e 	bl	800c05a <memcpy>
			}
		}

		if( uxOffset == 0u )
 8005c1e:	f1b8 0f00 	cmp.w	r8, #0
 8005c22:	d11e      	bne.n	8005c62 <uxStreamBufferAdd+0xa8>
 8005c24:	e017      	b.n	8005c56 <uxStreamBufferAdd+0x9c>
		if( uxLeft <= uxRight )
 8005c26:	428f      	cmp	r7, r1
 8005c28:	bf34      	ite	cc
 8005c2a:	2200      	movcc	r2, #0
 8005c2c:	2201      	movcs	r2, #1
 8005c2e:	e024      	b.n	8005c7a <uxStreamBufferAdd+0xc0>
 8005c30:	2400      	movs	r4, #0
			pxBuffer->uxFront = uxNextHead;
		}
	}

	return uxCount;
}
 8005c32:	4620      	mov	r0, r4
 8005c34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if( pucData != NULL )
 8005c38:	b16a      	cbz	r2, 8005c56 <uxStreamBufferAdd+0x9c>
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 8005c3a:	1bf6      	subs	r6, r6, r7
 8005c3c:	42a6      	cmp	r6, r4
 8005c3e:	bf28      	it	cs
 8005c40:	4626      	movcs	r6, r4
			memcpy( ( void* ) ( pxBuffer->ucArray + uxNextHead ), pucData, uxFirst );
 8005c42:	f100 0a14 	add.w	sl, r0, #20
 8005c46:	4632      	mov	r2, r6
 8005c48:	4649      	mov	r1, r9
 8005c4a:	eb0a 0007 	add.w	r0, sl, r7
 8005c4e:	f006 fa04 	bl	800c05a <memcpy>
			if( uxCount > uxFirst )
 8005c52:	42b4      	cmp	r4, r6
 8005c54:	d8dd      	bhi.n	8005c12 <uxStreamBufferAdd+0x58>
			uxNextHead += uxCount;
 8005c56:	4427      	add	r7, r4
			if( uxNextHead >= pxBuffer->LENGTH )
 8005c58:	692b      	ldr	r3, [r5, #16]
 8005c5a:	429f      	cmp	r7, r3
				uxNextHead -= pxBuffer->LENGTH;
 8005c5c:	bf28      	it	cs
 8005c5e:	1aff      	subcs	r7, r7, r3
			pxBuffer->uxHead = uxNextHead;
 8005c60:	60af      	str	r7, [r5, #8]
		if( xStreamBufferLessThenEqual( pxBuffer, pxBuffer->uxFront, uxNextHead ) != pdFALSE )
 8005c62:	68e9      	ldr	r1, [r5, #12]
size_t uxTail = pxBuffer->uxTail;
 8005c64:	682b      	ldr	r3, [r5, #0]
	if( ( uxLeft < uxTail ) ^ ( uxRight < uxTail ) )
 8005c66:	429f      	cmp	r7, r3
 8005c68:	bf2c      	ite	cs
 8005c6a:	2200      	movcs	r2, #0
 8005c6c:	2201      	movcc	r2, #1
 8005c6e:	4299      	cmp	r1, r3
 8005c70:	bf2c      	ite	cs
 8005c72:	2300      	movcs	r3, #0
 8005c74:	2301      	movcc	r3, #1
 8005c76:	4293      	cmp	r3, r2
 8005c78:	d0d5      	beq.n	8005c26 <uxStreamBufferAdd+0x6c>
 8005c7a:	2a00      	cmp	r2, #0
 8005c7c:	d0d9      	beq.n	8005c32 <uxStreamBufferAdd+0x78>
			pxBuffer->uxFront = uxNextHead;
 8005c7e:	60ef      	str	r7, [r5, #12]
 8005c80:	e7d7      	b.n	8005c32 <uxStreamBufferAdd+0x78>

08005c82 <uxStreamBufferGet>:
 * If 'pucData' equals NULL, the function is called to advance 'lTail' only.
 * if 'xPeek' is pdTRUE, or if 'uxOffset' is non-zero, the 'lTail' pointer will
 * not be advanced.
 */
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek )
{
 8005c82:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
size_t uxHead = pxBuffer->uxHead;
 8005c86:	6885      	ldr	r5, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 8005c88:	6804      	ldr	r4, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005c8a:	6906      	ldr	r6, [r0, #16]
 8005c8c:	4435      	add	r5, r6
 8005c8e:	1b2c      	subs	r4, r5, r4
	if ( uxCount >= pxBuffer->LENGTH )
 8005c90:	42a6      	cmp	r6, r4
		uxCount -= pxBuffer->LENGTH;
 8005c92:	bf98      	it	ls
 8005c94:	1ba4      	subls	r4, r4, r6
size_t uxSize, uxCount, uxFirst, uxNextTail;

	/* How much data is available? */
	uxSize = uxStreamBufferGetSize( pxBuffer );

	if( uxSize > uxOffset )
 8005c96:	42a1      	cmp	r1, r4
 8005c98:	d22f      	bcs.n	8005cfa <uxStreamBufferGet+0x78>
	{
		uxSize -= uxOffset;
 8005c9a:	1a64      	subs	r4, r4, r1
 8005c9c:	429c      	cmp	r4, r3
 8005c9e:	bf28      	it	cs
 8005ca0:	461c      	movcs	r4, r3
	}

	/* Use the minimum of the wanted bytes and the available bytes. */
	uxCount = FreeRTOS_min_uint32( uxSize, uxMaxCount );

	if( uxCount > 0u )
 8005ca2:	b35c      	cbz	r4, 8005cfc <uxStreamBufferGet+0x7a>
	{
		uxNextTail = pxBuffer->uxTail;
 8005ca4:	6807      	ldr	r7, [r0, #0]

		if( uxOffset != 0u )
 8005ca6:	b119      	cbz	r1, 8005cb0 <uxStreamBufferGet+0x2e>
		{
			uxNextTail += uxOffset;
 8005ca8:	440f      	add	r7, r1
			if( uxNextTail >= pxBuffer->LENGTH )
 8005caa:	42b7      	cmp	r7, r6
			{
				uxNextTail -= pxBuffer->LENGTH;
 8005cac:	bf28      	it	cs
 8005cae:	1bbf      	subcs	r7, r7, r6
 8005cb0:	4690      	mov	r8, r2
 8005cb2:	460d      	mov	r5, r1
 8005cb4:	4681      	mov	r9, r0
			}
		}

		if( pucData != NULL )
 8005cb6:	b16a      	cbz	r2, 8005cd4 <uxStreamBufferGet+0x52>
		{
			/* Calculate the number of bytes that can be read - which may be
			less than the number wanted if the data wraps around to the start of
			the buffer. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextTail, uxCount );
 8005cb8:	1bf6      	subs	r6, r6, r7
 8005cba:	42a6      	cmp	r6, r4
 8005cbc:	bf28      	it	cs
 8005cbe:	4626      	movcs	r6, r4

			/* Obtain the number of bytes it is possible to obtain in the first
			read. */
			memcpy( pucData, pxBuffer->ucArray + uxNextTail, uxFirst );
 8005cc0:	f100 0a14 	add.w	sl, r0, #20
 8005cc4:	4632      	mov	r2, r6
 8005cc6:	eb0a 0107 	add.w	r1, sl, r7
 8005cca:	4640      	mov	r0, r8
 8005ccc:	f006 f9c5 	bl	800c05a <memcpy>

			/* If the total number of wanted bytes is greater than the number
			that could be read in the first read... */
			if( uxCount > uxFirst )
 8005cd0:	42b4      	cmp	r4, r6
 8005cd2:	d80b      	bhi.n	8005cec <uxStreamBufferGet+0x6a>
				/*...then read the remaining bytes from the start of the buffer. */
				memcpy( pucData + uxFirst, pxBuffer->ucArray, uxCount - uxFirst );
			}
		}

		if( ( xPeek == pdFALSE ) && ( uxOffset == 0UL ) )
 8005cd4:	9b08      	ldr	r3, [sp, #32]
 8005cd6:	b98b      	cbnz	r3, 8005cfc <uxStreamBufferGet+0x7a>
 8005cd8:	b985      	cbnz	r5, 8005cfc <uxStreamBufferGet+0x7a>
		{
			/* Move the tail pointer to effecively remove the data read from
			the buffer. */
			uxNextTail += uxCount;
 8005cda:	4427      	add	r7, r4

			if( uxNextTail >= pxBuffer->LENGTH )
 8005cdc:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8005ce0:	429f      	cmp	r7, r3
			{
				uxNextTail -= pxBuffer->LENGTH;
 8005ce2:	bf28      	it	cs
 8005ce4:	1aff      	subcs	r7, r7, r3
			}

			pxBuffer->uxTail = uxNextTail;
 8005ce6:	f8c9 7000 	str.w	r7, [r9]
 8005cea:	e007      	b.n	8005cfc <uxStreamBufferGet+0x7a>
				memcpy( pucData + uxFirst, pxBuffer->ucArray, uxCount - uxFirst );
 8005cec:	1ba2      	subs	r2, r4, r6
 8005cee:	4651      	mov	r1, sl
 8005cf0:	eb08 0006 	add.w	r0, r8, r6
 8005cf4:	f006 f9b1 	bl	800c05a <memcpy>
 8005cf8:	e7ec      	b.n	8005cd4 <uxStreamBufferGet+0x52>
 8005cfa:	2400      	movs	r4, #0
		}
	}

	return uxCount;
}
 8005cfc:	4620      	mov	r0, r4
 8005cfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08005d04 <prvSocketSetMSS>:

static void prvSocketSetMSS( FreeRTOS_Socket_t *pxSocket )
{
uint32_t ulMSS = ipconfigTCP_MSS;

	if( ( ( FreeRTOS_ntohl( pxSocket->u.xTCP.ulRemoteIP ) ^ *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) != 0ul )
 8005d04:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8005d06:	0e13      	lsrs	r3, r2, #24
 8005d08:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005d0c:	0211      	lsls	r1, r2, #8
 8005d0e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8005d12:	430b      	orrs	r3, r1
 8005d14:	0a12      	lsrs	r2, r2, #8
 8005d16:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8005d1a:	4313      	orrs	r3, r2
 8005d1c:	4a08      	ldr	r2, [pc, #32]	; (8005d40 <prvSocketSetMSS+0x3c>)
 8005d1e:	6952      	ldr	r2, [r2, #20]
 8005d20:	4053      	eors	r3, r2
 8005d22:	4a08      	ldr	r2, [pc, #32]	; (8005d44 <prvSocketSetMSS+0x40>)
 8005d24:	6852      	ldr	r2, [r2, #4]
 8005d26:	4013      	ands	r3, r2
	{
		/* Data for this peer will pass through a router, and maybe through
		the internet.  Limit the MSS to 1400 bytes or less. */
		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) REDUCED_MSS_THROUGH_INTERNET, ulMSS );
 8005d28:	2b00      	cmp	r3, #0
	}

	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort ) );

	pxSocket->u.xTCP.usInitMSS = pxSocket->u.xTCP.usCurMSS = ( uint16_t ) ulMSS;
 8005d2a:	f240 53b4 	movw	r3, #1460	; 0x5b4
 8005d2e:	bf18      	it	ne
 8005d30:	f44f 63af 	movne.w	r3, #1400	; 0x578
 8005d34:	f8a0 304a 	strh.w	r3, [r0, #74]	; 0x4a
 8005d38:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
 8005d3c:	4770      	bx	lr
 8005d3e:	bf00      	nop
 8005d40:	20000010 	.word	0x20000010
 8005d44:	200004f8 	.word	0x200004f8

08005d48 <prvTCPAddTxData>:
{
 8005d48:	b510      	push	{r4, lr}
	lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
 8005d4a:	6f82      	ldr	r2, [r0, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 8005d4c:	6891      	ldr	r1, [r2, #8]
size_t uxMid = pxBuffer->uxMid;
 8005d4e:	6854      	ldr	r4, [r2, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005d50:	6913      	ldr	r3, [r2, #16]
 8005d52:	4419      	add	r1, r3
 8005d54:	1b09      	subs	r1, r1, r4
	if ( uxCount >= pxBuffer->LENGTH )
 8005d56:	428b      	cmp	r3, r1
		uxCount -= pxBuffer->LENGTH;
 8005d58:	bf98      	it	ls
 8005d5a:	1ac9      	subls	r1, r1, r3
	if( lLength > 0 )
 8005d5c:	2900      	cmp	r1, #0
 8005d5e:	dd1b      	ble.n	8005d98 <prvTCPAddTxData+0x50>
 8005d60:	4604      	mov	r4, r0
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
 8005d62:	6852      	ldr	r2, [r2, #4]
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
 8005d64:	30dc      	adds	r0, #220	; 0xdc
 8005d66:	f001 fe11 	bl	800798c <lTCPWindowTxAdd>
		if( lCount > 0 )
 8005d6a:	2800      	cmp	r0, #0
 8005d6c:	dd14      	ble.n	8005d98 <prvTCPAddTxData+0x50>
			vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
 8005d6e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 8005d70:	689a      	ldr	r2, [r3, #8]
size_t uxMid = pxBuffer->uxMid;
 8005d72:	685c      	ldr	r4, [r3, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005d74:	6919      	ldr	r1, [r3, #16]
 8005d76:	440a      	add	r2, r1
 8005d78:	1b12      	subs	r2, r2, r4
	if ( uxCount >= pxBuffer->LENGTH )
 8005d7a:	4291      	cmp	r1, r2
		uxCount -= pxBuffer->LENGTH;
 8005d7c:	bf98      	it	ls
 8005d7e:	1a52      	subls	r2, r2, r1
	pxBuffer->uxMid += uxCount;
 8005d80:	685c      	ldr	r4, [r3, #4]
 8005d82:	4290      	cmp	r0, r2
 8005d84:	bf94      	ite	ls
 8005d86:	1822      	addls	r2, r4, r0
 8005d88:	18a2      	addhi	r2, r4, r2
 8005d8a:	605a      	str	r2, [r3, #4]
	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
 8005d8c:	685a      	ldr	r2, [r3, #4]
 8005d8e:	4291      	cmp	r1, r2
 8005d90:	d802      	bhi.n	8005d98 <prvTCPAddTxData+0x50>
		pxBuffer->uxMid -= pxBuffer->LENGTH;
 8005d92:	685a      	ldr	r2, [r3, #4]
 8005d94:	1a51      	subs	r1, r2, r1
 8005d96:	6059      	str	r1, [r3, #4]
 8005d98:	bd10      	pop	{r4, pc}
	...

08005d9c <prvTCPReturnPacket>:
{
 8005d9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005da0:	b08a      	sub	sp, #40	; 0x28
 8005da2:	461d      	mov	r5, r3
	if( pxNetworkBuffer == NULL )
 8005da4:	460e      	mov	r6, r1
 8005da6:	2900      	cmp	r1, #0
 8005da8:	f000 80a3 	beq.w	8005ef2 <prvTCPReturnPacket+0x156>
		pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8005dac:	69b4      	ldr	r4, [r6, #24]
		if( pxSocket != NULL )
 8005dae:	2800      	cmp	r0, #0
 8005db0:	f000 80d0 	beq.w	8005f54 <prvTCPReturnPacket+0x1b8>
			if( pxSocket->u.xTCP.rxStream != NULL )
 8005db4:	6f41      	ldr	r1, [r0, #116]	; 0x74
 8005db6:	2900      	cmp	r1, #0
 8005db8:	f000 80a3 	beq.w	8005f02 <prvTCPReturnPacket+0x166>
size_t uxFront = pxBuffer->uxFront;
 8005dbc:	68cf      	ldr	r7, [r1, #12]
size_t uxTail = pxBuffer->uxTail;
 8005dbe:	680b      	ldr	r3, [r1, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005dc0:	6909      	ldr	r1, [r1, #16]
 8005dc2:	440b      	add	r3, r1
 8005dc4:	3b01      	subs	r3, #1
 8005dc6:	1bdb      	subs	r3, r3, r7
	if( uxCount >= pxBuffer->LENGTH )
 8005dc8:	4299      	cmp	r1, r3
 8005dca:	f200 809d 	bhi.w	8005f08 <prvTCPReturnPacket+0x16c>
		uxCount -= pxBuffer->LENGTH;
 8005dce:	eba3 0c01 	sub.w	ip, r3, r1
			ulSpace = FreeRTOS_min_uint32( pxSocket->u.xTCP.ulRxCurWinSize, pxTCPWindow->xSize.ulRxWindowLength );
 8005dd2:	f8d0 e0d0 	ldr.w	lr, [r0, #208]	; 0xd0
 8005dd6:	f8d0 70e0 	ldr.w	r7, [r0, #224]	; 0xe0
			if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStopped != pdFALSE_UNSIGNED ) )
 8005dda:	496d      	ldr	r1, [pc, #436]	; (8005f90 <prvTCPReturnPacket+0x1f4>)
 8005ddc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005dde:	4019      	ands	r1, r3
 8005de0:	2900      	cmp	r1, #0
 8005de2:	f040 8093 	bne.w	8005f0c <prvTCPReturnPacket+0x170>
 8005de6:	4577      	cmp	r7, lr
 8005de8:	bf28      	it	cs
 8005dea:	4677      	movcs	r7, lr
			if( ( ulSpace < pxSocket->u.xTCP.usCurMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usCurMSS ) )
 8005dec:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
 8005df0:	428f      	cmp	r7, r1
 8005df2:	d202      	bcs.n	8005dfa <prvTCPReturnPacket+0x5e>
				ulSpace = pxSocket->u.xTCP.usCurMSS;
 8005df4:	458c      	cmp	ip, r1
 8005df6:	bf28      	it	cs
 8005df8:	460f      	movcs	r7, r1
			ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
 8005dfa:	f890 30c9 	ldrb.w	r3, [r0, #201]	; 0xc9
 8005dfe:	fa27 f303 	lsr.w	r3, r7, r3
 8005e02:	f64f 71fc 	movw	r1, #65532	; 0xfffc
 8005e06:	428b      	cmp	r3, r1
 8005e08:	bf28      	it	cs
 8005e0a:	460b      	movcs	r3, r1
			pxTCPPacket->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
 8005e0c:	0219      	lsls	r1, r3, #8
 8005e0e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8005e12:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 8005e16:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8005e1a:	430b      	orrs	r3, r1
 8005e1c:	8623      	strh	r3, [r4, #48]	; 0x30
			pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
 8005e1e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8005e22:	f36f 0300 	bfc	r3, #0, #1
 8005e26:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
			pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
 8005e2a:	f8d0 10ec 	ldr.w	r1, [r0, #236]	; 0xec
 8005e2e:	440f      	add	r7, r1
 8005e30:	6447      	str	r7, [r0, #68]	; 0x44
				if( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED )
 8005e32:	f013 0f02 	tst.w	r3, #2
 8005e36:	d06b      	beq.n	8005f10 <prvTCPReturnPacket+0x174>
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 8005e38:	b2db      	uxtb	r3, r3
					pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 8005e3a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 8005e3e:	f043 0304 	orr.w	r3, r3, #4
 8005e42:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
					pxTCPPacket->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1UL;
 8005e46:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8005e4a:	3b01      	subs	r3, #1
					pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 8005e4c:	0e19      	lsrs	r1, r3, #24
 8005e4e:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 8005e52:	021f      	lsls	r7, r3, #8
 8005e54:	f407 077f 	and.w	r7, r7, #16711680	; 0xff0000
 8005e58:	4339      	orrs	r1, r7
 8005e5a:	0a1b      	lsrs	r3, r3, #8
 8005e5c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005e60:	430b      	orrs	r3, r1
 8005e62:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
			pxTCPPacket->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
 8005e66:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
 8005e6a:	0e19      	lsrs	r1, r3, #24
 8005e6c:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 8005e70:	0218      	lsls	r0, r3, #8
 8005e72:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 8005e76:	4301      	orrs	r1, r0
 8005e78:	0a1b      	lsrs	r3, r3, #8
 8005e7a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005e7e:	430b      	orrs	r3, r1
 8005e80:	f8c4 302a 	str.w	r3, [r4, #42]	; 0x2a
		pxIPHeader->ucTimeToLive           = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 8005e84:	2380      	movs	r3, #128	; 0x80
 8005e86:	75a3      	strb	r3, [r4, #22]
		pxIPHeader->usLength               = FreeRTOS_htons( ulLen );
 8005e88:	0a13      	lsrs	r3, r2, #8
 8005e8a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005e8e:	8223      	strh	r3, [r4, #16]
		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ) )
 8005e90:	4b40      	ldr	r3, [pc, #256]	; (8005f94 <prvTCPReturnPacket+0x1f8>)
 8005e92:	695b      	ldr	r3, [r3, #20]
 8005e94:	b90b      	cbnz	r3, 8005e9a <prvTCPReturnPacket+0xfe>
			ulSourceAddress = pxIPHeader->ulDestinationIPAddress;
 8005e96:	f8d4 301e 	ldr.w	r3, [r4, #30]
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 8005e9a:	f8d4 101a 	ldr.w	r1, [r4, #26]
 8005e9e:	f8c4 101e 	str.w	r1, [r4, #30]
		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
 8005ea2:	f8c4 301a 	str.w	r3, [r4, #26]
		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 8005ea6:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8005ea8:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
 8005eaa:	8461      	strh	r1, [r4, #34]	; 0x22
 8005eac:	84a3      	strh	r3, [r4, #36]	; 0x24
		pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
 8005eae:	483a      	ldr	r0, [pc, #232]	; (8005f98 <prvTCPReturnPacket+0x1fc>)
 8005eb0:	8803      	ldrh	r3, [r0, #0]
 8005eb2:	0a19      	lsrs	r1, r3, #8
 8005eb4:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 8005eb8:	8261      	strh	r1, [r4, #18]
		usPacketIdentifier++;
 8005eba:	3301      	adds	r3, #1
 8005ebc:	8003      	strh	r3, [r0, #0]
		pxIPHeader->usFragmentOffset = 0u;
 8005ebe:	2300      	movs	r3, #0
 8005ec0:	7523      	strb	r3, [r4, #20]
 8005ec2:	7563      	strb	r3, [r4, #21]
		pxNetworkBuffer->xDataLength = ulLen + ipSIZE_OF_ETH_HEADER;
 8005ec4:	320e      	adds	r2, #14
 8005ec6:	61f2      	str	r2, [r6, #28]
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ),
 8005ec8:	4627      	mov	r7, r4
 8005eca:	f857 3f06 	ldr.w	r3, [r7, #6]!
 8005ece:	6023      	str	r3, [r4, #0]
 8005ed0:	88bb      	ldrh	r3, [r7, #4]
 8005ed2:	80a3      	strh	r3, [r4, #4]
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8005ed4:	4b2f      	ldr	r3, [pc, #188]	; (8005f94 <prvTCPReturnPacket+0x1f8>)
 8005ed6:	6818      	ldr	r0, [r3, #0]
 8005ed8:	f8c4 0006 	str.w	r0, [r4, #6]
 8005edc:	889b      	ldrh	r3, [r3, #4]
 8005ede:	80bb      	strh	r3, [r7, #4]
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 8005ee0:	4629      	mov	r1, r5
 8005ee2:	4630      	mov	r0, r6
 8005ee4:	f002 fa82 	bl	80083ec <xNetworkInterfaceOutput>
		if( xReleaseAfterSend == pdFALSE )
 8005ee8:	2d00      	cmp	r5, #0
 8005eea:	d042      	beq.n	8005f72 <prvTCPReturnPacket+0x1d6>
}
 8005eec:	b00a      	add	sp, #40	; 0x28
 8005eee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		xTempBuffer.pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 8005ef2:	f100 0382 	add.w	r3, r0, #130	; 0x82
 8005ef6:	9307      	str	r3, [sp, #28]
		xTempBuffer.xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 8005ef8:	2346      	movs	r3, #70	; 0x46
 8005efa:	9308      	str	r3, [sp, #32]
		xReleaseAfterSend = pdFALSE;
 8005efc:	2500      	movs	r5, #0
		pxNetworkBuffer = &xTempBuffer;
 8005efe:	ae01      	add	r6, sp, #4
 8005f00:	e754      	b.n	8005dac <prvTCPReturnPacket+0x10>
				ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 8005f02:	f8d0 c06c 	ldr.w	ip, [r0, #108]	; 0x6c
 8005f06:	e764      	b.n	8005dd2 <prvTCPReturnPacket+0x36>
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005f08:	469c      	mov	ip, r3
 8005f0a:	e762      	b.n	8005dd2 <prvTCPReturnPacket+0x36>
				ulSpace = 0u;
 8005f0c:	2700      	movs	r7, #0
 8005f0e:	e76d      	b.n	8005dec <prvTCPReturnPacket+0x50>
				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber );
 8005f10:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8005f14:	0e19      	lsrs	r1, r3, #24
 8005f16:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 8005f1a:	021f      	lsls	r7, r3, #8
 8005f1c:	f407 077f 	and.w	r7, r7, #16711680	; 0xff0000
 8005f20:	4339      	orrs	r1, r7
 8005f22:	0a1b      	lsrs	r3, r3, #8
 8005f24:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005f28:	430b      	orrs	r3, r1
 8005f2a:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
				if( ( pxTCPPacket->xTCPHeader.ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u )
 8005f2e:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8005f32:	f013 0f01 	tst.w	r3, #1
 8005f36:	d096      	beq.n	8005e66 <prvTCPReturnPacket+0xca>
					uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + ipSIZE_OF_IPv4_HEADER ) );
 8005f38:	f1a2 0128 	sub.w	r1, r2, #40	; 0x28
					if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
 8005f3c:	f8d0 7108 	ldr.w	r7, [r0, #264]	; 0x108
 8005f40:	4439      	add	r1, r7
 8005f42:	f8d0 7100 	ldr.w	r7, [r0, #256]	; 0x100
 8005f46:	42b9      	cmp	r1, r7
						pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_FIN );
 8005f48:	bf1c      	itt	ne
 8005f4a:	f023 0301 	bicne.w	r3, r3, #1
 8005f4e:	f884 302f 	strbne.w	r3, [r4, #47]	; 0x2f
 8005f52:	e788      	b.n	8005e66 <prvTCPReturnPacket+0xca>
			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
 8005f54:	f8d4 3026 	ldr.w	r3, [r4, #38]	; 0x26
 8005f58:	f8d4 102a 	ldr.w	r1, [r4, #42]	; 0x2a
 8005f5c:	f8c4 1026 	str.w	r1, [r4, #38]	; 0x26
 8005f60:	f8c4 302a 	str.w	r3, [r4, #42]	; 0x2a
		pxIPHeader->ucTimeToLive           = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 8005f64:	2380      	movs	r3, #128	; 0x80
 8005f66:	75a3      	strb	r3, [r4, #22]
		pxIPHeader->usLength               = FreeRTOS_htons( ulLen );
 8005f68:	0a13      	lsrs	r3, r2, #8
 8005f6a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005f6e:	8223      	strh	r3, [r4, #16]
 8005f70:	e791      	b.n	8005e96 <prvTCPReturnPacket+0xfa>
			vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort);
 8005f72:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8005f74:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 8005f76:	8462      	strh	r2, [r4, #34]	; 0x22
 8005f78:	84a3      	strh	r3, [r4, #36]	; 0x24
			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
 8005f7a:	f8d4 301e 	ldr.w	r3, [r4, #30]
 8005f7e:	f8c4 301a 	str.w	r3, [r4, #26]
			memcpy( pxEthernetHeader->xSourceAddress.ucBytes, pxEthernetHeader->xDestinationAddress.ucBytes, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8005f82:	6823      	ldr	r3, [r4, #0]
 8005f84:	f8c4 3006 	str.w	r3, [r4, #6]
 8005f88:	88a3      	ldrh	r3, [r4, #4]
 8005f8a:	80bb      	strh	r3, [r7, #4]
}
 8005f8c:	e7ae      	b.n	8005eec <prvTCPReturnPacket+0x150>
 8005f8e:	bf00      	nop
 8005f90:	00040080 	.word	0x00040080
 8005f94:	20000010 	.word	0x20000010
 8005f98:	200004ac 	.word	0x200004ac

08005f9c <prvTCPSendReset>:
{
 8005f9c:	b508      	push	{r3, lr}
 8005f9e:	4601      	mov	r1, r0
	TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8005fa0:	6983      	ldr	r3, [r0, #24]
		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_RST;
 8005fa2:	2214      	movs	r2, #20
 8005fa4:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER + 0u ) << 2;
 8005fa8:	2250      	movs	r2, #80	; 0x50
 8005faa:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
		prvTCPReturnPacket( NULL, pxNetworkBuffer, ( uint32_t ) xSendLength, pdFALSE );
 8005fae:	2300      	movs	r3, #0
 8005fb0:	2228      	movs	r2, #40	; 0x28
 8005fb2:	4618      	mov	r0, r3
 8005fb4:	f7ff fef2 	bl	8005d9c <prvTCPReturnPacket>
}
 8005fb8:	2000      	movs	r0, #0
 8005fba:	bd08      	pop	{r3, pc}

08005fbc <prvTCPCreateWindow>:
{
 8005fbc:	b510      	push	{r4, lr}
 8005fbe:	b082      	sub	sp, #8
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxTxWinSize,
 8005fc0:	f8d0 20d8 	ldr.w	r2, [r0, #216]	; 0xd8
 8005fc4:	f240 51b4 	movw	r1, #1460	; 0x5b4
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxRxWinSize,
 8005fc8:	f8d0 40d4 	ldr.w	r4, [r0, #212]	; 0xd4
	vTCPWindowCreate(
 8005fcc:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 8005fd0:	9301      	str	r3, [sp, #4]
 8005fd2:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8005fd6:	9300      	str	r3, [sp, #0]
 8005fd8:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
 8005fdc:	fb01 f202 	mul.w	r2, r1, r2
 8005fe0:	fb01 f104 	mul.w	r1, r1, r4
 8005fe4:	30dc      	adds	r0, #220	; 0xdc
 8005fe6:	f001 fbc9 	bl	800777c <vTCPWindowCreate>
}
 8005fea:	b002      	add	sp, #8
 8005fec:	bd10      	pop	{r4, pc}
	...

08005ff0 <prvTCPNextTimeout>:
{
 8005ff0:	b510      	push	{r4, lr}
 8005ff2:	b082      	sub	sp, #8
 8005ff4:	4604      	mov	r4, r0
TickType_t ulDelayMs = ( TickType_t ) 20000;
 8005ff6:	f644 6320 	movw	r3, #20000	; 0x4e20
 8005ffa:	9301      	str	r3, [sp, #4]
	if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 8005ffc:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 8006000:	2b02      	cmp	r3, #2
 8006002:	d006      	beq.n	8006012 <prvTCPNextTimeout+0x22>
	else if( pxSocket->u.xTCP.usTimeout == 0u )
 8006004:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
 8006008:	b363      	cbz	r3, 8006064 <prvTCPNextTimeout+0x74>
	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 800600a:	f8b4 0048 	ldrh.w	r0, [r4, #72]	; 0x48
}
 800600e:	b002      	add	sp, #8
 8006010:	bd10      	pop	{r4, pc}
		if( pxSocket->u.xTCP.bits.bConnPrepared )
 8006012:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8006016:	f013 0f08 	tst.w	r3, #8
 800601a:	d014      	beq.n	8006046 <prvTCPNextTimeout+0x56>
			if( pxSocket->u.xTCP.ucRepCount < 3u )
 800601c:	f890 3052 	ldrb.w	r3, [r0, #82]	; 0x52
 8006020:	2b02      	cmp	r3, #2
 8006022:	d80c      	bhi.n	800603e <prvTCPNextTimeout+0x4e>
				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1u ) );
 8006024:	3b01      	subs	r3, #1
 8006026:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800602a:	409a      	lsls	r2, r3
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 800602c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8006030:	fb03 f302 	mul.w	r3, r3, r2
 8006034:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8006038:	d20d      	bcs.n	8006056 <prvTCPNextTimeout+0x66>
 800603a:	2301      	movs	r3, #1
 800603c:	e00f      	b.n	800605e <prvTCPNextTimeout+0x6e>
				ulDelayMs = 11000UL;
 800603e:	f642 23f8 	movw	r3, #11000	; 0x2af8
 8006042:	9301      	str	r3, [sp, #4]
 8006044:	e002      	b.n	800604c <prvTCPNextTimeout+0x5c>
			ulDelayMs = 500UL;
 8006046:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800604a:	9301      	str	r3, [sp, #4]
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 800604c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8006050:	9a01      	ldr	r2, [sp, #4]
 8006052:	fb03 f302 	mul.w	r3, r3, r2
 8006056:	4a12      	ldr	r2, [pc, #72]	; (80060a0 <prvTCPNextTimeout+0xb0>)
 8006058:	fba2 2303 	umull	r2, r3, r2, r3
 800605c:	099b      	lsrs	r3, r3, #6
 800605e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 8006062:	e7d2      	b.n	800600a <prvTCPNextTimeout+0x1a>
		BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs );
 8006064:	aa01      	add	r2, sp, #4
 8006066:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 800606a:	30dc      	adds	r0, #220	; 0xdc
 800606c:	f001 fcfe 	bl	8007a6c <xTCPWindowTxHasData>
		if( ulDelayMs == 0u )
 8006070:	9b01      	ldr	r3, [sp, #4]
 8006072:	b92b      	cbnz	r3, 8006080 <prvTCPNextTimeout+0x90>
			ulDelayMs = xResult ? 1UL : 20000UL;
 8006074:	2800      	cmp	r0, #0
 8006076:	f644 6320 	movw	r3, #20000	; 0x4e20
 800607a:	bf18      	it	ne
 800607c:	2301      	movne	r3, #1
 800607e:	9301      	str	r3, [sp, #4]
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 8006080:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8006084:	9a01      	ldr	r2, [sp, #4]
 8006086:	fb03 f302 	mul.w	r3, r3, r2
 800608a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800608e:	bf23      	ittte	cs
 8006090:	4a03      	ldrcs	r2, [pc, #12]	; (80060a0 <prvTCPNextTimeout+0xb0>)
 8006092:	fba2 2303 	umullcs	r2, r3, r2, r3
 8006096:	099b      	lsrcs	r3, r3, #6
 8006098:	2301      	movcc	r3, #1
 800609a:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 800609e:	e7b4      	b.n	800600a <prvTCPNextTimeout+0x1a>
 80060a0:	10624dd3 	.word	0x10624dd3

080060a4 <vTCPStateChange>:
{
 80060a4:	b570      	push	{r4, r5, r6, lr}
 80060a6:	4604      	mov	r4, r0
 80060a8:	460d      	mov	r5, r1
BaseType_t bBefore = ( BaseType_t ) NOW_CONNECTED( pxSocket->u.xTCP.ucTCPState );	/* Was it connected ? */
 80060aa:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 80060ae:	2b04      	cmp	r3, #4
 80060b0:	d961      	bls.n	8006176 <vTCPStateChange+0xd2>
 80060b2:	2b08      	cmp	r3, #8
 80060b4:	d05f      	beq.n	8006176 <vTCPStateChange+0xd2>
BaseType_t bAfter  = ( BaseType_t ) NOW_CONNECTED( eTCPState );						/* Is it connected now ? */
 80060b6:	2904      	cmp	r1, #4
 80060b8:	d817      	bhi.n	80060ea <vTCPStateChange+0x46>
			pxSocket->xEventBits |= eSOCKET_CLOSED;
 80060ba:	6823      	ldr	r3, [r4, #0]
 80060bc:	f043 0220 	orr.w	r2, r3, #32
 80060c0:	6022      	str	r2, [r4, #0]
				if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
 80060c2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80060c4:	f012 0f04 	tst.w	r2, #4
 80060c8:	d002      	beq.n	80060d0 <vTCPStateChange+0x2c>
					pxSocket->xEventBits |= ( eSELECT_EXCEPT << SOCKET_EVENT_BIT_COUNT );
 80060ca:	f443 6384 	orr.w	r3, r3, #1056	; 0x420
 80060ce:	6023      	str	r3, [r4, #0]
	switch( uxStatus )
 80060d0:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80060d4:	2b0b      	cmp	r3, #11
 80060d6:	f200 80ae 	bhi.w	8006236 <vTCPStateChange+0x192>
 80060da:	e8df f003 	tbb	[pc, r3]
 80060de:	ac2f      	.short	0xac2f
 80060e0:	acacacac 	.word	0xacacacac
 80060e4:	2f2f2fac 	.word	0x2f2f2fac
 80060e8:	2fac      	.short	0x2fac
BaseType_t bBefore = ( BaseType_t ) NOW_CONNECTED( pxSocket->u.xTCP.ucTCPState );	/* Was it connected ? */
 80060ea:	2301      	movs	r3, #1
 80060ec:	e046      	b.n	800617c <vTCPStateChange+0xd8>
					configASSERT( xParent != NULL );
 80060ee:	f240 51c5 	movw	r1, #1477	; 0x5c5
 80060f2:	485b      	ldr	r0, [pc, #364]	; (8006260 <vTCPStateChange+0x1bc>)
 80060f4:	f005 fe0a 	bl	800bd0c <vAssertCalled>
 80060f8:	e05d      	b.n	80061b6 <vTCPStateChange+0x112>
				if( xParent != NULL )
 80060fa:	b11c      	cbz	r4, 8006104 <vTCPStateChange+0x60>
					xParent = pxSocket;
 80060fc:	4626      	mov	r6, r4
 80060fe:	e04c      	b.n	800619a <vTCPStateChange+0xf6>
						xParent->u.xTCP.pxPeerSocket = pxSocket;
 8006100:	6574      	str	r4, [r6, #84]	; 0x54
 8006102:	e04d      	b.n	80061a0 <vTCPStateChange+0xfc>
					xParent = pxSocket;
 8006104:	4626      	mov	r6, r4
 8006106:	e056      	b.n	80061b6 <vTCPStateChange+0x112>
				pxSocket->xEventBits |= eSOCKET_CONNECT;
 8006108:	6823      	ldr	r3, [r4, #0]
 800610a:	f043 0208 	orr.w	r2, r3, #8
 800610e:	6022      	str	r2, [r4, #0]
					if( pxSocket->xSelectBits & eSELECT_WRITE )
 8006110:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006112:	f012 0f02 	tst.w	r2, #2
 8006116:	d0db      	beq.n	80060d0 <vTCPStateChange+0x2c>
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 8006118:	f443 7302 	orr.w	r3, r3, #520	; 0x208
 800611c:	6023      	str	r3, [r4, #0]
 800611e:	e7d7      	b.n	80060d0 <vTCPStateChange+0x2c>
		if( eTCPState == eCLOSED )
 8006120:	2d00      	cmp	r5, #0
 8006122:	d174      	bne.n	800620e <vTCPStateChange+0x16a>
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 8006124:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006128:	f013 0f06 	tst.w	r3, #6
 800612c:	d06f      	beq.n	800620e <vTCPStateChange+0x16a>
				if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 800612e:	f013 0f08 	tst.w	r3, #8
 8006132:	d16c      	bne.n	800620e <vTCPStateChange+0x16a>
					FreeRTOS_closesocket( pxSocket );
 8006134:	4620      	mov	r0, r4
 8006136:	f7fe fd43 	bl	8004bc0 <FreeRTOS_closesocket>
 800613a:	e068      	b.n	800620e <vTCPStateChange+0x16a>
	switch( uxStatus )
 800613c:	2600      	movs	r6, #0
			pxSocket->u.xTCP.usTimeout = 0u;
 800613e:	2300      	movs	r3, #0
 8006140:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 8006144:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8006148:	f003 fc3a 	bl	80099c0 <xTaskGetTickCount>
 800614c:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 800614e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 8006152:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8006156:	f36f 0341 	bfc	r3, #1, #1
 800615a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 800615e:	2300      	movs	r3, #0
 8006160:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 8006164:	f003 fc2c 	bl	80099c0 <xTaskGetTickCount>
 8006168:	65e0      	str	r0, [r4, #92]	; 0x5c
	if( xParent != NULL )
 800616a:	2e00      	cmp	r6, #0
 800616c:	d077      	beq.n	800625e <vTCPStateChange+0x1ba>
		vSocketWakeUpUser( xParent );
 800616e:	4630      	mov	r0, r6
 8006170:	f7fe fdfc 	bl	8004d6c <vSocketWakeUpUser>
}
 8006174:	bd70      	pop	{r4, r5, r6, pc}
BaseType_t bAfter  = ( BaseType_t ) NOW_CONNECTED( eTCPState );						/* Is it connected now ? */
 8006176:	2d04      	cmp	r5, #4
 8006178:	d9d2      	bls.n	8006120 <vTCPStateChange+0x7c>
 800617a:	2300      	movs	r3, #0
 800617c:	2d08      	cmp	r5, #8
 800617e:	d043      	beq.n	8006208 <vTCPStateChange+0x164>
	if( bBefore != bAfter )
 8006180:	2b00      	cmp	r3, #0
 8006182:	d1cd      	bne.n	8006120 <vTCPStateChange+0x7c>
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 8006184:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006188:	f013 0f04 	tst.w	r3, #4
 800618c:	d0bc      	beq.n	8006108 <vTCPStateChange+0x64>
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800618e:	f013 0f08 	tst.w	r3, #8
 8006192:	d1b2      	bne.n	80060fa <vTCPStateChange+0x56>
					xParent = pxSocket->u.xTCP.pxPeerSocket;
 8006194:	6d66      	ldr	r6, [r4, #84]	; 0x54
					configASSERT( xParent != NULL );
 8006196:	2e00      	cmp	r6, #0
 8006198:	d0a9      	beq.n	80060ee <vTCPStateChange+0x4a>
					if( xParent->u.xTCP.pxPeerSocket == NULL )
 800619a:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800619c:	2b00      	cmp	r3, #0
 800619e:	d0af      	beq.n	8006100 <vTCPStateChange+0x5c>
					xParent->xEventBits |= eSOCKET_ACCEPT;
 80061a0:	6833      	ldr	r3, [r6, #0]
 80061a2:	f043 0204 	orr.w	r2, r3, #4
 80061a6:	6032      	str	r2, [r6, #0]
						if( ( xParent->xSelectBits & eSELECT_READ ) != 0 )
 80061a8:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 80061aa:	f012 0f01 	tst.w	r2, #1
 80061ae:	d002      	beq.n	80061b6 <vTCPStateChange+0x112>
							xParent->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
 80061b0:	f443 7382 	orr.w	r3, r3, #260	; 0x104
 80061b4:	6033      	str	r3, [r6, #0]
				pxSocket->u.xTCP.pxPeerSocket = NULL;
 80061b6:	2300      	movs	r3, #0
 80061b8:	6563      	str	r3, [r4, #84]	; 0x54
				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 80061ba:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
 80061be:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80061c2:	f043 0302 	orr.w	r3, r3, #2
 80061c6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
	switch( uxStatus )
 80061ca:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80061ce:	2b0b      	cmp	r3, #11
 80061d0:	d8b8      	bhi.n	8006144 <vTCPStateChange+0xa0>
 80061d2:	a201      	add	r2, pc, #4	; (adr r2, 80061d8 <vTCPStateChange+0x134>)
 80061d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80061d8:	0800613f 	.word	0x0800613f
 80061dc:	08006145 	.word	0x08006145
 80061e0:	08006145 	.word	0x08006145
 80061e4:	08006145 	.word	0x08006145
 80061e8:	08006145 	.word	0x08006145
 80061ec:	08006145 	.word	0x08006145
 80061f0:	08006145 	.word	0x08006145
 80061f4:	0800613f 	.word	0x0800613f
 80061f8:	0800613f 	.word	0x0800613f
 80061fc:	0800613f 	.word	0x0800613f
 8006200:	08006145 	.word	0x08006145
 8006204:	0800613f 	.word	0x0800613f
	if( bBefore != bAfter )
 8006208:	2b00      	cmp	r3, #0
 800620a:	f47f af56 	bne.w	80060ba <vTCPStateChange+0x16>
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 800620e:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8006212:	f003 fbd5 	bl	80099c0 <xTaskGetTickCount>
 8006216:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 8006218:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800621c:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8006220:	f36f 0341 	bfc	r3, #1, #1
 8006224:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 8006228:	2300      	movs	r3, #0
 800622a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 800622e:	f003 fbc7 	bl	80099c0 <xTaskGetTickCount>
 8006232:	65e0      	str	r0, [r4, #92]	; 0x5c
 8006234:	bd70      	pop	{r4, r5, r6, pc}
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 8006236:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 800623a:	f003 fbc1 	bl	80099c0 <xTaskGetTickCount>
 800623e:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 8006240:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 8006244:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8006248:	f36f 0341 	bfc	r3, #1, #1
 800624c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 8006250:	2300      	movs	r3, #0
 8006252:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 8006256:	f003 fbb3 	bl	80099c0 <xTaskGetTickCount>
 800625a:	65e0      	str	r0, [r4, #92]	; 0x5c
 800625c:	bd70      	pop	{r4, r5, r6, pc}
 800625e:	bd70      	pop	{r4, r5, r6, pc}
 8006260:	0800c69c 	.word	0x0800c69c

08006264 <prvTCPPrepareSend>:
{
 8006264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006268:	b085      	sub	sp, #20
 800626a:	4605      	mov	r5, r0
 800626c:	4689      	mov	r9, r1
 800626e:	4616      	mov	r6, r2
	if( ( *ppxNetworkBuffer ) != NULL )
 8006270:	680b      	ldr	r3, [r1, #0]
 8006272:	b37b      	cbz	r3, 80062d4 <prvTCPPrepareSend+0x70>
		pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
 8006274:	699c      	ldr	r4, [r3, #24]
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 8006276:	f105 0bdc 	add.w	fp, r5, #220	; 0xdc
	lStreamPos = 0;
 800627a:	2300      	movs	r3, #0
 800627c:	9303      	str	r3, [sp, #12]
	pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_ACK;
 800627e:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006282:	f043 0310 	orr.w	r3, r3, #16
 8006286:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	if( pxSocket->u.xTCP.txStream != NULL )
 800628a:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800628c:	2b00      	cmp	r3, #0
 800628e:	f000 810e 	beq.w	80064ae <prvTCPPrepareSend+0x24a>
		if( pxSocket->u.xTCP.usCurMSS > 1u )
 8006292:	f8b5 304a 	ldrh.w	r3, [r5, #74]	; 0x4a
 8006296:	2b01      	cmp	r3, #1
 8006298:	f240 808a 	bls.w	80063b0 <prvTCPPrepareSend+0x14c>
			lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos );
 800629c:	aa03      	add	r2, sp, #12
 800629e:	f8d5 10cc 	ldr.w	r1, [r5, #204]	; 0xcc
 80062a2:	4658      	mov	r0, fp
 80062a4:	f001 fc1c 	bl	8007ae0 <ulTCPWindowTxGet>
 80062a8:	4682      	mov	sl, r0
 80062aa:	4607      	mov	r7, r0
		if( lDataLen > 0 )
 80062ac:	2800      	cmp	r0, #0
 80062ae:	f340 8100 	ble.w	80064b2 <prvTCPPrepareSend+0x24e>
			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
 80062b2:	f8d9 8000 	ldr.w	r8, [r9]
	if( xBufferAllocFixedSize != pdFALSE )
 80062b6:	4ba6      	ldr	r3, [pc, #664]	; (8006550 <prvTCPPrepareSend+0x2ec>)
 80062b8:	681b      	ldr	r3, [r3, #0]
 80062ba:	b173      	cbz	r3, 80062da <prvTCPPrepareSend+0x76>
	if( xResize != pdFALSE )
 80062bc:	f1b8 0f00 	cmp.w	r8, #0
 80062c0:	d05c      	beq.n	800637c <prvTCPPrepareSend+0x118>
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 80062c2:	f106 0336 	add.w	r3, r6, #54	; 0x36
 80062c6:	4403      	add	r3, r0
 80062c8:	f8c8 301c 	str.w	r3, [r8, #28]
			if( pxNewBuffer != NULL )
 80062cc:	f1b8 0f00 	cmp.w	r8, #0
 80062d0:	d116      	bne.n	8006300 <prvTCPPrepareSend+0x9c>
 80062d2:	e0b0      	b.n	8006436 <prvTCPPrepareSend+0x1d2>
		pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 80062d4:	f100 0482 	add.w	r4, r0, #130	; 0x82
 80062d8:	e7cd      	b.n	8006276 <prvTCPPrepareSend+0x12>
			( int32_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + lDataLen );
 80062da:	f106 0036 	add.w	r0, r6, #54	; 0x36
 80062de:	4450      	add	r0, sl
	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
 80062e0:	2846      	cmp	r0, #70	; 0x46
 80062e2:	bfb8      	it	lt
 80062e4:	2046      	movlt	r0, #70	; 0x46
		xResize = ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < (size_t)lNeeded );
 80062e6:	f1b8 0f00 	cmp.w	r8, #0
 80062ea:	f000 810d 	beq.w	8006508 <prvTCPPrepareSend+0x2a4>
	if( xResize != pdFALSE )
 80062ee:	f8d8 301c 	ldr.w	r3, [r8, #28]
 80062f2:	4283      	cmp	r3, r0
 80062f4:	d344      	bcc.n	8006380 <prvTCPPrepareSend+0x11c>
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 80062f6:	f106 0336 	add.w	r3, r6, #54	; 0x36
 80062fa:	4453      	add	r3, sl
 80062fc:	f8c8 301c 	str.w	r3, [r8, #28]
				*ppxNetworkBuffer = pxNewBuffer;
 8006300:	f8c9 8000 	str.w	r8, [r9]
				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
 8006304:	f8d8 4018 	ldr.w	r4, [r8, #24]
				pucSendData = pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 8006308:	f106 0236 	add.w	r2, r6, #54	; 0x36
 800630c:	4422      	add	r2, r4
				uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, ( size_t ) lStreamPos );
 800630e:	6fa8      	ldr	r0, [r5, #120]	; 0x78
 8006310:	f8d0 e000 	ldr.w	lr, [r0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8006314:	6903      	ldr	r3, [r0, #16]
 8006316:	9903      	ldr	r1, [sp, #12]
 8006318:	4419      	add	r1, r3
 800631a:	eba1 010e 	sub.w	r1, r1, lr
	if ( uxCount >= pxBuffer->LENGTH )
 800631e:	428b      	cmp	r3, r1
		uxCount -= pxBuffer->LENGTH;
 8006320:	bf98      	it	ls
 8006322:	1ac9      	subls	r1, r1, r3
				ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, ( size_t ) lDataLen, pdTRUE );
 8006324:	2301      	movs	r3, #1
 8006326:	9300      	str	r3, [sp, #0]
 8006328:	4653      	mov	r3, sl
 800632a:	f7ff fcaa 	bl	8005c82 <uxStreamBufferGet>
				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) )
 800632e:	f8b5 3040 	ldrh.w	r3, [r5, #64]	; 0x40
 8006332:	f423 537e 	bic.w	r3, r3, #16256	; 0x3f80
 8006336:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800633a:	045b      	lsls	r3, r3, #17
 800633c:	0c5b      	lsrs	r3, r3, #17
 800633e:	2b40      	cmp	r3, #64	; 0x40
 8006340:	d137      	bne.n	80063b2 <prvTCPPrepareSend+0x14e>
					ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStreamPos, pxSocket->u.xTCP.txStream->uxHead );
 8006342:	6faa      	ldr	r2, [r5, #120]	; 0x78
 8006344:	6893      	ldr	r3, [r2, #8]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8006346:	6912      	ldr	r2, [r2, #16]
 8006348:	4413      	add	r3, r2
 800634a:	9903      	ldr	r1, [sp, #12]
 800634c:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 800634e:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8006350:	bf98      	it	ls
 8006352:	1a9b      	subls	r3, r3, r2
					if( ulDistance == ulDataGot )
 8006354:	4298      	cmp	r0, r3
 8006356:	d12c      	bne.n	80063b2 <prvTCPPrepareSend+0x14e>
						pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
 8006358:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 800635c:	f043 0301 	orr.w	r3, r3, #1
 8006360:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLen;
 8006364:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
 8006368:	4453      	add	r3, sl
 800636a:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800636e:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006372:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006376:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 800637a:	e01a      	b.n	80063b2 <prvTCPPrepareSend+0x14e>
		lNeeded = ( int32_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
 800637c:	f240 50f2 	movw	r0, #1522	; 0x5f2
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 8006380:	2100      	movs	r1, #0
 8006382:	f001 fd97 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>
		if( pxReturn != NULL )
 8006386:	2800      	cmp	r0, #0
 8006388:	f000 808e 	beq.w	80064a8 <prvTCPPrepareSend+0x244>
			if( pxNetworkBuffer )
 800638c:	f1b8 0f00 	cmp.w	r8, #0
 8006390:	d00c      	beq.n	80063ac <prvTCPPrepareSend+0x148>
				memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 8006392:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8006396:	f8d8 1018 	ldr.w	r1, [r8, #24]
 800639a:	4604      	mov	r4, r0
 800639c:	6980      	ldr	r0, [r0, #24]
 800639e:	f005 fe5c 	bl	800c05a <memcpy>
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80063a2:	4640      	mov	r0, r8
 80063a4:	f001 fd60 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 80063a8:	46a0      	mov	r8, r4
 80063aa:	e7a9      	b.n	8006300 <prvTCPPrepareSend+0x9c>
 80063ac:	4680      	mov	r8, r0
 80063ae:	e0b0      	b.n	8006512 <prvTCPPrepareSend+0x2ae>
	lDataLen = 0;
 80063b0:	2700      	movs	r7, #0
	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
 80063b2:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 80063b6:	2b05      	cmp	r3, #5
 80063b8:	f000 8081 	beq.w	80064be <prvTCPPrepareSend+0x25a>
	if( ( lDataLen > 0 ) ||
 80063bc:	2f00      	cmp	r7, #0
 80063be:	dd3c      	ble.n	800643a <prvTCPPrepareSend+0x1d6>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 80063c0:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 80063c4:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80063c8:	f106 0214 	add.w	r2, r6, #20
 80063cc:	0092      	lsls	r2, r2, #2
 80063ce:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 80063d2:	f043 0210 	orr.w	r2, r3, #16
 80063d6:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_PSH;
 80063da:	f043 0318 	orr.w	r3, r3, #24
 80063de:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
		lDataLen += ( int32_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 80063e2:	3628      	adds	r6, #40	; 0x28
 80063e4:	4437      	add	r7, r6
}
 80063e6:	4638      	mov	r0, r7
 80063e8:	b005      	add	sp, #20
 80063ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 80063ee:	4658      	mov	r0, fp
 80063f0:	f001 fb36 	bl	8007a60 <xTCPWindowTxDone>
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 80063f4:	2800      	cmp	r0, #0
 80063f6:	d067      	beq.n	80064c8 <prvTCPPrepareSend+0x264>
			pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
 80063f8:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 80063fc:	f36f 1345 	bfc	r3, #5, #1
 8006400:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
 8006404:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006408:	f043 0301 	orr.w	r3, r3, #1
 800640c:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 8006410:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8006414:	f043 0341 	orr.w	r3, r3, #65	; 0x41
 8006418:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800641c:	f8d5 30fc 	ldr.w	r3, [r5, #252]	; 0xfc
 8006420:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
 8006424:	2106      	movs	r1, #6
 8006426:	4628      	mov	r0, r5
 8006428:	f7ff fe3c 	bl	80060a4 <vTCPStateChange>
 800642c:	e04c      	b.n	80064c8 <prvTCPPrepareSend+0x264>
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800642e:	2108      	movs	r1, #8
 8006430:	4628      	mov	r0, r5
 8006432:	f7ff fe37 	bl	80060a4 <vTCPStateChange>
	pxTCPPacket = ( TCPPacket_t * ) ( pucEthernetBuffer );
 8006436:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 800643a:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 800643e:	f013 0f03 	tst.w	r3, #3
 8006442:	d0d0      	beq.n	80063e6 <prvTCPPrepareSend+0x182>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 8006444:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006448:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800644c:	f106 0214 	add.w	r2, r6, #20
 8006450:	0092      	lsls	r2, r2, #2
 8006452:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 8006456:	f043 0210 	orr.w	r2, r3, #16
 800645a:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
		if( lDataLen != 0l )
 800645e:	2f00      	cmp	r7, #0
 8006460:	d0bf      	beq.n	80063e2 <prvTCPPrepareSend+0x17e>
 8006462:	e7ba      	b.n	80063da <prvTCPPrepareSend+0x176>
				TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastAliveTime;
 8006464:	f003 faac 	bl	80099c0 <xTaskGetTickCount>
 8006468:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 800646a:	1ac0      	subs	r0, r0, r3
				if( pxSocket->u.xTCP.ucKeepRepCount )
 800646c:	f895 1058 	ldrb.w	r1, [r5, #88]	; 0x58
					xMax = ( 3u * configTICK_RATE_HZ );
 8006470:	f640 32b8 	movw	r2, #3000	; 0xbb8
 8006474:	f644 6320 	movw	r3, #20000	; 0x4e20
 8006478:	2900      	cmp	r1, #0
 800647a:	bf18      	it	ne
 800647c:	4613      	movne	r3, r2
				if( xAge > xMax )
 800647e:	4283      	cmp	r3, r0
 8006480:	d22e      	bcs.n	80064e0 <prvTCPPrepareSend+0x27c>
					pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 8006482:	f003 fa9d 	bl	80099c0 <xTaskGetTickCount>
 8006486:	65e8      	str	r0, [r5, #92]	; 0x5c
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdTRUE_UNSIGNED;
 8006488:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 800648c:	f043 0302 	orr.w	r3, r3, #2
 8006490:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500 ) );
 8006494:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8006498:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
					pxSocket->u.xTCP.ucKeepRepCount++;
 800649c:	f895 3058 	ldrb.w	r3, [r5, #88]	; 0x58
 80064a0:	3301      	adds	r3, #1
 80064a2:	f885 3058 	strb.w	r3, [r5, #88]	; 0x58
 80064a6:	e01b      	b.n	80064e0 <prvTCPPrepareSend+0x27c>
				lDataLen = -1;
 80064a8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80064ac:	e786      	b.n	80063bc <prvTCPPrepareSend+0x158>
	lDataLen = 0;
 80064ae:	2700      	movs	r7, #0
 80064b0:	e77f      	b.n	80063b2 <prvTCPPrepareSend+0x14e>
	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
 80064b2:	2800      	cmp	r0, #0
 80064b4:	db38      	blt.n	8006528 <prvTCPPrepareSend+0x2c4>
 80064b6:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 80064ba:	2b05      	cmp	r3, #5
 80064bc:	d1bd      	bne.n	800643a <prvTCPPrepareSend+0x1d6>
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 80064be:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 80064c2:	f013 0f20 	tst.w	r3, #32
 80064c6:	d192      	bne.n	80063ee <prvTCPPrepareSend+0x18a>
			if( pxSocket->u.xTCP.ucKeepRepCount > 3u )
 80064c8:	f895 3058 	ldrb.w	r3, [r5, #88]	; 0x58
 80064cc:	2b03      	cmp	r3, #3
 80064ce:	d8ae      	bhi.n	800642e <prvTCPPrepareSend+0x1ca>
			if( ( lDataLen == 0 ) && ( pxSocket->u.xTCP.bits.bWinChange == pdFALSE_UNSIGNED ) )
 80064d0:	2f00      	cmp	r7, #0
 80064d2:	f47f af73 	bne.w	80063bc <prvTCPPrepareSend+0x158>
 80064d6:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 80064da:	f013 0f01 	tst.w	r3, #1
 80064de:	d0c1      	beq.n	8006464 <prvTCPPrepareSend+0x200>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 80064e0:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 80064e4:	f013 0f03 	tst.w	r3, #3
 80064e8:	f43f af7d 	beq.w	80063e6 <prvTCPPrepareSend+0x182>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 80064ec:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 80064f0:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80064f4:	f106 0214 	add.w	r2, r6, #20
 80064f8:	0092      	lsls	r2, r2, #2
 80064fa:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 80064fe:	f043 0310 	orr.w	r3, r3, #16
 8006502:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
 8006506:	e76c      	b.n	80063e2 <prvTCPPrepareSend+0x17e>
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 8006508:	2100      	movs	r1, #0
 800650a:	f001 fcd3 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>
		if( pxReturn != NULL )
 800650e:	4680      	mov	r8, r0
 8006510:	b138      	cbz	r0, 8006522 <prvTCPPrepareSend+0x2be>
				memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 8006512:	2246      	movs	r2, #70	; 0x46
 8006514:	f105 0182 	add.w	r1, r5, #130	; 0x82
 8006518:	f8d8 0018 	ldr.w	r0, [r8, #24]
 800651c:	f005 fd9d 	bl	800c05a <memcpy>
 8006520:	e6ee      	b.n	8006300 <prvTCPPrepareSend+0x9c>
				lDataLen = -1;
 8006522:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8006526:	e749      	b.n	80063bc <prvTCPPrepareSend+0x158>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 8006528:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 800652c:	f013 0f03 	tst.w	r3, #3
 8006530:	f43f af59 	beq.w	80063e6 <prvTCPPrepareSend+0x182>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 8006534:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006538:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800653c:	f106 0214 	add.w	r2, r6, #20
 8006540:	0092      	lsls	r2, r2, #2
 8006542:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 8006546:	f043 0210 	orr.w	r2, r3, #16
 800654a:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
 800654e:	e744      	b.n	80063da <prvTCPPrepareSend+0x176>
 8006550:	0800c73c 	.word	0x0800c73c

08006554 <prvTCPSendRepeated>:
{
 8006554:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006558:	4681      	mov	r9, r0
 800655a:	4688      	mov	r8, r1
 800655c:	2408      	movs	r4, #8
int32_t lResult = 0;
 800655e:	2600      	movs	r6, #0
		xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 8006560:	4637      	mov	r7, r6
 8006562:	463a      	mov	r2, r7
 8006564:	4641      	mov	r1, r8
 8006566:	4648      	mov	r0, r9
 8006568:	f7ff fe7c 	bl	8006264 <prvTCPPrepareSend>
		if( xSendLength <= 0 )
 800656c:	1e05      	subs	r5, r0, #0
 800656e:	dd09      	ble.n	8006584 <prvTCPSendRepeated+0x30>
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 8006570:	463b      	mov	r3, r7
 8006572:	462a      	mov	r2, r5
 8006574:	f8d8 1000 	ldr.w	r1, [r8]
 8006578:	4648      	mov	r0, r9
 800657a:	f7ff fc0f 	bl	8005d9c <prvTCPReturnPacket>
		lResult += xSendLength;
 800657e:	442e      	add	r6, r5
	for( uxIndex = 0u; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 8006580:	3c01      	subs	r4, #1
 8006582:	d1ee      	bne.n	8006562 <prvTCPSendRepeated+0xe>
}
 8006584:	4630      	mov	r0, r6
 8006586:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

0800658c <xTCPSocketCheck>:
{
 800658c:	b530      	push	{r4, r5, lr}
 800658e:	b085      	sub	sp, #20
 8006590:	4604      	mov	r4, r0
	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != NULL ) )
 8006592:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 8006596:	2b04      	cmp	r3, #4
 8006598:	f240 8145 	bls.w	8006826 <xTCPSocketCheck+0x29a>
 800659c:	6f83      	ldr	r3, [r0, #120]	; 0x78
 800659e:	2b00      	cmp	r3, #0
 80065a0:	f000 8129 	beq.w	80067f6 <xTCPSocketCheck+0x26a>
		prvTCPAddTxData( pxSocket );
 80065a4:	f7ff fbd0 	bl	8005d48 <prvTCPAddTxData>
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 80065a8:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80065aa:	2800      	cmp	r0, #0
 80065ac:	f040 813e 	bne.w	800682c <xTCPSocketCheck+0x2a0>
 80065b0:	e00e      	b.n	80065d0 <xTCPSocketCheck+0x44>
					prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER, ipconfigZERO_COPY_TX_DRIVER );
 80065b2:	2300      	movs	r3, #0
 80065b4:	2228      	movs	r2, #40	; 0x28
 80065b6:	4601      	mov	r1, r0
 80065b8:	4620      	mov	r0, r4
 80065ba:	f7ff fbef 	bl	8005d9c <prvTCPReturnPacket>
 80065be:	e140      	b.n	8006842 <xTCPSocketCheck+0x2b6>
BaseType_t xReady = pdFALSE;
 80065c0:	2500      	movs	r5, #0
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 80065c2:	f001 fc51 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
				pxSocket->u.xTCP.pxAckMessage = NULL;
 80065c6:	2300      	movs	r3, #0
 80065c8:	67e3      	str	r3, [r4, #124]	; 0x7c
	if( xReady == pdFALSE )
 80065ca:	2d00      	cmp	r5, #0
 80065cc:	f040 8102 	bne.w	80067d4 <xTCPSocketCheck+0x248>
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 80065d0:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80065d4:	2b04      	cmp	r3, #4
 80065d6:	f200 8112 	bhi.w	80067fe <xTCPSocketCheck+0x272>
 80065da:	2b02      	cmp	r3, #2
 80065dc:	d012      	beq.n	8006604 <xTCPSocketCheck+0x78>
		prvTCPNextTimeout( pxSocket );
 80065de:	4620      	mov	r0, r4
 80065e0:	f7ff fd06 	bl	8005ff0 <prvTCPNextTimeout>
		switch( pxSocket->u.xTCP.ucTCPState )
 80065e4:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80065e8:	2b08      	cmp	r3, #8
 80065ea:	f200 80fa 	bhi.w	80067e2 <xTCPSocketCheck+0x256>
 80065ee:	e8df f013 	tbh	[pc, r3, lsl #1]
 80065f2:	00f5      	.short	0x00f5
 80065f4:	00f800f5 	.word	0x00f800f5
 80065f8:	00f800f8 	.word	0x00f800f8
 80065fc:	00f800f5 	.word	0x00f800f5
 8006600:	00f500f8 	.word	0x00f500f8
		if( pxSocket->u.xTCP.ucRepCount >= 3u )
 8006604:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8006608:	2b02      	cmp	r3, #2
 800660a:	f200 80be 	bhi.w	800678a <xTCPSocketCheck+0x1fe>
		else if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) || ( prvTCPPrepareConnect( pxSocket ) == pdTRUE ) )
 800660e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006612:	f013 0f08 	tst.w	r3, #8
 8006616:	d178      	bne.n	800670a <xTCPSocketCheck+0x17e>
		memset( xEthAddress.ucBytes, '\0', sizeof( xEthAddress.ucBytes ) );
 8006618:	2300      	movs	r3, #0
 800661a:	9302      	str	r3, [sp, #8]
 800661c:	f8ad 300c 	strh.w	r3, [sp, #12]
	ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 8006620:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006622:	0e1a      	lsrs	r2, r3, #24
 8006624:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006628:	0219      	lsls	r1, r3, #8
 800662a:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 800662e:	430a      	orrs	r2, r1
 8006630:	0a1b      	lsrs	r3, r3, #8
 8006632:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006636:	4313      	orrs	r3, r2
 8006638:	a804      	add	r0, sp, #16
 800663a:	f840 3d0c 	str.w	r3, [r0, #-12]!
	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );
 800663e:	a902      	add	r1, sp, #8
 8006640:	f7fc ff16 	bl	8003470 <eARPGetCacheEntry>
	switch( eReturned )
 8006644:	2801      	cmp	r0, #1
 8006646:	f040 80a5 	bne.w	8006794 <xTCPSocketCheck+0x208>
		pxSocket->u.xTCP.ucRepCount = 0u;
 800664a:	2500      	movs	r5, #0
 800664c:	f884 5052 	strb.w	r5, [r4, #82]	; 0x52
		pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
 8006650:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006654:	f043 0308 	orr.w	r3, r3, #8
 8006658:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, '\0', sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800665c:	2246      	movs	r2, #70	; 0x46
 800665e:	4629      	mov	r1, r5
 8006660:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8006664:	f005 fd1e 	bl	800c0a4 <memset>
		memcpy( &pxTCPPacket->xEthernetHeader.xSourceAddress, &xEthAddress, sizeof( xEthAddress ) );
 8006668:	9802      	ldr	r0, [sp, #8]
 800666a:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 800666e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8006672:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
		pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
 8006676:	2308      	movs	r3, #8
 8006678:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
 800667c:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f
		pxIPHeader->ucVersionHeaderLength = 0x45u;
 8006680:	2345      	movs	r3, #69	; 0x45
 8006682:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
		pxIPHeader->usLength = FreeRTOS_htons( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
 8006686:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 800668a:	2338      	movs	r3, #56	; 0x38
 800668c:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 8006690:	2380      	movs	r3, #128	; 0x80
 8006692:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
		pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
 8006696:	2306      	movs	r3, #6
 8006698:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
		pxIPHeader->ulDestinationIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800669c:	4b6f      	ldr	r3, [pc, #444]	; (800685c <xTCPSocketCheck+0x2d0>)
 800669e:	695b      	ldr	r3, [r3, #20]
 80066a0:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 80066a4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80066a6:	0e1a      	lsrs	r2, r3, #24
 80066a8:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80066ac:	0219      	lsls	r1, r3, #8
 80066ae:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80066b2:	430a      	orrs	r2, r1
 80066b4:	0a1b      	lsrs	r3, r3, #8
 80066b6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80066ba:	4313      	orrs	r3, r2
 80066bc:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
 80066c0:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 80066c2:	0a13      	lsrs	r3, r2, #8
 80066c4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80066c8:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 80066cc:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 80066ce:	0a13      	lsrs	r3, r2, #8
 80066d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80066d4:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0ul;
 80066d8:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulNextInitialSequenceNumber;
 80066dc:	4a60      	ldr	r2, [pc, #384]	; (8006860 <xTCPSocketCheck+0x2d4>)
 80066de:	6813      	ldr	r3, [r2, #0]
 80066e0:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		ulNextInitialSequenceNumber += 0x102UL;
 80066e4:	f503 7381 	add.w	r3, r3, #258	; 0x102
 80066e8:	6013      	str	r3, [r2, #0]
		pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50u;
 80066ea:	2350      	movs	r3, #80	; 0x50
 80066ec:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_SYN;
 80066f0:	2302      	movs	r3, #2
 80066f2:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
		prvSocketSetMSS( pxSocket );
 80066f6:	4620      	mov	r0, r4
 80066f8:	f7ff fb04 	bl	8005d04 <prvSocketSetMSS>
		pxSocket->u.xTCP.ulRxCurWinSize = pxSocket->u.xTCP.usInitMSS;
 80066fc:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8006700:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		prvTCPCreateWindow( pxSocket );
 8006704:	4620      	mov	r0, r4
 8006706:	f7ff fc59 	bl	8005fbc <prvTCPCreateWindow>
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 800670a:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) TCP_OPT_MSS;
 800670e:	2202      	movs	r2, #2
 8006710:	f884 20b8 	strb.w	r2, [r4, #184]	; 0xb8
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) TCP_OPT_MSS_LEN;
 8006714:	2204      	movs	r2, #4
 8006716:	f884 20b9 	strb.w	r2, [r4, #185]	; 0xb9
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 800671a:	0a1a      	lsrs	r2, r3, #8
 800671c:	f884 20ba 	strb.w	r2, [r4, #186]	; 0xba
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffu );
 8006720:	f884 30bb 	strb.w	r3, [r4, #187]	; 0xbb
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 8006724:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8006728:	fb02 f203 	mul.w	r2, r2, r3
		while( uxWinSize > 0xfffful )
 800672c:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8006730:	d339      	bcc.n	80067a6 <xTCPSocketCheck+0x21a>
 8006732:	2300      	movs	r3, #0
			uxWinSize >>= 1;
 8006734:	0852      	lsrs	r2, r2, #1
			ucFactor++;
 8006736:	3301      	adds	r3, #1
 8006738:	b2db      	uxtb	r3, r3
		while( uxWinSize > 0xfffful )
 800673a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800673e:	d2f9      	bcs.n	8006734 <xTCPSocketCheck+0x1a8>
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 8006740:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
		pxTCPHeader->ucOptdata[ 4 ] = TCP_OPT_NOOP;
 8006744:	2201      	movs	r2, #1
 8006746:	f884 20bc 	strb.w	r2, [r4, #188]	; 0xbc
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( TCP_OPT_WSOPT );
 800674a:	2103      	movs	r1, #3
 800674c:	f884 10bd 	strb.w	r1, [r4, #189]	; 0xbd
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( TCP_OPT_WSOPT_LEN );
 8006750:	f884 10be 	strb.w	r1, [r4, #190]	; 0xbe
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 8006754:	f884 30bf 	strb.w	r3, [r4, #191]	; 0xbf
			pxTCPHeader->ucOptdata[ uxOptionsLength + 0 ] = TCP_OPT_NOOP;
 8006758:	f884 20c0 	strb.w	r2, [r4, #192]	; 0xc0
			pxTCPHeader->ucOptdata[ uxOptionsLength + 1 ] = TCP_OPT_NOOP;
 800675c:	f884 20c1 	strb.w	r2, [r4, #193]	; 0xc1
			pxTCPHeader->ucOptdata[ uxOptionsLength + 2 ] = TCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 8006760:	2304      	movs	r3, #4
 8006762:	f884 30c2 	strb.w	r3, [r4, #194]	; 0xc2
			pxTCPHeader->ucOptdata[ uxOptionsLength + 3 ] = 2;	/* 2: length of this option. */
 8006766:	2302      	movs	r3, #2
 8006768:	f884 30c3 	strb.w	r3, [r4, #195]	; 0xc3
			pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800676c:	2380      	movs	r3, #128	; 0x80
 800676e:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
			pxSocket->u.xTCP.ucRepCount++;
 8006772:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8006776:	4413      	add	r3, r2
 8006778:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
			prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
 800677c:	2300      	movs	r3, #0
 800677e:	2234      	movs	r2, #52	; 0x34
 8006780:	4619      	mov	r1, r3
 8006782:	4620      	mov	r0, r4
 8006784:	f7ff fb0a 	bl	8005d9c <prvTCPReturnPacket>
 8006788:	e729      	b.n	80065de <xTCPSocketCheck+0x52>
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800678a:	2108      	movs	r1, #8
 800678c:	4620      	mov	r0, r4
 800678e:	f7ff fc89 	bl	80060a4 <vTCPStateChange>
 8006792:	e724      	b.n	80065de <xTCPSocketCheck+0x52>
		pxSocket->u.xTCP.ucRepCount++;
 8006794:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8006798:	3301      	adds	r3, #1
 800679a:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
		FreeRTOS_OutputARPRequest( ulRemoteIP );
 800679e:	9801      	ldr	r0, [sp, #4]
 80067a0:	f7fc feee 	bl	8003580 <FreeRTOS_OutputARPRequest>
 80067a4:	e71b      	b.n	80065de <xTCPSocketCheck+0x52>
		ucFactor = 0u;
 80067a6:	2300      	movs	r3, #0
 80067a8:	e7ca      	b.n	8006740 <xTCPSocketCheck+0x1b4>
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 80067aa:	2108      	movs	r1, #8
 80067ac:	4620      	mov	r0, r4
 80067ae:	f7ff fc79 	bl	80060a4 <vTCPStateChange>
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 80067b2:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80067b6:	f013 0f04 	tst.w	r3, #4
 80067ba:	d00d      	beq.n	80067d8 <xTCPSocketCheck+0x24c>
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 80067bc:	f013 0f08 	tst.w	r3, #8
 80067c0:	d002      	beq.n	80067c8 <xTCPSocketCheck+0x23c>
					xResult = -1;
 80067c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80067c6:	e00a      	b.n	80067de <xTCPSocketCheck+0x252>
						vSocketClose( pxSocket );
 80067c8:	4620      	mov	r0, r4
 80067ca:	f7fe fa11 	bl	8004bf0 <vSocketClose>
					xResult = -1;
 80067ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80067d2:	e004      	b.n	80067de <xTCPSocketCheck+0x252>
BaseType_t xResult = 0;
 80067d4:	2000      	movs	r0, #0
 80067d6:	e002      	b.n	80067de <xTCPSocketCheck+0x252>
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 80067d8:	2001      	movs	r0, #1
 80067da:	e000      	b.n	80067de <xTCPSocketCheck+0x252>
		switch( pxSocket->u.xTCP.ucTCPState )
 80067dc:	2000      	movs	r0, #0
}
 80067de:	b005      	add	sp, #20
 80067e0:	bd30      	pop	{r4, r5, pc}
			TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastActTime;
 80067e2:	f003 f8ed 	bl	80099c0 <xTaskGetTickCount>
 80067e6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80067e8:	1ac0      	subs	r0, r0, r3
			if( xAge > ( ipconfigTCP_HANG_PROTECTION_TIME * configTICK_RATE_HZ ) )
 80067ea:	f247 5330 	movw	r3, #30000	; 0x7530
 80067ee:	4298      	cmp	r0, r3
 80067f0:	d8db      	bhi.n	80067aa <xTCPSocketCheck+0x21e>
 80067f2:	2001      	movs	r0, #1
 80067f4:	e7f3      	b.n	80067de <xTCPSocketCheck+0x252>
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 80067f6:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 80067f8:	b9c0      	cbnz	r0, 800682c <xTCPSocketCheck+0x2a0>
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 80067fa:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
	if( pxSocket->u.xTCP.ucTCPState != eCONNECT_SYN )
 80067fe:	2b02      	cmp	r3, #2
 8006800:	f43f af00 	beq.w	8006604 <xTCPSocketCheck+0x78>
		pxNetworkBuffer = NULL;
 8006804:	a904      	add	r1, sp, #16
 8006806:	2300      	movs	r3, #0
 8006808:	f841 3d08 	str.w	r3, [r1, #-8]!
		lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 800680c:	4620      	mov	r0, r4
 800680e:	f7ff fea1 	bl	8006554 <prvTCPSendRepeated>
		if( pxNetworkBuffer != NULL )
 8006812:	9802      	ldr	r0, [sp, #8]
 8006814:	2800      	cmp	r0, #0
 8006816:	f43f aee2 	beq.w	80065de <xTCPSocketCheck+0x52>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800681a:	f001 fb25 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
 800681e:	e6de      	b.n	80065de <xTCPSocketCheck+0x52>
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 8006820:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006824:	e6d9      	b.n	80065da <xTCPSocketCheck+0x4e>
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8006826:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8006828:	2800      	cmp	r0, #0
 800682a:	d0f9      	beq.n	8006820 <xTCPSocketCheck+0x294>
			if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
 800682c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006830:	f013 0f20 	tst.w	r3, #32
 8006834:	f47f aec4 	bne.w	80065c0 <xTCPSocketCheck+0x34>
				if( pxSocket->u.xTCP.ucTCPState != eCLOSED )
 8006838:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 800683c:	2b00      	cmp	r3, #0
 800683e:	f47f aeb8 	bne.w	80065b2 <xTCPSocketCheck+0x26>
				if( prvTCPNextTimeout( pxSocket ) > 1 )
 8006842:	4620      	mov	r0, r4
 8006844:	f7ff fbd4 	bl	8005ff0 <prvTCPNextTimeout>
 8006848:	2801      	cmp	r0, #1
 800684a:	bf94      	ite	ls
 800684c:	2500      	movls	r5, #0
 800684e:	2501      	movhi	r5, #1
			if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8006850:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8006852:	2800      	cmp	r0, #0
 8006854:	f43f aeb9 	beq.w	80065ca <xTCPSocketCheck+0x3e>
 8006858:	e6b3      	b.n	80065c2 <xTCPSocketCheck+0x36>
 800685a:	bf00      	nop
 800685c:	20000010 	.word	0x20000010
 8006860:	2000053c 	.word	0x2000053c

08006864 <prvTCPHandleFin>:
{
 8006864:	b538      	push	{r3, r4, r5, lr}
 8006866:	4604      	mov	r4, r0
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006868:	698d      	ldr	r5, [r1, #24]
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 800686a:	f8d5 302a 	ldr.w	r3, [r5, #42]	; 0x2a
	if( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u )
 800686e:	f895 202f 	ldrb.w	r2, [r5, #47]	; 0x2f
 8006872:	f012 0f01 	tst.w	r2, #1
 8006876:	d004      	beq.n	8006882 <prvTCPHandleFin+0x1e>
		pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1u;
 8006878:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 800687c:	3201      	adds	r2, #1
 800687e:	f8c0 20ec 	str.w	r2, [r0, #236]	; 0xec
	if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 8006882:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8006886:	f012 0f40 	tst.w	r2, #64	; 0x40
 800688a:	d129      	bne.n	80068e0 <prvTCPHandleFin+0x7c>
		pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800688c:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8006890:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 8006894:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8006898:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
	if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
 800689c:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 80068a0:	f012 0f01 	tst.w	r2, #1
 80068a4:	d033      	beq.n	800690e <prvTCPHandleFin+0xaa>
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1u;
 80068a6:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 80068aa:	3301      	adds	r3, #1
 80068ac:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
 80068b0:	f994 3041 	ldrsb.w	r3, [r4, #65]	; 0x41
 80068b4:	2b00      	cmp	r3, #0
 80068b6:	db36      	blt.n	8006926 <prvTCPHandleFin+0xc2>
			pxTCPHeader->ucTCPFlags = 0u;
 80068b8:	2300      	movs	r3, #0
 80068ba:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
	pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 80068be:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 80068c2:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
	if( pxTCPHeader->ucTCPFlags != 0u )
 80068c6:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 80068ca:	b3c3      	cbz	r3, 800693e <prvTCPHandleFin+0xda>
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength );
 80068cc:	f894 0118 	ldrb.w	r0, [r4, #280]	; 0x118
 80068d0:	3028      	adds	r0, #40	; 0x28
	pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) << 2 );
 80068d2:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
 80068d6:	3314      	adds	r3, #20
 80068d8:	009b      	lsls	r3, r3, #2
 80068da:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
}
 80068de:	bd38      	pop	{r3, r4, r5, pc}
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 80068e0:	0e1a      	lsrs	r2, r3, #24
 80068e2:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80068e6:	0219      	lsls	r1, r3, #8
 80068e8:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80068ec:	430a      	orrs	r2, r1
 80068ee:	0a1b      	lsrs	r3, r3, #8
 80068f0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80068f4:	4313      	orrs	r3, r2
		if( ulAckNr == pxTCPWindow->tx.ulFINSequenceNumber + 1u )
 80068f6:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 80068fa:	3201      	adds	r2, #1
 80068fc:	4293      	cmp	r3, r2
 80068fe:	d1cd      	bne.n	800689c <prvTCPHandleFin+0x38>
			pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
 8006900:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8006904:	f043 0301 	orr.w	r3, r3, #1
 8006908:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800690c:	e7c6      	b.n	800689c <prvTCPHandleFin+0x38>
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800690e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8006912:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_FIN;
 8006916:	2311      	movs	r3, #17
 8006918:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
		vTCPStateChange( pxSocket, eLAST_ACK );
 800691c:	210a      	movs	r1, #10
 800691e:	4620      	mov	r0, r4
 8006920:	f7ff fbc0 	bl	80060a4 <vTCPStateChange>
 8006924:	e7cb      	b.n	80068be <prvTCPHandleFin+0x5a>
			if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
 8006926:	f012 0f02 	tst.w	r2, #2
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 800692a:	bf0c      	ite	eq
 800692c:	2310      	moveq	r3, #16
				pxTCPHeader->ucTCPFlags = 0u;
 800692e:	2300      	movne	r3, #0
 8006930:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8006934:	2108      	movs	r1, #8
 8006936:	4620      	mov	r0, r4
 8006938:	f7ff fbb4 	bl	80060a4 <vTCPStateChange>
 800693c:	e7bf      	b.n	80068be <prvTCPHandleFin+0x5a>
 800693e:	2000      	movs	r0, #0
 8006940:	e7c7      	b.n	80068d2 <prvTCPHandleFin+0x6e>
	...

08006944 <xProcessReceivedTCPPacket>:
 *		prvTCPSendRepeated()
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC
*/
BaseType_t xProcessReceivedTCPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 8006944:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006948:	b089      	sub	sp, #36	; 0x24
 800694a:	9005      	str	r0, [sp, #20]
FreeRTOS_Socket_t *pxSocket;
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800694c:	f8d0 8018 	ldr.w	r8, [r0, #24]
uint16_t ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags;
 8006950:	f898 502f 	ldrb.w	r5, [r8, #47]	; 0x2f
uint32_t ulLocalIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulDestinationIPAddress );
 8006954:	f8d8 401e 	ldr.w	r4, [r8, #30]
uint16_t xLocalPort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usDestinationPort );
 8006958:	f8b8 1024 	ldrh.w	r1, [r8, #36]	; 0x24
uint32_t ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 800695c:	f8d8 001a 	ldr.w	r0, [r8, #26]
uint16_t xRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 8006960:	f8b8 3022 	ldrh.w	r3, [r8, #34]	; 0x22
 8006964:	0a1a      	lsrs	r2, r3, #8
 8006966:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
uint32_t ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 800696a:	0e06      	lsrs	r6, r0, #24
 800696c:	ea46 6600 	orr.w	r6, r6, r0, lsl #24
 8006970:	0202      	lsls	r2, r0, #8
 8006972:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8006976:	4316      	orrs	r6, r2
 8006978:	0a00      	lsrs	r0, r0, #8
 800697a:	f400 427f 	and.w	r2, r0, #65280	; 0xff00
uint16_t xLocalPort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usDestinationPort );
 800697e:	0a08      	lsrs	r0, r1, #8
 8006980:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
uint32_t ulLocalIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulDestinationIPAddress );
 8006984:	0e20      	lsrs	r0, r4, #24
 8006986:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 800698a:	0227      	lsls	r7, r4, #8
 800698c:	f407 077f 	and.w	r7, r7, #16711680	; 0xff0000
 8006990:	4338      	orrs	r0, r7
 8006992:	0a24      	lsrs	r4, r4, #8
 8006994:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
BaseType_t xResult = pdPASS;

	/* Find the destination socket, and if not found: return a socket listing to
	the destination PORT. */
	pxSocket = ( FreeRTOS_Socket_t * ) pxTCPSocketLookup( ulLocalIP, xLocalPort, ulRemoteIP, xRemotePort );
 8006998:	b29b      	uxth	r3, r3
 800699a:	4332      	orrs	r2, r6
 800699c:	b289      	uxth	r1, r1
 800699e:	4320      	orrs	r0, r4
 80069a0:	f7fe fcea 	bl	8005378 <pxTCPSocketLookup>

	if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE ) )
 80069a4:	b160      	cbz	r0, 80069c0 <xProcessReceivedTCPPacket+0x7c>
 80069a6:	4604      	mov	r4, r0
 80069a8:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
	switch( uxStatus )
 80069ac:	2b0b      	cmp	r3, #11
 80069ae:	d816      	bhi.n	80069de <xProcessReceivedTCPPacket+0x9a>
 80069b0:	e8df f003 	tbb	[pc, r3]
 80069b4:	15151506 	.word	0x15151506
 80069b8:	06151515 	.word	0x06151515
 80069bc:	06150606 	.word	0x06150606
		the other party will get a ECONN error.  There are two exceptions:
		1) A packet that already has the RST flag set.
		2) A packet that only has the ACK flag set.
		A packet with only the ACK flag set might be the last ACK in
	 	a three-way hand-shake that closes a connection. */
		if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_ACK ) &&
 80069c0:	f005 031f 	and.w	r3, r5, #31
 80069c4:	2b10      	cmp	r3, #16
 80069c6:	d002      	beq.n	80069ce <xProcessReceivedTCPPacket+0x8a>
 80069c8:	f015 0f04 	tst.w	r5, #4
 80069cc:	d003      	beq.n	80069d6 <xProcessReceivedTCPPacket+0x92>
		}

		/* And finally, calculate when this socket wants to be woken up. */
		prvTCPNextTimeout ( pxSocket );
		/* Return pdPASS to tell that the network buffer is 'consumed'. */
		xResult = pdPASS;
 80069ce:	2000      	movs	r0, #0
	}

	/* pdPASS being returned means the buffer has been consumed. */
	return xResult;
}
 80069d0:	b009      	add	sp, #36	; 0x24
 80069d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			prvTCPSendReset( pxNetworkBuffer );
 80069d6:	9805      	ldr	r0, [sp, #20]
 80069d8:	f7ff fae0 	bl	8005f9c <prvTCPSendReset>
 80069dc:	e7f7      	b.n	80069ce <xProcessReceivedTCPPacket+0x8a>
		pxSocket->u.xTCP.ucRepCount = 0u;
 80069de:	2200      	movs	r2, #0
 80069e0:	f880 2052 	strb.w	r2, [r0, #82]	; 0x52
		if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 80069e4:	2b01      	cmp	r3, #1
 80069e6:	f000 80c8 	beq.w	8006b7a <xProcessReceivedTCPPacket+0x236>
			if( ( ucTCPFlags & ipTCP_FLAG_RST ) != 0u )
 80069ea:	f015 0f04 	tst.w	r5, #4
 80069ee:	f040 8183 	bne.w	8006cf8 <xProcessReceivedTCPPacket+0x3b4>
			else if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) )
 80069f2:	f005 051f 	and.w	r5, r5, #31
 80069f6:	2d02      	cmp	r5, #2
 80069f8:	f000 8182 	beq.w	8006d00 <xProcessReceivedTCPPacket+0x3bc>
				memcpy( pxSocket->u.xTCP.xPacket.u.ucLastPacket + lOffset, pxNetworkBuffer->pucEthernetBuffer + lOffset, ipSIZE_OF_TCP_HEADER );
 80069fc:	9a05      	ldr	r2, [sp, #20]
 80069fe:	6992      	ldr	r2, [r2, #24]
 8006a00:	f852 1f22 	ldr.w	r1, [r2, #34]!
 8006a04:	6856      	ldr	r6, [r2, #4]
 8006a06:	6895      	ldr	r5, [r2, #8]
 8006a08:	68d0      	ldr	r0, [r2, #12]
 8006a0a:	f8c4 10a4 	str.w	r1, [r4, #164]	; 0xa4
 8006a0e:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
 8006a12:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
 8006a16:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
 8006a1a:	6911      	ldr	r1, [r2, #16]
 8006a1c:	f8c4 10b4 	str.w	r1, [r4, #180]	; 0xb4
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8006a20:	f002 ffce 	bl	80099c0 <xTaskGetTickCount>
 8006a24:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 8006a26:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 8006a2a:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8006a2e:	f36f 0341 	bfc	r3, #1, #1
 8006a32:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 8006a36:	2300      	movs	r3, #0
 8006a38:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 8006a3c:	f002 ffc0 	bl	80099c0 <xTaskGetTickCount>
 8006a40:	65e0      	str	r0, [r4, #92]	; 0x5c
		if( ( pxTCPPacket->xTCPHeader.ucTCPOffset & TCP_OFFSET_LENGTH_BITS ) > TCP_OFFSET_STANDARD_LENGTH )
 8006a42:	f898 302e 	ldrb.w	r3, [r8, #46]	; 0x2e
 8006a46:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8006a4a:	2b50      	cmp	r3, #80	; 0x50
 8006a4c:	f200 815c 	bhi.w	8006d08 <xProcessReceivedTCPPacket+0x3c4>
			pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPPacket->xTCPHeader.usWindow );
 8006a50:	f8b8 2030 	ldrh.w	r2, [r8, #48]	; 0x30
 8006a54:	0a13      	lsrs	r3, r2, #8
 8006a56:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006a5a:	b29b      	uxth	r3, r3
				( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 8006a5c:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
 8006a60:	4093      	lsls	r3, r2
			pxSocket->u.xTCP.ulWindowSize =
 8006a62:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 8006a66:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8006a6a:	f8d9 6018 	ldr.w	r6, [r9, #24]
uint32_t ulSequenceNumber = FreeRTOS_ntohl (pxTCPHeader->ulSequenceNumber);
 8006a6e:	f8d6 3026 	ldr.w	r3, [r6, #38]	; 0x26
 8006a72:	0e1a      	lsrs	r2, r3, #24
 8006a74:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006a78:	0219      	lsls	r1, r3, #8
 8006a7a:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006a7e:	430a      	orrs	r2, r1
 8006a80:	0a1b      	lsrs	r3, r3, #8
 8006a82:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006a86:	ea42 0803 	orr.w	r8, r2, r3
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8006a8a:	f896 b02f 	ldrb.w	fp, [r6, #47]	; 0x2f
    lTCPHeaderLength = ( BaseType_t ) ( ( pxTCPHeader->ucTCPOffset & VALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2 );
 8006a8e:	f896 302e 	ldrb.w	r3, [r6, #46]	; 0x2e
 8006a92:	089b      	lsrs	r3, r3, #2
 8006a94:	f003 033c 	and.w	r3, r3, #60	; 0x3c
	*ppucRecvData = pxNetworkBuffer->pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + lTCPHeaderLength;
 8006a98:	f103 0722 	add.w	r7, r3, #34	; 0x22
 8006a9c:	4437      	add	r7, r6
	lReceiveLength = ( ( int32_t ) pxNetworkBuffer->xDataLength ) - ( int32_t ) ipSIZE_OF_ETH_HEADER;
 8006a9e:	f8d9 501c 	ldr.w	r5, [r9, #28]
 8006aa2:	f1a5 010e 	sub.w	r1, r5, #14
	lLength =  ( int32_t )FreeRTOS_htons( pxTCPPacket->xIPHeader.usLength );
 8006aa6:	8a35      	ldrh	r5, [r6, #16]
 8006aa8:	0a2a      	lsrs	r2, r5, #8
 8006aaa:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 8006aae:	b295      	uxth	r5, r2
 8006ab0:	428d      	cmp	r5, r1
 8006ab2:	bfa8      	it	ge
 8006ab4:	460d      	movge	r5, r1
	if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER ) )
 8006ab6:	3314      	adds	r3, #20
 8006ab8:	429d      	cmp	r5, r3
		lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER );
 8006aba:	bfcc      	ite	gt
 8006abc:	1aed      	subgt	r5, r5, r3
		lReceiveLength = 0;
 8006abe:	2500      	movle	r5, #0
	if( ( pxTCPHeader->ucTCPFlags & ipTCP_FLAG_URG ) != 0u )
 8006ac0:	f01b 0f20 	tst.w	fp, #32
 8006ac4:	d009      	beq.n	8006ada <xProcessReceivedTCPPacket+0x196>
		lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
 8006ac6:	8eb2      	ldrh	r2, [r6, #52]	; 0x34
 8006ac8:	0a13      	lsrs	r3, r2, #8
 8006aca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006ace:	b29b      	uxth	r3, r3
		*ppucRecvData += lUrgentLength;
 8006ad0:	441f      	add	r7, r3
		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
 8006ad2:	42ab      	cmp	r3, r5
 8006ad4:	bfd4      	ite	le
 8006ad6:	1aed      	suble	r5, r5, r3
 8006ad8:	1b6d      	subgt	r5, r5, r5
	ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
 8006ada:	9502      	str	r5, [sp, #8]
	if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
 8006adc:	f894 2053 	ldrb.w	r2, [r4, #83]	; 0x53
 8006ae0:	2a04      	cmp	r2, #4
 8006ae2:	d906      	bls.n	8006af2 <xProcessReceivedTCPPacket+0x1ae>
		if ( pxTCPWindow->rx.ulCurrentSequenceNumber == ulSequenceNumber + 1u )
 8006ae4:	f108 0301 	add.w	r3, r8, #1
 8006ae8:	f8d4 10ec 	ldr.w	r1, [r4, #236]	; 0xec
 8006aec:	4299      	cmp	r1, r3
 8006aee:	f000 81d6 	beq.w	8006e9e <xProcessReceivedTCPPacket+0x55a>
	if( ( ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSequenceNumber ) ) > 0 )
 8006af2:	9b02      	ldr	r3, [sp, #8]
 8006af4:	eb08 0a03 	add.w	sl, r8, r3
 8006af8:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8006afc:	ebaa 0303 	sub.w	r3, sl, r3
 8006b00:	2b00      	cmp	r3, #0
		pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
 8006b02:	bfc8      	it	gt
 8006b04:	f8c4 a0f4 	strgt.w	sl, [r4, #244]	; 0xf4
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 8006b08:	f104 03dc 	add.w	r3, r4, #220	; 0xdc
 8006b0c:	9303      	str	r3, [sp, #12]
	if( ( ulReceiveLength > 0u ) && ( pxSocket->u.xTCP.ucTCPState >= eSYN_RECEIVED ) )
 8006b0e:	9b02      	ldr	r3, [sp, #8]
 8006b10:	2b00      	cmp	r3, #0
 8006b12:	f000 81e1 	beq.w	8006ed8 <xProcessReceivedTCPPacket+0x594>
 8006b16:	2a03      	cmp	r2, #3
 8006b18:	f240 81de 	bls.w	8006ed8 <xProcessReceivedTCPPacket+0x594>
		if ( pxSocket->u.xTCP.rxStream )
 8006b1c:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8006b1e:	2a00      	cmp	r2, #0
 8006b20:	f000 81c4 	beq.w	8006eac <xProcessReceivedTCPPacket+0x568>
size_t uxHead = pxBuffer->uxHead;
 8006b24:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8006b26:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8006b28:	6912      	ldr	r2, [r2, #16]
 8006b2a:	4413      	add	r3, r2
 8006b2c:	3b01      	subs	r3, #1
 8006b2e:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8006b30:	429a      	cmp	r2, r3
 8006b32:	d800      	bhi.n	8006b36 <xProcessReceivedTCPPacket+0x1f2>
		uxCount -= pxBuffer->LENGTH;
 8006b34:	1a9b      	subs	r3, r3, r2
	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 8006b36:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8006b3a:	f8d2 2026 	ldr.w	r2, [r2, #38]	; 0x26
 8006b3e:	0e10      	lsrs	r0, r2, #24
 8006b40:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 8006b44:	0211      	lsls	r1, r2, #8
 8006b46:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006b4a:	4308      	orrs	r0, r1
 8006b4c:	0a12      	lsrs	r2, r2, #8
 8006b4e:	f402 417f 	and.w	r1, r2, #65280	; 0xff00
		lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace );
 8006b52:	9a02      	ldr	r2, [sp, #8]
 8006b54:	4301      	orrs	r1, r0
 8006b56:	9803      	ldr	r0, [sp, #12]
 8006b58:	f000 fe60 	bl	800781c <lTCPWindowRxCheck>
		if( lOffset >= 0 )
 8006b5c:	1e01      	subs	r1, r0, #0
 8006b5e:	f2c0 83f9 	blt.w	8007354 <xProcessReceivedTCPPacket+0xa10>
			lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRecvData, ulReceiveLength );
 8006b62:	9b02      	ldr	r3, [sp, #8]
 8006b64:	463a      	mov	r2, r7
 8006b66:	4620      	mov	r0, r4
 8006b68:	f7fe fc2e 	bl	80053c8 <lTCPAddRxdata>
			if( lStored != ( int32_t ) ulReceiveLength )
 8006b6c:	4285      	cmp	r5, r0
 8006b6e:	f000 83f1 	beq.w	8007354 <xProcessReceivedTCPPacket+0xa10>
				prvTCPSendReset( pxNetworkBuffer );
 8006b72:	4648      	mov	r0, r9
 8006b74:	f7ff fa12 	bl	8005f9c <prvTCPSendReset>
 8006b78:	e3bc      	b.n	80072f4 <xProcessReceivedTCPPacket+0x9b0>
			if( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_SYN )
 8006b7a:	f005 031f 	and.w	r3, r5, #31
 8006b7e:	2b02      	cmp	r3, #2
 8006b80:	d007      	beq.n	8006b92 <xProcessReceivedTCPPacket+0x24e>
				if( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u )
 8006b82:	f015 0f04 	tst.w	r5, #4
 8006b86:	f47f af22 	bne.w	80069ce <xProcessReceivedTCPPacket+0x8a>
					prvTCPSendReset( pxNetworkBuffer );
 8006b8a:	9805      	ldr	r0, [sp, #20]
 8006b8c:	f7ff fa06 	bl	8005f9c <prvTCPSendReset>
 8006b90:	e71d      	b.n	80069ce <xProcessReceivedTCPPacket+0x8a>
				pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
 8006b92:	9d05      	ldr	r5, [sp, #20]
/*-----------------------------------------------------------*/

static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006b94:	69af      	ldr	r7, [r5, #24]
FreeRTOS_Socket_t *pxReturn;

	/* A pure SYN (without ACK) has come in, create a new socket to answer
	it. */
	if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 8006b96:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8006b9a:	f013 0f08 	tst.w	r3, #8
 8006b9e:	d043      	beq.n	8006c28 <xProcessReceivedTCPPacket+0x2e4>
	{
		/* The flag bReuseSocket indicates that the same instance of the
		listening socket should be used for the connection. */
		pxReturn = pxSocket;
		pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 8006ba0:	f043 0304 	orr.w	r3, r3, #4
 8006ba4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
		pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 8006ba8:	6560      	str	r0, [r4, #84]	; 0x54
		}
	}

	if( pxReturn != NULL )
	{
		pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 8006baa:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8006bac:	0a13      	lsrs	r3, r2, #8
 8006bae:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006bb2:	87a3      	strh	r3, [r4, #60]	; 0x3c
		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 8006bb4:	f8d7 301a 	ldr.w	r3, [r7, #26]
 8006bb8:	0e1a      	lsrs	r2, r3, #24
 8006bba:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006bbe:	0219      	lsls	r1, r3, #8
 8006bc0:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006bc4:	430a      	orrs	r2, r1
 8006bc6:	0a1b      	lsrs	r3, r3, #8
 8006bc8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006bcc:	4313      	orrs	r3, r2
 8006bce:	63a3      	str	r3, [r4, #56]	; 0x38
		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulNextInitialSequenceNumber;
 8006bd0:	4ebc      	ldr	r6, [pc, #752]	; (8006ec4 <xProcessReceivedTCPPacket+0x580>)
 8006bd2:	6833      	ldr	r3, [r6, #0]
 8006bd4:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108

		/* Here is the SYN action. */
		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 8006bd8:	f8d7 3026 	ldr.w	r3, [r7, #38]	; 0x26
 8006bdc:	0e1a      	lsrs	r2, r3, #24
 8006bde:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006be2:	0219      	lsls	r1, r3, #8
 8006be4:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006be8:	430a      	orrs	r2, r1
 8006bea:	0a1b      	lsrs	r3, r3, #8
 8006bec:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006bf0:	4313      	orrs	r3, r2
 8006bf2:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
		prvSocketSetMSS( pxReturn );
 8006bf6:	4620      	mov	r0, r4
 8006bf8:	f7ff f884 	bl	8005d04 <prvSocketSetMSS>

		prvTCPCreateWindow( pxReturn );
 8006bfc:	4620      	mov	r0, r4
 8006bfe:	f7ff f9dd 	bl	8005fbc <prvTCPCreateWindow>

		/* It is recommended to increase the ISS for each new connection with a value of 0x102. */
		ulNextInitialSequenceNumber += INITIAL_SEQUENCE_NUMBER_INCREMENT;
 8006c02:	6833      	ldr	r3, [r6, #0]
 8006c04:	f503 7381 	add.w	r3, r3, #258	; 0x102
 8006c08:	6033      	str	r3, [r6, #0]

		vTCPStateChange( pxReturn, eSYN_FIRST );
 8006c0a:	2103      	movs	r1, #3
 8006c0c:	4620      	mov	r0, r4
 8006c0e:	f7ff fa49 	bl	80060a4 <vTCPStateChange>

		/* Make a copy of the header up to the TCP header.  It is needed later
		on, whenever data must be sent to the peer. */
		memcpy( pxReturn->u.xTCP.xPacket.u.ucLastPacket, pxNetworkBuffer->pucEthernetBuffer, sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) );
 8006c12:	2246      	movs	r2, #70	; 0x46
 8006c14:	69a9      	ldr	r1, [r5, #24]
 8006c16:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8006c1a:	f005 fa1e 	bl	800c05a <memcpy>
	if( xResult != pdFAIL )
 8006c1e:	2c00      	cmp	r4, #0
 8006c20:	f47f aefe 	bne.w	8006a20 <xProcessReceivedTCPPacket+0xdc>
 8006c24:	2000      	movs	r0, #0
 8006c26:	e6d3      	b.n	80069d0 <xProcessReceivedTCPPacket+0x8c>
		if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 8006c28:	f8b0 204e 	ldrh.w	r2, [r0, #78]	; 0x4e
 8006c2c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8006c30:	429a      	cmp	r2, r3
 8006c32:	d249      	bcs.n	8006cc8 <xProcessReceivedTCPPacket+0x384>
			FreeRTOS_Socket_t *pxNewSocket = (FreeRTOS_Socket_t *)
 8006c34:	2206      	movs	r2, #6
 8006c36:	2101      	movs	r1, #1
 8006c38:	2002      	movs	r0, #2
 8006c3a:	f7fd fd5f 	bl	80046fc <FreeRTOS_socket>
 8006c3e:	4606      	mov	r6, r0
			if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 8006c40:	1e43      	subs	r3, r0, #1
 8006c42:	f113 0f03 	cmn.w	r3, #3
 8006c46:	d84e      	bhi.n	8006ce6 <xProcessReceivedTCPPacket+0x3a2>
 */
static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket )
{
struct freertos_sockaddr xAddress;

	pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
 8006c48:	69e3      	ldr	r3, [r4, #28]
 8006c4a:	61c3      	str	r3, [r0, #28]
	pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
 8006c4c:	6a23      	ldr	r3, [r4, #32]
 8006c4e:	6203      	str	r3, [r0, #32]
	pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
 8006c50:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8006c54:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
	pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
 8006c58:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006c5a:	66c3      	str	r3, [r0, #108]	; 0x6c
	pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
 8006c5c:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8006c5e:	6703      	str	r3, [r0, #112]	; 0x70
	pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
 8006c60:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8006c62:	6643      	str	r3, [r0, #100]	; 0x64
	pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
 8006c64:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8006c66:	6683      	str	r3, [r0, #104]	; 0x68
	pxNewSocket->u.xTCP.uxRxWinSize  = pxSocket->u.xTCP.uxRxWinSize;
 8006c68:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8006c6c:	f8c0 30d4 	str.w	r3, [r0, #212]	; 0xd4
	pxNewSocket->u.xTCP.uxTxWinSize  = pxSocket->u.xTCP.uxTxWinSize;
 8006c70:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 8006c74:	f8c0 30d8 	str.w	r3, [r0, #216]	; 0xd8

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		/* Child socket of listening sockets will inherit the Socket Set
		Otherwise the owner has no chance of including it into the set. */
		if( pxSocket->pxSocketSet )
 8006c78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006c7a:	b123      	cbz	r3, 8006c86 <xProcessReceivedTCPPacket+0x342>
		{
			pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
 8006c7c:	6283      	str	r3, [r0, #40]	; 0x28
			pxNewSocket->xSelectBits = pxSocket->xSelectBits | eSELECT_READ | eSELECT_EXCEPT;
 8006c7e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006c80:	f043 0305 	orr.w	r3, r3, #5
 8006c84:	62c3      	str	r3, [r0, #44]	; 0x2c
		}
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	/* And bind it to the same local port as its parent. */
	xAddress.sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
 8006c86:	4b90      	ldr	r3, [pc, #576]	; (8006ec8 <xProcessReceivedTCPPacket+0x584>)
 8006c88:	695b      	ldr	r3, [r3, #20]
 8006c8a:	9307      	str	r3, [sp, #28]
	xAddress.sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 8006c8c:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 8006c8e:	0a13      	lsrs	r3, r2, #8
 8006c90:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006c94:	f8ad 301a 	strh.w	r3, [sp, #26]
		orphan temporarily.  Once this socket is really connected, the owner of
		the server socket will be notified. */

		/* When bPassQueued is true, the socket is an orphan until it gets
		connected. */
		pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 8006c98:	f896 3040 	ldrb.w	r3, [r6, #64]	; 0x40
 8006c9c:	f043 0304 	orr.w	r3, r3, #4
 8006ca0:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
		pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
 8006ca4:	6574      	str	r4, [r6, #84]	; 0x54
			pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
		}
	}
	#endif

	pxSocket->u.xTCP.usChildCount++;
 8006ca6:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8006caa:	3301      	adds	r3, #1
 8006cac:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
		pxSocket->u.xTCP.usChildCount,
		pxSocket->u.xTCP.usBacklog,
		pxSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );

	/* Now bind the child socket to the same port as the listening socket. */
	if( vSocketBind ( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
 8006cb0:	2301      	movs	r3, #1
 8006cb2:	2208      	movs	r2, #8
 8006cb4:	a906      	add	r1, sp, #24
 8006cb6:	4630      	mov	r0, r6
 8006cb8:	f7fd fefe 	bl	8004ab8 <vSocketBind>
 8006cbc:	b9b8      	cbnz	r0, 8006cee <xProcessReceivedTCPPacket+0x3aa>
				pxReturn = pxNewSocket;
 8006cbe:	4634      	mov	r4, r6
	if( pxReturn != NULL )
 8006cc0:	2e00      	cmp	r6, #0
 8006cc2:	f47f af72 	bne.w	8006baa <xProcessReceivedTCPPacket+0x266>
 8006cc6:	e00c      	b.n	8006ce2 <xProcessReceivedTCPPacket+0x39e>
			FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
 8006cc8:	8c81      	ldrh	r1, [r0, #36]	; 0x24
 8006cca:	4c80      	ldr	r4, [pc, #512]	; (8006ecc <xProcessReceivedTCPPacket+0x588>)
 8006ccc:	4880      	ldr	r0, [pc, #512]	; (8006ed0 <xProcessReceivedTCPPacket+0x58c>)
 8006cce:	2a01      	cmp	r2, #1
 8006cd0:	bf18      	it	ne
 8006cd2:	4620      	movne	r0, r4
 8006cd4:	9000      	str	r0, [sp, #0]
 8006cd6:	487f      	ldr	r0, [pc, #508]	; (8006ed4 <xProcessReceivedTCPPacket+0x590>)
 8006cd8:	f004 fb7e 	bl	800b3d8 <lUDPLoggingPrintf>
			prvTCPSendReset( pxNetworkBuffer );
 8006cdc:	4628      	mov	r0, r5
 8006cde:	f7ff f95d 	bl	8005f9c <prvTCPSendReset>
		xResult = pdPASS;
 8006ce2:	2000      	movs	r0, #0
 8006ce4:	e674      	b.n	80069d0 <xProcessReceivedTCPPacket+0x8c>
				prvTCPSendReset( pxNetworkBuffer );
 8006ce6:	4628      	mov	r0, r5
 8006ce8:	f7ff f958 	bl	8005f9c <prvTCPSendReset>
 8006cec:	e7f9      	b.n	8006ce2 <xProcessReceivedTCPPacket+0x39e>
	{
		FreeRTOS_debug_printf( ( "TCP: Listen: new socket bind error\n" ) );
		vSocketClose( pxNewSocket );
 8006cee:	4630      	mov	r0, r6
 8006cf0:	f7fd ff7e 	bl	8004bf0 <vSocketClose>
 8006cf4:	2400      	movs	r4, #0
 8006cf6:	e792      	b.n	8006c1e <xProcessReceivedTCPPacket+0x2da>
				vTCPStateChange( pxSocket, eCLOSED );
 8006cf8:	2100      	movs	r1, #0
 8006cfa:	f7ff f9d3 	bl	80060a4 <vTCPStateChange>
 8006cfe:	e666      	b.n	80069ce <xProcessReceivedTCPPacket+0x8a>
			else if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) )
 8006d00:	2b04      	cmp	r3, #4
 8006d02:	f63f ae64 	bhi.w	80069ce <xProcessReceivedTCPPacket+0x8a>
 8006d06:	e679      	b.n	80069fc <xProcessReceivedTCPPacket+0xb8>
	pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006d08:	9b05      	ldr	r3, [sp, #20]
 8006d0a:	6999      	ldr	r1, [r3, #24]
	pucPtr = pxTCPHeader->ucOptdata;
 8006d0c:	f101 0336 	add.w	r3, r1, #54	; 0x36
	pucLast = pucPtr + (((pxTCPHeader->ucTCPOffset >> 4) - 5) << 2);
 8006d10:	f891 202e 	ldrb.w	r2, [r1, #46]	; 0x2e
 8006d14:	0912      	lsrs	r2, r2, #4
 8006d16:	3a05      	subs	r2, #5
 8006d18:	eb03 0782 	add.w	r7, r3, r2, lsl #2
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 8006d1c:	f104 02dc 	add.w	r2, r4, #220	; 0xdc
 8006d20:	9202      	str	r2, [sp, #8]
	while( pucPtr < pucLast )
 8006d22:	42bb      	cmp	r3, r7
 8006d24:	f4bf ae94 	bcs.w	8006a50 <xProcessReceivedTCPPacket+0x10c>
		if( pucPtr[ 0 ] == TCP_OPT_END )
 8006d28:	f891 2036 	ldrb.w	r2, [r1, #54]	; 0x36
 8006d2c:	2a00      	cmp	r2, #0
 8006d2e:	f43f ae8f 	beq.w	8006a50 <xProcessReceivedTCPPacket+0x10c>
							uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 8006d32:	f04f 0b00 	mov.w	fp, #0
 8006d36:	f8cd 8010 	str.w	r8, [sp, #16]
 8006d3a:	46b9      	mov	r9, r7
 8006d3c:	e088      	b.n	8006e50 <xProcessReceivedTCPPacket+0x50c>
			pucPtr++;
 8006d3e:	3301      	adds	r3, #1
 8006d40:	e082      	b.n	8006e48 <xProcessReceivedTCPPacket+0x504>
		else if( ( pucPtr[ 0 ] == TCP_OPT_WSOPT ) && ( pucPtr[ 1 ] == TCP_OPT_WSOPT_LEN ) )
 8006d42:	785a      	ldrb	r2, [r3, #1]
 8006d44:	2a03      	cmp	r2, #3
 8006d46:	d005      	beq.n	8006d54 <xProcessReceivedTCPPacket+0x410>
			int len = ( int )pucPtr[ 1 ];
 8006d48:	7859      	ldrb	r1, [r3, #1]
			if( len == 0 )
 8006d4a:	2900      	cmp	r1, #0
 8006d4c:	d17b      	bne.n	8006e46 <xProcessReceivedTCPPacket+0x502>
 8006d4e:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8006d52:	e67d      	b.n	8006a50 <xProcessReceivedTCPPacket+0x10c>
			pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
 8006d54:	789a      	ldrb	r2, [r3, #2]
 8006d56:	f884 20ca 	strb.w	r2, [r4, #202]	; 0xca
			pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
 8006d5a:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8006d5e:	f042 0210 	orr.w	r2, r2, #16
 8006d62:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
			pucPtr += TCP_OPT_WSOPT_LEN;
 8006d66:	3303      	adds	r3, #3
 8006d68:	e06e      	b.n	8006e48 <xProcessReceivedTCPPacket+0x504>
		else if( ( pucPtr[ 0 ] == TCP_OPT_MSS ) && ( pucPtr[ 1 ] == TCP_OPT_MSS_LEN ) )
 8006d6a:	785a      	ldrb	r2, [r3, #1]
 8006d6c:	2a04      	cmp	r2, #4
 8006d6e:	d005      	beq.n	8006d7c <xProcessReceivedTCPPacket+0x438>
			int len = ( int )pucPtr[ 1 ];
 8006d70:	4611      	mov	r1, r2
			if( len == 0 )
 8006d72:	2a00      	cmp	r2, #0
 8006d74:	d167      	bne.n	8006e46 <xProcessReceivedTCPPacket+0x502>
 8006d76:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8006d7a:	e669      	b.n	8006a50 <xProcessReceivedTCPPacket+0x10c>
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 8006d7c:	7899      	ldrb	r1, [r3, #2]
			  ( ( ( uint32_t )apChr[1] ) ) );
 8006d7e:	78da      	ldrb	r2, [r3, #3]
	return ( uint16_t )
 8006d80:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
			if( pxSocket->u.xTCP.usInitMSS != uxNewMSS )
 8006d84:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
			if( pxSocket->u.xTCP.usInitMSS > uxNewMSS )
 8006d88:	428a      	cmp	r2, r1
 8006d8a:	d215      	bcs.n	8006db8 <xProcessReceivedTCPPacket+0x474>
				pxSocket->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
 8006d8c:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
 8006d90:	f041 0101 	orr.w	r1, r1, #1
 8006d94:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
				pxTCPWindow->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( pxTCPWindow->xSize.ulRxWindowLength / ( ( uint32_t ) uxNewMSS ) );
 8006d98:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
 8006d9c:	fbb1 f1f2 	udiv	r1, r1, r2
 8006da0:	fb02 f101 	mul.w	r1, r2, r1
 8006da4:	f8c4 10e0 	str.w	r1, [r4, #224]	; 0xe0
				pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
 8006da8:	f8a4 219a 	strh.w	r2, [r4, #410]	; 0x19a
				pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
 8006dac:	f8a4 2198 	strh.w	r2, [r4, #408]	; 0x198
				pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
 8006db0:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
				pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
 8006db4:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
				pucPtr += TCP_OPT_MSS_LEN;
 8006db8:	3304      	adds	r3, #4
 8006dba:	e045      	b.n	8006e48 <xProcessReceivedTCPPacket+0x504>
 8006dbc:	3508      	adds	r5, #8
					while( len >= 8 )
 8006dbe:	42b5      	cmp	r5, r6
 8006dc0:	d038      	beq.n	8006e34 <xProcessReceivedTCPPacket+0x4f0>
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8006dc2:	f815 3c04 	ldrb.w	r3, [r5, #-4]
			( ( ( uint32_t )apChr[1] ) << 16) |
 8006dc6:	f815 2c03 	ldrb.w	r2, [r5, #-3]
 8006dca:	0412      	lsls	r2, r2, #16
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8006dcc:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
			( ( ( uint32_t )apChr[3] ) );
 8006dd0:	f815 3c01 	ldrb.w	r3, [r5, #-1]
			( ( ( uint32_t )apChr[2] ) << 8) |
 8006dd4:	431a      	orrs	r2, r3
 8006dd6:	f815 0c02 	ldrb.w	r0, [r5, #-2]
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8006dda:	f815 1c08 	ldrb.w	r1, [r5, #-8]
			( ( ( uint32_t )apChr[1] ) << 16) |
 8006dde:	f815 3c07 	ldrb.w	r3, [r5, #-7]
 8006de2:	041b      	lsls	r3, r3, #16
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8006de4:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
			( ( ( uint32_t )apChr[3] ) );
 8006de8:	f815 1c05 	ldrb.w	r1, [r5, #-5]
			( ( ( uint32_t )apChr[2] ) << 8) |
 8006dec:	430b      	orrs	r3, r1
 8006dee:	f815 1c06 	ldrb.w	r1, [r5, #-6]
					uint32_t ulCount = ulTCPWindowTxSack( &pxSocket->u.xTCP.xTCPWindow, ulFirst, ulLast );
 8006df2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8006df6:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8006dfa:	9802      	ldr	r0, [sp, #8]
 8006dfc:	f000 fefa 	bl	8007bf4 <ulTCPWindowTxSack>
 8006e00:	4603      	mov	r3, r0
						if( ( pxSocket->u.xTCP.txStream  != NULL ) && ( ulCount > 0 ) )
 8006e02:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8006e04:	2800      	cmp	r0, #0
 8006e06:	d0d9      	beq.n	8006dbc <xProcessReceivedTCPPacket+0x478>
 8006e08:	2b00      	cmp	r3, #0
 8006e0a:	d0d7      	beq.n	8006dbc <xProcessReceivedTCPPacket+0x478>
							uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 8006e0c:	f8cd b000 	str.w	fp, [sp]
 8006e10:	465a      	mov	r2, fp
 8006e12:	4659      	mov	r1, fp
 8006e14:	f7fe ff35 	bl	8005c82 <uxStreamBufferGet>
							pxSocket->xEventBits |= eSOCKET_SEND;
 8006e18:	6823      	ldr	r3, [r4, #0]
 8006e1a:	f043 0202 	orr.w	r2, r3, #2
 8006e1e:	6022      	str	r2, [r4, #0]
								if( pxSocket->xSelectBits & eSELECT_WRITE )
 8006e20:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006e22:	f012 0f02 	tst.w	r2, #2
 8006e26:	d0c9      	beq.n	8006dbc <xProcessReceivedTCPPacket+0x478>
									pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 8006e28:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8006e2c:	f043 0302 	orr.w	r3, r3, #2
 8006e30:	6023      	str	r3, [r4, #0]
 8006e32:	e7c3      	b.n	8006dbc <xProcessReceivedTCPPacket+0x478>
 8006e34:	f10a 0608 	add.w	r6, sl, #8
 8006e38:	9b03      	ldr	r3, [sp, #12]
 8006e3a:	4433      	add	r3, r6
 8006e3c:	3f0a      	subs	r7, #10
 8006e3e:	f028 0807 	bic.w	r8, r8, #7
 8006e42:	eba7 0108 	sub.w	r1, r7, r8
			pucPtr += len;
 8006e46:	440b      	add	r3, r1
	while( pucPtr < pucLast )
 8006e48:	4599      	cmp	r9, r3
 8006e4a:	d91f      	bls.n	8006e8c <xProcessReceivedTCPPacket+0x548>
		if( pucPtr[ 0 ] == TCP_OPT_END )
 8006e4c:	781a      	ldrb	r2, [r3, #0]
 8006e4e:	b302      	cbz	r2, 8006e92 <xProcessReceivedTCPPacket+0x54e>
		if( pucPtr[ 0 ] == TCP_OPT_NOOP)
 8006e50:	2a01      	cmp	r2, #1
 8006e52:	f43f af74 	beq.w	8006d3e <xProcessReceivedTCPPacket+0x3fa>
		else if( ( pucPtr[ 0 ] == TCP_OPT_WSOPT ) && ( pucPtr[ 1 ] == TCP_OPT_WSOPT_LEN ) )
 8006e56:	2a03      	cmp	r2, #3
 8006e58:	f43f af73 	beq.w	8006d42 <xProcessReceivedTCPPacket+0x3fe>
		else if( ( pucPtr[ 0 ] == TCP_OPT_MSS ) && ( pucPtr[ 1 ] == TCP_OPT_MSS_LEN ) )
 8006e5c:	2a02      	cmp	r2, #2
 8006e5e:	d084      	beq.n	8006d6a <xProcessReceivedTCPPacket+0x426>
			int len = ( int )pucPtr[ 1 ];
 8006e60:	785f      	ldrb	r7, [r3, #1]
 8006e62:	4639      	mov	r1, r7
			if( len == 0 )
 8006e64:	b1c7      	cbz	r7, 8006e98 <xProcessReceivedTCPPacket+0x554>
				if( pucPtr[0] == TCP_OPT_SACK_A )
 8006e66:	2a05      	cmp	r2, #5
 8006e68:	d1ed      	bne.n	8006e46 <xProcessReceivedTCPPacket+0x502>
					len -= 2;
 8006e6a:	1eb9      	subs	r1, r7, #2
					pucPtr += 2;
 8006e6c:	1c9a      	adds	r2, r3, #2
 8006e6e:	9203      	str	r2, [sp, #12]
					while( len >= 8 )
 8006e70:	2907      	cmp	r1, #7
 8006e72:	dd09      	ble.n	8006e88 <xProcessReceivedTCPPacket+0x544>
 8006e74:	f103 050a 	add.w	r5, r3, #10
 8006e78:	f1a7 080a 	sub.w	r8, r7, #10
 8006e7c:	f028 0a07 	bic.w	sl, r8, #7
 8006e80:	f10a 0612 	add.w	r6, sl, #18
 8006e84:	441e      	add	r6, r3
 8006e86:	e79c      	b.n	8006dc2 <xProcessReceivedTCPPacket+0x47e>
					pucPtr += 2;
 8006e88:	9b03      	ldr	r3, [sp, #12]
 8006e8a:	e7dc      	b.n	8006e46 <xProcessReceivedTCPPacket+0x502>
 8006e8c:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8006e90:	e5de      	b.n	8006a50 <xProcessReceivedTCPPacket+0x10c>
 8006e92:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8006e96:	e5db      	b.n	8006a50 <xProcessReceivedTCPPacket+0x10c>
 8006e98:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8006e9c:	e5d8      	b.n	8006a50 <xProcessReceivedTCPPacket+0x10c>
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8006e9e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006ea2:	f043 0301 	orr.w	r3, r3, #1
 8006ea6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8006eaa:	e622      	b.n	8006af2 <xProcessReceivedTCPPacket+0x1ae>
			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
 8006eac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006eae:	e642      	b.n	8006b36 <xProcessReceivedTCPPacket+0x1f2>
				lTCPAddRxdata( pxSocket, 0ul, NULL, pxTCPWindow->ulUserDataLength );
 8006eb0:	2200      	movs	r2, #0
 8006eb2:	4611      	mov	r1, r2
 8006eb4:	4620      	mov	r0, r4
 8006eb6:	f7fe fa87 	bl	80053c8 <lTCPAddRxdata>
				pxTCPWindow->ulUserDataLength = 0;
 8006eba:	2300      	movs	r3, #0
 8006ebc:	f8c4 310c 	str.w	r3, [r4, #268]	; 0x10c
 8006ec0:	e24d      	b.n	800735e <xProcessReceivedTCPPacket+0xa1a>
 8006ec2:	bf00      	nop
 8006ec4:	2000053c 	.word	0x2000053c
 8006ec8:	20000010 	.word	0x20000010
 8006ecc:	0800c6d0 	.word	0x0800c6d0
 8006ed0:	0800ce78 	.word	0x0800ce78
 8006ed4:	0800c6d4 	.word	0x0800c6d4
		pxTCPWindow->ucOptionLength = 0u;
 8006ed8:	2300      	movs	r3, #0
 8006eda:	f884 3118 	strb.w	r3, [r4, #280]	; 0x118
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006ede:	9b05      	ldr	r3, [sp, #20]
 8006ee0:	699d      	ldr	r5, [r3, #24]
	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMssChange != pdFALSE_UNSIGNED ) )
 8006ee2:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006ee6:	2b04      	cmp	r3, #4
 8006ee8:	d94b      	bls.n	8006f82 <xProcessReceivedTCPPacket+0x63e>
 8006eea:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006eee:	f013 0f01 	tst.w	r3, #1
 8006ef2:	f000 8087 	beq.w	8007004 <xProcessReceivedTCPPacket+0x6c0>
		pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
 8006ef6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006efa:	f36f 0300 	bfc	r3, #0, #1
 8006efe:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		pxTCPHeader->ucOptdata[ 0 ] = TCP_OPT_MSS;
 8006f02:	2302      	movs	r3, #2
 8006f04:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
		pxTCPHeader->ucOptdata[ 1 ] = TCP_OPT_MSS_LEN;
 8006f08:	f04f 0904 	mov.w	r9, #4
 8006f0c:	f885 9037 	strb.w	r9, [r5, #55]	; 0x37
		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
 8006f10:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8006f14:	0a1b      	lsrs	r3, r3, #8
 8006f16:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffu );
 8006f1a:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8006f1e:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8006f22:	2360      	movs	r3, #96	; 0x60
 8006f24:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
		if( ( pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) )
 8006f28:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006f2c:	2b04      	cmp	r3, #4
 8006f2e:	d02b      	beq.n	8006f88 <xProcessReceivedTCPPacket+0x644>
		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 8006f30:	f01b 0f01 	tst.w	fp, #1
 8006f34:	d014      	beq.n	8006f60 <xProcessReceivedTCPPacket+0x61c>
 8006f36:	f994 3041 	ldrsb.w	r3, [r4, #65]	; 0x41
 8006f3a:	2b00      	cmp	r3, #0
 8006f3c:	db10      	blt.n	8006f60 <xProcessReceivedTCPPacket+0x61c>
			pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
 8006f3e:	f8c4 a0f0 	str.w	sl, [r4, #240]	; 0xf0
			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
 8006f42:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006f46:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006f4a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 8006f4e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8006f52:	d105      	bne.n	8006f60 <xProcessReceivedTCPPacket+0x61c>
				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
 8006f54:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8006f58:	f043 0302 	orr.w	r3, r3, #2
 8006f5c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		switch (pxSocket->u.xTCP.ucTCPState)
 8006f60:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006f64:	1e9a      	subs	r2, r3, #2
 8006f66:	2a08      	cmp	r2, #8
 8006f68:	f200 817f 	bhi.w	800726a <xProcessReceivedTCPPacket+0x926>
 8006f6c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8006f70:	004d0230 	.word	0x004d0230
 8006f74:	00d80230 	.word	0x00d80230
 8006f78:	01770177 	.word	0x01770177
 8006f7c:	017d017d 	.word	0x017d017d
 8006f80:	0177      	.short	0x0177
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 8006f82:	f04f 0900 	mov.w	r9, #0
 8006f86:	e7cf      	b.n	8006f28 <xProcessReceivedTCPPacket+0x5e4>
		if( ( pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) )
 8006f88:	f00b 021f 	and.w	r2, fp, #31
 8006f8c:	2a02      	cmp	r2, #2
 8006f8e:	d034      	beq.n	8006ffa <xProcessReceivedTCPPacket+0x6b6>
		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 8006f90:	f01b 0f01 	tst.w	fp, #1
 8006f94:	f040 8215 	bne.w	80073c2 <xProcessReceivedTCPPacket+0xa7e>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 8006f98:	9a05      	ldr	r2, [sp, #20]
 8006f9a:	6996      	ldr	r6, [r2, #24]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8006f9c:	f896 202f 	ldrb.w	r2, [r6, #47]	; 0x2f
	uint16_t usExpect = ( uint16_t ) ipTCP_FLAG_ACK;
 8006fa0:	2110      	movs	r1, #16
	if( ( ucTCPFlags & 0x17u ) != usExpect )
 8006fa2:	f002 0217 	and.w	r2, r2, #23
 8006fa6:	428a      	cmp	r2, r1
 8006fa8:	d17e      	bne.n	80070a8 <xProcessReceivedTCPPacket+0x764>
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 8006faa:	f8d6 2026 	ldr.w	r2, [r6, #38]	; 0x26
 8006fae:	0e11      	lsrs	r1, r2, #24
 8006fb0:	ea41 6102 	orr.w	r1, r1, r2, lsl #24
 8006fb4:	0210      	lsls	r0, r2, #8
 8006fb6:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 8006fba:	4301      	orrs	r1, r0
 8006fbc:	0a12      	lsrs	r2, r2, #8
 8006fbe:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8006fc2:	ea41 0502 	orr.w	r5, r1, r2
		pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
 8006fc6:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8006fc8:	f8a4 2196 	strh.w	r2, [r4, #406]	; 0x196
		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
 8006fcc:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 8006fce:	f8a4 2194 	strh.w	r2, [r4, #404]	; 0x194
		if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 8006fd2:	2b02      	cmp	r3, #2
 8006fd4:	d07a      	beq.n	80070cc <xProcessReceivedTCPPacket+0x788>
		else if( ulReceiveLength == 0u )
 8006fd6:	9b02      	ldr	r3, [sp, #8]
 8006fd8:	2b00      	cmp	r3, #0
 8006fda:	f040 81d4 	bne.w	8007386 <xProcessReceivedTCPPacket+0xa42>
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 8006fde:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 8006fe2:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8006fe6:	3301      	adds	r3, #1
 8006fe8:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		if( ( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0u ) )
 8006fec:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006ff0:	2b02      	cmp	r3, #2
 8006ff2:	f000 81cd 	beq.w	8007390 <xProcessReceivedTCPPacket+0xa4c>
BaseType_t xSendLength = 0;
 8006ff6:	2500      	movs	r5, #0
 8006ff8:	e1d4      	b.n	80073a4 <xProcessReceivedTCPPacket+0xa60>
			vTCPStateChange( pxSocket, eSYN_FIRST );
 8006ffa:	2103      	movs	r1, #3
 8006ffc:	4620      	mov	r0, r4
 8006ffe:	f7ff f851 	bl	80060a4 <vTCPStateChange>
 8007002:	e795      	b.n	8006f30 <xProcessReceivedTCPPacket+0x5ec>
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 8007004:	f04f 0900 	mov.w	r9, #0
 8007008:	e792      	b.n	8006f30 <xProcessReceivedTCPPacket+0x5ec>
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 800700a:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) TCP_OPT_MSS;
 800700e:	2202      	movs	r2, #2
 8007010:	f886 2036 	strb.w	r2, [r6, #54]	; 0x36
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) TCP_OPT_MSS_LEN;
 8007014:	2204      	movs	r2, #4
 8007016:	f886 2037 	strb.w	r2, [r6, #55]	; 0x37
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 800701a:	0a1a      	lsrs	r2, r3, #8
 800701c:	f886 2038 	strb.w	r2, [r6, #56]	; 0x38
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffu );
 8007020:	f886 3039 	strb.w	r3, [r6, #57]	; 0x39
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 8007024:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8007028:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 800702c:	fb02 f203 	mul.w	r2, r2, r3
		while( uxWinSize > 0xfffful )
 8007030:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007034:	d336      	bcc.n	80070a4 <xProcessReceivedTCPPacket+0x760>
 8007036:	2300      	movs	r3, #0
			uxWinSize >>= 1;
 8007038:	0852      	lsrs	r2, r2, #1
			ucFactor++;
 800703a:	3301      	adds	r3, #1
 800703c:	b2db      	uxtb	r3, r3
		while( uxWinSize > 0xfffful )
 800703e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007042:	d2f9      	bcs.n	8007038 <xProcessReceivedTCPPacket+0x6f4>
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 8007044:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
		pxTCPHeader->ucOptdata[ 4 ] = TCP_OPT_NOOP;
 8007048:	2301      	movs	r3, #1
 800704a:	f886 303a 	strb.w	r3, [r6, #58]	; 0x3a
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( TCP_OPT_WSOPT );
 800704e:	2203      	movs	r2, #3
 8007050:	f886 203b 	strb.w	r2, [r6, #59]	; 0x3b
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( TCP_OPT_WSOPT_LEN );
 8007054:	f886 203c 	strb.w	r2, [r6, #60]	; 0x3c
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 8007058:	f894 20c9 	ldrb.w	r2, [r4, #201]	; 0xc9
 800705c:	f886 203d 	strb.w	r2, [r6, #61]	; 0x3d
			pxTCPHeader->ucOptdata[ uxOptionsLength + 0 ] = TCP_OPT_NOOP;
 8007060:	f886 303e 	strb.w	r3, [r6, #62]	; 0x3e
			pxTCPHeader->ucOptdata[ uxOptionsLength + 1 ] = TCP_OPT_NOOP;
 8007064:	f886 303f 	strb.w	r3, [r6, #63]	; 0x3f
			pxTCPHeader->ucOptdata[ uxOptionsLength + 2 ] = TCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 8007068:	2104      	movs	r1, #4
 800706a:	f886 1040 	strb.w	r1, [r6, #64]	; 0x40
			pxTCPHeader->ucOptdata[ uxOptionsLength + 3 ] = 2;	/* 2: length of this option. */
 800706e:	2302      	movs	r3, #2
 8007070:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_SYN | ipTCP_FLAG_ACK;
 8007074:	2312      	movs	r3, #18
 8007076:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
				pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800707a:	2380      	movs	r3, #128	; 0x80
 800707c:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
				vTCPStateChange( pxSocket, eSYN_RECEIVED );
 8007080:	4620      	mov	r0, r4
 8007082:	f7ff f80f 	bl	80060a4 <vTCPStateChange>
				pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
 8007086:	f108 0301 	add.w	r3, r8, #1
 800708a:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
 800708e:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u; /* because we send a TCP_SYN. */
 8007092:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007096:	3301      	adds	r3, #1
 8007098:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
 800709c:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
				xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 80070a0:	2534      	movs	r5, #52	; 0x34
 80070a2:	e0e5      	b.n	8007270 <xProcessReceivedTCPPacket+0x92c>
		ucFactor = 0u;
 80070a4:	2300      	movs	r3, #0
 80070a6:	e7cd      	b.n	8007044 <xProcessReceivedTCPPacket+0x700>
		vTCPStateChange( pxSocket, eCLOSE_WAIT );
 80070a8:	2108      	movs	r1, #8
 80070aa:	4620      	mov	r0, r4
 80070ac:	f7fe fffa 	bl	80060a4 <vTCPStateChange>
		pxTCPHeader->ucTCPFlags |= ipTCP_FLAG_RST;
 80070b0:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
 80070b4:	f043 0304 	orr.w	r3, r3, #4
 80070b8:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 80070bc:	f109 0528 	add.w	r5, r9, #40	; 0x28
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80070c0:	f109 0314 	add.w	r3, r9, #20
 80070c4:	009b      	lsls	r3, r3, #2
 80070c6:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
 80070ca:	e0cf      	b.n	800726c <xProcessReceivedTCPPacket+0x928>
			pxLastTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK;
 80070cc:	2310      	movs	r3, #16
 80070ce:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
 80070d2:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80070d6:	f8d4 2108 	ldr.w	r2, [r4, #264]	; 0x108
 80070da:	4629      	mov	r1, r5
 80070dc:	9803      	ldr	r0, [sp, #12]
 80070de:	f000 fb26 	bl	800772e <vTCPWindowInit>
			pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
 80070e2:	3501      	adds	r5, #1
 80070e4:	f8c4 50f4 	str.w	r5, [r4, #244]	; 0xf4
 80070e8:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
 80070ec:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 80070f0:	3301      	adds	r3, #1
 80070f2:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
			pxTCPWindow->ulNextTxSequenceNumber++;
 80070f6:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 80070fa:	3301      	adds	r3, #1
 80070fc:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 8007100:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007104:	3301      	adds	r3, #1
 8007106:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		if( ( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0u ) )
 800710a:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 800710e:	2b02      	cmp	r3, #2
 8007110:	f000 813e 	beq.w	8007390 <xProcessReceivedTCPPacket+0xa4c>
 8007114:	9b02      	ldr	r3, [sp, #8]
 8007116:	2b00      	cmp	r3, #0
 8007118:	f040 813a 	bne.w	8007390 <xProcessReceivedTCPPacket+0xa4c>
BaseType_t xSendLength = 0;
 800711c:	2500      	movs	r5, #0
 800711e:	e141      	b.n	80073a4 <xProcessReceivedTCPPacket+0xa60>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 8007120:	9b05      	ldr	r3, [sp, #20]
 8007122:	699e      	ldr	r6, [r3, #24]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8007124:	f896 502f 	ldrb.w	r5, [r6, #47]	; 0x2f
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount;
 8007128:	f8d6 7026 	ldr.w	r7, [r6, #38]	; 0x26
	pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPHeader->usWindow );
 800712c:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 800712e:	0a13      	lsrs	r3, r2, #8
 8007130:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007134:	b29b      	uxth	r3, r3
		( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 8007136:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
 800713a:	4093      	lsls	r3, r2
	pxSocket->u.xTCP.ulWindowSize =
 800713c:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
	if( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_ACK ) != 0u )
 8007140:	f015 0f10 	tst.w	r5, #16
 8007144:	d11f      	bne.n	8007186 <xProcessReceivedTCPPacket+0x842>
	if( pxSocket->u.xTCP.txStream != NULL )
 8007146:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8007148:	b113      	cbz	r3, 8007150 <xProcessReceivedTCPPacket+0x80c>
		prvTCPAddTxData( pxSocket );
 800714a:	4620      	mov	r0, r4
 800714c:	f7fe fdfc 	bl	8005d48 <prvTCPAddTxData>
	pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 8007150:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8007154:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
	if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u ) )
 8007158:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800715c:	f013 0f20 	tst.w	r3, #32
 8007160:	d102      	bne.n	8007168 <xProcessReceivedTCPPacket+0x824>
 8007162:	f015 0f01 	tst.w	r5, #1
 8007166:	d056      	beq.n	8007216 <xProcessReceivedTCPPacket+0x8d2>
		if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 8007168:	f013 0f40 	tst.w	r3, #64	; 0x40
 800716c:	d036      	beq.n	80071dc <xProcessReceivedTCPPacket+0x898>
			pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
 800716e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007172:	f043 0320 	orr.w	r3, r3, #32
 8007176:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 800717a:	9905      	ldr	r1, [sp, #20]
 800717c:	4620      	mov	r0, r4
 800717e:	f7ff fb71 	bl	8006864 <prvTCPHandleFin>
 8007182:	4605      	mov	r5, r0
 8007184:	e072      	b.n	800726c <xProcessReceivedTCPPacket+0x928>
		ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulAckNr ) );
 8007186:	f8d6 302a 	ldr.w	r3, [r6, #42]	; 0x2a
 800718a:	0e19      	lsrs	r1, r3, #24
 800718c:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 8007190:	021a      	lsls	r2, r3, #8
 8007192:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8007196:	4311      	orrs	r1, r2
 8007198:	0a1b      	lsrs	r3, r3, #8
 800719a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800719e:	4319      	orrs	r1, r3
 80071a0:	9803      	ldr	r0, [sp, #12]
 80071a2:	f000 fd1b 	bl	8007bdc <ulTCPWindowTxAck>
 80071a6:	4603      	mov	r3, r0
		if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0u ) )
 80071a8:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 80071aa:	2800      	cmp	r0, #0
 80071ac:	d0d0      	beq.n	8007150 <xProcessReceivedTCPPacket+0x80c>
 80071ae:	2b00      	cmp	r3, #0
 80071b0:	d0cb      	beq.n	800714a <xProcessReceivedTCPPacket+0x806>
			if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0u, NULL, ( size_t ) ulCount, pdFALSE ) != 0u )
 80071b2:	2100      	movs	r1, #0
 80071b4:	9100      	str	r1, [sp, #0]
 80071b6:	460a      	mov	r2, r1
 80071b8:	f7fe fd63 	bl	8005c82 <uxStreamBufferGet>
 80071bc:	2800      	cmp	r0, #0
 80071be:	d0c2      	beq.n	8007146 <xProcessReceivedTCPPacket+0x802>
				pxSocket->xEventBits |= eSOCKET_SEND;
 80071c0:	6823      	ldr	r3, [r4, #0]
 80071c2:	f043 0202 	orr.w	r2, r3, #2
 80071c6:	6022      	str	r2, [r4, #0]
					if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
 80071c8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80071ca:	f012 0f02 	tst.w	r2, #2
 80071ce:	d0ba      	beq.n	8007146 <xProcessReceivedTCPPacket+0x802>
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 80071d0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80071d4:	f043 0302 	orr.w	r3, r3, #2
 80071d8:	6023      	str	r3, [r4, #0]
 80071da:	e7b4      	b.n	8007146 <xProcessReceivedTCPPacket+0x802>
			bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
 80071dc:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80071e0:	4640      	mov	r0, r8
 80071e2:	f000 fa71 	bl	80076c8 <xTCPWindowRxEmpty>
 80071e6:	4605      	mov	r5, r0
			bTxDone     = xTCPWindowTxDone( pxTCPWindow );
 80071e8:	4640      	mov	r0, r8
 80071ea:	f000 fc39 	bl	8007a60 <xTCPWindowTxDone>
			if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
 80071ee:	b195      	cbz	r5, 8007216 <xProcessReceivedTCPPacket+0x8d2>
 80071f0:	b188      	cbz	r0, 8007216 <xProcessReceivedTCPPacket+0x8d2>
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount;
 80071f2:	0e3b      	lsrs	r3, r7, #24
 80071f4:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 80071f8:	023a      	lsls	r2, r7, #8
 80071fa:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 80071fe:	431a      	orrs	r2, r3
 8007200:	0a3b      	lsrs	r3, r7, #8
 8007202:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8007206:	4313      	orrs	r3, r2
				lDistance = ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNumber );
 8007208:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 800720c:	1a9b      	subs	r3, r3, r2
 800720e:	9a02      	ldr	r2, [sp, #8]
 8007210:	4413      	add	r3, r2
		if( xMayClose != pdFALSE )
 8007212:	2b01      	cmp	r3, #1
 8007214:	ddab      	ble.n	800716e <xProcessReceivedTCPPacket+0x82a>
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 8007216:	2310      	movs	r3, #16
 8007218:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
		if( ulReceiveLength != 0u )
 800721c:	9b02      	ldr	r3, [sp, #8]
 800721e:	2b00      	cmp	r3, #0
 8007220:	f000 80df 	beq.w	80073e2 <xProcessReceivedTCPPacket+0xa9e>
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 8007224:	f109 0528 	add.w	r5, r9, #40	; 0x28
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8007228:	f109 0314 	add.w	r3, r9, #20
 800722c:	009b      	lsls	r3, r3, #2
 800722e:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
			if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 8007232:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007236:	f013 0f40 	tst.w	r3, #64	; 0x40
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800723a:	bf1c      	itt	ne
 800723c:	f8d4 3100 	ldrne.w	r3, [r4, #256]	; 0x100
 8007240:	f8c4 30fc 	strne.w	r3, [r4, #252]	; 0xfc
		if( uxOptionsLength == 0u )
 8007244:	f1b9 0f00 	cmp.w	r9, #0
 8007248:	d110      	bne.n	800726c <xProcessReceivedTCPPacket+0x928>
 800724a:	462e      	mov	r6, r5
			lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 800724c:	2200      	movs	r2, #0
 800724e:	a905      	add	r1, sp, #20
 8007250:	4620      	mov	r0, r4
 8007252:	f7ff f807 	bl	8006264 <prvTCPPrepareSend>
			if( lSendResult > 0 )
 8007256:	1e05      	subs	r5, r0, #0
 8007258:	dc0a      	bgt.n	8007270 <xProcessReceivedTCPPacket+0x92c>
 800725a:	4635      	mov	r5, r6
 800725c:	e006      	b.n	800726c <xProcessReceivedTCPPacket+0x928>
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 800725e:	9905      	ldr	r1, [sp, #20]
 8007260:	4620      	mov	r0, r4
 8007262:	f7ff faff 	bl	8006864 <prvTCPHandleFin>
 8007266:	4605      	mov	r5, r0
 8007268:	e000      	b.n	800726c <xProcessReceivedTCPPacket+0x928>
BaseType_t xSendLength = 0;
 800726a:	2500      	movs	r5, #0
	if( xSendLength > 0 )
 800726c:	2d00      	cmp	r5, #0
 800726e:	dd41      	ble.n	80072f4 <xProcessReceivedTCPPacket+0x9b0>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 8007270:	9e05      	ldr	r6, [sp, #20]
 8007272:	f8d6 e018 	ldr.w	lr, [r6, #24]
									 ( pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulCurrentSequenceNumber );
 8007276:	f8d4 70ec 	ldr.w	r7, [r4, #236]	; 0xec
	pxSocket->u.xTCP.ulRxCurWinSize = pxTCPWindow->xSize.ulRxWindowLength -
 800727a:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
 800727e:	4439      	add	r1, r7
 8007280:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8007284:	1ac9      	subs	r1, r1, r3
 8007286:	f8c4 10d0 	str.w	r1, [r4, #208]	; 0xd0
	if( pxSocket->u.xTCP.rxStream != NULL )
 800728a:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800728c:	2800      	cmp	r0, #0
 800728e:	d03d      	beq.n	800730c <xProcessReceivedTCPPacket+0x9c8>
size_t uxFront = pxBuffer->uxFront;
 8007290:	68c3      	ldr	r3, [r0, #12]
size_t uxTail = pxBuffer->uxTail;
 8007292:	6802      	ldr	r2, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8007294:	6900      	ldr	r0, [r0, #16]
 8007296:	4402      	add	r2, r0
 8007298:	3a01      	subs	r2, #1
 800729a:	1ad3      	subs	r3, r2, r3
	if( uxCount >= pxBuffer->LENGTH )
 800729c:	4298      	cmp	r0, r3
 800729e:	d800      	bhi.n	80072a2 <xProcessReceivedTCPPacket+0x95e>
		uxCount -= pxBuffer->LENGTH;
 80072a0:	1a1b      	subs	r3, r3, r0
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 80072a2:	428b      	cmp	r3, r1
 80072a4:	bf28      	it	cs
 80072a6:	460b      	movcs	r3, r1
	pxSocket->u.xTCP.ulRxCurWinSize = FreeRTOS_min_uint32( ulFrontSpace, pxSocket->u.xTCP.ulRxCurWinSize );
 80072a8:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
 80072ac:	9b02      	ldr	r3, [sp, #8]
 80072ae:	b16b      	cbz	r3, 80072cc <xProcessReceivedTCPPacket+0x988>
	lRxSpace = (int32_t)( pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber );
 80072b0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80072b2:	1bdf      	subs	r7, r3, r7
			lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usCurMSS );
 80072b4:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
 80072b8:	ebb7 0f43 	cmp.w	r7, r3, lsl #1
 80072bc:	db06      	blt.n	80072cc <xProcessReceivedTCPPacket+0x988>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 80072be:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
 80072c2:	f013 0f40 	tst.w	r3, #64	; 0x40
 80072c6:	d101      	bne.n	80072cc <xProcessReceivedTCPPacket+0x988>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 80072c8:	2d28      	cmp	r5, #40	; 0x28
 80072ca:	d021      	beq.n	8007310 <xProcessReceivedTCPPacket+0x9cc>
		else if( pxSocket->u.xTCP.pxAckMessage != NULL )
 80072cc:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80072ce:	b128      	cbz	r0, 80072dc <xProcessReceivedTCPPacket+0x998>
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 80072d0:	4286      	cmp	r6, r0
 80072d2:	d001      	beq.n	80072d8 <xProcessReceivedTCPPacket+0x994>
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 80072d4:	f000 fdc8 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
			pxSocket->u.xTCP.pxAckMessage = NULL;
 80072d8:	2300      	movs	r3, #0
 80072da:	67e3      	str	r3, [r4, #124]	; 0x7c
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 80072dc:	2300      	movs	r3, #0
 80072de:	462a      	mov	r2, r5
 80072e0:	9905      	ldr	r1, [sp, #20]
 80072e2:	4620      	mov	r0, r4
 80072e4:	f7fe fd5a 	bl	8005d9c <prvTCPReturnPacket>
		if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
 80072e8:	2d00      	cmp	r5, #0
 80072ea:	dd03      	ble.n	80072f4 <xProcessReceivedTCPPacket+0x9b0>
				prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 80072ec:	a905      	add	r1, sp, #20
 80072ee:	4620      	mov	r0, r4
 80072f0:	f7ff f930 	bl	8006554 <prvTCPSendRepeated>
		if( pxNetworkBuffer != NULL )
 80072f4:	9805      	ldr	r0, [sp, #20]
 80072f6:	b118      	cbz	r0, 8007300 <xProcessReceivedTCPPacket+0x9bc>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80072f8:	f000 fdb6 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
			pxNetworkBuffer = NULL;
 80072fc:	2300      	movs	r3, #0
 80072fe:	9305      	str	r3, [sp, #20]
		prvTCPNextTimeout ( pxSocket );
 8007300:	4620      	mov	r0, r4
 8007302:	f7fe fe75 	bl	8005ff0 <prvTCPNextTimeout>
		xResult = pdPASS;
 8007306:	2001      	movs	r0, #1
	return xResult;
 8007308:	f7ff bb62 	b.w	80069d0 <xProcessReceivedTCPPacket+0x8c>
		ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 800730c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800730e:	e7c8      	b.n	80072a2 <xProcessReceivedTCPPacket+0x95e>
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
 8007310:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007314:	2b05      	cmp	r3, #5
 8007316:	d1d9      	bne.n	80072cc <xProcessReceivedTCPPacket+0x988>
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
 8007318:	f89e 302f 	ldrb.w	r3, [lr, #47]	; 0x2f
 800731c:	2b10      	cmp	r3, #16
 800731e:	d1d5      	bne.n	80072cc <xProcessReceivedTCPPacket+0x988>
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 8007320:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8007322:	4286      	cmp	r6, r0
 8007324:	d004      	beq.n	8007330 <xProcessReceivedTCPPacket+0x9ec>
				if( pxSocket->u.xTCP.pxAckMessage != 0 )
 8007326:	b108      	cbz	r0, 800732c <xProcessReceivedTCPPacket+0x9e8>
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8007328:	f000 fd9e 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
 800732c:	9b05      	ldr	r3, [sp, #20]
 800732e:	67e3      	str	r3, [r4, #124]	; 0x7c
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
 8007330:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8007334:	9a02      	ldr	r2, [sp, #8]
 8007336:	429a      	cmp	r2, r3
 8007338:	d302      	bcc.n	8007340 <xProcessReceivedTCPPacket+0x9fc>
 800733a:	ebb7 0f43 	cmp.w	r7, r3, lsl #1
 800733e:	da05      	bge.n	800734c <xProcessReceivedTCPPacket+0xa08>
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_SHORT_DELAY_MS );
 8007340:	2302      	movs	r3, #2
 8007342:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
			*ppxNetworkBuffer = NULL;
 8007346:	2300      	movs	r3, #0
 8007348:	9305      	str	r3, [sp, #20]
 800734a:	e7d3      	b.n	80072f4 <xProcessReceivedTCPPacket+0x9b0>
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_LONGER_DELAY_MS );
 800734c:	2314      	movs	r3, #20
 800734e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 8007352:	e7f8      	b.n	8007346 <xProcessReceivedTCPPacket+0xa02>
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
 8007354:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 8007358:	2b00      	cmp	r3, #0
 800735a:	f47f ada9 	bne.w	8006eb0 <xProcessReceivedTCPPacket+0x56c>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800735e:	9b05      	ldr	r3, [sp, #20]
 8007360:	699d      	ldr	r5, [r3, #24]
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 8007362:	f894 7118 	ldrb.w	r7, [r4, #280]	; 0x118
 8007366:	46b9      	mov	r9, r7
		if( uxOptionsLength != 0u )
 8007368:	2f00      	cmp	r7, #0
 800736a:	f43f adba 	beq.w	8006ee2 <xProcessReceivedTCPPacket+0x59e>
			memcpy( pxTCPHeader->ucOptdata, pxTCPWindow->ulOptionsData, ( size_t ) uxOptionsLength );
 800736e:	463a      	mov	r2, r7
 8007370:	f504 71ae 	add.w	r1, r4, #348	; 0x15c
 8007374:	f105 0036 	add.w	r0, r5, #54	; 0x36
 8007378:	f004 fe6f 	bl	800c05a <memcpy>
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800737c:	3714      	adds	r7, #20
 800737e:	00bf      	lsls	r7, r7, #2
 8007380:	f885 702e 	strb.w	r7, [r5, #46]	; 0x2e
 8007384:	e5d0      	b.n	8006f28 <xProcessReceivedTCPPacket+0x5e4>
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 8007386:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 800738a:	3301      	adds	r3, #1
 800738c:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
			pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 8007390:	2310      	movs	r3, #16
 8007392:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 8007396:	f109 0528 	add.w	r5, r9, #40	; 0x28
			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800739a:	f109 0314 	add.w	r3, r9, #20
 800739e:	009b      	lsls	r3, r3, #2
 80073a0:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
		if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
 80073a4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80073a8:	f013 0f10 	tst.w	r3, #16
 80073ac:	d104      	bne.n	80073b8 <xProcessReceivedTCPPacket+0xa74>
			pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
 80073ae:	2300      	movs	r3, #0
 80073b0:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
			pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
 80073b4:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
		vTCPStateChange( pxSocket, eESTABLISHED );
 80073b8:	2105      	movs	r1, #5
 80073ba:	4620      	mov	r0, r4
 80073bc:	f7fe fe72 	bl	80060a4 <vTCPStateChange>
 80073c0:	e754      	b.n	800726c <xProcessReceivedTCPPacket+0x928>
		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 80073c2:	f994 3041 	ldrsb.w	r3, [r4, #65]	; 0x41
 80073c6:	2b00      	cmp	r3, #0
 80073c8:	f6bf adb9 	bge.w	8006f3e <xProcessReceivedTCPPacket+0x5fa>
		switch (pxSocket->u.xTCP.ucTCPState)
 80073cc:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 80073d0:	9a05      	ldr	r2, [sp, #20]
 80073d2:	6996      	ldr	r6, [r2, #24]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 80073d4:	f896 202f 	ldrb.w	r2, [r6, #47]	; 0x2f
		usExpect |= ( uint16_t ) ipTCP_FLAG_SYN;
 80073d8:	2b02      	cmp	r3, #2
 80073da:	bf14      	ite	ne
 80073dc:	2110      	movne	r1, #16
 80073de:	2112      	moveq	r1, #18
 80073e0:	e5df      	b.n	8006fa2 <xProcessReceivedTCPPacket+0x65e>
		if( uxOptionsLength == 0u )
 80073e2:	f1b9 0f00 	cmp.w	r9, #0
 80073e6:	d185      	bne.n	80072f4 <xProcessReceivedTCPPacket+0x9b0>
 80073e8:	2600      	movs	r6, #0
 80073ea:	e72f      	b.n	800724c <xProcessReceivedTCPPacket+0x908>

080073ec <FreeRTOS_GetTCPStateName>:
	{
		if( ulState >= ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) )
		{
			ulState = ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) - 1u;
		}
		return pcStateNames[ ulState ];
 80073ec:	280c      	cmp	r0, #12
 80073ee:	bf28      	it	cs
 80073f0:	200c      	movcs	r0, #12
	}
 80073f2:	4b02      	ldr	r3, [pc, #8]	; (80073fc <FreeRTOS_GetTCPStateName+0x10>)
 80073f4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80073f8:	4770      	bx	lr
 80073fa:	bf00      	nop
 80073fc:	0800c5c4 	.word	0x0800c5c4

08007400 <xTCPCheckNewClient>:
 * In the API accept(), the user asks is there is a new client?  As API's can
 * not walk through the xBoundTCPSocketsList the IP-task will do this.
 */
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
TickType_t xLocalPort = FreeRTOS_htons( pxSocket->usLocalPort );
 8007400:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 8007402:	0a19      	lsrs	r1, r3, #8
 8007404:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
FreeRTOS_Socket_t *pxFound;
BaseType_t xResult = pdFALSE;

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8007408:	4a10      	ldr	r2, [pc, #64]	; (800744c <xTCPCheckNewClient+0x4c>)
 800740a:	68d3      	ldr	r3, [r2, #12]
 800740c:	3208      	adds	r2, #8
 800740e:	4293      	cmp	r3, r2
 8007410:	d019      	beq.n	8007446 <xTCPCheckNewClient+0x46>
{
 8007412:	b430      	push	{r4, r5}
 8007414:	b289      	uxth	r1, r1
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8007416:	4614      	mov	r4, r2
 8007418:	e002      	b.n	8007420 <xTCPCheckNewClient+0x20>
		pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
		pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 800741a:	685b      	ldr	r3, [r3, #4]
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800741c:	42a3      	cmp	r3, r4
 800741e:	d00f      	beq.n	8007440 <xTCPCheckNewClient+0x40>
	{
		if( listGET_LIST_ITEM_VALUE( pxIterator ) == xLocalPort )
 8007420:	681a      	ldr	r2, [r3, #0]
 8007422:	4291      	cmp	r1, r2
 8007424:	d1f9      	bne.n	800741a <xTCPCheckNewClient+0x1a>
		{
			pxFound = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007426:	68da      	ldr	r2, [r3, #12]
			if( ( pxFound->ucProtocol == FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 8007428:	f892 5027 	ldrb.w	r5, [r2, #39]	; 0x27
 800742c:	2d06      	cmp	r5, #6
 800742e:	d1f4      	bne.n	800741a <xTCPCheckNewClient+0x1a>
 8007430:	f892 5040 	ldrb.w	r5, [r2, #64]	; 0x40
 8007434:	f015 0f02 	tst.w	r5, #2
 8007438:	d0ef      	beq.n	800741a <xTCPCheckNewClient+0x1a>
			{
				pxSocket->u.xTCP.pxPeerSocket = pxFound;
 800743a:	6542      	str	r2, [r0, #84]	; 0x54
				FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) );
				xResult = pdTRUE;
 800743c:	2001      	movs	r0, #1
				break;
 800743e:	e000      	b.n	8007442 <xTCPCheckNewClient+0x42>
BaseType_t xResult = pdFALSE;
 8007440:	2000      	movs	r0, #0
			}
		}
	}
	return xResult;
}
 8007442:	bc30      	pop	{r4, r5}
 8007444:	4770      	bx	lr
BaseType_t xResult = pdFALSE;
 8007446:	2000      	movs	r0, #0
	return xResult;
 8007448:	4770      	bx	lr
 800744a:	bf00      	nop
 800744c:	20002804 	.word	0x20002804

08007450 <xTCPWindowRxFind>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxFind( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 8007450:	b410      	push	{r4}
	TCPSegment_t *pxSegment, *pxReturn = NULL;

		/* Find a segment with a given sequence number in the list of received
		segments. */

		pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xRxSegments );
 8007452:	f100 04ac 	add.w	r4, r0, #172	; 0xac

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007456:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 800745a:	429c      	cmp	r4, r3
 800745c:	d00f      	beq.n	800747e <xTCPWindowRxFind+0x2e>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800745e:	68d8      	ldr	r0, [r3, #12]

			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 8007460:	6802      	ldr	r2, [r0, #0]
 8007462:	4291      	cmp	r1, r2
 8007464:	d008      	beq.n	8007478 <xTCPWindowRxFind+0x28>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8007466:	685b      	ldr	r3, [r3, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007468:	429c      	cmp	r4, r3
 800746a:	d004      	beq.n	8007476 <xTCPWindowRxFind+0x26>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800746c:	68d8      	ldr	r0, [r3, #12]
			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 800746e:	6802      	ldr	r2, [r0, #0]
 8007470:	428a      	cmp	r2, r1
 8007472:	d1f8      	bne.n	8007466 <xTCPWindowRxFind+0x16>
 8007474:	e000      	b.n	8007478 <xTCPWindowRxFind+0x28>
	TCPSegment_t *pxSegment, *pxReturn = NULL;
 8007476:	2000      	movs	r0, #0
				break;
			}
		}

		return pxReturn;
	}
 8007478:	f85d 4b04 	ldr.w	r4, [sp], #4
 800747c:	4770      	bx	lr
	TCPSegment_t *pxSegment, *pxReturn = NULL;
 800747e:	2000      	movs	r0, #0
		return pxReturn;
 8007480:	e7fa      	b.n	8007478 <xTCPWindowRxFind+0x28>

08007482 <xTCPWindowPeekHead>:
	{
	ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8007482:	6803      	ldr	r3, [r0, #0]
 8007484:	b113      	cbz	r3, 800748c <xTCPWindowPeekHead+0xa>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 8007486:	68c3      	ldr	r3, [r0, #12]
 8007488:	68d8      	ldr	r0, [r3, #12]
 800748a:	4770      	bx	lr
			pxReturn = NULL;
 800748c:	2000      	movs	r0, #0
		}

		return pxReturn;
	}
 800748e:	4770      	bx	lr

08007490 <prvTCPWindowTxHasSpace>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t *pxWindow, uint32_t ulWindowSize )
	{
 8007490:	b538      	push	{r3, r4, r5, lr}
 8007492:	4605      	mov	r5, r0
 8007494:	460c      	mov	r4, r1
	TCPSegment_t *pxSegment;

		/* This function will look if there is new transmission data.  It will
		return true if there is data to be sent. */

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 8007496:	3054      	adds	r0, #84	; 0x54
 8007498:	f7ff fff3 	bl	8007482 <xTCPWindowPeekHead>

		if( pxSegment == NULL )
 800749c:	b1a0      	cbz	r0, 80074c8 <prvTCPWindowTxHasSpace+0x38>
		}
		else
		{
			/* How much data is outstanding, i.e. how much data has been sent
			but not yet acknowledged ? */
			if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
 800749e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80074a0:	6a2a      	ldr	r2, [r5, #32]
 80074a2:	4293      	cmp	r3, r2
 80074a4:	d312      	bcc.n	80074cc <prvTCPWindowTxHasSpace+0x3c>
			{
				ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
 80074a6:	1a9b      	subs	r3, r3, r2

			/* Subtract this from the peer's space. */
			ulWindowSize -= FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );

			/* See if the next segment may be sent. */
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 80074a8:	6882      	ldr	r2, [r0, #8]
			ulWindowSize -= FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
 80074aa:	42a3      	cmp	r3, r4
 80074ac:	bf94      	ite	ls
 80074ae:	1ae0      	subls	r0, r4, r3
 80074b0:	1b20      	subhi	r0, r4, r4
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 80074b2:	4290      	cmp	r0, r2
 80074b4:	bf34      	ite	cc
 80074b6:	2000      	movcc	r0, #0
 80074b8:	2001      	movcs	r0, #1

			/* If 'xHasSpace', it looks like the peer has at least space for 1
			more new segment of size MSS.  xSize.ulTxWindowLength is the self-imposed
			limitation of the transmission window (in case of many resends it
			may be decreased). */
			if( ( ulTxOutstanding != 0UL ) && ( pxWindow->xSize.ulTxWindowLength < ulTxOutstanding + ( ( uint32_t ) pxSegment->lDataLength ) ) )
 80074ba:	b163      	cbz	r3, 80074d6 <prvTCPWindowTxHasSpace+0x46>
 80074bc:	4413      	add	r3, r2
 80074be:	68aa      	ldr	r2, [r5, #8]
			{
				xHasSpace = pdFALSE;
 80074c0:	429a      	cmp	r2, r3
 80074c2:	bf38      	it	cc
 80074c4:	2000      	movcc	r0, #0
 80074c6:	bd38      	pop	{r3, r4, r5, pc}
			xHasSpace = pdFALSE;
 80074c8:	2000      	movs	r0, #0
			}
		}

		return xHasSpace;
 80074ca:	bd38      	pop	{r3, r4, r5, pc}
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 80074cc:	6880      	ldr	r0, [r0, #8]
 80074ce:	4284      	cmp	r4, r0
 80074d0:	bf34      	ite	cc
 80074d2:	2000      	movcc	r0, #0
 80074d4:	2001      	movcs	r0, #1
	}
 80074d6:	bd38      	pop	{r3, r4, r5, pc}

080074d8 <xTCPWindowGetHead>:
	{
 80074d8:	b510      	push	{r4, lr}
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 80074da:	6803      	ldr	r3, [r0, #0]
 80074dc:	b12b      	cbz	r3, 80074ea <xTCPWindowGetHead+0x12>
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 80074de:	68c0      	ldr	r0, [r0, #12]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 80074e0:	68c4      	ldr	r4, [r0, #12]
			uxListRemove( pxItem );
 80074e2:	f001 f9b1 	bl	8008848 <uxListRemove>
	}
 80074e6:	4620      	mov	r0, r4
 80074e8:	bd10      	pop	{r4, pc}
			pxSegment = NULL;
 80074ea:	2400      	movs	r4, #0
		return pxSegment;
 80074ec:	e7fb      	b.n	80074e6 <xTCPWindowGetHead+0xe>

080074ee <vListInsertGeneric>:
	pxNewListItem->pxNext = (struct xLIST_ITEM * configLIST_VOLATILE)pxWhere;
 80074ee:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxWhere->pxPrevious;
 80074f0:	6893      	ldr	r3, [r2, #8]
 80074f2:	608b      	str	r3, [r1, #8]
	pxWhere->pxPrevious->pxNext = pxNewListItem;
 80074f4:	6893      	ldr	r3, [r2, #8]
 80074f6:	6059      	str	r1, [r3, #4]
	pxWhere->pxPrevious = pxNewListItem;
 80074f8:	6091      	str	r1, [r2, #8]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80074fa:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80074fc:	6803      	ldr	r3, [r0, #0]
 80074fe:	3301      	adds	r3, #1
 8007500:	6003      	str	r3, [r0, #0]
 8007502:	4770      	bx	lr

08007504 <vTCPWindowFree>:
	{
 8007504:	b510      	push	{r4, lr}
 8007506:	4604      	mov	r4, r0
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
 8007508:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800750a:	b113      	cbz	r3, 8007512 <vTCPWindowFree+0xe>
			uxListRemove( &( pxSegment->xQueueItem ) );
 800750c:	3018      	adds	r0, #24
 800750e:	f001 f99b 	bl	8008848 <uxListRemove>
		pxSegment->ulSequenceNumber = 0u;
 8007512:	2300      	movs	r3, #0
 8007514:	6023      	str	r3, [r4, #0]
		pxSegment->lDataLength = 0l;
 8007516:	60a3      	str	r3, [r4, #8]
		pxSegment->u.ulFlags = 0u;
 8007518:	6163      	str	r3, [r4, #20]
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xListItem ) ) != NULL )
 800751a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800751c:	b11b      	cbz	r3, 8007526 <vTCPWindowFree+0x22>
			uxListRemove( &( pxSegment->xListItem ) );
 800751e:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8007522:	f001 f991 	bl	8008848 <uxListRemove>
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007526:	4804      	ldr	r0, [pc, #16]	; (8007538 <vTCPWindowFree+0x34>)
 8007528:	f100 0208 	add.w	r2, r0, #8
 800752c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 8007530:	f7ff ffdd 	bl	80074ee <vListInsertGeneric>
 8007534:	bd10      	pop	{r4, pc}
 8007536:	bf00      	nop
 8007538:	20000540 	.word	0x20000540

0800753c <prvTCPWindowTxCheckAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 800753c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007540:	b083      	sub	sp, #12
 8007542:	9201      	str	r2, [sp, #4]
	uint32_t ulBytesConfirmed = 0u;
	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xTxSegments );
 8007544:	f100 0798 	add.w	r7, r0, #152	; 0x98

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		for(
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007548:	f8d0 409c 	ldr.w	r4, [r0, #156]	; 0x9c
		for(
 800754c:	42a7      	cmp	r7, r4
 800754e:	d03c      	beq.n	80075ca <prvTCPWindowTxCheckAck+0x8e>
 8007550:	4682      	mov	sl, r0
 8007552:	460d      	mov	r5, r1
 8007554:	f102 38ff 	add.w	r8, r2, #4294967295	; 0xffffffff
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007558:	eba8 0301 	sub.w	r3, r8, r1
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
 800755c:	2b00      	cmp	r3, #0
 800755e:	db3a      	blt.n	80075d6 <prvTCPWindowTxCheckAck+0x9a>
 8007560:	2300      	movs	r3, #0
 8007562:	9300      	str	r3, [sp, #0]
		return ( ( a - b - 1UL ) & 0x80000000UL ) == 0UL;
 8007564:	ea6f 0b02 	mvn.w	fp, r2
 8007568:	e043      	b.n	80075f2 <prvTCPWindowTxCheckAck+0xb6>
				/* This segment is fully ACK'd, set the flag. */
				pxSegment->u.bits.bAcked = pdTRUE_UNSIGNED;

				/* Calculate the RTT only if the segment was sent-out for the
				first time and if this is the last ACK'd segment in a range. */
				if( ( pxSegment->u.bits.ucTransmitCount == 1 ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
 800756a:	9b01      	ldr	r3, [sp, #4]
 800756c:	4293      	cmp	r3, r2
 800756e:	d159      	bne.n	8007624 <prvTCPWindowTxCheckAck+0xe8>
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 8007570:	f002 fa26 	bl	80099c0 <xTaskGetTickCount>
 8007574:	6933      	ldr	r3, [r6, #16]
 8007576:	1ac0      	subs	r0, r0, r3
				{
					int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );

					if( pxWindow->lSRTT >= mS )
 8007578:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 800757c:	4298      	cmp	r0, r3
 800757e:	dc0f      	bgt.n	80075a0 <prvTCPWindowTxCheckAck+0x64>
					{
						/* RTT becomes smaller: adapt slowly. */
						pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
 8007580:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8007584:	181b      	adds	r3, r3, r0
 8007586:	bf48      	it	mi
 8007588:	3307      	addmi	r3, #7
 800758a:	10db      	asrs	r3, r3, #3
 800758c:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
						/* RTT becomes larger: adapt quicker */
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
					}

					/* Cap to the minimum of 50ms. */
					if( pxWindow->lSRTT < winSRTT_CAP_mS )
 8007590:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8007594:	2b31      	cmp	r3, #49	; 0x31
 8007596:	dc45      	bgt.n	8007624 <prvTCPWindowTxCheckAck+0xe8>
					{
						pxWindow->lSRTT = winSRTT_CAP_mS;
 8007598:	2332      	movs	r3, #50	; 0x32
 800759a:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
 800759e:	e041      	b.n	8007624 <prvTCPWindowTxCheckAck+0xe8>
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
 80075a0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80075a4:	4403      	add	r3, r0
 80075a6:	005b      	lsls	r3, r3, #1
 80075a8:	bf48      	it	mi
 80075aa:	3307      	addmi	r3, #7
 80075ac:	10db      	asrs	r3, r3, #3
 80075ae:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
 80075b2:	e7ed      	b.n	8007590 <prvTCPWindowTxCheckAck+0x54>
						ulLast - pxWindow->tx.ulFirstSequenceNumber,
						pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
				}

				/* Increase the left-hand value of the transmission window. */
				pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
 80075b4:	eb09 0305 	add.w	r3, r9, r5
 80075b8:	f8ca 3020 	str.w	r3, [sl, #32]

				/* This function will return the number of bytes that the tail
				of txStream may be advanced. */
				ulBytesConfirmed += ulDataLength;
 80075bc:	9b00      	ldr	r3, [sp, #0]
 80075be:	444b      	add	r3, r9
 80075c0:	9300      	str	r3, [sp, #0]

				/* All segments below tx.ulCurrentSequenceNumber may be freed. */
				vTCPWindowFree( pxSegment );
 80075c2:	4630      	mov	r0, r6
 80075c4:	f7ff ff9e 	bl	8007504 <vTCPWindowFree>
 80075c8:	e00c      	b.n	80075e4 <prvTCPWindowTxCheckAck+0xa8>
	uint32_t ulBytesConfirmed = 0u;
 80075ca:	2300      	movs	r3, #0
 80075cc:	9300      	str	r3, [sp, #0]

			ulSequenceNumber += ulDataLength;
		}

		return ulBytesConfirmed;
	}
 80075ce:	9800      	ldr	r0, [sp, #0]
 80075d0:	b003      	add	sp, #12
 80075d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t ulBytesConfirmed = 0u;
 80075d6:	2300      	movs	r3, #0
 80075d8:	9300      	str	r3, [sp, #0]
		return ulBytesConfirmed;
 80075da:	e7f8      	b.n	80075ce <prvTCPWindowTxCheckAck+0x92>
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 80075dc:	f8da 3020 	ldr.w	r3, [sl, #32]
 80075e0:	429d      	cmp	r5, r3
 80075e2:	d0e7      	beq.n	80075b4 <prvTCPWindowTxCheckAck+0x78>
			ulSequenceNumber += ulDataLength;
 80075e4:	444d      	add	r5, r9
		for(
 80075e6:	42a7      	cmp	r7, r4
 80075e8:	d0f1      	beq.n	80075ce <prvTCPWindowTxCheckAck+0x92>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 80075ea:	eba8 0305 	sub.w	r3, r8, r5
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
 80075ee:	2b00      	cmp	r3, #0
 80075f0:	dbed      	blt.n	80075ce <prvTCPWindowTxCheckAck+0x92>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 80075f2:	68e6      	ldr	r6, [r4, #12]
			pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 80075f4:	6864      	ldr	r4, [r4, #4]
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 80075f6:	6833      	ldr	r3, [r6, #0]
		return ( ( a - b - 1UL ) & 0x80000000UL ) == 0UL;
 80075f8:	43da      	mvns	r2, r3
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 80075fa:	42ea      	cmn	r2, r5
 80075fc:	d5f3      	bpl.n	80075e6 <prvTCPWindowTxCheckAck+0xaa>
			if( ulSequenceNumber != pxSegment->ulSequenceNumber )
 80075fe:	42ab      	cmp	r3, r5
 8007600:	d1e5      	bne.n	80075ce <prvTCPWindowTxCheckAck+0x92>
			ulDataLength = ( uint32_t ) pxSegment->lDataLength;
 8007602:	f8d6 9008 	ldr.w	r9, [r6, #8]
			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 8007606:	7db3      	ldrb	r3, [r6, #22]
 8007608:	f013 0f02 	tst.w	r3, #2
 800760c:	d1e6      	bne.n	80075dc <prvTCPWindowTxCheckAck+0xa0>
				if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t )ulDataLength, ulLast ) != pdFALSE )
 800760e:	eb09 0205 	add.w	r2, r9, r5
 8007612:	eb1b 0f02 	cmn.w	fp, r2
 8007616:	d5da      	bpl.n	80075ce <prvTCPWindowTxCheckAck+0x92>
				pxSegment->u.bits.bAcked = pdTRUE_UNSIGNED;
 8007618:	f043 0302 	orr.w	r3, r3, #2
 800761c:	75b3      	strb	r3, [r6, #22]
				if( ( pxSegment->u.bits.ucTransmitCount == 1 ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
 800761e:	7d33      	ldrb	r3, [r6, #20]
 8007620:	2b01      	cmp	r3, #1
 8007622:	d0a2      	beq.n	800756a <prvTCPWindowTxCheckAck+0x2e>
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 8007624:	f8da 3020 	ldr.w	r3, [sl, #32]
 8007628:	429d      	cmp	r5, r3
 800762a:	d0c3      	beq.n	80075b4 <prvTCPWindowTxCheckAck+0x78>
			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
 800762c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800762e:	2b00      	cmp	r3, #0
 8007630:	d0d8      	beq.n	80075e4 <prvTCPWindowTxCheckAck+0xa8>
				uxListRemove( &pxSegment->xQueueItem );
 8007632:	f106 0018 	add.w	r0, r6, #24
 8007636:	f001 f907 	bl	8008848 <uxListRemove>
 800763a:	e7d3      	b.n	80075e4 <prvTCPWindowTxCheckAck+0xa8>

0800763c <xTCPWindowNew>:
	{
 800763c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
 8007640:	4c1f      	ldr	r4, [pc, #124]	; (80076c0 <xTCPWindowNew+0x84>)
 8007642:	6824      	ldr	r4, [r4, #0]
 8007644:	2c00      	cmp	r4, #0
 8007646:	d038      	beq.n	80076ba <xTCPWindowNew+0x7e>
 8007648:	461d      	mov	r5, r3
 800764a:	4617      	mov	r7, r2
 800764c:	4688      	mov	r8, r1
 800764e:	4606      	mov	r6, r0
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
 8007650:	4b1b      	ldr	r3, [pc, #108]	; (80076c0 <xTCPWindowNew+0x84>)
 8007652:	f8d3 900c 	ldr.w	r9, [r3, #12]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 8007656:	f8d9 400c 	ldr.w	r4, [r9, #12]
			configASSERT( pxItem != NULL );
 800765a:	f1b9 0f00 	cmp.w	r9, #0
 800765e:	d01d      	beq.n	800769c <xTCPWindowNew+0x60>
			configASSERT( pxSegment != NULL );
 8007660:	b314      	cbz	r4, 80076a8 <xTCPWindowNew+0x6c>
			uxListRemove( pxItem );
 8007662:	4648      	mov	r0, r9
 8007664:	f001 f8f0 	bl	8008848 <uxListRemove>
			vListInsertFifo( xIsForRx ? &pxWindow->xRxSegments : &pxWindow->xTxSegments, pxItem );
 8007668:	b325      	cbz	r5, 80076b4 <xTCPWindowNew+0x78>
 800766a:	f106 00a4 	add.w	r0, r6, #164	; 0xa4
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800766e:	f100 0208 	add.w	r2, r0, #8
 8007672:	4649      	mov	r1, r9
 8007674:	f7ff ff3b 	bl	80074ee <vListInsertGeneric>
	pxTimer->ulBorn = xTaskGetTickCount ( );
 8007678:	f002 f9a2 	bl	80099c0 <xTaskGetTickCount>
 800767c:	6120      	str	r0, [r4, #16]
			pxSegment->u.ulFlags = 0;
 800767e:	2300      	movs	r3, #0
 8007680:	6163      	str	r3, [r4, #20]
			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 );
 8007682:	1aed      	subs	r5, r5, r3
 8007684:	bf18      	it	ne
 8007686:	2501      	movne	r5, #1
 8007688:	f365 0382 	bfi	r3, r5, #2, #1
 800768c:	75a3      	strb	r3, [r4, #22]
			pxSegment->lMaxLength = lCount;
 800768e:	6067      	str	r7, [r4, #4]
			pxSegment->lDataLength = lCount;
 8007690:	60a7      	str	r7, [r4, #8]
			pxSegment->ulSequenceNumber = ulSequenceNumber;
 8007692:	f8c4 8000 	str.w	r8, [r4]
	}
 8007696:	4620      	mov	r0, r4
 8007698:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			configASSERT( pxItem != NULL );
 800769c:	f240 11af 	movw	r1, #431	; 0x1af
 80076a0:	4808      	ldr	r0, [pc, #32]	; (80076c4 <xTCPWindowNew+0x88>)
 80076a2:	f004 fb33 	bl	800bd0c <vAssertCalled>
 80076a6:	e7db      	b.n	8007660 <xTCPWindowNew+0x24>
			configASSERT( pxSegment != NULL );
 80076a8:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 80076ac:	4805      	ldr	r0, [pc, #20]	; (80076c4 <xTCPWindowNew+0x88>)
 80076ae:	f004 fb2d 	bl	800bd0c <vAssertCalled>
 80076b2:	e7d6      	b.n	8007662 <xTCPWindowNew+0x26>
			vListInsertFifo( xIsForRx ? &pxWindow->xRxSegments : &pxWindow->xTxSegments, pxItem );
 80076b4:	f106 0090 	add.w	r0, r6, #144	; 0x90
 80076b8:	e7d9      	b.n	800766e <xTCPWindowNew+0x32>
			pxSegment = NULL;
 80076ba:	2400      	movs	r4, #0
		return pxSegment;
 80076bc:	e7eb      	b.n	8007696 <xTCPWindowNew+0x5a>
 80076be:	bf00      	nop
 80076c0:	20000540 	.word	0x20000540
 80076c4:	0800c704 	.word	0x0800c704

080076c8 <xTCPWindowRxEmpty>:
		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
 80076c8:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 80076cc:	b92b      	cbnz	r3, 80076da <xTCPWindowRxEmpty+0x12>
	return ( ( a - b ) & 0x80000000UL ) == 0UL;
 80076ce:	6903      	ldr	r3, [r0, #16]
 80076d0:	6980      	ldr	r0, [r0, #24]
 80076d2:	1a18      	subs	r0, r3, r0
		else if( xSequenceGreaterThanOrEqual( pxWindow->rx.ulCurrentSequenceNumber, pxWindow->rx.ulHighestSequenceNumber ) != pdFALSE )
 80076d4:	43c0      	mvns	r0, r0
 80076d6:	0fc0      	lsrs	r0, r0, #31
 80076d8:	4770      	bx	lr
 80076da:	2000      	movs	r0, #0
	}
 80076dc:	4770      	bx	lr

080076de <vTCPWindowDestroy>:
	{
 80076de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80076e2:	4606      	mov	r6, r0
 80076e4:	2501      	movs	r5, #1
				pxSegments = &( pxWindow->xTxSegments );
 80076e6:	f100 0890 	add.w	r8, r0, #144	; 0x90
				pxSegments = &( pxWindow->xRxSegments );
 80076ea:	f100 07a4 	add.w	r7, r0, #164	; 0xa4
 80076ee:	e009      	b.n	8007704 <vTCPWindowDestroy+0x26>
			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
 80076f0:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 80076f4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80076f8:	d103      	bne.n	8007702 <vTCPWindowDestroy+0x24>
				pxSegments = &( pxWindow->xTxSegments );
 80076fa:	4644      	mov	r4, r8
 80076fc:	e00a      	b.n	8007714 <vTCPWindowDestroy+0x36>
		for( xRound = 0; xRound < 2; xRound++ )
 80076fe:	2d01      	cmp	r5, #1
 8007700:	dc13      	bgt.n	800772a <vTCPWindowDestroy+0x4c>
 8007702:	3501      	adds	r5, #1
			if( xRound != 0 )
 8007704:	2d01      	cmp	r5, #1
 8007706:	d0f3      	beq.n	80076f0 <vTCPWindowDestroy+0x12>
			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
 8007708:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 800770c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8007710:	d1f5      	bne.n	80076fe <vTCPWindowDestroy+0x20>
				pxSegments = &( pxWindow->xRxSegments );
 8007712:	463c      	mov	r4, r7
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 8007714:	6823      	ldr	r3, [r4, #0]
 8007716:	2b00      	cmp	r3, #0
 8007718:	d0f1      	beq.n	80076fe <vTCPWindowDestroy+0x20>
					pxSegment = ( TCPSegment_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxSegments );
 800771a:	68e3      	ldr	r3, [r4, #12]
					vTCPWindowFree( pxSegment );
 800771c:	68d8      	ldr	r0, [r3, #12]
 800771e:	f7ff fef1 	bl	8007504 <vTCPWindowFree>
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 8007722:	6823      	ldr	r3, [r4, #0]
 8007724:	2b00      	cmp	r3, #0
 8007726:	d1f8      	bne.n	800771a <vTCPWindowDestroy+0x3c>
 8007728:	e7e9      	b.n	80076fe <vTCPWindowDestroy+0x20>
	}
 800772a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800772e <vTCPWindowInit>:
{
 800772e:	b410      	push	{r4}
	pxWindow->u.ulFlags = 0ul;
 8007730:	2400      	movs	r4, #0
 8007732:	6004      	str	r4, [r0, #0]
	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 8007734:	2401      	movs	r4, #1
 8007736:	7004      	strb	r4, [r0, #0]
	if( ulMSS != 0ul )
 8007738:	b193      	cbz	r3, 8007760 <vTCPWindowInit+0x32>
 800773a:	461c      	mov	r4, r3
		if( pxWindow->usMSSInit != 0u )
 800773c:	f8b0 30be 	ldrh.w	r3, [r0, #190]	; 0xbe
 8007740:	b10b      	cbz	r3, 8007746 <vTCPWindowInit+0x18>
			pxWindow->usMSSInit = ( uint16_t ) ulMSS;
 8007742:	f8a0 40be 	strh.w	r4, [r0, #190]	; 0xbe
		if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0u ) )
 8007746:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	; 0xbc
 800774a:	429c      	cmp	r4, r3
 800774c:	d300      	bcc.n	8007750 <vTCPWindowInit+0x22>
 800774e:	b93b      	cbnz	r3, 8007760 <vTCPWindowInit+0x32>
			pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
 8007750:	6843      	ldr	r3, [r0, #4]
 8007752:	fbb3 f3f4 	udiv	r3, r3, r4
 8007756:	fb04 f303 	mul.w	r3, r4, r3
 800775a:	6043      	str	r3, [r0, #4]
			pxWindow->usMSS = ( uint16_t ) ulMSS;
 800775c:	f8a0 40bc 	strh.w	r4, [r0, #188]	; 0xbc
	pxWindow->lSRTT = l500ms;
 8007760:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8007764:	6383      	str	r3, [r0, #56]	; 0x38
	pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
 8007766:	60c1      	str	r1, [r0, #12]
	pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
 8007768:	6101      	str	r1, [r0, #16]
	pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
 800776a:	6181      	str	r1, [r0, #24]
	pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
 800776c:	61c2      	str	r2, [r0, #28]
	pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
 800776e:	6202      	str	r2, [r0, #32]
	pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
 8007770:	6342      	str	r2, [r0, #52]	; 0x34
	pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
 8007772:	6282      	str	r2, [r0, #40]	; 0x28
	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 8007774:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 8007776:	f85d 4b04 	ldr.w	r4, [sp], #4
 800777a:	4770      	bx	lr

0800777c <vTCPWindowCreate>:
{
 800777c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007780:	4605      	mov	r5, r0
 8007782:	468a      	mov	sl, r1
 8007784:	4691      	mov	r9, r2
 8007786:	4698      	mov	r8, r3
		if( xTCPSegments == NULL )
 8007788:	4b22      	ldr	r3, [pc, #136]	; (8007814 <vTCPWindowCreate+0x98>)
 800778a:	681b      	ldr	r3, [r3, #0]
 800778c:	b1fb      	cbz	r3, 80077ce <vTCPWindowCreate+0x52>
		vListInitialise( &pxWindow->xTxSegments );
 800778e:	f105 0090 	add.w	r0, r5, #144	; 0x90
 8007792:	f001 f825 	bl	80087e0 <vListInitialise>
		vListInitialise( &pxWindow->xRxSegments );
 8007796:	f105 00a4 	add.w	r0, r5, #164	; 0xa4
 800779a:	f001 f821 	bl	80087e0 <vListInitialise>
		vListInitialise( &pxWindow->xPriorityQueue );			/* Priority queue: segments which must be sent immediately */
 800779e:	f105 0040 	add.w	r0, r5, #64	; 0x40
 80077a2:	f001 f81d 	bl	80087e0 <vListInitialise>
		vListInitialise( &pxWindow->xTxQueue   );			/* Transmit queue: segments queued for transmission */
 80077a6:	f105 0054 	add.w	r0, r5, #84	; 0x54
 80077aa:	f001 f819 	bl	80087e0 <vListInitialise>
		vListInitialise( &pxWindow->xWaitQueue );			/* Waiting queue:  outstanding segments */
 80077ae:	f105 0068 	add.w	r0, r5, #104	; 0x68
 80077b2:	f001 f815 	bl	80087e0 <vListInitialise>
	pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
 80077b6:	f8c5 a004 	str.w	sl, [r5, #4]
	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 80077ba:	f8c5 9008 	str.w	r9, [r5, #8]
	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
 80077be:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80077c0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80077c2:	4641      	mov	r1, r8
 80077c4:	4628      	mov	r0, r5
 80077c6:	f7ff ffb2 	bl	800772e <vTCPWindowInit>
 80077ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		vListInitialise( &xSegmentList );
 80077ce:	4812      	ldr	r0, [pc, #72]	; (8007818 <vTCPWindowCreate+0x9c>)
 80077d0:	f001 f806 	bl	80087e0 <vListInitialise>
		xTCPSegments = ( TCPSegment_t * ) pvPortMallocLarge( ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 80077d4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80077d8:	f001 fa16 	bl	8008c08 <pvPortMalloc>
 80077dc:	4606      	mov	r6, r0
 80077de:	4b0d      	ldr	r3, [pc, #52]	; (8007814 <vTCPWindowCreate+0x98>)
 80077e0:	6018      	str	r0, [r3, #0]
		if( xTCPSegments == NULL )
 80077e2:	2800      	cmp	r0, #0
 80077e4:	d0d3      	beq.n	800778e <vTCPWindowCreate+0x12>
			memset( xTCPSegments, '\0', ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 80077e6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80077ea:	2100      	movs	r1, #0
 80077ec:	f004 fc5a 	bl	800c0a4 <memset>
 80077f0:	4634      	mov	r4, r6
 80077f2:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 80077f6:	4f08      	ldr	r7, [pc, #32]	; (8007818 <vTCPWindowCreate+0x9c>)
 80077f8:	f107 0b08 	add.w	fp, r7, #8
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xListItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
 80077fc:	63a4      	str	r4, [r4, #56]	; 0x38
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
 80077fe:	6264      	str	r4, [r4, #36]	; 0x24
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007800:	465a      	mov	r2, fp
 8007802:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 8007806:	4638      	mov	r0, r7
 8007808:	f7ff fe71 	bl	80074ee <vListInsertGeneric>
 800780c:	3440      	adds	r4, #64	; 0x40
			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 800780e:	42b4      	cmp	r4, r6
 8007810:	d1f4      	bne.n	80077fc <vTCPWindowCreate+0x80>
 8007812:	e7bc      	b.n	800778e <vTCPWindowCreate+0x12>
 8007814:	20000554 	.word	0x20000554
 8007818:	20000540 	.word	0x20000540

0800781c <lTCPWindowRxCheck>:
	{
 800781c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007820:	4605      	mov	r5, r0
 8007822:	460e      	mov	r6, r1
 8007824:	4690      	mov	r8, r2
		ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 8007826:	6907      	ldr	r7, [r0, #16]
		pxWindow->ucOptionLength = 0u;
 8007828:	2200      	movs	r2, #0
 800782a:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
		pxWindow->ulUserDataLength = 0ul;
 800782e:	6302      	str	r2, [r0, #48]	; 0x30
		if( ulCurrentSequenceNumber == ulSequenceNumber )
 8007830:	428f      	cmp	r7, r1
 8007832:	d00f      	beq.n	8007854 <lTCPWindowRxCheck+0x38>
		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
 8007834:	1c4a      	adds	r2, r1, #1
 8007836:	4297      	cmp	r7, r2
 8007838:	f000 809a 	beq.w	8007970 <lTCPWindowRxCheck+0x154>
			ulLast = ulSequenceNumber + ulLength;
 800783c:	eb01 0408 	add.w	r4, r1, r8
			lDistance = ( int32_t ) ( ulLast - ulCurrentSequenceNumber );
 8007840:	1be2      	subs	r2, r4, r7
			if( lDistance <= 0 )
 8007842:	2a00      	cmp	r2, #0
 8007844:	f340 8098 	ble.w	8007978 <lTCPWindowRxCheck+0x15c>
			else if( lDistance > ( int32_t ) ulSpace )
 8007848:	429a      	cmp	r2, r3
 800784a:	dd50      	ble.n	80078ee <lTCPWindowRxCheck+0xd2>
				lReturn = -1;
 800784c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007850:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( ulLength > ulSpace )
 8007854:	4598      	cmp	r8, r3
 8007856:	f200 8087 	bhi.w	8007968 <lTCPWindowRxCheck+0x14c>
				ulCurrentSequenceNumber += ulLength;
 800785a:	4447      	add	r7, r8
				if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0 )
 800785c:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8007860:	b91b      	cbnz	r3, 800786a <lTCPWindowRxCheck+0x4e>
				pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
 8007862:	612f      	str	r7, [r5, #16]
				lReturn = 0;
 8007864:	2000      	movs	r0, #0
 8007866:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
 800786a:	eb01 0c08 	add.w	ip, r1, r8
	const MiniListItem_t* pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &pxWindow->xRxSegments );
 800786e:	f100 0eac 	add.w	lr, r0, #172	; 0xac
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007872:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8007876:	459e      	cmp	lr, r3
 8007878:	d021      	beq.n	80078be <lTCPWindowRxCheck+0xa2>
 800787a:	4610      	mov	r0, r2
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 800787c:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 8007880:	e003      	b.n	800788a <lTCPWindowRxCheck+0x6e>
					pxBest = pxSegment;
 8007882:	4620      	mov	r0, r4
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8007884:	685b      	ldr	r3, [r3, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007886:	459e      	cmp	lr, r3
 8007888:	d012      	beq.n	80078b0 <lTCPWindowRxCheck+0x94>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800788a:	68dc      	ldr	r4, [r3, #12]
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 800788c:	6822      	ldr	r2, [r4, #0]
	return ( ( a - b ) & 0x80000000UL ) == 0UL;
 800788e:	1b91      	subs	r1, r2, r6
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8007890:	2900      	cmp	r1, #0
 8007892:	dbf7      	blt.n	8007884 <lTCPWindowRxCheck+0x68>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007894:	ebac 0102 	sub.w	r1, ip, r2
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8007898:	2900      	cmp	r1, #0
 800789a:	dbf3      	blt.n	8007884 <lTCPWindowRxCheck+0x68>
				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
 800789c:	2800      	cmp	r0, #0
 800789e:	d0f0      	beq.n	8007882 <lTCPWindowRxCheck+0x66>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 80078a0:	6801      	ldr	r1, [r0, #0]
 80078a2:	3901      	subs	r1, #1
 80078a4:	1a8a      	subs	r2, r1, r2
					pxBest = pxSegment;
 80078a6:	ea10 0022 	ands.w	r0, r0, r2, asr #32
 80078aa:	bf38      	it	cc
 80078ac:	4620      	movcc	r0, r4
 80078ae:	e7e9      	b.n	8007884 <lTCPWindowRxCheck+0x68>
					if( pxFound != NULL )
 80078b0:	b138      	cbz	r0, 80078c2 <lTCPWindowRxCheck+0xa6>
						ulCurrentSequenceNumber = pxFound->ulSequenceNumber + ( ( uint32_t ) pxFound->lDataLength );
 80078b2:	6804      	ldr	r4, [r0, #0]
 80078b4:	6883      	ldr	r3, [r0, #8]
 80078b6:	441c      	add	r4, r3
						vTCPWindowFree( pxFound );
 80078b8:	f7ff fe24 	bl	8007504 <vTCPWindowFree>
 80078bc:	e008      	b.n	80078d0 <lTCPWindowRxCheck+0xb4>
				ulCurrentSequenceNumber += ulLength;
 80078be:	463c      	mov	r4, r7
 80078c0:	e006      	b.n	80078d0 <lTCPWindowRxCheck+0xb4>
 80078c2:	463c      	mov	r4, r7
 80078c4:	e004      	b.n	80078d0 <lTCPWindowRxCheck+0xb4>
						ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
 80078c6:	689a      	ldr	r2, [r3, #8]
 80078c8:	4414      	add	r4, r2
						vTCPWindowFree( pxFound );
 80078ca:	4618      	mov	r0, r3
 80078cc:	f7ff fe1a 	bl	8007504 <vTCPWindowFree>
					while( ( pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber ) ) != NULL )
 80078d0:	4621      	mov	r1, r4
 80078d2:	4628      	mov	r0, r5
 80078d4:	f7ff fdbc 	bl	8007450 <xTCPWindowRxFind>
 80078d8:	4603      	mov	r3, r0
 80078da:	2800      	cmp	r0, #0
 80078dc:	d1f3      	bne.n	80078c6 <lTCPWindowRxCheck+0xaa>
					if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
 80078de:	42bc      	cmp	r4, r7
						pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
 80078e0:	bf1c      	itt	ne
 80078e2:	1be7      	subne	r7, r4, r7
 80078e4:	632f      	strne	r7, [r5, #48]	; 0x30
 80078e6:	4627      	mov	r7, r4
 80078e8:	e7bb      	b.n	8007862 <lTCPWindowRxCheck+0x46>
					ulLast += ( uint32_t ) pxFound->lDataLength;
 80078ea:	689b      	ldr	r3, [r3, #8]
 80078ec:	441c      	add	r4, r3
				while( ( pxFound = xTCPWindowRxFind( pxWindow, ulLast ) ) != NULL )
 80078ee:	4621      	mov	r1, r4
 80078f0:	4628      	mov	r0, r5
 80078f2:	f7ff fdad 	bl	8007450 <xTCPWindowRxFind>
 80078f6:	4603      	mov	r3, r0
 80078f8:	2800      	cmp	r0, #0
 80078fa:	d1f6      	bne.n	80078ea <lTCPWindowRxCheck+0xce>
				pxWindow->ulOptionsData[0] = OPTION_CODE_SINGLE_SACK;
 80078fc:	4b22      	ldr	r3, [pc, #136]	; (8007988 <lTCPWindowRxCheck+0x16c>)
 80078fe:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
				pxWindow->ulOptionsData[1] = FreeRTOS_htonl( ulSequenceNumber );
 8007902:	0e33      	lsrs	r3, r6, #24
 8007904:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 8007908:	0232      	lsls	r2, r6, #8
 800790a:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800790e:	4313      	orrs	r3, r2
 8007910:	0a32      	lsrs	r2, r6, #8
 8007912:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8007916:	4313      	orrs	r3, r2
 8007918:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
				pxWindow->ulOptionsData[2] = FreeRTOS_htonl( ulLast );
 800791c:	0e23      	lsrs	r3, r4, #24
 800791e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 8007922:	0222      	lsls	r2, r4, #8
 8007924:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8007928:	4313      	orrs	r3, r2
 800792a:	0a24      	lsrs	r4, r4, #8
 800792c:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
 8007930:	431c      	orrs	r4, r3
 8007932:	f8c5 4088 	str.w	r4, [r5, #136]	; 0x88
				pxWindow->ucOptionLength = 3 * sizeof( pxWindow->ulOptionsData[ 0 ] );
 8007936:	230c      	movs	r3, #12
 8007938:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
				pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
 800793c:	4631      	mov	r1, r6
 800793e:	4628      	mov	r0, r5
 8007940:	f7ff fd86 	bl	8007450 <xTCPWindowRxFind>
				if( pxFound != NULL )
 8007944:	b9e0      	cbnz	r0, 8007980 <lTCPWindowRxCheck+0x164>
					pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
 8007946:	2301      	movs	r3, #1
 8007948:	4642      	mov	r2, r8
 800794a:	4631      	mov	r1, r6
 800794c:	4628      	mov	r0, r5
 800794e:	f7ff fe75 	bl	800763c <xTCPWindowNew>
					if( pxFound == NULL )
 8007952:	b110      	cbz	r0, 800795a <lTCPWindowRxCheck+0x13e>
						lReturn = ( int32_t ) ( ulSequenceNumber - ulCurrentSequenceNumber );
 8007954:	1bf0      	subs	r0, r6, r7
 8007956:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxWindow->ucOptionLength = 0u;
 800795a:	2300      	movs	r3, #0
 800795c:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
						lReturn = -1;
 8007960:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007964:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				lReturn = -1;
 8007968:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800796c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			lReturn = -1;
 8007970:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007974:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				lReturn = -1;
 8007978:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800797c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					lReturn = -1;
 8007980:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
 8007984:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007988:	0a050101 	.word	0x0a050101

0800798c <lTCPWindowTxAdd>:
	{
 800798c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007990:	b083      	sub	sp, #12
 8007992:	4605      	mov	r5, r0
 8007994:	4616      	mov	r6, r2
 8007996:	469a      	mov	sl, r3
	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
 8007998:	460f      	mov	r7, r1
	TCPSegment_t *pxSegment = pxWindow->pxHeadSegment;
 800799a:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
		if( pxSegment != NULL )
 800799c:	b313      	cbz	r3, 80079e4 <lTCPWindowTxAdd+0x58>
			if( pxSegment->lDataLength < pxSegment->lMaxLength )
 800799e:	f8d3 8008 	ldr.w	r8, [r3, #8]
 80079a2:	685a      	ldr	r2, [r3, #4]
 80079a4:	4590      	cmp	r8, r2
 80079a6:	da20      	bge.n	80079ea <lTCPWindowTxAdd+0x5e>
				if( ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength != 0 ) )
 80079a8:	7d98      	ldrb	r0, [r3, #22]
 80079aa:	f010 0f01 	tst.w	r0, #1
 80079ae:	d152      	bne.n	8007a56 <lTCPWindowTxAdd+0xca>
 80079b0:	f1b8 0f00 	cmp.w	r8, #0
 80079b4:	d01b      	beq.n	80079ee <lTCPWindowTxAdd+0x62>
					lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
 80079b6:	eba2 0008 	sub.w	r0, r2, r8
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
 80079ba:	4288      	cmp	r0, r1
 80079bc:	bfa8      	it	ge
 80079be:	4608      	movge	r0, r1
					pxSegment->lDataLength += lToWrite;
 80079c0:	eb08 0400 	add.w	r4, r8, r0
 80079c4:	609c      	str	r4, [r3, #8]
					if( pxSegment->lDataLength >= pxSegment->lMaxLength )
 80079c6:	42a2      	cmp	r2, r4
						pxWindow->pxHeadSegment = NULL;
 80079c8:	bfdc      	itt	le
 80079ca:	2300      	movle	r3, #0
 80079cc:	67eb      	strle	r3, [r5, #124]	; 0x7c
					lBytesLeft -= lToWrite;
 80079ce:	1a0f      	subs	r7, r1, r0
					pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 80079d0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80079d2:	4403      	add	r3, r0
 80079d4:	636b      	str	r3, [r5, #52]	; 0x34
		lPosition += lCount;
 80079d6:	4406      	add	r6, r0
		if( lPosition >= lMax )
 80079d8:	45b2      	cmp	sl, r6
 80079da:	dc3f      	bgt.n	8007a5c <lTCPWindowTxAdd+0xd0>
			lPosition -= lMax;
 80079dc:	eba6 060a 	sub.w	r6, r6, sl
					lDone += lToWrite;
 80079e0:	4680      	mov	r8, r0
 80079e2:	e004      	b.n	80079ee <lTCPWindowTxAdd+0x62>
	int32_t lDone = 0;
 80079e4:	f04f 0800 	mov.w	r8, #0
 80079e8:	e001      	b.n	80079ee <lTCPWindowTxAdd+0x62>
 80079ea:	f04f 0800 	mov.w	r8, #0
		while( lBytesLeft > 0 )
 80079ee:	2f00      	cmp	r7, #0
 80079f0:	dd2d      	ble.n	8007a4e <lTCPWindowTxAdd+0xc2>
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, pxWindow->usMSS );
 80079f2:	f04f 0900 	mov.w	r9, #0
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 80079f6:	f105 0b54 	add.w	fp, r5, #84	; 0x54
 80079fa:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 80079fe:	9301      	str	r3, [sp, #4]
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, pxWindow->usMSS );
 8007a00:	464b      	mov	r3, r9
 8007a02:	f8b5 20bc 	ldrh.w	r2, [r5, #188]	; 0xbc
 8007a06:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8007a08:	4628      	mov	r0, r5
 8007a0a:	f7ff fe17 	bl	800763c <xTCPWindowNew>
			if( pxSegment != NULL )
 8007a0e:	4604      	mov	r4, r0
 8007a10:	b1e8      	cbz	r0, 8007a4e <lTCPWindowTxAdd+0xc2>
 8007a12:	6843      	ldr	r3, [r0, #4]
 8007a14:	42bb      	cmp	r3, r7
 8007a16:	bfa8      	it	ge
 8007a18:	463b      	movge	r3, r7
				pxSegment->lDataLength = lToWrite;
 8007a1a:	6083      	str	r3, [r0, #8]
				pxSegment->lStreamPos = lPosition;
 8007a1c:	60c6      	str	r6, [r0, #12]
				lBytesLeft -= lToWrite;
 8007a1e:	1aff      	subs	r7, r7, r3
		lPosition += lCount;
 8007a20:	441e      	add	r6, r3
		if( lPosition >= lMax )
 8007a22:	45b2      	cmp	sl, r6
			lPosition -= lMax;
 8007a24:	bfd8      	it	le
 8007a26:	eba6 060a 	suble.w	r6, r6, sl
				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 8007a2a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8007a2c:	441a      	add	r2, r3
 8007a2e:	636a      	str	r2, [r5, #52]	; 0x34
				lDone += lToWrite;
 8007a30:	4498      	add	r8, r3
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007a32:	9a01      	ldr	r2, [sp, #4]
 8007a34:	f100 0118 	add.w	r1, r0, #24
 8007a38:	4658      	mov	r0, fp
 8007a3a:	f7ff fd58 	bl	80074ee <vListInsertGeneric>
				if( pxSegment->lDataLength < pxSegment->lMaxLength )
 8007a3e:	68a2      	ldr	r2, [r4, #8]
 8007a40:	6863      	ldr	r3, [r4, #4]
 8007a42:	429a      	cmp	r2, r3
					pxWindow->pxHeadSegment = pxSegment;
 8007a44:	bfa8      	it	ge
 8007a46:	464c      	movge	r4, r9
 8007a48:	67ec      	str	r4, [r5, #124]	; 0x7c
		while( lBytesLeft > 0 )
 8007a4a:	2f00      	cmp	r7, #0
 8007a4c:	dcd8      	bgt.n	8007a00 <lTCPWindowTxAdd+0x74>
	}
 8007a4e:	4640      	mov	r0, r8
 8007a50:	b003      	add	sp, #12
 8007a52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int32_t lDone = 0;
 8007a56:	f04f 0800 	mov.w	r8, #0
 8007a5a:	e7c8      	b.n	80079ee <lTCPWindowTxAdd+0x62>
					lDone += lToWrite;
 8007a5c:	4680      	mov	r8, r0
 8007a5e:	e7c6      	b.n	80079ee <lTCPWindowTxAdd+0x62>

08007a60 <xTCPWindowTxDone>:
		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
 8007a60:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
	}
 8007a64:	fab0 f080 	clz	r0, r0
 8007a68:	0940      	lsrs	r0, r0, #5
 8007a6a:	4770      	bx	lr

08007a6c <xTCPWindowTxHasData>:
	{
 8007a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		*pulDelay = 0u;
 8007a6e:	2300      	movs	r3, #0
 8007a70:	6013      	str	r3, [r2, #0]
		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
 8007a72:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8007a74:	bb53      	cbnz	r3, 8007acc <xTCPWindowTxHasData+0x60>
 8007a76:	4615      	mov	r5, r2
 8007a78:	460e      	mov	r6, r1
 8007a7a:	4604      	mov	r4, r0
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 8007a7c:	3068      	adds	r0, #104	; 0x68
 8007a7e:	f7ff fd00 	bl	8007482 <xTCPWindowPeekHead>
			if( pxSegment != NULL )
 8007a82:	4607      	mov	r7, r0
 8007a84:	b160      	cbz	r0, 8007aa0 <xTCPWindowTxHasData+0x34>
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 8007a86:	f001 ff9b 	bl	80099c0 <xTaskGetTickCount>
 8007a8a:	693b      	ldr	r3, [r7, #16]
 8007a8c:	1ac0      	subs	r0, r0, r3
				ulMaxAge = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 8007a8e:	7d3a      	ldrb	r2, [r7, #20]
 8007a90:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8007a92:	4093      	lsls	r3, r2
				if( ulMaxAge > ulAge )
 8007a94:	4298      	cmp	r0, r3
 8007a96:	d21b      	bcs.n	8007ad0 <xTCPWindowTxHasData+0x64>
					*pulDelay = ulMaxAge - ulAge;
 8007a98:	1a1b      	subs	r3, r3, r0
 8007a9a:	602b      	str	r3, [r5, #0]
				xReturn = pdTRUE;
 8007a9c:	2001      	movs	r0, #1
 8007a9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );
 8007aa0:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8007aa4:	f7ff fced 	bl	8007482 <xTCPWindowPeekHead>
				if( pxSegment == NULL )
 8007aa8:	4605      	mov	r5, r0
 8007aaa:	b198      	cbz	r0, 8007ad4 <xTCPWindowTxHasData+0x68>
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 8007aac:	4631      	mov	r1, r6
 8007aae:	4620      	mov	r0, r4
 8007ab0:	f7ff fcee 	bl	8007490 <prvTCPWindowTxHasSpace>
 8007ab4:	b180      	cbz	r0, 8007ad8 <xTCPWindowTxHasData+0x6c>
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 8007ab6:	7823      	ldrb	r3, [r4, #0]
 8007ab8:	f013 0f02 	tst.w	r3, #2
 8007abc:	d00e      	beq.n	8007adc <xTCPWindowTxHasData+0x70>
 8007abe:	68a8      	ldr	r0, [r5, #8]
 8007ac0:	686b      	ldr	r3, [r5, #4]
 8007ac2:	4298      	cmp	r0, r3
 8007ac4:	bfb4      	ite	lt
 8007ac6:	2000      	movlt	r0, #0
 8007ac8:	2001      	movge	r0, #1
 8007aca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 8007acc:	2001      	movs	r0, #1
 8007ace:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				xReturn = pdTRUE;
 8007ad0:	2001      	movs	r0, #1
 8007ad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xReturn = pdFALSE;
 8007ad4:	2000      	movs	r0, #0
 8007ad6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xReturn = pdFALSE;
 8007ad8:	2000      	movs	r0, #0
 8007ada:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xReturn = pdTRUE;
 8007adc:	2001      	movs	r0, #1
	}
 8007ade:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08007ae0 <ulTCPWindowTxGet>:
	{
 8007ae0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007ae4:	4605      	mov	r5, r0
 8007ae6:	460f      	mov	r7, r1
 8007ae8:	4616      	mov	r6, r2
		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
 8007aea:	3040      	adds	r0, #64	; 0x40
 8007aec:	f7ff fcf4 	bl	80074d8 <xTCPWindowGetHead>
		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
 8007af0:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007af2:	62eb      	str	r3, [r5, #44]	; 0x2c
		if( pxSegment == NULL )
 8007af4:	4604      	mov	r4, r0
 8007af6:	b310      	cbz	r0, 8007b3e <ulTCPWindowTxGet+0x5e>
			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
 8007af8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007afa:	b123      	cbz	r3, 8007b06 <ulTCPWindowTxGet+0x26>
 8007afc:	f240 5181 	movw	r1, #1409	; 0x581
 8007b00:	4835      	ldr	r0, [pc, #212]	; (8007bd8 <ulTCPWindowTxGet+0xf8>)
 8007b02:	f004 f903 	bl	800bd0c <vAssertCalled>
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007b06:	f105 0270 	add.w	r2, r5, #112	; 0x70
 8007b0a:	f104 0118 	add.w	r1, r4, #24
 8007b0e:	f105 0068 	add.w	r0, r5, #104	; 0x68
 8007b12:	f7ff fcec 	bl	80074ee <vListInsertGeneric>
			pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
 8007b16:	7da3      	ldrb	r3, [r4, #22]
 8007b18:	f043 0301 	orr.w	r3, r3, #1
 8007b1c:	75a3      	strb	r3, [r4, #22]
			( pxSegment->u.bits.ucTransmitCount )++;
 8007b1e:	7d23      	ldrb	r3, [r4, #20]
 8007b20:	3301      	adds	r3, #1
 8007b22:	b2db      	uxtb	r3, r3
 8007b24:	7523      	strb	r3, [r4, #20]
			if( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW )
 8007b26:	2b04      	cmp	r3, #4
 8007b28:	d047      	beq.n	8007bba <ulTCPWindowTxGet+0xda>
	pxTimer->ulBorn = xTaskGetTickCount ( );
 8007b2a:	f001 ff49 	bl	80099c0 <xTaskGetTickCount>
 8007b2e:	6120      	str	r0, [r4, #16]
			pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
 8007b30:	6823      	ldr	r3, [r4, #0]
 8007b32:	62eb      	str	r3, [r5, #44]	; 0x2c
			*plPosition = pxSegment->lStreamPos;
 8007b34:	68e3      	ldr	r3, [r4, #12]
 8007b36:	6033      	str	r3, [r6, #0]
			ulReturn = ( uint32_t ) pxSegment->lDataLength;
 8007b38:	68a0      	ldr	r0, [r4, #8]
 8007b3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 8007b3e:	f105 0868 	add.w	r8, r5, #104	; 0x68
 8007b42:	4640      	mov	r0, r8
 8007b44:	f7ff fc9d 	bl	8007482 <xTCPWindowPeekHead>
			if( pxSegment != NULL )
 8007b48:	4681      	mov	r9, r0
 8007b4a:	b148      	cbz	r0, 8007b60 <ulTCPWindowTxGet+0x80>
				ulMaxTime = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 8007b4c:	7d03      	ldrb	r3, [r0, #20]
 8007b4e:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8007b50:	409c      	lsls	r4, r3
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 8007b52:	f001 ff35 	bl	80099c0 <xTaskGetTickCount>
 8007b56:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8007b5a:	1ac0      	subs	r0, r0, r3
				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
 8007b5c:	42a0      	cmp	r0, r4
 8007b5e:	d815      	bhi.n	8007b8c <ulTCPWindowTxGet+0xac>
				pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 8007b60:	f105 0454 	add.w	r4, r5, #84	; 0x54
 8007b64:	4620      	mov	r0, r4
 8007b66:	f7ff fc8c 	bl	8007482 <xTCPWindowPeekHead>
				if( pxSegment == NULL )
 8007b6a:	b370      	cbz	r0, 8007bca <ulTCPWindowTxGet+0xea>
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 8007b6c:	782a      	ldrb	r2, [r5, #0]
 8007b6e:	f012 0f02 	tst.w	r2, #2
 8007b72:	d003      	beq.n	8007b7c <ulTCPWindowTxGet+0x9c>
 8007b74:	6882      	ldr	r2, [r0, #8]
 8007b76:	6843      	ldr	r3, [r0, #4]
 8007b78:	429a      	cmp	r2, r3
 8007b7a:	db29      	blt.n	8007bd0 <ulTCPWindowTxGet+0xf0>
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 8007b7c:	4639      	mov	r1, r7
 8007b7e:	4628      	mov	r0, r5
 8007b80:	f7ff fc86 	bl	8007490 <prvTCPWindowTxHasSpace>
 8007b84:	b958      	cbnz	r0, 8007b9e <ulTCPWindowTxGet+0xbe>
 8007b86:	2000      	movs	r0, #0
		return ulReturn;
 8007b88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
 8007b8c:	4640      	mov	r0, r8
 8007b8e:	f7ff fca3 	bl	80074d8 <xTCPWindowGetHead>
 8007b92:	4604      	mov	r4, r0
					pxSegment->u.bits.ucDupAckCount = pdFALSE_UNSIGNED;
 8007b94:	2300      	movs	r3, #0
 8007b96:	7543      	strb	r3, [r0, #21]
			if( pxSegment == NULL )
 8007b98:	2800      	cmp	r0, #0
 8007b9a:	d1ad      	bne.n	8007af8 <ulTCPWindowTxGet+0x18>
 8007b9c:	e7e0      	b.n	8007b60 <ulTCPWindowTxGet+0x80>
					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );
 8007b9e:	4620      	mov	r0, r4
 8007ba0:	f7ff fc9a 	bl	80074d8 <xTCPWindowGetHead>
 8007ba4:	4604      	mov	r4, r0
					if( pxWindow->pxHeadSegment == pxSegment )
 8007ba6:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8007ba8:	4298      	cmp	r0, r3
						pxWindow->pxHeadSegment = NULL;
 8007baa:	bf04      	itt	eq
 8007bac:	2300      	moveq	r3, #0
 8007bae:	67eb      	streq	r3, [r5, #124]	; 0x7c
					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
 8007bb0:	6803      	ldr	r3, [r0, #0]
 8007bb2:	6882      	ldr	r2, [r0, #8]
 8007bb4:	4413      	add	r3, r2
 8007bb6:	62ab      	str	r3, [r5, #40]	; 0x28
 8007bb8:	e79e      	b.n	8007af8 <ulTCPWindowTxGet+0x18>
				if( pxWindow->xSize.ulTxWindowLength > ( 2U * pxWindow->usMSS ) )
 8007bba:	f8b5 30bc 	ldrh.w	r3, [r5, #188]	; 0xbc
 8007bbe:	005b      	lsls	r3, r3, #1
 8007bc0:	68aa      	ldr	r2, [r5, #8]
 8007bc2:	429a      	cmp	r2, r3
					pxWindow->xSize.ulTxWindowLength = ( 2UL * pxWindow->usMSS );
 8007bc4:	bf88      	it	hi
 8007bc6:	60ab      	strhi	r3, [r5, #8]
 8007bc8:	e7af      	b.n	8007b2a <ulTCPWindowTxGet+0x4a>
 8007bca:	2000      	movs	r0, #0
 8007bcc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8007bd0:	2000      	movs	r0, #0
 8007bd2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8007bd6:	bf00      	nop
 8007bd8:	0800c704 	.word	0x0800c704

08007bdc <ulTCPWindowTxAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxAck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 8007bdc:	b508      	push	{r3, lr}
	uint32_t ulFirstSequence, ulReturn;

		/* Receive a normal ACK. */

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
 8007bde:	6a03      	ldr	r3, [r0, #32]
		return ( ( b - a ) & 0x80000000UL ) == 0UL;
 8007be0:	1a5a      	subs	r2, r3, r1

		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
 8007be2:	2a00      	cmp	r2, #0
 8007be4:	db01      	blt.n	8007bea <ulTCPWindowTxAck+0xe>
		{
			ulReturn = 0UL;
 8007be6:	2000      	movs	r0, #0
		{
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
		}

		return ulReturn;
	}
 8007be8:	bd08      	pop	{r3, pc}
 8007bea:	460a      	mov	r2, r1
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
 8007bec:	4619      	mov	r1, r3
 8007bee:	f7ff fca5 	bl	800753c <prvTCPWindowTxCheckAck>
 8007bf2:	bd08      	pop	{r3, pc}

08007bf4 <ulTCPWindowTxSack>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxSack( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 8007bf4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007bf8:	4607      	mov	r7, r0
 8007bfa:	460e      	mov	r6, r1
	uint32_t ulAckCount = 0UL;
	uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;

		/* Receive a SACK option. */
		ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
 8007bfc:	f7ff fc9e 	bl	800753c <prvTCPWindowTxCheckAck>
 8007c00:	4680      	mov	r8, r0
		pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &( pxWindow->xWaitQueue ) );
 8007c02:	f107 0570 	add.w	r5, r7, #112	; 0x70
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007c06:	6f7c      	ldr	r4, [r7, #116]	; 0x74
 8007c08:	42a5      	cmp	r5, r4
 8007c0a:	d025      	beq.n	8007c58 <ulTCPWindowTxSack+0x64>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007c0c:	3e01      	subs	r6, #1
				pxSegment->u.bits.ucTransmitCount = pdFALSE_UNSIGNED;
 8007c0e:	f04f 0a00 	mov.w	sl, #0
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007c12:	f107 0940 	add.w	r9, r7, #64	; 0x40
 8007c16:	e001      	b.n	8007c1c <ulTCPWindowTxSack+0x28>
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007c18:	42a5      	cmp	r5, r4
 8007c1a:	d01d      	beq.n	8007c58 <ulTCPWindowTxSack+0x64>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007c1c:	68e3      	ldr	r3, [r4, #12]
			pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 8007c1e:	6864      	ldr	r4, [r4, #4]
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
 8007c20:	7d9a      	ldrb	r2, [r3, #22]
 8007c22:	f012 0f02 	tst.w	r2, #2
 8007c26:	d1f7      	bne.n	8007c18 <ulTCPWindowTxSack+0x24>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007c28:	681a      	ldr	r2, [r3, #0]
 8007c2a:	1ab2      	subs	r2, r6, r2
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
 8007c2c:	2a00      	cmp	r2, #0
 8007c2e:	dbf3      	blt.n	8007c18 <ulTCPWindowTxSack+0x24>
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
 8007c30:	7d5a      	ldrb	r2, [r3, #21]
 8007c32:	3201      	adds	r2, #1
 8007c34:	b2d2      	uxtb	r2, r2
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
 8007c36:	755a      	strb	r2, [r3, #21]
 8007c38:	2a03      	cmp	r2, #3
 8007c3a:	d1ed      	bne.n	8007c18 <ulTCPWindowTxSack+0x24>
				pxSegment->u.bits.ucTransmitCount = pdFALSE_UNSIGNED;
 8007c3c:	f883 a014 	strb.w	sl, [r3, #20]
				uxListRemove( &pxSegment->xQueueItem );
 8007c40:	f103 0b18 	add.w	fp, r3, #24
 8007c44:	4658      	mov	r0, fp
 8007c46:	f000 fdff 	bl	8008848 <uxListRemove>
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007c4a:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8007c4e:	4659      	mov	r1, fp
 8007c50:	4648      	mov	r0, r9
 8007c52:	f7ff fc4c 	bl	80074ee <vListInsertGeneric>
 8007c56:	e7df      	b.n	8007c18 <ulTCPWindowTxSack+0x24>
				pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
			FreeRTOS_flush_logging( );
		}

		return ulAckCount;
	}
 8007c58:	4640      	mov	r0, r8
 8007c5a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08007c60 <vProcessGeneratedUDPPacket>:
	}
};
/*-----------------------------------------------------------*/

void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8007c60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c62:	b083      	sub	sp, #12
 8007c64:	4604      	mov	r4, r0
UDPPacket_t *pxUDPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
 8007c66:	6943      	ldr	r3, [r0, #20]
 8007c68:	a802      	add	r0, sp, #8
 8007c6a:	f840 3d04 	str.w	r3, [r0, #-4]!

	/* Map the UDP packet onto the start of the frame. */
	pxUDPPacket = ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
 8007c6e:	69a5      	ldr	r5, [r4, #24]

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ) );
 8007c70:	4629      	mov	r1, r5
 8007c72:	f7fb fbfd 	bl	8003470 <eARPGetCacheEntry>

	if( eReturned != eCantSendPacket )
 8007c76:	2802      	cmp	r0, #2
 8007c78:	d003      	beq.n	8007c82 <vProcessGeneratedUDPPacket+0x22>
	{
		if( eReturned == eARPCacheHit )
 8007c7a:	2801      	cmp	r0, #1
 8007c7c:	d006      	beq.n	8007c8c <vProcessGeneratedUDPPacket+0x2c>
					pxUDPPacket->xUDPHeader.usChecksum = 0u;
				}
			}
			#endif
		}
		else if( eReturned == eARPCacheMiss )
 8007c7e:	2800      	cmp	r0, #0
 8007c80:	d041      	beq.n	8007d06 <vProcessGeneratedUDPPacket+0xa6>
	}
	else
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
		packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8007c82:	4620      	mov	r0, r4
 8007c84:	f000 f8f0 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
	}
}
 8007c88:	b003      	add	sp, #12
 8007c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if( pxNetworkBuffer->usPort != ipPACKET_CONTAINS_ICMP_DATA )
 8007c8c:	8c23      	ldrh	r3, [r4, #32]
 8007c8e:	b173      	cbz	r3, 8007cae <vProcessGeneratedUDPPacket+0x4e>
				pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 8007c90:	84ab      	strh	r3, [r5, #36]	; 0x24
				pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 8007c92:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8007c94:	846b      	strh	r3, [r5, #34]	; 0x22
				pxUDPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( UDPHeader_t ) );
 8007c96:	69e3      	ldr	r3, [r4, #28]
 8007c98:	3308      	adds	r3, #8
 8007c9a:	b29b      	uxth	r3, r3
				pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 8007c9c:	0a1a      	lsrs	r2, r3, #8
 8007c9e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8007ca2:	84eb      	strh	r3, [r5, #38]	; 0x26
				pxUDPHeader->usChecksum = 0u;
 8007ca4:	2300      	movs	r3, #0
 8007ca6:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 8007caa:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
			memcpy( ( void *) &( pxUDPPacket->xEthernetHeader.xSourceAddress ), ( void * ) xDefaultPartUDPPacketHeader.ucBytes, sizeof( xDefaultPartUDPPacketHeader ) );
 8007cae:	4e1e      	ldr	r6, [pc, #120]	; (8007d28 <vProcessGeneratedUDPPacket+0xc8>)
 8007cb0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8007cb2:	f8c5 0006 	str.w	r0, [r5, #6]
 8007cb6:	f8c5 100a 	str.w	r1, [r5, #10]
 8007cba:	f8c5 200e 	str.w	r2, [r5, #14]
 8007cbe:	f8c5 3012 	str.w	r3, [r5, #18]
 8007cc2:	ce03      	ldmia	r6!, {r0, r1}
 8007cc4:	f8c5 0016 	str.w	r0, [r5, #22]
 8007cc8:	f8c5 101a 	str.w	r1, [r5, #26]
			if( pxNetworkBuffer->usPort == ipPACKET_CONTAINS_ICMP_DATA )
 8007ccc:	8c23      	ldrh	r3, [r4, #32]
 8007cce:	b9b3      	cbnz	r3, 8007cfe <vProcessGeneratedUDPPacket+0x9e>
				pxIPHeader->ucProtocol = ipPROTOCOL_ICMP;
 8007cd0:	2301      	movs	r3, #1
 8007cd2:	75eb      	strb	r3, [r5, #23]
				pxIPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( IPHeader_t ) );
 8007cd4:	69e3      	ldr	r3, [r4, #28]
 8007cd6:	3314      	adds	r3, #20
 8007cd8:	822b      	strh	r3, [r5, #16]
			pxNetworkBuffer->xDataLength = pxIPHeader->usLength + sizeof( EthernetHeader_t );
 8007cda:	8a2b      	ldrh	r3, [r5, #16]
 8007cdc:	330e      	adds	r3, #14
 8007cde:	61e3      	str	r3, [r4, #28]
			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 8007ce0:	8a2a      	ldrh	r2, [r5, #16]
 8007ce2:	0a13      	lsrs	r3, r2, #8
 8007ce4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007ce8:	822b      	strh	r3, [r5, #16]
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
 8007cea:	6963      	ldr	r3, [r4, #20]
 8007cec:	f8c5 301e 	str.w	r3, [r5, #30]
				if( pxNetworkBuffer->ulIPAddress == ipLLMNR_IP_ADDR )
 8007cf0:	6962      	ldr	r2, [r4, #20]
 8007cf2:	4b0e      	ldr	r3, [pc, #56]	; (8007d2c <vProcessGeneratedUDPPacket+0xcc>)
 8007cf4:	429a      	cmp	r2, r3
 8007cf6:	d112      	bne.n	8007d1e <vProcessGeneratedUDPPacket+0xbe>
					pxIPHeader->ucTimeToLive = 0x01;
 8007cf8:	2301      	movs	r3, #1
 8007cfa:	75ab      	strb	r3, [r5, #22]
 8007cfc:	e00f      	b.n	8007d1e <vProcessGeneratedUDPPacket+0xbe>
				pxIPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
 8007cfe:	69e3      	ldr	r3, [r4, #28]
 8007d00:	331c      	adds	r3, #28
 8007d02:	822b      	strh	r3, [r5, #16]
 8007d04:	e7e9      	b.n	8007cda <vProcessGeneratedUDPPacket+0x7a>
			vARPRefreshCacheEntry( NULL, ulIPAddress );
 8007d06:	9901      	ldr	r1, [sp, #4]
 8007d08:	f7fb fac8 	bl	800329c <vARPRefreshCacheEntry>
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
 8007d0c:	2100      	movs	r1, #0
 8007d0e:	2002      	movs	r0, #2
 8007d10:	f003 fa66 	bl	800b1e0 <vExampleDebugStatUpdate>
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8007d14:	9b01      	ldr	r3, [sp, #4]
 8007d16:	6163      	str	r3, [r4, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
 8007d18:	4620      	mov	r0, r4
 8007d1a:	f7fb fc05 	bl	8003528 <vARPGenerateRequestPacket>
		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 8007d1e:	2101      	movs	r1, #1
 8007d20:	4620      	mov	r0, r4
 8007d22:	f000 fb63 	bl	80083ec <xNetworkInterfaceOutput>
 8007d26:	e7af      	b.n	8007c88 <vProcessGeneratedUDPPacket+0x28>
 8007d28:	20000010 	.word	0x20000010
 8007d2c:	fc0000e0 	.word	0xfc0000e0

08007d30 <xProcessReceivedUDPPacket>:
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
 8007d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007d32:	4606      	mov	r6, r0
 8007d34:	460f      	mov	r7, r1
BaseType_t xReturn = pdPASS;
FreeRTOS_Socket_t *pxSocket;

UDPPacket_t *pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
 8007d36:	6985      	ldr	r5, [r0, #24]

	pxSocket = pxUDPSocketLookup( usPort );
 8007d38:	4608      	mov	r0, r1
 8007d3a:	f7fc ffb1 	bl	8004ca0 <pxUDPSocketLookup>

	if( pxSocket )
 8007d3e:	b328      	cbz	r0, 8007d8c <xProcessReceivedUDPPacket+0x5c>
 8007d40:	4604      	mov	r4, r0
	{

		/* When refreshing the ARP cache with received UDP packets we must be
		careful;  hundreds of broadcast messages may pass and if we're not
		handling them, no use to fill the ARP cache with those IP addresses. */
		vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 8007d42:	f8d5 101a 	ldr.w	r1, [r5, #26]
 8007d46:	1da8      	adds	r0, r5, #6
 8007d48:	f7fb faa8 	bl	800329c <vARPRefreshCacheEntry>
		}
		#endif

		if( xReturn == pdPASS )
		{
			vTaskSuspendAll();
 8007d4c:	f001 fe30 	bl	80099b0 <vTaskSuspendAll>
			{
				if( xReturn == pdPASS )
				{
					taskENTER_CRITICAL();
 8007d50:	f000 fdd0 	bl	80088f4 <vPortEnterCritical>
					{
						/* Add the network packet to the list of packets to be
						processed by the socket. */
						vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
 8007d54:	4631      	mov	r1, r6
 8007d56:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8007d5a:	f000 fd4f 	bl	80087fc <vListInsertEnd>
					}
					taskEXIT_CRITICAL();
 8007d5e:	f000 fdeb 	bl	8008938 <vPortExitCritical>
				}
			}
			xTaskResumeAll();
 8007d62:	f001 feff 	bl	8009b64 <xTaskResumeAll>

			/* Set the socket's receive event */
			if( pxSocket->xEventGroup != NULL )
 8007d66:	6860      	ldr	r0, [r4, #4]
 8007d68:	b110      	cbz	r0, 8007d70 <xProcessReceivedUDPPacket+0x40>
			{
				xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_RECEIVE );
 8007d6a:	2101      	movs	r1, #1
 8007d6c:	f000 fcc8 	bl	8008700 <xEventGroupSetBits>
			}

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) )
 8007d70:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007d72:	b363      	cbz	r3, 8007dce <xProcessReceivedUDPPacket+0x9e>
 8007d74:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007d76:	f012 0f01 	tst.w	r2, #1
 8007d7a:	d101      	bne.n	8007d80 <xProcessReceivedUDPPacket+0x50>
BaseType_t xReturn = pdPASS;
 8007d7c:	2001      	movs	r0, #1
 8007d7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				{
					xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_READ );
 8007d80:	2101      	movs	r1, #1
 8007d82:	6818      	ldr	r0, [r3, #0]
 8007d84:	f000 fcbc 	bl	8008700 <xEventGroupSetBits>
BaseType_t xReturn = pdPASS;
 8007d88:	2001      	movs	r0, #1
 8007d8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		#if( ipconfigUSE_DNS == 1 )
			/* a DNS reply, check for the source port.  Although the DNS client
			does open a UDP socket to send a messages, this socket will be
			closed after a short timeout.  Messages that come late (after the
			socket is closed) will be treated here. */
			if( FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usSourcePort ) == ipDNS_PORT )
 8007d8c:	8c6a      	ldrh	r2, [r5, #34]	; 0x22
 8007d8e:	0a13      	lsrs	r3, r2, #8
 8007d90:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007d94:	b21b      	sxth	r3, r3
 8007d96:	2b35      	cmp	r3, #53	; 0x35
 8007d98:	d007      	beq.n	8007daa <xProcessReceivedUDPPacket+0x7a>
			else
		#endif

		#if( ipconfigUSE_LLMNR == 1 )
			/* a LLMNR request, check for the destination port. */
			if( ( usPort == FreeRTOS_ntohs( ipLLMNR_PORT ) ) ||
 8007d9a:	f64e 3314 	movw	r3, #60180	; 0xeb14
 8007d9e:	429f      	cmp	r7, r3
 8007da0:	d00c      	beq.n	8007dbc <xProcessReceivedUDPPacket+0x8c>
 8007da2:	429a      	cmp	r2, r3
 8007da4:	d00a      	beq.n	8007dbc <xProcessReceivedUDPPacket+0x8c>
				xReturn = ( BaseType_t )ulNBNSHandlePacket( pxNetworkBuffer );
			}
			else
		#endif /* ipconfigUSE_NBNS */
		{
			xReturn = pdFAIL;
 8007da6:	2000      	movs	r0, #0
		}
	}

	return xReturn;
}
 8007da8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 8007daa:	f8d5 101a 	ldr.w	r1, [r5, #26]
 8007dae:	1da8      	adds	r0, r5, #6
 8007db0:	f7fb fa74 	bl	800329c <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 8007db4:	4630      	mov	r0, r6
 8007db6:	f7fb ff9e 	bl	8003cf6 <ulDNSHandlePacket>
 8007dba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 8007dbc:	f8d5 101a 	ldr.w	r1, [r5, #26]
 8007dc0:	1da8      	adds	r0, r5, #6
 8007dc2:	f7fb fa6b 	bl	800329c <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 8007dc6:	4630      	mov	r0, r6
 8007dc8:	f7fb ff95 	bl	8003cf6 <ulDNSHandlePacket>
 8007dcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
BaseType_t xReturn = pdPASS;
 8007dce:	2001      	movs	r0, #1
 8007dd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08007dd4 <xNetworkBuffersInitialise>:
static SemaphoreHandle_t xNetworkBufferSemaphore = NULL;

/*-----------------------------------------------------------*/

BaseType_t xNetworkBuffersInitialise( void )
{
 8007dd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
BaseType_t xReturn, x;

	/* Only initialise the buffers and their associated kernel objects if they
	have not been initialised before. */
	if( xNetworkBufferSemaphore == NULL )
 8007dd6:	4b1a      	ldr	r3, [pc, #104]	; (8007e40 <xNetworkBuffersInitialise+0x6c>)
 8007dd8:	681b      	ldr	r3, [r3, #0]
 8007dda:	b12b      	cbz	r3, 8007de8 <xNetworkBuffersInitialise+0x14>

			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
		}
	}

	if( xNetworkBufferSemaphore == NULL )
 8007ddc:	4b18      	ldr	r3, [pc, #96]	; (8007e40 <xNetworkBuffersInitialise+0x6c>)
 8007dde:	6818      	ldr	r0, [r3, #0]
	{
		xReturn = pdPASS;
	}

	return xReturn;
}
 8007de0:	3000      	adds	r0, #0
 8007de2:	bf18      	it	ne
 8007de4:	2001      	movne	r0, #1
 8007de6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		xNetworkBufferSemaphore = xSemaphoreCreateCounting( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS );
 8007de8:	2119      	movs	r1, #25
 8007dea:	4608      	mov	r0, r1
 8007dec:	f001 f93a 	bl	8009064 <xQueueCreateCountingSemaphore>
 8007df0:	4b13      	ldr	r3, [pc, #76]	; (8007e40 <xNetworkBuffersInitialise+0x6c>)
 8007df2:	6018      	str	r0, [r3, #0]
		configASSERT( xNetworkBufferSemaphore );
 8007df4:	b1f8      	cbz	r0, 8007e36 <xNetworkBuffersInitialise+0x62>
			vQueueAddToRegistry( xNetworkBufferSemaphore, "NetBufSem" );
 8007df6:	4c12      	ldr	r4, [pc, #72]	; (8007e40 <xNetworkBuffersInitialise+0x6c>)
 8007df8:	4912      	ldr	r1, [pc, #72]	; (8007e44 <xNetworkBuffersInitialise+0x70>)
 8007dfa:	6820      	ldr	r0, [r4, #0]
 8007dfc:	f001 fb44 	bl	8009488 <vQueueAddToRegistry>
		if( xNetworkBufferSemaphore != NULL )
 8007e00:	6823      	ldr	r3, [r4, #0]
 8007e02:	2b00      	cmp	r3, #0
 8007e04:	d0ea      	beq.n	8007ddc <xNetworkBuffersInitialise+0x8>
			vListInitialise( &xFreeBuffersList );
 8007e06:	4810      	ldr	r0, [pc, #64]	; (8007e48 <xNetworkBuffersInitialise+0x74>)
 8007e08:	f000 fcea 	bl	80087e0 <vListInitialise>
 8007e0c:	4c0f      	ldr	r4, [pc, #60]	; (8007e4c <xNetworkBuffersInitialise+0x78>)
 8007e0e:	f504 7761 	add.w	r7, r4, #900	; 0x384
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 8007e12:	2600      	movs	r6, #0
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8007e14:	4d0c      	ldr	r5, [pc, #48]	; (8007e48 <xNetworkBuffersInitialise+0x74>)
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 8007e16:	61a6      	str	r6, [r4, #24]
				vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8007e18:	4620      	mov	r0, r4
 8007e1a:	f000 fcec 	bl	80087f6 <vListInitialiseItem>
				listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );
 8007e1e:	60e4      	str	r4, [r4, #12]
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8007e20:	4621      	mov	r1, r4
 8007e22:	4628      	mov	r0, r5
 8007e24:	f000 fcf6 	bl	8008814 <vListInsert>
 8007e28:	3424      	adds	r4, #36	; 0x24
			for( x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 8007e2a:	42bc      	cmp	r4, r7
 8007e2c:	d1f3      	bne.n	8007e16 <xNetworkBuffersInitialise+0x42>
			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
 8007e2e:	2219      	movs	r2, #25
 8007e30:	4b07      	ldr	r3, [pc, #28]	; (8007e50 <xNetworkBuffersInitialise+0x7c>)
 8007e32:	601a      	str	r2, [r3, #0]
 8007e34:	e7d2      	b.n	8007ddc <xNetworkBuffersInitialise+0x8>
		configASSERT( xNetworkBufferSemaphore );
 8007e36:	2187      	movs	r1, #135	; 0x87
 8007e38:	4806      	ldr	r0, [pc, #24]	; (8007e54 <xNetworkBuffersInitialise+0x80>)
 8007e3a:	f003 ff67 	bl	800bd0c <vAssertCalled>
 8007e3e:	e7da      	b.n	8007df6 <xNetworkBuffersInitialise+0x22>
 8007e40:	200008f4 	.word	0x200008f4
 8007e44:	0800c794 	.word	0x0800c794
 8007e48:	2000055c 	.word	0x2000055c
 8007e4c:	20000570 	.word	0x20000570
 8007e50:	20000558 	.word	0x20000558
 8007e54:	0800c740 	.word	0x0800c740

08007e58 <vReleaseNetworkBuffer>:
void vReleaseNetworkBuffer( uint8_t *pucEthernetBuffer )
{
	/* There is space before the Ethernet buffer in which a pointer to the
	network buffer that references this Ethernet buffer is stored.  Remove the
	space before freeing the buffer. */
	if( pucEthernetBuffer != NULL )
 8007e58:	b120      	cbz	r0, 8007e64 <vReleaseNetworkBuffer+0xc>
{
 8007e5a:	b508      	push	{r3, lr}
	{
		pucEthernetBuffer -= ipBUFFER_PADDING;
		vPortFree( ( void * ) pucEthernetBuffer );
 8007e5c:	380a      	subs	r0, #10
 8007e5e:	f000 ff39 	bl	8008cd4 <vPortFree>
 8007e62:	bd08      	pop	{r3, pc}
 8007e64:	4770      	bx	lr
	...

08007e68 <vReleaseNetworkBufferAndDescriptor>:
	return pxReturn;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBufferAndDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8007e68:	b510      	push	{r4, lr}
 8007e6a:	4604      	mov	r4, r0
	/* Ensure the buffer is returned to the list of free buffers before the
	counting semaphore is 'given' to say a buffer is available.  Release the
	storage allocated to the buffer payload.  THIS FILE SHOULD NOT BE USED
	IF THE PROJECT INCLUDES A MEMORY ALLOCATOR THAT WILL FRAGMENT THE HEAP
	MEMORY.  For example, heap_2 must not be used, heap_4 can be used. */
	vReleaseNetworkBuffer( pxNetworkBuffer->pucEthernetBuffer );
 8007e6c:	6980      	ldr	r0, [r0, #24]
 8007e6e:	f7ff fff3 	bl	8007e58 <vReleaseNetworkBuffer>
	pxNetworkBuffer->pucEthernetBuffer = NULL;
 8007e72:	2300      	movs	r3, #0
 8007e74:	61a3      	str	r3, [r4, #24]

	taskENTER_CRITICAL();
 8007e76:	f000 fd3d 	bl	80088f4 <vPortEnterCritical>
	{
		xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );

		if( xListItemAlreadyInFreeList == pdFALSE )
 8007e7a:	6922      	ldr	r2, [r4, #16]
 8007e7c:	4b0b      	ldr	r3, [pc, #44]	; (8007eac <vReleaseNetworkBufferAndDescriptor+0x44>)
 8007e7e:	429a      	cmp	r2, r3
 8007e80:	d011      	beq.n	8007ea6 <vReleaseNetworkBufferAndDescriptor+0x3e>
		{
			vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 8007e82:	4621      	mov	r1, r4
 8007e84:	4618      	mov	r0, r3
 8007e86:	f000 fcb9 	bl	80087fc <vListInsertEnd>
		}
	}
	taskEXIT_CRITICAL();
 8007e8a:	f000 fd55 	bl	8008938 <vPortExitCritical>

	if( xListItemAlreadyInFreeList == pdFALSE )
	{
		xSemaphoreGive( xNetworkBufferSemaphore );
 8007e8e:	2300      	movs	r3, #0
 8007e90:	461a      	mov	r2, r3
 8007e92:	4619      	mov	r1, r3
 8007e94:	4806      	ldr	r0, [pc, #24]	; (8007eb0 <vReleaseNetworkBufferAndDescriptor+0x48>)
 8007e96:	6800      	ldr	r0, [r0, #0]
 8007e98:	f001 f902 	bl	80090a0 <xQueueGenericSend>
	}

	iptraceNETWORK_BUFFER_RELEASED( pxNetworkBuffer );
 8007e9c:	2100      	movs	r1, #0
 8007e9e:	2014      	movs	r0, #20
 8007ea0:	f003 f99e 	bl	800b1e0 <vExampleDebugStatUpdate>
}
 8007ea4:	bd10      	pop	{r4, pc}
	taskEXIT_CRITICAL();
 8007ea6:	f000 fd47 	bl	8008938 <vPortExitCritical>
 8007eaa:	e7f7      	b.n	8007e9c <vReleaseNetworkBufferAndDescriptor+0x34>
 8007eac:	2000055c 	.word	0x2000055c
 8007eb0:	200008f4 	.word	0x200008f4

08007eb4 <pxGetNetworkBufferWithDescriptor>:
{
 8007eb4:	b570      	push	{r4, r5, r6, lr}
 8007eb6:	460a      	mov	r2, r1
	if( ( xRequestedSizeBytes != 0u ) && ( xRequestedSizeBytes < ( size_t ) baMINIMAL_BUFFER_SIZE ) )
 8007eb8:	1e43      	subs	r3, r0, #1
 8007eba:	2b44      	cmp	r3, #68	; 0x44
 8007ebc:	d936      	bls.n	8007f2c <pxGetNetworkBufferWithDescriptor+0x78>
	xRequestedSizeBytes += 2u;
 8007ebe:	1c84      	adds	r4, r0, #2
	if( ( xRequestedSizeBytes & ( sizeof( size_t ) - 1u ) ) != 0u )
 8007ec0:	f014 0f03 	tst.w	r4, #3
 8007ec4:	d002      	beq.n	8007ecc <pxGetNetworkBufferWithDescriptor+0x18>
		xRequestedSizeBytes = ( xRequestedSizeBytes | ( sizeof( size_t ) - 1u ) ) + 1u;
 8007ec6:	f044 0403 	orr.w	r4, r4, #3
 8007eca:	3401      	adds	r4, #1
	if( xSemaphoreTake( xNetworkBufferSemaphore, xBlockTimeTicks ) == pdPASS )
 8007ecc:	2300      	movs	r3, #0
 8007ece:	4619      	mov	r1, r3
 8007ed0:	4822      	ldr	r0, [pc, #136]	; (8007f5c <pxGetNetworkBufferWithDescriptor+0xa8>)
 8007ed2:	6800      	ldr	r0, [r0, #0]
 8007ed4:	f001 f9f2 	bl	80092bc <xQueueGenericReceive>
 8007ed8:	2801      	cmp	r0, #1
 8007eda:	d138      	bne.n	8007f4e <pxGetNetworkBufferWithDescriptor+0x9a>
		taskENTER_CRITICAL();
 8007edc:	f000 fd0a 	bl	80088f4 <vPortEnterCritical>
			pxReturn = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &xFreeBuffersList );
 8007ee0:	4e1f      	ldr	r6, [pc, #124]	; (8007f60 <pxGetNetworkBufferWithDescriptor+0xac>)
 8007ee2:	68f3      	ldr	r3, [r6, #12]
 8007ee4:	68dd      	ldr	r5, [r3, #12]
			uxListRemove( &( pxReturn->xBufferListItem ) );
 8007ee6:	4628      	mov	r0, r5
 8007ee8:	f000 fcae 	bl	8008848 <uxListRemove>
		taskEXIT_CRITICAL();
 8007eec:	f000 fd24 	bl	8008938 <vPortExitCritical>
		uxCount = listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 8007ef0:	6833      	ldr	r3, [r6, #0]
		if( uxMinimumFreeNetworkBuffers > uxCount )
 8007ef2:	4a1c      	ldr	r2, [pc, #112]	; (8007f64 <pxGetNetworkBufferWithDescriptor+0xb0>)
 8007ef4:	6812      	ldr	r2, [r2, #0]
 8007ef6:	4293      	cmp	r3, r2
			uxMinimumFreeNetworkBuffers = uxCount;
 8007ef8:	bf3c      	itt	cc
 8007efa:	4a1a      	ldrcc	r2, [pc, #104]	; (8007f64 <pxGetNetworkBufferWithDescriptor+0xb0>)
 8007efc:	6013      	strcc	r3, [r2, #0]
		configASSERT( pxReturn->pucEthernetBuffer == NULL );
 8007efe:	69ab      	ldr	r3, [r5, #24]
 8007f00:	b123      	cbz	r3, 8007f0c <pxGetNetworkBufferWithDescriptor+0x58>
 8007f02:	f44f 7189 	mov.w	r1, #274	; 0x112
 8007f06:	4818      	ldr	r0, [pc, #96]	; (8007f68 <pxGetNetworkBufferWithDescriptor+0xb4>)
 8007f08:	f003 ff00 	bl	800bd0c <vAssertCalled>
		if( xRequestedSizeBytes > 0 )
 8007f0c:	b984      	cbnz	r4, 8007f30 <pxGetNetworkBufferWithDescriptor+0x7c>
	if( pxReturn == NULL )
 8007f0e:	b1f5      	cbz	r5, 8007f4e <pxGetNetworkBufferWithDescriptor+0x9a>
		iptraceNETWORK_BUFFER_OBTAINED( pxReturn );
 8007f10:	4b12      	ldr	r3, [pc, #72]	; (8007f5c <pxGetNetworkBufferWithDescriptor+0xa8>)
 8007f12:	6818      	ldr	r0, [r3, #0]
 8007f14:	f001 faa6 	bl	8009464 <uxQueueMessagesWaiting>
 8007f18:	4601      	mov	r1, r0
 8007f1a:	2003      	movs	r0, #3
 8007f1c:	f003 f960 	bl	800b1e0 <vExampleDebugStatUpdate>
 8007f20:	2100      	movs	r1, #0
 8007f22:	2013      	movs	r0, #19
 8007f24:	f003 f95c 	bl	800b1e0 <vExampleDebugStatUpdate>
}
 8007f28:	4628      	mov	r0, r5
 8007f2a:	bd70      	pop	{r4, r5, r6, pc}
	xRequestedSizeBytes += 2u;
 8007f2c:	2448      	movs	r4, #72	; 0x48
 8007f2e:	e7cd      	b.n	8007ecc <pxGetNetworkBufferWithDescriptor+0x18>
			pxReturn->pucEthernetBuffer = ( uint8_t * ) pvPortMalloc( xRequestedSizeBytes + ipBUFFER_PADDING );
 8007f30:	f104 000a 	add.w	r0, r4, #10
 8007f34:	f000 fe68 	bl	8008c08 <pvPortMalloc>
 8007f38:	61a8      	str	r0, [r5, #24]
			if( pxReturn->pucEthernetBuffer == NULL )
 8007f3a:	b128      	cbz	r0, 8007f48 <pxGetNetworkBufferWithDescriptor+0x94>
				*( ( NetworkBufferDescriptor_t ** ) ( pxReturn->pucEthernetBuffer ) ) = pxReturn;
 8007f3c:	6005      	str	r5, [r0, #0]
				pxReturn->pucEthernetBuffer += ipBUFFER_PADDING;
 8007f3e:	69ab      	ldr	r3, [r5, #24]
 8007f40:	330a      	adds	r3, #10
 8007f42:	61ab      	str	r3, [r5, #24]
				pxReturn->xDataLength = xRequestedSizeBytes;
 8007f44:	61ec      	str	r4, [r5, #28]
 8007f46:	e7e2      	b.n	8007f0e <pxGetNetworkBufferWithDescriptor+0x5a>
				vReleaseNetworkBufferAndDescriptor( pxReturn );
 8007f48:	4628      	mov	r0, r5
 8007f4a:	f7ff ff8d 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
		iptraceFAILED_TO_OBTAIN_NETWORK_BUFFER();
 8007f4e:	2100      	movs	r1, #0
 8007f50:	2006      	movs	r0, #6
 8007f52:	f003 f945 	bl	800b1e0 <vExampleDebugStatUpdate>
 8007f56:	2500      	movs	r5, #0
 8007f58:	e7e6      	b.n	8007f28 <pxGetNetworkBufferWithDescriptor+0x74>
 8007f5a:	bf00      	nop
 8007f5c:	200008f4 	.word	0x200008f4
 8007f60:	2000055c 	.word	0x2000055c
 8007f64:	20000558 	.word	0x20000558
 8007f68:	0800c740 	.word	0x0800c740

08007f6c <uxGetNumberOfFreeNetworkBuffers>:
 * Returns the number of free network buffers
 */
UBaseType_t uxGetNumberOfFreeNetworkBuffers( void )
{
	return listCURRENT_LIST_LENGTH( &xFreeBuffersList );
}
 8007f6c:	4b01      	ldr	r3, [pc, #4]	; (8007f74 <uxGetNumberOfFreeNetworkBuffers+0x8>)
 8007f6e:	6818      	ldr	r0, [r3, #0]
 8007f70:	4770      	bx	lr
 8007f72:	bf00      	nop
 8007f74:	2000055c 	.word	0x2000055c

08007f78 <uxGetMinimumFreeNetworkBuffers>:
/*-----------------------------------------------------------*/

UBaseType_t uxGetMinimumFreeNetworkBuffers( void )
{
	return uxMinimumFreeNetworkBuffers;
}
 8007f78:	4b01      	ldr	r3, [pc, #4]	; (8007f80 <uxGetMinimumFreeNetworkBuffers+0x8>)
 8007f7a:	6818      	ldr	r0, [r3, #0]
 8007f7c:	4770      	bx	lr
 8007f7e:	bf00      	nop
 8007f80:	20000558 	.word	0x20000558

08007f84 <prvNetworkInterfaceInput>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvNetworkInterfaceInput( void )
{
 8007f84:	b570      	push	{r4, r5, r6, lr}
 8007f86:	b082      	sub	sp, #8
xNetworkBufferDescriptor_t *pxDescriptor;
uint16_t usReceivedLength;
__IO ETH_DMADescTypeDef *xDMARxDescriptor;
uint32_t ulSegCount;
xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };
 8007f88:	2301      	movs	r3, #1
 8007f8a:	f88d 3000 	strb.w	r3, [sp]
 8007f8e:	2300      	movs	r3, #0
 8007f90:	9301      	str	r3, [sp, #4]
const TickType_t xDescriptorWaitTime = pdMS_TO_TICKS( 250 );

	/* get received frame */
	if( HAL_ETH_GetReceivedFrame( &xETH ) != HAL_OK )
 8007f92:	482d      	ldr	r0, [pc, #180]	; (8008048 <prvNetworkInterfaceInput+0xc4>)
 8007f94:	f7f9 ffa4 	bl	8001ee0 <HAL_ETH_GetReceivedFrame>
 8007f98:	2800      	cmp	r0, #0
 8007f9a:	d14e      	bne.n	800803a <prvNetworkInterfaceInput+0xb6>
		usReceivedLength = 0;
	}
	else
	{
		/* Obtain the size of the packet and put it into the "usReceivedLength" variable. */
		usReceivedLength = xETH.RxFrameInfos.length;
 8007f9c:	4b2a      	ldr	r3, [pc, #168]	; (8008048 <prvNetworkInterfaceInput+0xc4>)
 8007f9e:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8007fa0:	b2ac      	uxth	r4, r5

		if( usReceivedLength > 0 )
 8007fa2:	2c00      	cmp	r4, #0
 8007fa4:	d035      	beq.n	8008012 <prvNetworkInterfaceInput+0x8e>
		{
			/* Create a buffer of the required length. */
			pxDescriptor = pxGetNetworkBufferWithDescriptor( usReceivedLength, xDescriptorWaitTime );
 8007fa6:	21fa      	movs	r1, #250	; 0xfa
 8007fa8:	4620      	mov	r0, r4
 8007faa:	f7ff ff83 	bl	8007eb4 <pxGetNetworkBufferWithDescriptor>

			if( pxDescriptor != NULL )
 8007fae:	4606      	mov	r6, r0
 8007fb0:	b350      	cbz	r0, 8008008 <prvNetworkInterfaceInput+0x84>
			{
				xDMARxDescriptor = xETH.RxFrameInfos.FSRxDesc;

				/* Copy remaining data. */
				if( usReceivedLength > pxDescriptor->xDataLength )
 8007fb2:	69c3      	ldr	r3, [r0, #28]
 8007fb4:	429c      	cmp	r4, r3
				{
					usReceivedLength = pxDescriptor->xDataLength;
 8007fb6:	bf88      	it	hi
 8007fb8:	b29c      	uxthhi	r4, r3
				}

				memcpy( pxDescriptor->pucEthernetBuffer, ( uint8_t * ) xETH.RxFrameInfos.buffer, usReceivedLength);
 8007fba:	4622      	mov	r2, r4
 8007fbc:	4b22      	ldr	r3, [pc, #136]	; (8008048 <prvNetworkInterfaceInput+0xc4>)
 8007fbe:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8007fc0:	6980      	ldr	r0, [r0, #24]
 8007fc2:	f004 f84a 	bl	800c05a <memcpy>

				xRxEvent.pvData = ( void * ) pxDescriptor;
 8007fc6:	9601      	str	r6, [sp, #4]

				/* Pass the data to the TCP/IP task for processing. */
				if( xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE )
 8007fc8:	21fa      	movs	r1, #250	; 0xfa
 8007fca:	4668      	mov	r0, sp
 8007fcc:	f7fb ffe4 	bl	8003f98 <xSendEventStructToIPTask>
 8007fd0:	b9a8      	cbnz	r0, 8007ffe <prvNetworkInterfaceInput+0x7a>
				{
					/* Could not send the descriptor into the TCP/IP stack, it
					must be released. */
					vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 8007fd2:	4630      	mov	r0, r6
 8007fd4:	f7ff ff48 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
					iptraceETHERNET_RX_EVENT_LOST();
 8007fd8:	2100      	movs	r1, #0
 8007fda:	200a      	movs	r0, #10
 8007fdc:	f003 f900 	bl	800b1e0 <vExampleDebugStatUpdate>
				{
					iptraceNETWORK_INTERFACE_RECEIVE();
				}

				/* Release descriptors to DMA.  Point to first descriptor. */
				xDMARxDescriptor = xETH.RxFrameInfos.FSRxDesc;
 8007fe0:	4a19      	ldr	r2, [pc, #100]	; (8008048 <prvNetworkInterfaceInput+0xc4>)
 8007fe2:	6b13      	ldr	r3, [r2, #48]	; 0x30
				ulSegCount = xETH.RxFrameInfos.SegCount;
 8007fe4:	6b91      	ldr	r1, [r2, #56]	; 0x38

				/* Set Own bit in RX descriptors: gives the buffers back to
				DMA. */
				while( ulSegCount != 0 )
 8007fe6:	b131      	cbz	r1, 8007ff6 <prvNetworkInterfaceInput+0x72>
				{
					xDMARxDescriptor->Status |= ETH_DMARXDESC_OWN;
 8007fe8:	681a      	ldr	r2, [r3, #0]
 8007fea:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8007fee:	601a      	str	r2, [r3, #0]
					xDMARxDescriptor = ( ETH_DMADescTypeDef * ) xDMARxDescriptor->Buffer2NextDescAddr;
 8007ff0:	68db      	ldr	r3, [r3, #12]
				while( ulSegCount != 0 )
 8007ff2:	3901      	subs	r1, #1
 8007ff4:	d1f8      	bne.n	8007fe8 <prvNetworkInterfaceInput+0x64>
					ulSegCount--;
				}

				/* Clear Segment_Count */
				xETH.RxFrameInfos.SegCount = 0;
 8007ff6:	2200      	movs	r2, #0
 8007ff8:	4b13      	ldr	r3, [pc, #76]	; (8008048 <prvNetworkInterfaceInput+0xc4>)
 8007ffa:	639a      	str	r2, [r3, #56]	; 0x38
 8007ffc:	e00c      	b.n	8008018 <prvNetworkInterfaceInput+0x94>
					iptraceNETWORK_INTERFACE_RECEIVE();
 8007ffe:	2100      	movs	r1, #0
 8008000:	4608      	mov	r0, r1
 8008002:	f003 f8ed 	bl	800b1e0 <vExampleDebugStatUpdate>
 8008006:	e7eb      	b.n	8007fe0 <prvNetworkInterfaceInput+0x5c>
			}
			else
			{
				FreeRTOS_printf( ( "prvNetworkInterfaceInput: pxGetNetworkBuffer failed length %u\n", usReceivedLength ) );
 8008008:	4621      	mov	r1, r4
 800800a:	4810      	ldr	r0, [pc, #64]	; (800804c <prvNetworkInterfaceInput+0xc8>)
 800800c:	f003 f9e4 	bl	800b3d8 <lUDPLoggingPrintf>
 8008010:	e002      	b.n	8008018 <prvNetworkInterfaceInput+0x94>
			}
		}
		else
		{
			FreeRTOS_printf( ( "prvNetworkInterfaceInput: zero-sized packet?\n" ) );
 8008012:	480f      	ldr	r0, [pc, #60]	; (8008050 <prvNetworkInterfaceInput+0xcc>)
 8008014:	f003 f9e0 	bl	800b3d8 <lUDPLoggingPrintf>
			pxDescriptor = NULL;
		}

		/* When Rx Buffer unavailable flag is set clear it and resume
		reception. */
		if( ( xETH.Instance->DMASR & ETH_DMASR_RBUS ) != 0 )
 8008018:	4b0b      	ldr	r3, [pc, #44]	; (8008048 <prvNetworkInterfaceInput+0xc4>)
 800801a:	681b      	ldr	r3, [r3, #0]
 800801c:	f241 0214 	movw	r2, #4116	; 0x1014
 8008020:	589a      	ldr	r2, [r3, r2]
 8008022:	f012 0f80 	tst.w	r2, #128	; 0x80
 8008026:	d009      	beq.n	800803c <prvNetworkInterfaceInput+0xb8>
		{
			/* Clear RBUS ETHERNET DMA flag. */
			xETH.Instance->DMASR = ETH_DMASR_RBUS;
 8008028:	2180      	movs	r1, #128	; 0x80
 800802a:	f241 0214 	movw	r2, #4116	; 0x1014
 800802e:	5099      	str	r1, [r3, r2]

			/* Resume DMA reception. */
			xETH.Instance->DMARPDR = 0;
 8008030:	2100      	movs	r1, #0
 8008032:	f241 0208 	movw	r2, #4104	; 0x1008
 8008036:	5099      	str	r1, [r3, r2]
 8008038:	e000      	b.n	800803c <prvNetworkInterfaceInput+0xb8>
		usReceivedLength = 0;
 800803a:	2400      	movs	r4, #0
		}
	}

	return ( usReceivedLength > 0 );
}
 800803c:	1c20      	adds	r0, r4, #0
 800803e:	bf18      	it	ne
 8008040:	2001      	movne	r0, #1
 8008042:	b002      	add	sp, #8
 8008044:	bd70      	pop	{r4, r5, r6, pc}
 8008046:	bf00      	nop
 8008048:	2000090c 	.word	0x2000090c
 800804c:	0800c884 	.word	0x0800c884
 8008050:	0800c8c4 	.word	0x0800c8c4

08008054 <prvEthernetUpdateConfig>:
	ulACRValue = ulAdvertise;
}
/*-----------------------------------------------------------*/

static void prvEthernetUpdateConfig( BaseType_t xForce )
{
 8008054:	b530      	push	{r4, r5, lr}
 8008056:	b085      	sub	sp, #20
 8008058:	4604      	mov	r4, r0
__IO uint32_t ulTimeout = 0;
 800805a:	2300      	movs	r3, #0
 800805c:	9303      	str	r3, [sp, #12]
uint32_t ulRegValue = 0;
 800805e:	9302      	str	r3, [sp, #8]

	FreeRTOS_printf( ( "prvEthernetUpdateConfig: LS %d Force %d\n",
 8008060:	4b4b      	ldr	r3, [pc, #300]	; (8008190 <prvEthernetUpdateConfig+0x13c>)
 8008062:	6819      	ldr	r1, [r3, #0]
 8008064:	4602      	mov	r2, r0
 8008066:	f3c1 0180 	ubfx	r1, r1, #2, #1
 800806a:	484a      	ldr	r0, [pc, #296]	; (8008194 <prvEthernetUpdateConfig+0x140>)
 800806c:	f003 f9b4 	bl	800b3d8 <lUDPLoggingPrintf>
		( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ,
		xForce ) );

	if( ( xForce != pdFALSE ) || ( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) )
 8008070:	b92c      	cbnz	r4, 800807e <prvEthernetUpdateConfig+0x2a>
 8008072:	4b47      	ldr	r3, [pc, #284]	; (8008190 <prvEthernetUpdateConfig+0x13c>)
 8008074:	681b      	ldr	r3, [r3, #0]
 8008076:	f013 0f04 	tst.w	r3, #4
 800807a:	f000 8085 	beq.w	8008188 <prvEthernetUpdateConfig+0x134>
	{
		/* Restart the auto-negotiation. */
		if( xETH.Init.AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE )
 800807e:	4b46      	ldr	r3, [pc, #280]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 8008080:	685b      	ldr	r3, [r3, #4]
 8008082:	2b00      	cmp	r3, #0
 8008084:	d064      	beq.n	8008150 <prvEthernetUpdateConfig+0xfc>
		{
			/* Enable Auto-Negotiation. */
			HAL_ETH_WritePHYRegister( &xETH, PHY_BCR, ulBCRvalue | BMCR_ANRESTART );
 8008086:	4b45      	ldr	r3, [pc, #276]	; (800819c <prvEthernetUpdateConfig+0x148>)
 8008088:	681a      	ldr	r2, [r3, #0]
 800808a:	4c43      	ldr	r4, [pc, #268]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 800808c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8008090:	2100      	movs	r1, #0
 8008092:	4620      	mov	r0, r4
 8008094:	f7f9 ffda 	bl	800204c <HAL_ETH_WritePHYRegister>
			HAL_ETH_WritePHYRegister( &xETH, PHY_REG_04_ADVERTISE, ulACRValue);
 8008098:	4b41      	ldr	r3, [pc, #260]	; (80081a0 <prvEthernetUpdateConfig+0x14c>)
 800809a:	681a      	ldr	r2, [r3, #0]
 800809c:	2104      	movs	r1, #4
 800809e:	4620      	mov	r0, r4
 80080a0:	f7f9 ffd4 	bl	800204c <HAL_ETH_WritePHYRegister>
			/* Wait until the auto-negotiation will be completed */
			do
			{
				ulTimeout++;
				HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &ulRegValue );
			} while( ( ( ulRegValue & PHY_AUTONEGO_COMPLETE) == 0 ) && ( ulTimeout < PHY_READ_TO ) );
 80080a4:	4d3f      	ldr	r5, [pc, #252]	; (80081a4 <prvEthernetUpdateConfig+0x150>)
				ulTimeout++;
 80080a6:	9b03      	ldr	r3, [sp, #12]
 80080a8:	3301      	adds	r3, #1
 80080aa:	9303      	str	r3, [sp, #12]
				HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &ulRegValue );
 80080ac:	aa02      	add	r2, sp, #8
 80080ae:	2101      	movs	r1, #1
 80080b0:	4620      	mov	r0, r4
 80080b2:	f7f9 ff7d 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
			} while( ( ( ulRegValue & PHY_AUTONEGO_COMPLETE) == 0 ) && ( ulTimeout < PHY_READ_TO ) );
 80080b6:	9b02      	ldr	r3, [sp, #8]
 80080b8:	f013 0f20 	tst.w	r3, #32
 80080bc:	d102      	bne.n	80080c4 <prvEthernetUpdateConfig+0x70>
 80080be:	9b03      	ldr	r3, [sp, #12]
 80080c0:	42ab      	cmp	r3, r5
 80080c2:	d9f0      	bls.n	80080a6 <prvEthernetUpdateConfig+0x52>

			HAL_ETH_WritePHYRegister( &xETH, PHY_BCR, ulBCRvalue & ~BMCR_ANRESTART );
 80080c4:	4b35      	ldr	r3, [pc, #212]	; (800819c <prvEthernetUpdateConfig+0x148>)
 80080c6:	681a      	ldr	r2, [r3, #0]
 80080c8:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80080cc:	2100      	movs	r1, #0
 80080ce:	4832      	ldr	r0, [pc, #200]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 80080d0:	f7f9 ffbc 	bl	800204c <HAL_ETH_WritePHYRegister>

			if( ulTimeout < PHY_READ_TO )
 80080d4:	9a03      	ldr	r2, [sp, #12]
 80080d6:	4b33      	ldr	r3, [pc, #204]	; (80081a4 <prvEthernetUpdateConfig+0x150>)
 80080d8:	429a      	cmp	r2, r3
 80080da:	d843      	bhi.n	8008164 <prvEthernetUpdateConfig+0x110>
			{
				/* Reset Timeout counter. */
				ulTimeout = 0;
 80080dc:	2300      	movs	r3, #0
 80080de:	9303      	str	r3, [sp, #12]

				/* Read the result of the auto-negotiation. */
				HAL_ETH_ReadPHYRegister( &xETH, PHY_SR, &ulRegValue);
 80080e0:	aa02      	add	r2, sp, #8
 80080e2:	2110      	movs	r1, #16
 80080e4:	482c      	ldr	r0, [pc, #176]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 80080e6:	f7f9 ff63 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
				if( ( ulRegValue & PHY_LINK_STATUS ) != 0 )
 80080ea:	9902      	ldr	r1, [sp, #8]
 80080ec:	f011 0501 	ands.w	r5, r1, #1
				{
					ulPHYLinkStatus |= BMSR_LINK_STATUS;
 80080f0:	4a27      	ldr	r2, [pc, #156]	; (8008190 <prvEthernetUpdateConfig+0x13c>)
 80080f2:	6813      	ldr	r3, [r2, #0]
 80080f4:	bf14      	ite	ne
 80080f6:	f043 0304 	orrne.w	r3, r3, #4
				}
				else
				{
					ulPHYLinkStatus &= ~( BMSR_LINK_STATUS );
 80080fa:	f023 0304 	biceq.w	r3, r3, #4
 80080fe:	6013      	str	r3, [r2, #0]
				}

				FreeRTOS_printf( ( ">> Autonego ready: %08x: %s duplex %u mbit %s status\n",
 8008100:	f001 0404 	and.w	r4, r1, #4
 8008104:	f001 0302 	and.w	r3, r1, #2
 8008108:	2b00      	cmp	r3, #0
 800810a:	bf14      	ite	ne
 800810c:	230a      	movne	r3, #10
 800810e:	2364      	moveq	r3, #100	; 0x64
 8008110:	4a25      	ldr	r2, [pc, #148]	; (80081a8 <prvEthernetUpdateConfig+0x154>)
 8008112:	4826      	ldr	r0, [pc, #152]	; (80081ac <prvEthernetUpdateConfig+0x158>)
 8008114:	2d00      	cmp	r5, #0
 8008116:	bf08      	it	eq
 8008118:	4610      	moveq	r0, r2
 800811a:	9000      	str	r0, [sp, #0]
 800811c:	4824      	ldr	r0, [pc, #144]	; (80081b0 <prvEthernetUpdateConfig+0x15c>)
 800811e:	4a25      	ldr	r2, [pc, #148]	; (80081b4 <prvEthernetUpdateConfig+0x160>)
 8008120:	2c00      	cmp	r4, #0
 8008122:	bf08      	it	eq
 8008124:	4602      	moveq	r2, r0
 8008126:	4824      	ldr	r0, [pc, #144]	; (80081b8 <prvEthernetUpdateConfig+0x164>)
 8008128:	f003 f956 	bl	800b3d8 <lUDPLoggingPrintf>
					(ulRegValue & PHY_SPEED_STATUS) ? 10 : 100,
					(ulRegValue & PHY_LINK_STATUS) ? "high" : "low" ) );

				/* Configure the MAC with the Duplex Mode fixed by the
				auto-negotiation process. */
				if( ( ulRegValue & PHY_DUPLEX_STATUS ) != ( uint32_t ) RESET )
 800812c:	9b02      	ldr	r3, [sp, #8]
 800812e:	f013 0f04 	tst.w	r3, #4
				{
					/* Set Ethernet duplex mode to Full-duplex following the
					auto-negotiation. */
					xETH.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 8008132:	bf14      	ite	ne
 8008134:	f44f 6100 	movne.w	r1, #2048	; 0x800
				}
				else
				{
					/* Set Ethernet duplex mode to Half-duplex following the
					auto-negotiation. */
					xETH.Init.DuplexMode = ETH_MODE_HALFDUPLEX;
 8008138:	2100      	moveq	r1, #0
 800813a:	4a17      	ldr	r2, [pc, #92]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 800813c:	60d1      	str	r1, [r2, #12]
				}

				/* Configure the MAC with the speed fixed by the
				auto-negotiation process. */
				if( ( ulRegValue & PHY_SPEED_STATUS) != 0 )
 800813e:	f013 0f02 	tst.w	r3, #2
				{
					/* Set Ethernet speed to 10M following the
					auto-negotiation. */
					xETH.Init.Speed = ETH_SPEED_10M;
 8008142:	bf14      	ite	ne
 8008144:	2200      	movne	r2, #0
				}
				else
				{
					/* Set Ethernet speed to 100M following the
					auto-negotiation. */
					xETH.Init.Speed = ETH_SPEED_100M;
 8008146:	f44f 4280 	moveq.w	r2, #16384	; 0x4000
 800814a:	4b13      	ldr	r3, [pc, #76]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 800814c:	609a      	str	r2, [r3, #8]
 800814e:	e009      	b.n	8008164 <prvEthernetUpdateConfig+0x110>
			/* Check parameters */
			assert_param( IS_ETH_SPEED( xETH.Init.Speed ) );
			assert_param( IS_ETH_DUPLEX_MODE( xETH.Init.DuplexMode ) );

			/* Set MAC Speed and Duplex Mode to PHY */
			usValue = ( uint16_t ) ( xETH.Init.DuplexMode >> 3 ) | ( uint16_t ) ( xETH.Init.Speed >> 1 );
 8008150:	4811      	ldr	r0, [pc, #68]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 8008152:	68c2      	ldr	r2, [r0, #12]
 8008154:	6883      	ldr	r3, [r0, #8]
 8008156:	085b      	lsrs	r3, r3, #1
 8008158:	ea43 02d2 	orr.w	r2, r3, r2, lsr #3
			HAL_ETH_WritePHYRegister( &xETH, PHY_BCR, usValue );
 800815c:	b292      	uxth	r2, r2
 800815e:	2100      	movs	r1, #0
 8008160:	f7f9 ff74 	bl	800204c <HAL_ETH_WritePHYRegister>
		}

		/* ETHERNET MAC Re-Configuration */
		HAL_ETH_ConfigMAC( &xETH, (ETH_MACInitTypeDef *) NULL);
 8008164:	4c0c      	ldr	r4, [pc, #48]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 8008166:	2100      	movs	r1, #0
 8008168:	4620      	mov	r0, r4
 800816a:	f7fa f835 	bl	80021d8 <HAL_ETH_ConfigMAC>

		/* Restart MAC interface */
		HAL_ETH_Start( &xETH);
 800816e:	4620      	mov	r0, r4
 8008170:	f7f9 ffba 	bl	80020e8 <HAL_ETH_Start>

		FreeRTOS_printf( ( "MACCR = %08x DMABMR = %08x\n",
 8008174:	6823      	ldr	r3, [r4, #0]
 8008176:	6819      	ldr	r1, [r3, #0]
 8008178:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800817c:	681a      	ldr	r2, [r3, #0]
 800817e:	480f      	ldr	r0, [pc, #60]	; (80081bc <prvEthernetUpdateConfig+0x168>)
 8008180:	f003 f92a 	bl	800b3d8 <lUDPLoggingPrintf>
	else
	{
		/* Stop MAC interface */
		HAL_ETH_Stop( &xETH );
	}
}
 8008184:	b005      	add	sp, #20
 8008186:	bd30      	pop	{r4, r5, pc}
		HAL_ETH_Stop( &xETH );
 8008188:	4803      	ldr	r0, [pc, #12]	; (8008198 <prvEthernetUpdateConfig+0x144>)
 800818a:	f7f9 ffe9 	bl	8002160 <HAL_ETH_Stop>
}
 800818e:	e7f9      	b.n	8008184 <prvEthernetUpdateConfig+0x130>
 8008190:	20000904 	.word	0x20000904
 8008194:	0800c804 	.word	0x0800c804
 8008198:	2000090c 	.word	0x2000090c
 800819c:	200008fc 	.word	0x200008fc
 80081a0:	200008f8 	.word	0x200008f8
 80081a4:	0004fffe 	.word	0x0004fffe
 80081a8:	0800c800 	.word	0x0800c800
 80081ac:	0800c7f8 	.word	0x0800c7f8
 80081b0:	0800c7f0 	.word	0x0800c7f0
 80081b4:	0800c7e8 	.word	0x0800c7e8
 80081b8:	0800c830 	.word	0x0800c830
 80081bc:	0800c868 	.word	0x0800c868

080081c0 <prvEMACHandlerTask>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvEMACHandlerTask( void *pvParameters )
{
 80081c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80081c4:	b085      	sub	sp, #20
const TickType_t ulMaxBlockTime = pdMS_TO_TICKS( 100UL );

	/* Remove compiler warnings about unused parameters. */
	( void ) pvParameters;

	vTaskSetTimeOutState( &xPhyTime );
 80081c6:	a802      	add	r0, sp, #8
 80081c8:	f001 feee 	bl	8009fa8 <vTaskSetTimeOutState>
	xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
 80081cc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80081d0:	9301      	str	r3, [sp, #4]
BaseType_t xResult = 0;
 80081d2:	2600      	movs	r6, #0
UBaseType_t uxLastMinBufferCount = 0;
 80081d4:	4637      	mov	r7, r6
		if( uxLastMinBufferCount != uxCurrentCount )
		{
			/* The logging produced below may be helpful
			while tuning +TCP: see how many buffers are in use. */
			uxLastMinBufferCount = uxCurrentCount;
			FreeRTOS_printf( ( "Network buffers: %lu lowest %lu\n",
 80081d6:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 80082c4 <prvEMACHandlerTask+0x104>
				FreeRTOS_printf( ( "Queue space: lowest %lu\n", uxCurrentCount ) );
			}
		}
		#endif /* ipconfigCHECK_IP_QUEUE_SPACE */

		if( ( ulISREvents & EMAC_IF_ALL_EVENT ) == 0 )
 80081da:	4c37      	ldr	r4, [pc, #220]	; (80082b8 <prvEMACHandlerTask+0xf8>)
			xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
			xResult = 0;
		}
		else if( xTaskCheckForTimeOut( &xPhyTime, &xPhyRemTime ) != pdFALSE )
		{
			HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &xStatus );
 80081dc:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 80082c8 <prvEMACHandlerTask+0x108>
 80081e0:	e01e      	b.n	8008220 <prvEMACHandlerTask+0x60>
			ulTaskNotifyTake( pdFALSE, ulMaxBlockTime );
 80081e2:	2164      	movs	r1, #100	; 0x64
 80081e4:	2000      	movs	r0, #0
 80081e6:	f002 f9c9 	bl	800a57c <ulTaskNotifyTake>
 80081ea:	e029      	b.n	8008240 <prvEMACHandlerTask+0x80>
		if( ( ulISREvents & EMAC_IF_TX_EVENT ) != 0 )
 80081ec:	6823      	ldr	r3, [r4, #0]
 80081ee:	f013 0f02 	tst.w	r3, #2
 80081f2:	d003      	beq.n	80081fc <prvEMACHandlerTask+0x3c>
			ulISREvents &= ~EMAC_IF_TX_EVENT;
 80081f4:	6823      	ldr	r3, [r4, #0]
 80081f6:	f023 0302 	bic.w	r3, r3, #2
 80081fa:	6023      	str	r3, [r4, #0]
		if( ( ulISREvents & EMAC_IF_ERR_EVENT ) != 0 )
 80081fc:	6823      	ldr	r3, [r4, #0]
 80081fe:	f013 0f04 	tst.w	r3, #4
 8008202:	d003      	beq.n	800820c <prvEMACHandlerTask+0x4c>
			ulISREvents &= ~EMAC_IF_ERR_EVENT;
 8008204:	6823      	ldr	r3, [r4, #0]
 8008206:	f023 0304 	bic.w	r3, r3, #4
 800820a:	6023      	str	r3, [r4, #0]
		if( xResult > 0 )
 800820c:	2e00      	cmp	r6, #0
 800820e:	dd28      	ble.n	8008262 <prvEMACHandlerTask+0xa2>
			vTaskSetTimeOutState( &xPhyTime );
 8008210:	a802      	add	r0, sp, #8
 8008212:	f001 fec9 	bl	8009fa8 <vTaskSetTimeOutState>
			xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
 8008216:	f643 2398 	movw	r3, #15000	; 0x3a98
 800821a:	9301      	str	r3, [sp, #4]
			xResult = 0;
 800821c:	2600      	movs	r6, #0
 800821e:	462f      	mov	r7, r5
		uxCurrentCount = uxGetMinimumFreeNetworkBuffers();
 8008220:	f7ff feaa 	bl	8007f78 <uxGetMinimumFreeNetworkBuffers>
 8008224:	4605      	mov	r5, r0
		if( uxLastMinBufferCount != uxCurrentCount )
 8008226:	4287      	cmp	r7, r0
 8008228:	d006      	beq.n	8008238 <prvEMACHandlerTask+0x78>
			FreeRTOS_printf( ( "Network buffers: %lu lowest %lu\n",
 800822a:	f7ff fe9f 	bl	8007f6c <uxGetNumberOfFreeNetworkBuffers>
 800822e:	462a      	mov	r2, r5
 8008230:	4601      	mov	r1, r0
 8008232:	4640      	mov	r0, r8
 8008234:	f003 f8d0 	bl	800b3d8 <lUDPLoggingPrintf>
		if( ( ulISREvents & EMAC_IF_ALL_EVENT ) == 0 )
 8008238:	6823      	ldr	r3, [r4, #0]
 800823a:	f013 0f07 	tst.w	r3, #7
 800823e:	d0d0      	beq.n	80081e2 <prvEMACHandlerTask+0x22>
		if( ( ulISREvents & EMAC_IF_RX_EVENT ) != 0 )
 8008240:	6823      	ldr	r3, [r4, #0]
 8008242:	f013 0f01 	tst.w	r3, #1
 8008246:	d0d1      	beq.n	80081ec <prvEMACHandlerTask+0x2c>
			ulISREvents &= ~EMAC_IF_RX_EVENT;
 8008248:	6823      	ldr	r3, [r4, #0]
 800824a:	f023 0301 	bic.w	r3, r3, #1
 800824e:	6023      	str	r3, [r4, #0]
			xResult = prvNetworkInterfaceInput();
 8008250:	f7ff fe98 	bl	8007f84 <prvNetworkInterfaceInput>
			if( xResult > 0 )
 8008254:	1e06      	subs	r6, r0, #0
 8008256:	ddc9      	ble.n	80081ec <prvEMACHandlerTask+0x2c>
			  	while( prvNetworkInterfaceInput() > 0 )
 8008258:	f7ff fe94 	bl	8007f84 <prvNetworkInterfaceInput>
 800825c:	2800      	cmp	r0, #0
 800825e:	dcfb      	bgt.n	8008258 <prvEMACHandlerTask+0x98>
 8008260:	e7c4      	b.n	80081ec <prvEMACHandlerTask+0x2c>
		else if( xTaskCheckForTimeOut( &xPhyTime, &xPhyRemTime ) != pdFALSE )
 8008262:	a901      	add	r1, sp, #4
 8008264:	a802      	add	r0, sp, #8
 8008266:	f001 feb5 	bl	8009fd4 <xTaskCheckForTimeOut>
 800826a:	2800      	cmp	r0, #0
 800826c:	d0d7      	beq.n	800821e <prvEMACHandlerTask+0x5e>
			HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &xStatus );
 800826e:	466a      	mov	r2, sp
 8008270:	2101      	movs	r1, #1
 8008272:	4648      	mov	r0, r9
 8008274:	f7f9 fe9c 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != ( xStatus & BMSR_LINK_STATUS ) )
 8008278:	9900      	ldr	r1, [sp, #0]
 800827a:	4b10      	ldr	r3, [pc, #64]	; (80082bc <prvEMACHandlerTask+0xfc>)
 800827c:	681b      	ldr	r3, [r3, #0]
 800827e:	404b      	eors	r3, r1
 8008280:	f013 0f04 	tst.w	r3, #4
 8008284:	d10d      	bne.n	80082a2 <prvEMACHandlerTask+0xe2>
				ulPHYLinkStatus = xStatus;
				FreeRTOS_printf( ( "prvEMACHandlerTask: PHY LS now %d\n", ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) );
				prvEthernetUpdateConfig( pdFALSE );
			}

			vTaskSetTimeOutState( &xPhyTime );
 8008286:	a802      	add	r0, sp, #8
 8008288:	f001 fe8e 	bl	8009fa8 <vTaskSetTimeOutState>
			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 800828c:	4b0b      	ldr	r3, [pc, #44]	; (80082bc <prvEMACHandlerTask+0xfc>)
 800828e:	681b      	ldr	r3, [r3, #0]
 8008290:	f013 0f04 	tst.w	r3, #4
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
 8008294:	bf14      	ite	ne
 8008296:	f643 2398 	movwne	r3, #15000	; 0x3a98
			}
			else
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
 800829a:	f44f 737a 	moveq.w	r3, #1000	; 0x3e8
 800829e:	9301      	str	r3, [sp, #4]
 80082a0:	e7bd      	b.n	800821e <prvEMACHandlerTask+0x5e>
				ulPHYLinkStatus = xStatus;
 80082a2:	4b06      	ldr	r3, [pc, #24]	; (80082bc <prvEMACHandlerTask+0xfc>)
 80082a4:	6019      	str	r1, [r3, #0]
				FreeRTOS_printf( ( "prvEMACHandlerTask: PHY LS now %d\n", ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) );
 80082a6:	f3c1 0180 	ubfx	r1, r1, #2, #1
 80082aa:	4805      	ldr	r0, [pc, #20]	; (80082c0 <prvEMACHandlerTask+0x100>)
 80082ac:	f003 f894 	bl	800b3d8 <lUDPLoggingPrintf>
				prvEthernetUpdateConfig( pdFALSE );
 80082b0:	2000      	movs	r0, #0
 80082b2:	f7ff fecf 	bl	8008054 <prvEthernetUpdateConfig>
 80082b6:	e7e6      	b.n	8008286 <prvEMACHandlerTask+0xc6>
 80082b8:	20000900 	.word	0x20000900
 80082bc:	20000904 	.word	0x20000904
 80082c0:	0800c7c4 	.word	0x0800c7c4
 80082c4:	0800c7a0 	.word	0x0800c7a0
 80082c8:	2000090c 	.word	0x2000090c

080082cc <HAL_ETH_RxCpltCallback>:
{
 80082cc:	b500      	push	{lr}
 80082ce:	b083      	sub	sp, #12
BaseType_t xHigherPriorityTaskWoken = 0;
 80082d0:	2300      	movs	r3, #0
 80082d2:	9301      	str	r3, [sp, #4]
    ulISREvents |= EMAC_IF_RX_EVENT;
 80082d4:	4a0b      	ldr	r2, [pc, #44]	; (8008304 <HAL_ETH_RxCpltCallback+0x38>)
 80082d6:	6813      	ldr	r3, [r2, #0]
 80082d8:	f043 0301 	orr.w	r3, r3, #1
 80082dc:	6013      	str	r3, [r2, #0]
	if( xEMACTaskHandle != NULL )
 80082de:	4b0a      	ldr	r3, [pc, #40]	; (8008308 <HAL_ETH_RxCpltCallback+0x3c>)
 80082e0:	6818      	ldr	r0, [r3, #0]
 80082e2:	b160      	cbz	r0, 80082fe <HAL_ETH_RxCpltCallback+0x32>
		vTaskNotifyGiveFromISR( xEMACTaskHandle, &xHigherPriorityTaskWoken );
 80082e4:	a901      	add	r1, sp, #4
 80082e6:	f002 f9ef 	bl	800a6c8 <vTaskNotifyGiveFromISR>
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 80082ea:	9b01      	ldr	r3, [sp, #4]
 80082ec:	b13b      	cbz	r3, 80082fe <HAL_ETH_RxCpltCallback+0x32>
 80082ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80082f2:	4b06      	ldr	r3, [pc, #24]	; (800830c <HAL_ETH_RxCpltCallback+0x40>)
 80082f4:	601a      	str	r2, [r3, #0]
 80082f6:	f3bf 8f4f 	dsb	sy
 80082fa:	f3bf 8f6f 	isb	sy
}
 80082fe:	b003      	add	sp, #12
 8008300:	f85d fb04 	ldr.w	pc, [sp], #4
 8008304:	20000900 	.word	0x20000900
 8008308:	20000908 	.word	0x20000908
 800830c:	e000ed04 	.word	0xe000ed04

08008310 <HAL_ETH_TxCpltCallback>:
{
 8008310:	4770      	bx	lr
	...

08008314 <xNetworkInterfaceInitialise>:
	if( xEMACTaskHandle == NULL )
 8008314:	4b26      	ldr	r3, [pc, #152]	; (80083b0 <xNetworkInterfaceInitialise+0x9c>)
 8008316:	681b      	ldr	r3, [r3, #0]
 8008318:	b123      	cbz	r3, 8008324 <xNetworkInterfaceInitialise+0x10>
	return ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0;
 800831a:	4b26      	ldr	r3, [pc, #152]	; (80083b4 <xNetworkInterfaceInitialise+0xa0>)
 800831c:	6818      	ldr	r0, [r3, #0]
}
 800831e:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8008322:	4770      	bx	lr
{
 8008324:	b570      	push	{r4, r5, r6, lr}
 8008326:	b082      	sub	sp, #8
		xETH.Instance = ETH;
 8008328:	4c23      	ldr	r4, [pc, #140]	; (80083b8 <xNetworkInterfaceInitialise+0xa4>)
 800832a:	4b24      	ldr	r3, [pc, #144]	; (80083bc <xNetworkInterfaceInitialise+0xa8>)
 800832c:	6023      	str	r3, [r4, #0]
		xETH.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 800832e:	2501      	movs	r5, #1
 8008330:	6065      	str	r5, [r4, #4]
		xETH.Init.Speed = ETH_SPEED_100M;
 8008332:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8008336:	60a3      	str	r3, [r4, #8]
		xETH.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 8008338:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800833c:	60e3      	str	r3, [r4, #12]
		xETH.Init.PhyAddress = 1;
 800833e:	8225      	strh	r5, [r4, #16]
		xETH.Init.MACAddr = ( uint8_t *) ucMACAddress;
 8008340:	4b1f      	ldr	r3, [pc, #124]	; (80083c0 <xNetworkInterfaceInitialise+0xac>)
 8008342:	6163      	str	r3, [r4, #20]
		xETH.Init.RxMode = ETH_RXINTERRUPT_MODE;
 8008344:	61a5      	str	r5, [r4, #24]
		xETH.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 8008346:	2600      	movs	r6, #0
 8008348:	61e6      	str	r6, [r4, #28]
		xETH.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 800834a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 800834e:	6223      	str	r3, [r4, #32]
		hal_eth_init_status = HAL_ETH_Init( &xETH );
 8008350:	4620      	mov	r0, r4
 8008352:	f7f9 fc4d 	bl	8001bf0 <HAL_ETH_Init>
		__HAL_ETH_DMA_ENABLE_IT( &xETH , ETH_DMA_ALL_INTS );
 8008356:	6821      	ldr	r1, [r4, #0]
 8008358:	f241 021c 	movw	r2, #4124	; 0x101c
 800835c:	5888      	ldr	r0, [r1, r2]
 800835e:	4b19      	ldr	r3, [pc, #100]	; (80083c4 <xNetworkInterfaceInitialise+0xb0>)
 8008360:	4303      	orrs	r3, r0
 8008362:	508b      	str	r3, [r1, r2]
		HAL_ETH_DMATxDescListInit( &xETH, DMATxDscrTab, Tx_Buff[ 0 ], ETH_TXBUFNB );
 8008364:	2302      	movs	r3, #2
 8008366:	4a18      	ldr	r2, [pc, #96]	; (80083c8 <xNetworkInterfaceInitialise+0xb4>)
 8008368:	4918      	ldr	r1, [pc, #96]	; (80083cc <xNetworkInterfaceInitialise+0xb8>)
 800836a:	4620      	mov	r0, r4
 800836c:	f7f9 fbc3 	bl	8001af6 <HAL_ETH_DMATxDescListInit>
		HAL_ETH_DMARxDescListInit( &xETH, DMARxDscrTab, Rx_Buff[ 0 ], ETH_RXBUFNB );
 8008370:	2304      	movs	r3, #4
 8008372:	4a17      	ldr	r2, [pc, #92]	; (80083d0 <xNetworkInterfaceInitialise+0xbc>)
 8008374:	4917      	ldr	r1, [pc, #92]	; (80083d4 <xNetworkInterfaceInitialise+0xc0>)
 8008376:	4620      	mov	r0, r4
 8008378:	f7f9 fc00 	bl	8001b7c <HAL_ETH_DMARxDescListInit>
	( *(__IO uint32_t *)( ( uint32_t ) ( ETH_MAC_ADDR_HBASE + ulIndex ) ) ) = ulTempReg;
 800837c:	4a16      	ldr	r2, [pc, #88]	; (80083d8 <xNetworkInterfaceInitialise+0xc4>)
 800837e:	4b17      	ldr	r3, [pc, #92]	; (80083dc <xNetworkInterfaceInitialise+0xc8>)
 8008380:	601a      	str	r2, [r3, #0]
	( *(__IO uint32_t *) ( ( uint32_t ) ( ETH_MAC_ADDR_LBASE + ulIndex ) ) ) = ulTempReg;
 8008382:	4a17      	ldr	r2, [pc, #92]	; (80083e0 <xNetworkInterfaceInitialise+0xcc>)
 8008384:	3304      	adds	r3, #4
 8008386:	601a      	str	r2, [r3, #0]
		prvEthernetUpdateConfig( pdTRUE );
 8008388:	4628      	mov	r0, r5
 800838a:	f7ff fe63 	bl	8008054 <prvEthernetUpdateConfig>
		xTaskCreate( prvEMACHandlerTask, "EMAC", configEMAC_TASK_STACK_SIZE, NULL, configMAX_PRIORITIES - 1, &xEMACTaskHandle );
 800838e:	4b08      	ldr	r3, [pc, #32]	; (80083b0 <xNetworkInterfaceInitialise+0x9c>)
 8008390:	9301      	str	r3, [sp, #4]
 8008392:	2306      	movs	r3, #6
 8008394:	9300      	str	r3, [sp, #0]
 8008396:	4633      	mov	r3, r6
 8008398:	f44f 7280 	mov.w	r2, #256	; 0x100
 800839c:	4911      	ldr	r1, [pc, #68]	; (80083e4 <xNetworkInterfaceInitialise+0xd0>)
 800839e:	4812      	ldr	r0, [pc, #72]	; (80083e8 <xNetworkInterfaceInitialise+0xd4>)
 80083a0:	f001 f930 	bl	8009604 <xTaskCreate>
	return ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0;
 80083a4:	4b03      	ldr	r3, [pc, #12]	; (80083b4 <xNetworkInterfaceInitialise+0xa0>)
 80083a6:	6818      	ldr	r0, [r3, #0]
}
 80083a8:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80083ac:	b002      	add	sp, #8
 80083ae:	bd70      	pop	{r4, r5, r6, pc}
 80083b0:	20000908 	.word	0x20000908
 80083b4:	20000904 	.word	0x20000904
 80083b8:	2000090c 	.word	0x2000090c
 80083bc:	40028000 	.word	0x40028000
 80083c0:	0800d618 	.word	0x0800d618
 80083c4:	3801e7fb 	.word	0x3801e7fb
 80083c8:	200040bc 	.word	0x200040bc
 80083cc:	2000282c 	.word	0x2000282c
 80083d0:	2000286c 	.word	0x2000286c
 80083d4:	2000403c 	.word	0x2000403c
 80083d8:	8000fc00 	.word	0x8000fc00
 80083dc:	40028048 	.word	0x40028048
 80083e0:	005e0001 	.word	0x005e0001
 80083e4:	0800c950 	.word	0x0800c950
 80083e8:	080081c1 	.word	0x080081c1

080083ec <xNetworkInterfaceOutput>:
{
 80083ec:	b570      	push	{r4, r5, r6, lr}
 80083ee:	4604      	mov	r4, r0
 80083f0:	460e      	mov	r6, r1
		pxPacket = ( ProtocolPacket_t * ) ( pxDescriptor->pucEthernetBuffer );
 80083f2:	6983      	ldr	r3, [r0, #24]
		if( pxPacket->xICMPPacket.xIPHeader.ucProtocol == ipPROTOCOL_ICMP )
 80083f4:	7dda      	ldrb	r2, [r3, #23]
 80083f6:	2a01      	cmp	r2, #1
 80083f8:	d01e      	beq.n	8008438 <xNetworkInterfaceOutput+0x4c>
	if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 80083fa:	4b17      	ldr	r3, [pc, #92]	; (8008458 <xNetworkInterfaceOutput+0x6c>)
 80083fc:	681b      	ldr	r3, [r3, #0]
 80083fe:	f013 0f04 	tst.w	r3, #4
 8008402:	d01f      	beq.n	8008444 <xNetworkInterfaceOutput+0x58>
		pxDmaTxDesc = xETH.TxDesc;
 8008404:	4b15      	ldr	r3, [pc, #84]	; (800845c <xNetworkInterfaceOutput+0x70>)
 8008406:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		if( ( pxDmaTxDesc->Status & ETH_DMATXDESC_OWN ) != 0 )
 8008408:	681a      	ldr	r2, [r3, #0]
 800840a:	2a00      	cmp	r2, #0
 800840c:	db1e      	blt.n	800844c <xNetworkInterfaceOutput+0x60>
			ulTransmitSize = pxDescriptor->xDataLength;
 800840e:	69e5      	ldr	r5, [r4, #28]
 8008410:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8008414:	4295      	cmp	r5, r2
 8008416:	bf28      	it	cs
 8008418:	4615      	movcs	r5, r2
			memcpy( ( void * ) pxDmaTxDesc->Buffer1Addr, pxDescriptor->pucEthernetBuffer, ulTransmitSize );
 800841a:	6898      	ldr	r0, [r3, #8]
 800841c:	462a      	mov	r2, r5
 800841e:	69a1      	ldr	r1, [r4, #24]
 8008420:	f003 fe1b 	bl	800c05a <memcpy>
			HAL_ETH_TransmitFrame( &xETH, ulTransmitSize );
 8008424:	4629      	mov	r1, r5
 8008426:	480d      	ldr	r0, [pc, #52]	; (800845c <xNetworkInterfaceOutput+0x70>)
 8008428:	f7f9 fcd2 	bl	8001dd0 <HAL_ETH_TransmitFrame>
			iptraceNETWORK_INTERFACE_TRANSMIT();
 800842c:	2100      	movs	r1, #0
 800842e:	2001      	movs	r0, #1
 8008430:	f002 fed6 	bl	800b1e0 <vExampleDebugStatUpdate>
			xReturn = pdPASS;
 8008434:	2501      	movs	r5, #1
 8008436:	e006      	b.n	8008446 <xNetworkInterfaceOutput+0x5a>
			pxPacket->xICMPPacket.xICMPHeader.usChecksum = ( uint16_t )0u;
 8008438:	2200      	movs	r2, #0
 800843a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 800843e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8008442:	e7da      	b.n	80083fa <xNetworkInterfaceOutput+0xe>
		xReturn = pdFAIL;
 8008444:	2500      	movs	r5, #0
		if( bReleaseAfterSend != pdFALSE )
 8008446:	b91e      	cbnz	r6, 8008450 <xNetworkInterfaceOutput+0x64>
}
 8008448:	4628      	mov	r0, r5
 800844a:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdFAIL;
 800844c:	2500      	movs	r5, #0
 800844e:	e7fa      	b.n	8008446 <xNetworkInterfaceOutput+0x5a>
			vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 8008450:	4620      	mov	r0, r4
 8008452:	f7ff fd09 	bl	8007e68 <vReleaseNetworkBufferAndDescriptor>
	return xReturn;
 8008456:	e7f7      	b.n	8008448 <xNetworkInterfaceOutput+0x5c>
 8008458:	20000904 	.word	0x20000904
 800845c:	2000090c 	.word	0x2000090c

08008460 <vMACBProbePhy>:
{
 8008460:	b530      	push	{r4, r5, lr}
 8008462:	b089      	sub	sp, #36	; 0x24
TickType_t xRemTime = 0;
 8008464:	2500      	movs	r5, #0
 8008466:	9500      	str	r5, [sp, #0]
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_03_PHYSID2, &ulLower);
 8008468:	4c3d      	ldr	r4, [pc, #244]	; (8008560 <vMACBProbePhy+0x100>)
 800846a:	aa05      	add	r2, sp, #20
 800846c:	2103      	movs	r1, #3
 800846e:	4620      	mov	r0, r4
 8008470:	f7f9 fd9e 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_02_PHYSID1, &ulUpper);
 8008474:	aa04      	add	r2, sp, #16
 8008476:	2102      	movs	r1, #2
 8008478:	4620      	mov	r0, r4
 800847a:	f7f9 fd99 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	ulMACPhyID = ( ( ulUpper << 16 ) & 0xFFFF0000 ) | ( ulLower & 0xFFF0 );
 800847e:	9905      	ldr	r1, [sp, #20]
 8008480:	f021 010f 	bic.w	r1, r1, #15
 8008484:	0409      	lsls	r1, r1, #16
 8008486:	0c09      	lsrs	r1, r1, #16
	FreeRTOS_printf( ( "PHY ID %X\n", ulMACPhyID ) );
 8008488:	9b04      	ldr	r3, [sp, #16]
 800848a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800848e:	4835      	ldr	r0, [pc, #212]	; (8008564 <vMACBProbePhy+0x104>)
 8008490:	f002 ffa2 	bl	800b3d8 <lUDPLoggingPrintf>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_00_BMCR, &ulConfig);
 8008494:	aa06      	add	r2, sp, #24
 8008496:	4629      	mov	r1, r5
 8008498:	4620      	mov	r0, r4
 800849a:	f7f9 fd89 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulConfig | BMCR_RESET );
 800849e:	9a06      	ldr	r2, [sp, #24]
 80084a0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80084a4:	4629      	mov	r1, r5
 80084a6:	4620      	mov	r0, r4
 80084a8:	f7f9 fdd0 	bl	800204c <HAL_ETH_WritePHYRegister>
	xRemTime = ( TickType_t ) pdMS_TO_TICKS( 1000UL );
 80084ac:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80084b0:	9300      	str	r3, [sp, #0]
	vTaskSetTimeOutState( &xPhyTime );
 80084b2:	a801      	add	r0, sp, #4
 80084b4:	f001 fd78 	bl	8009fa8 <vTaskSetTimeOutState>
		HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_00_BMCR, &ulValue);
 80084b8:	4625      	mov	r5, r4
 80084ba:	2400      	movs	r4, #0
 80084bc:	aa03      	add	r2, sp, #12
 80084be:	4621      	mov	r1, r4
 80084c0:	4628      	mov	r0, r5
 80084c2:	f7f9 fd75 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
		if( ( ulValue & BMCR_RESET ) == 0 )
 80084c6:	9b03      	ldr	r3, [sp, #12]
 80084c8:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 80084cc:	d009      	beq.n	80084e2 <vMACBProbePhy+0x82>
		if( xTaskCheckForTimeOut( &xPhyTime, &xRemTime ) != pdFALSE )
 80084ce:	4669      	mov	r1, sp
 80084d0:	a801      	add	r0, sp, #4
 80084d2:	f001 fd7f 	bl	8009fd4 <xTaskCheckForTimeOut>
 80084d6:	2800      	cmp	r0, #0
 80084d8:	d0f0      	beq.n	80084bc <vMACBProbePhy+0x5c>
			FreeRTOS_printf( ( "BMCR_RESET timed out\n" ) );
 80084da:	4823      	ldr	r0, [pc, #140]	; (8008568 <vMACBProbePhy+0x108>)
 80084dc:	f002 ff7c 	bl	800b3d8 <lUDPLoggingPrintf>
			break;
 80084e0:	e002      	b.n	80084e8 <vMACBProbePhy+0x88>
			FreeRTOS_printf( ( "BMCR_RESET ready\n" ) );
 80084e2:	4822      	ldr	r0, [pc, #136]	; (800856c <vMACBProbePhy+0x10c>)
 80084e4:	f002 ff78 	bl	800b3d8 <lUDPLoggingPrintf>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulConfig & ~BMCR_RESET);
 80084e8:	ad08      	add	r5, sp, #32
 80084ea:	f855 2d08 	ldr.w	r2, [r5, #-8]!
 80084ee:	4c1c      	ldr	r4, [pc, #112]	; (8008560 <vMACBProbePhy+0x100>)
 80084f0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80084f4:	2100      	movs	r1, #0
 80084f6:	4620      	mov	r0, r4
 80084f8:	f7f9 fda8 	bl	800204c <HAL_ETH_WritePHYRegister>
	vTaskDelay( pdMS_TO_TICKS( 50ul ) );
 80084fc:	2032      	movs	r0, #50	; 0x32
 80084fe:	f001 fbb1 	bl	8009c64 <vTaskDelay>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_04_ADVERTISE, ulAdvertise);
 8008502:	f240 12e1 	movw	r2, #481	; 0x1e1
 8008506:	2104      	movs	r1, #4
 8008508:	4620      	mov	r0, r4
 800850a:	f7f9 fd9f 	bl	800204c <HAL_ETH_WritePHYRegister>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_00_BMCR, &ulConfig);
 800850e:	462a      	mov	r2, r5
 8008510:	2100      	movs	r1, #0
 8008512:	4620      	mov	r0, r4
 8008514:	f7f9 fd4c 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	ulConfig &= ~( BMCR_ANRESTART | BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX );
 8008518:	9b06      	ldr	r3, [sp, #24]
 800851a:	f423 534c 	bic.w	r3, r3, #13056	; 0x3300
	ulConfig |= (BMCR_ANRESTART | BMCR_ANENABLE);
 800851e:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
 8008522:	9306      	str	r3, [sp, #24]
	HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_19_PHYCR, &ulPhyControl );
 8008524:	aa07      	add	r2, sp, #28
 8008526:	2119      	movs	r1, #25
 8008528:	4620      	mov	r0, r4
 800852a:	f7f9 fd41 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	ulPhyControl &= ~( PHYCR_MDIX_EN|PHYCR_MDIX_FORCE );
 800852e:	9a07      	ldr	r2, [sp, #28]
 8008530:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
		ulPhyControl |= PHYCR_MDIX_EN;
 8008534:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8008538:	9207      	str	r2, [sp, #28]
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_19_PHYCR, ulPhyControl );
 800853a:	2119      	movs	r1, #25
 800853c:	4620      	mov	r0, r4
 800853e:	f7f9 fd85 	bl	800204c <HAL_ETH_WritePHYRegister>
	FreeRTOS_printf( ( "+TCP: advertise: %lX config %lX\n", ulAdvertise, ulConfig ) );
 8008542:	9a06      	ldr	r2, [sp, #24]
 8008544:	f240 11e1 	movw	r1, #481	; 0x1e1
 8008548:	4809      	ldr	r0, [pc, #36]	; (8008570 <vMACBProbePhy+0x110>)
 800854a:	f002 ff45 	bl	800b3d8 <lUDPLoggingPrintf>
	ulBCRvalue = ulConfig;
 800854e:	9a06      	ldr	r2, [sp, #24]
 8008550:	4b08      	ldr	r3, [pc, #32]	; (8008574 <vMACBProbePhy+0x114>)
 8008552:	601a      	str	r2, [r3, #0]
	ulACRValue = ulAdvertise;
 8008554:	f240 12e1 	movw	r2, #481	; 0x1e1
 8008558:	4b07      	ldr	r3, [pc, #28]	; (8008578 <vMACBProbePhy+0x118>)
 800855a:	601a      	str	r2, [r3, #0]
}
 800855c:	b009      	add	sp, #36	; 0x24
 800855e:	bd30      	pop	{r4, r5, pc}
 8008560:	2000090c 	.word	0x2000090c
 8008564:	0800c8f4 	.word	0x0800c8f4
 8008568:	0800c914 	.word	0x0800c914
 800856c:	0800c900 	.word	0x0800c900
 8008570:	0800c92c 	.word	0x0800c92c
 8008574:	200008fc 	.word	0x200008fc
 8008578:	200008f8 	.word	0x200008f8

0800857c <xGetPhyLinkStatus>:
	if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 800857c:	4b02      	ldr	r3, [pc, #8]	; (8008588 <xGetPhyLinkStatus+0xc>)
 800857e:	6818      	ldr	r0, [r3, #0]
}
 8008580:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8008584:	4770      	bx	lr
 8008586:	bf00      	nop
 8008588:	20000904 	.word	0x20000904

0800858c <ETH_IRQHandler>:
	}
}
/*-----------------------------------------------------------*/

void ETH_IRQHandler( void )
{
 800858c:	b508      	push	{r3, lr}
	HAL_ETH_IRQHandler( &xETH );
 800858e:	4802      	ldr	r0, [pc, #8]	; (8008598 <ETH_IRQHandler+0xc>)
 8008590:	f7f9 fcee 	bl	8001f70 <HAL_ETH_IRQHandler>
 8008594:	bd08      	pop	{r3, pc}
 8008596:	bf00      	nop
 8008598:	2000090c 	.word	0x2000090c

0800859c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
 800859c:	b510      	push	{r4, lr}
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
 800859e:	201c      	movs	r0, #28
 80085a0:	f000 fb32 	bl	8008c08 <pvPortMalloc>

		if( pxEventBits != NULL )
 80085a4:	4604      	mov	r4, r0
 80085a6:	b120      	cbz	r0, 80085b2 <xEventGroupCreate+0x16>
		{
			pxEventBits->uxEventBits = 0;
 80085a8:	2300      	movs	r3, #0
 80085aa:	f840 3b04 	str.w	r3, [r0], #4
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 80085ae:	f000 f917 	bl	80087e0 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
 80085b2:	4620      	mov	r0, r4
 80085b4:	bd10      	pop	{r4, pc}
	...

080085b8 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
 80085b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80085bc:	460d      	mov	r5, r1
 80085be:	4617      	mov	r7, r2
 80085c0:	4698      	mov	r8, r3
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
 80085c2:	4606      	mov	r6, r0
 80085c4:	b308      	cbz	r0, 800860a <xEventGroupWaitBits+0x52>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80085c6:	f015 4f7f 	tst.w	r5, #4278190080	; 0xff000000
 80085ca:	d124      	bne.n	8008616 <xEventGroupWaitBits+0x5e>
	configASSERT( uxBitsToWaitFor != 0 );
 80085cc:	b34d      	cbz	r5, 8008622 <xEventGroupWaitBits+0x6a>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80085ce:	f001 fe23 	bl	800a218 <xTaskGetSchedulerState>
 80085d2:	b930      	cbnz	r0, 80085e2 <xEventGroupWaitBits+0x2a>
 80085d4:	9b06      	ldr	r3, [sp, #24]
 80085d6:	b123      	cbz	r3, 80085e2 <xEventGroupWaitBits+0x2a>
 80085d8:	f44f 71a9 	mov.w	r1, #338	; 0x152
 80085dc:	4836      	ldr	r0, [pc, #216]	; (80086b8 <xEventGroupWaitBits+0x100>)
 80085de:	f003 fb95 	bl	800bd0c <vAssertCalled>
	}
	#endif

	vTaskSuspendAll();
 80085e2:	f001 f9e5 	bl	80099b0 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 80085e6:	6834      	ldr	r4, [r6, #0]

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
 80085e8:	f1b8 0f00 	cmp.w	r8, #0
 80085ec:	d11f      	bne.n	800862e <xEventGroupWaitBits+0x76>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 80085ee:	4225      	tst	r5, r4
 80085f0:	bf14      	ite	ne
 80085f2:	2301      	movne	r3, #1
 80085f4:	2300      	moveq	r3, #0
		if( xWaitConditionMet != pdFALSE )
 80085f6:	b303      	cbz	r3, 800863a <xEventGroupWaitBits+0x82>
			if( xClearOnExit != pdFALSE )
 80085f8:	b117      	cbz	r7, 8008600 <xEventGroupWaitBits+0x48>
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80085fa:	ea24 0505 	bic.w	r5, r4, r5
 80085fe:	6035      	str	r5, [r6, #0]
	xAlreadyYielded = xTaskResumeAll();
 8008600:	f001 fab0 	bl	8009b64 <xTaskResumeAll>
 8008604:	4620      	mov	r0, r4
}
 8008606:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT( xEventGroup );
 800860a:	f240 114d 	movw	r1, #333	; 0x14d
 800860e:	482a      	ldr	r0, [pc, #168]	; (80086b8 <xEventGroupWaitBits+0x100>)
 8008610:	f003 fb7c 	bl	800bd0c <vAssertCalled>
 8008614:	e7d7      	b.n	80085c6 <xEventGroupWaitBits+0xe>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008616:	f44f 71a7 	mov.w	r1, #334	; 0x14e
 800861a:	4827      	ldr	r0, [pc, #156]	; (80086b8 <xEventGroupWaitBits+0x100>)
 800861c:	f003 fb76 	bl	800bd0c <vAssertCalled>
 8008620:	e7d4      	b.n	80085cc <xEventGroupWaitBits+0x14>
	configASSERT( uxBitsToWaitFor != 0 );
 8008622:	f240 114f 	movw	r1, #335	; 0x14f
 8008626:	4824      	ldr	r0, [pc, #144]	; (80086b8 <xEventGroupWaitBits+0x100>)
 8008628:	f003 fb70 	bl	800bd0c <vAssertCalled>
 800862c:	e7cf      	b.n	80085ce <xEventGroupWaitBits+0x16>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800862e:	ea35 0304 	bics.w	r3, r5, r4
 8008632:	bf0c      	ite	eq
 8008634:	2301      	moveq	r3, #1
 8008636:	2300      	movne	r3, #0
 8008638:	e7dd      	b.n	80085f6 <xEventGroupWaitBits+0x3e>
		else if( xTicksToWait == ( TickType_t ) 0 )
 800863a:	9b06      	ldr	r3, [sp, #24]
 800863c:	2b00      	cmp	r3, #0
 800863e:	d0df      	beq.n	8008600 <xEventGroupWaitBits+0x48>
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 8008640:	2f00      	cmp	r7, #0
 8008642:	bf0c      	ite	eq
 8008644:	2100      	moveq	r1, #0
 8008646:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
			if( xWaitForAllBits != pdFALSE )
 800864a:	f1b8 0f00 	cmp.w	r8, #0
 800864e:	d001      	beq.n	8008654 <xEventGroupWaitBits+0x9c>
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 8008650:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 8008654:	9a06      	ldr	r2, [sp, #24]
 8008656:	4329      	orrs	r1, r5
 8008658:	1d30      	adds	r0, r6, #4
 800865a:	f001 fbf3 	bl	8009e44 <vTaskPlaceOnUnorderedEventList>
	xAlreadyYielded = xTaskResumeAll();
 800865e:	f001 fa81 	bl	8009b64 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8008662:	b938      	cbnz	r0, 8008674 <xEventGroupWaitBits+0xbc>
			portYIELD_WITHIN_API();
 8008664:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008668:	4b14      	ldr	r3, [pc, #80]	; (80086bc <xEventGroupWaitBits+0x104>)
 800866a:	601a      	str	r2, [r3, #0]
 800866c:	f3bf 8f4f 	dsb	sy
 8008670:	f3bf 8f6f 	isb	sy
		uxReturn = uxTaskResetEventItemValue();
 8008674:	f001 ff68 	bl	800a548 <uxTaskResetEventItemValue>
 8008678:	4604      	mov	r4, r0
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 800867a:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 800867e:	d003      	beq.n	8008688 <xEventGroupWaitBits+0xd0>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 8008680:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
	return uxReturn;
 8008684:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			taskENTER_CRITICAL();
 8008688:	f000 f934 	bl	80088f4 <vPortEnterCritical>
				uxReturn = pxEventBits->uxEventBits;
 800868c:	6834      	ldr	r4, [r6, #0]
	if( xWaitForAllBits == pdFALSE )
 800868e:	f1b8 0f00 	cmp.w	r8, #0
 8008692:	d10b      	bne.n	80086ac <xEventGroupWaitBits+0xf4>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 8008694:	4225      	tst	r5, r4
 8008696:	bf14      	ite	ne
 8008698:	2301      	movne	r3, #1
 800869a:	2300      	moveq	r3, #0
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 800869c:	b11b      	cbz	r3, 80086a6 <xEventGroupWaitBits+0xee>
					if( xClearOnExit != pdFALSE )
 800869e:	b117      	cbz	r7, 80086a6 <xEventGroupWaitBits+0xee>
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80086a0:	ea24 0505 	bic.w	r5, r4, r5
 80086a4:	6035      	str	r5, [r6, #0]
			taskEXIT_CRITICAL();
 80086a6:	f000 f947 	bl	8008938 <vPortExitCritical>
 80086aa:	e7e9      	b.n	8008680 <xEventGroupWaitBits+0xc8>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 80086ac:	ea35 0304 	bics.w	r3, r5, r4
 80086b0:	bf0c      	ite	eq
 80086b2:	2301      	moveq	r3, #1
 80086b4:	2300      	movne	r3, #0
 80086b6:	e7f1      	b.n	800869c <xEventGroupWaitBits+0xe4>
 80086b8:	0800c958 	.word	0x0800c958
 80086bc:	e000ed04 	.word	0xe000ed04

080086c0 <xEventGroupClearBits>:
{
 80086c0:	b570      	push	{r4, r5, r6, lr}
 80086c2:	460c      	mov	r4, r1
	configASSERT( xEventGroup );
 80086c4:	4606      	mov	r6, r0
 80086c6:	b160      	cbz	r0, 80086e2 <xEventGroupClearBits+0x22>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80086c8:	f014 4f7f 	tst.w	r4, #4278190080	; 0xff000000
 80086cc:	d10f      	bne.n	80086ee <xEventGroupClearBits+0x2e>
	taskENTER_CRITICAL();
 80086ce:	f000 f911 	bl	80088f4 <vPortEnterCritical>
		uxReturn = pxEventBits->uxEventBits;
 80086d2:	6835      	ldr	r5, [r6, #0]
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 80086d4:	ea25 0404 	bic.w	r4, r5, r4
 80086d8:	6034      	str	r4, [r6, #0]
	taskEXIT_CRITICAL();
 80086da:	f000 f92d 	bl	8008938 <vPortExitCritical>
}
 80086de:	4628      	mov	r0, r5
 80086e0:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( xEventGroup );
 80086e2:	f240 11df 	movw	r1, #479	; 0x1df
 80086e6:	4805      	ldr	r0, [pc, #20]	; (80086fc <xEventGroupClearBits+0x3c>)
 80086e8:	f003 fb10 	bl	800bd0c <vAssertCalled>
 80086ec:	e7ec      	b.n	80086c8 <xEventGroupClearBits+0x8>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80086ee:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 80086f2:	4802      	ldr	r0, [pc, #8]	; (80086fc <xEventGroupClearBits+0x3c>)
 80086f4:	f003 fb0a 	bl	800bd0c <vAssertCalled>
 80086f8:	e7e9      	b.n	80086ce <xEventGroupClearBits+0xe>
 80086fa:	bf00      	nop
 80086fc:	0800c958 	.word	0x0800c958

08008700 <xEventGroupSetBits>:
{
 8008700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008702:	460c      	mov	r4, r1
	configASSERT( xEventGroup );
 8008704:	4605      	mov	r5, r0
 8008706:	b170      	cbz	r0, 8008726 <xEventGroupSetBits+0x26>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008708:	f014 4f7f 	tst.w	r4, #4278190080	; 0xff000000
 800870c:	d111      	bne.n	8008732 <xEventGroupSetBits+0x32>
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800870e:	f105 060c 	add.w	r6, r5, #12
	vTaskSuspendAll();
 8008712:	f001 f94d 	bl	80099b0 <vTaskSuspendAll>
		pxListItem = listGET_HEAD_ENTRY( pxList );
 8008716:	6928      	ldr	r0, [r5, #16]
		pxEventBits->uxEventBits |= uxBitsToSet;
 8008718:	682b      	ldr	r3, [r5, #0]
 800871a:	4323      	orrs	r3, r4
 800871c:	602b      	str	r3, [r5, #0]
		while( pxListItem != pxListEnd )
 800871e:	4286      	cmp	r6, r0
 8008720:	d02f      	beq.n	8008782 <xEventGroupSetBits+0x82>
 8008722:	2700      	movs	r7, #0
 8008724:	e015      	b.n	8008752 <xEventGroupSetBits+0x52>
	configASSERT( xEventGroup );
 8008726:	f240 211d 	movw	r1, #541	; 0x21d
 800872a:	481a      	ldr	r0, [pc, #104]	; (8008794 <xEventGroupSetBits+0x94>)
 800872c:	f003 faee 	bl	800bd0c <vAssertCalled>
 8008730:	e7ea      	b.n	8008708 <xEventGroupSetBits+0x8>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008732:	f240 211e 	movw	r1, #542	; 0x21e
 8008736:	4817      	ldr	r0, [pc, #92]	; (8008794 <xEventGroupSetBits+0x94>)
 8008738:	f003 fae8 	bl	800bd0c <vAssertCalled>
 800873c:	e7e7      	b.n	800870e <xEventGroupSetBits+0xe>
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 800873e:	6829      	ldr	r1, [r5, #0]
 8008740:	ea32 0101 	bics.w	r1, r2, r1
 8008744:	bf0c      	ite	eq
 8008746:	2101      	moveq	r1, #1
 8008748:	2100      	movne	r1, #0
 800874a:	e00e      	b.n	800876a <xEventGroupSetBits+0x6a>
 800874c:	4620      	mov	r0, r4
		while( pxListItem != pxListEnd )
 800874e:	42a6      	cmp	r6, r4
 8008750:	d018      	beq.n	8008784 <xEventGroupSetBits+0x84>
			pxNext = listGET_NEXT( pxListItem );
 8008752:	6844      	ldr	r4, [r0, #4]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 8008754:	6803      	ldr	r3, [r0, #0]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8008756:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 800875a:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 800875e:	d1ee      	bne.n	800873e <xEventGroupSetBits+0x3e>
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 8008760:	6829      	ldr	r1, [r5, #0]
 8008762:	420a      	tst	r2, r1
 8008764:	bf14      	ite	ne
 8008766:	2101      	movne	r1, #1
 8008768:	2100      	moveq	r1, #0
			if( xMatchFound != pdFALSE )
 800876a:	2900      	cmp	r1, #0
 800876c:	d0ee      	beq.n	800874c <xEventGroupSetBits+0x4c>
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 800876e:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
					uxBitsToClear |= uxBitsWaitedFor;
 8008772:	bf18      	it	ne
 8008774:	4317      	orrne	r7, r2
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8008776:	6829      	ldr	r1, [r5, #0]
 8008778:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 800877c:	f001 fbd0 	bl	8009f20 <vTaskRemoveFromUnorderedEventList>
 8008780:	e7e4      	b.n	800874c <xEventGroupSetBits+0x4c>
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 8008782:	2700      	movs	r7, #0
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 8008784:	682b      	ldr	r3, [r5, #0]
 8008786:	ea23 0707 	bic.w	r7, r3, r7
 800878a:	602f      	str	r7, [r5, #0]
	( void ) xTaskResumeAll();
 800878c:	f001 f9ea 	bl	8009b64 <xTaskResumeAll>
}
 8008790:	6828      	ldr	r0, [r5, #0]
 8008792:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008794:	0800c958 	.word	0x0800c958

08008798 <vEventGroupDelete>:
{
 8008798:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800879a:	4604      	mov	r4, r0
	vTaskSuspendAll();
 800879c:	f001 f908 	bl	80099b0 <vTaskSuspendAll>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 80087a0:	6863      	ldr	r3, [r4, #4]
 80087a2:	b17b      	cbz	r3, 80087c4 <vEventGroupDelete+0x2c>
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 80087a4:	f104 050c 	add.w	r5, r4, #12
 80087a8:	4f0c      	ldr	r7, [pc, #48]	; (80087dc <vEventGroupDelete+0x44>)
 80087aa:	f240 267d 	movw	r6, #637	; 0x27d
 80087ae:	6923      	ldr	r3, [r4, #16]
 80087b0:	42ab      	cmp	r3, r5
 80087b2:	d00d      	beq.n	80087d0 <vEventGroupDelete+0x38>
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 80087b4:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 80087b8:	6920      	ldr	r0, [r4, #16]
 80087ba:	f001 fbb1 	bl	8009f20 <vTaskRemoveFromUnorderedEventList>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 80087be:	6863      	ldr	r3, [r4, #4]
 80087c0:	2b00      	cmp	r3, #0
 80087c2:	d1f4      	bne.n	80087ae <vEventGroupDelete+0x16>
			vPortFree( pxEventBits );
 80087c4:	4620      	mov	r0, r4
 80087c6:	f000 fa85 	bl	8008cd4 <vPortFree>
	( void ) xTaskResumeAll();
 80087ca:	f001 f9cb 	bl	8009b64 <xTaskResumeAll>
 80087ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 80087d0:	4631      	mov	r1, r6
 80087d2:	4638      	mov	r0, r7
 80087d4:	f003 fa9a 	bl	800bd0c <vAssertCalled>
 80087d8:	e7ec      	b.n	80087b4 <vEventGroupDelete+0x1c>
 80087da:	bf00      	nop
 80087dc:	0800c958 	.word	0x0800c958

080087e0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80087e0:	f100 0308 	add.w	r3, r0, #8
 80087e4:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80087e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80087ea:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80087ec:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80087ee:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80087f0:	2300      	movs	r3, #0
 80087f2:	6003      	str	r3, [r0, #0]
 80087f4:	4770      	bx	lr

080087f6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80087f6:	2300      	movs	r3, #0
 80087f8:	6103      	str	r3, [r0, #16]
 80087fa:	4770      	bx	lr

080087fc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80087fc:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80087fe:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8008800:	689a      	ldr	r2, [r3, #8]
 8008802:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8008804:	689a      	ldr	r2, [r3, #8]
 8008806:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8008808:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800880a:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800880c:	6803      	ldr	r3, [r0, #0]
 800880e:	3301      	adds	r3, #1
 8008810:	6003      	str	r3, [r0, #0]
 8008812:	4770      	bx	lr

08008814 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8008814:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8008816:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8008818:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
 800881c:	d002      	beq.n	8008824 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800881e:	f100 0208 	add.w	r2, r0, #8
 8008822:	e002      	b.n	800882a <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
 8008824:	6902      	ldr	r2, [r0, #16]
 8008826:	e004      	b.n	8008832 <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008828:	461a      	mov	r2, r3
 800882a:	6853      	ldr	r3, [r2, #4]
 800882c:	681c      	ldr	r4, [r3, #0]
 800882e:	42a5      	cmp	r5, r4
 8008830:	d2fa      	bcs.n	8008828 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8008832:	6853      	ldr	r3, [r2, #4]
 8008834:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8008836:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8008838:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800883a:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800883c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 800883e:	6803      	ldr	r3, [r0, #0]
 8008840:	3301      	adds	r3, #1
 8008842:	6003      	str	r3, [r0, #0]
}
 8008844:	bc30      	pop	{r4, r5}
 8008846:	4770      	bx	lr

08008848 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8008848:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800884a:	6842      	ldr	r2, [r0, #4]
 800884c:	6881      	ldr	r1, [r0, #8]
 800884e:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8008850:	6882      	ldr	r2, [r0, #8]
 8008852:	6841      	ldr	r1, [r0, #4]
 8008854:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8008856:	685a      	ldr	r2, [r3, #4]
 8008858:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800885a:	bf04      	itt	eq
 800885c:	6882      	ldreq	r2, [r0, #8]
 800885e:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8008860:	2200      	movs	r2, #0
 8008862:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8008864:	6818      	ldr	r0, [r3, #0]
 8008866:	3801      	subs	r0, #1
 8008868:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800886a:	4770      	bx	lr

0800886c <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800886c:	4808      	ldr	r0, [pc, #32]	; (8008890 <prvPortStartFirstTask+0x24>)
 800886e:	6800      	ldr	r0, [r0, #0]
 8008870:	6800      	ldr	r0, [r0, #0]
 8008872:	f380 8808 	msr	MSP, r0
 8008876:	f04f 0000 	mov.w	r0, #0
 800887a:	f380 8814 	msr	CONTROL, r0
 800887e:	b662      	cpsie	i
 8008880:	b661      	cpsie	f
 8008882:	f3bf 8f4f 	dsb	sy
 8008886:	f3bf 8f6f 	isb	sy
 800888a:	df00      	svc	0
 800888c:	bf00      	nop
 800888e:	0000      	.short	0x0000
 8008890:	e000ed08 	.word	0xe000ed08

08008894 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8008894:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80088a4 <vPortEnableVFP+0x10>
 8008898:	6801      	ldr	r1, [r0, #0]
 800889a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800889e:	6001      	str	r1, [r0, #0]
 80088a0:	4770      	bx	lr
 80088a2:	0000      	.short	0x0000
 80088a4:	e000ed88 	.word	0xe000ed88

080088a8 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80088a8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80088ac:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80088b0:	f021 0101 	bic.w	r1, r1, #1
 80088b4:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80088b8:	2300      	movs	r3, #0
 80088ba:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80088be:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80088c2:	f06f 0302 	mvn.w	r3, #2
 80088c6:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80088ca:	3844      	subs	r0, #68	; 0x44
 80088cc:	4770      	bx	lr
	...

080088d0 <SVC_Handler>:
	__asm volatile (
 80088d0:	4b07      	ldr	r3, [pc, #28]	; (80088f0 <pxCurrentTCBConst2>)
 80088d2:	6819      	ldr	r1, [r3, #0]
 80088d4:	6808      	ldr	r0, [r1, #0]
 80088d6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80088da:	f380 8809 	msr	PSP, r0
 80088de:	f3bf 8f6f 	isb	sy
 80088e2:	f04f 0000 	mov.w	r0, #0
 80088e6:	f380 8811 	msr	BASEPRI, r0
 80088ea:	4770      	bx	lr
 80088ec:	f3af 8000 	nop.w

080088f0 <pxCurrentTCBConst2>:
 80088f0:	20000974 	.word	0x20000974

080088f4 <vPortEnterCritical>:
{
 80088f4:	b508      	push	{r3, lr}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80088f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80088fa:	f383 8811 	msr	BASEPRI, r3
 80088fe:	f3bf 8f6f 	isb	sy
 8008902:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8008906:	4a09      	ldr	r2, [pc, #36]	; (800892c <vPortEnterCritical+0x38>)
 8008908:	6813      	ldr	r3, [r2, #0]
 800890a:	3301      	adds	r3, #1
 800890c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800890e:	2b01      	cmp	r3, #1
 8008910:	d000      	beq.n	8008914 <vPortEnterCritical+0x20>
 8008912:	bd08      	pop	{r3, pc}
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8008914:	4b06      	ldr	r3, [pc, #24]	; (8008930 <vPortEnterCritical+0x3c>)
 8008916:	681b      	ldr	r3, [r3, #0]
 8008918:	f013 0fff 	tst.w	r3, #255	; 0xff
 800891c:	d0f9      	beq.n	8008912 <vPortEnterCritical+0x1e>
 800891e:	f240 11bb 	movw	r1, #443	; 0x1bb
 8008922:	4804      	ldr	r0, [pc, #16]	; (8008934 <vPortEnterCritical+0x40>)
 8008924:	f003 f9f2 	bl	800bd0c <vAssertCalled>
}
 8008928:	e7f3      	b.n	8008912 <vPortEnterCritical+0x1e>
 800892a:	bf00      	nop
 800892c:	20000028 	.word	0x20000028
 8008930:	e000ed04 	.word	0xe000ed04
 8008934:	0800c984 	.word	0x0800c984

08008938 <vPortExitCritical>:
{
 8008938:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
 800893a:	4b08      	ldr	r3, [pc, #32]	; (800895c <vPortExitCritical+0x24>)
 800893c:	681b      	ldr	r3, [r3, #0]
 800893e:	b13b      	cbz	r3, 8008950 <vPortExitCritical+0x18>
	uxCriticalNesting--;
 8008940:	4a06      	ldr	r2, [pc, #24]	; (800895c <vPortExitCritical+0x24>)
 8008942:	6813      	ldr	r3, [r2, #0]
 8008944:	3b01      	subs	r3, #1
 8008946:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8008948:	b90b      	cbnz	r3, 800894e <vPortExitCritical+0x16>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800894a:	f383 8811 	msr	BASEPRI, r3
 800894e:	bd08      	pop	{r3, pc}
	configASSERT( uxCriticalNesting );
 8008950:	f44f 71e1 	mov.w	r1, #450	; 0x1c2
 8008954:	4802      	ldr	r0, [pc, #8]	; (8008960 <vPortExitCritical+0x28>)
 8008956:	f003 f9d9 	bl	800bd0c <vAssertCalled>
 800895a:	e7f1      	b.n	8008940 <vPortExitCritical+0x8>
 800895c:	20000028 	.word	0x20000028
 8008960:	0800c984 	.word	0x0800c984
	...

08008970 <PendSV_Handler>:
	__asm volatile
 8008970:	f3ef 8009 	mrs	r0, PSP
 8008974:	f3bf 8f6f 	isb	sy
 8008978:	4b15      	ldr	r3, [pc, #84]	; (80089d0 <pxCurrentTCBConst>)
 800897a:	681a      	ldr	r2, [r3, #0]
 800897c:	f01e 0f10 	tst.w	lr, #16
 8008980:	bf08      	it	eq
 8008982:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8008986:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800898a:	6010      	str	r0, [r2, #0]
 800898c:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8008990:	f04f 0050 	mov.w	r0, #80	; 0x50
 8008994:	f380 8811 	msr	BASEPRI, r0
 8008998:	f3bf 8f4f 	dsb	sy
 800899c:	f3bf 8f6f 	isb	sy
 80089a0:	f001 f9c4 	bl	8009d2c <vTaskSwitchContext>
 80089a4:	f04f 0000 	mov.w	r0, #0
 80089a8:	f380 8811 	msr	BASEPRI, r0
 80089ac:	bc08      	pop	{r3}
 80089ae:	6819      	ldr	r1, [r3, #0]
 80089b0:	6808      	ldr	r0, [r1, #0]
 80089b2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80089b6:	f01e 0f10 	tst.w	lr, #16
 80089ba:	bf08      	it	eq
 80089bc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80089c0:	f380 8809 	msr	PSP, r0
 80089c4:	f3bf 8f6f 	isb	sy
 80089c8:	4770      	bx	lr
 80089ca:	bf00      	nop
 80089cc:	f3af 8000 	nop.w

080089d0 <pxCurrentTCBConst>:
 80089d0:	20000974 	.word	0x20000974

080089d4 <SysTick_Handler>:
{
 80089d4:	b508      	push	{r3, lr}
	__asm volatile
 80089d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80089da:	f383 8811 	msr	BASEPRI, r3
 80089de:	f3bf 8f6f 	isb	sy
 80089e2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80089e6:	f001 f805 	bl	80099f4 <xTaskIncrementTick>
 80089ea:	b118      	cbz	r0, 80089f4 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80089ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80089f0:	4b02      	ldr	r3, [pc, #8]	; (80089fc <SysTick_Handler+0x28>)
 80089f2:	601a      	str	r2, [r3, #0]
	__asm volatile
 80089f4:	2300      	movs	r3, #0
 80089f6:	f383 8811 	msr	BASEPRI, r3
 80089fa:	bd08      	pop	{r3, pc}
 80089fc:	e000ed04 	.word	0xe000ed04

08008a00 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8008a00:	4a08      	ldr	r2, [pc, #32]	; (8008a24 <vPortSetupTimerInterrupt+0x24>)
 8008a02:	2300      	movs	r3, #0
 8008a04:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8008a06:	4908      	ldr	r1, [pc, #32]	; (8008a28 <vPortSetupTimerInterrupt+0x28>)
 8008a08:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8008a0a:	4b08      	ldr	r3, [pc, #32]	; (8008a2c <vPortSetupTimerInterrupt+0x2c>)
 8008a0c:	681b      	ldr	r3, [r3, #0]
 8008a0e:	4908      	ldr	r1, [pc, #32]	; (8008a30 <vPortSetupTimerInterrupt+0x30>)
 8008a10:	fba1 1303 	umull	r1, r3, r1, r3
 8008a14:	099b      	lsrs	r3, r3, #6
 8008a16:	3b01      	subs	r3, #1
 8008a18:	4906      	ldr	r1, [pc, #24]	; (8008a34 <vPortSetupTimerInterrupt+0x34>)
 8008a1a:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8008a1c:	2307      	movs	r3, #7
 8008a1e:	6013      	str	r3, [r2, #0]
 8008a20:	4770      	bx	lr
 8008a22:	bf00      	nop
 8008a24:	e000e010 	.word	0xe000e010
 8008a28:	e000e018 	.word	0xe000e018
 8008a2c:	20000000 	.word	0x20000000
 8008a30:	10624dd3 	.word	0x10624dd3
 8008a34:	e000e014 	.word	0xe000e014

08008a38 <xPortStartScheduler>:
{
 8008a38:	b510      	push	{r4, lr}
 8008a3a:	b082      	sub	sp, #8
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8008a3c:	4b3c      	ldr	r3, [pc, #240]	; (8008b30 <xPortStartScheduler+0xf8>)
 8008a3e:	681a      	ldr	r2, [r3, #0]
 8008a40:	4b3c      	ldr	r3, [pc, #240]	; (8008b34 <xPortStartScheduler+0xfc>)
 8008a42:	429a      	cmp	r2, r3
 8008a44:	d01e      	beq.n	8008a84 <xPortStartScheduler+0x4c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8008a46:	4b3a      	ldr	r3, [pc, #232]	; (8008b30 <xPortStartScheduler+0xf8>)
 8008a48:	681a      	ldr	r2, [r3, #0]
 8008a4a:	4b3b      	ldr	r3, [pc, #236]	; (8008b38 <xPortStartScheduler+0x100>)
 8008a4c:	429a      	cmp	r2, r3
 8008a4e:	d01f      	beq.n	8008a90 <xPortStartScheduler+0x58>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8008a50:	4b3a      	ldr	r3, [pc, #232]	; (8008b3c <xPortStartScheduler+0x104>)
 8008a52:	781a      	ldrb	r2, [r3, #0]
 8008a54:	b2d2      	uxtb	r2, r2
 8008a56:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8008a58:	22ff      	movs	r2, #255	; 0xff
 8008a5a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8008a5c:	781b      	ldrb	r3, [r3, #0]
 8008a5e:	b2db      	uxtb	r3, r3
 8008a60:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8008a64:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a68:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8008a6c:	4a34      	ldr	r2, [pc, #208]	; (8008b40 <xPortStartScheduler+0x108>)
 8008a6e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8008a70:	2207      	movs	r2, #7
 8008a72:	4b34      	ldr	r3, [pc, #208]	; (8008b44 <xPortStartScheduler+0x10c>)
 8008a74:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8008a76:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a7a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008a7e:	d051      	beq.n	8008b24 <xPortStartScheduler+0xec>
 8008a80:	2206      	movs	r2, #6
 8008a82:	e00c      	b.n	8008a9e <xPortStartScheduler+0x66>
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8008a84:	f240 1147 	movw	r1, #327	; 0x147
 8008a88:	482f      	ldr	r0, [pc, #188]	; (8008b48 <xPortStartScheduler+0x110>)
 8008a8a:	f003 f93f 	bl	800bd0c <vAssertCalled>
 8008a8e:	e7da      	b.n	8008a46 <xPortStartScheduler+0xe>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8008a90:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008a94:	482c      	ldr	r0, [pc, #176]	; (8008b48 <xPortStartScheduler+0x110>)
 8008a96:	f003 f939 	bl	800bd0c <vAssertCalled>
 8008a9a:	e7d9      	b.n	8008a50 <xPortStartScheduler+0x18>
 8008a9c:	460a      	mov	r2, r1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8008a9e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008aa2:	005b      	lsls	r3, r3, #1
 8008aa4:	b2db      	uxtb	r3, r3
 8008aa6:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8008aaa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008aae:	1e51      	subs	r1, r2, #1
 8008ab0:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008ab4:	d1f2      	bne.n	8008a9c <xPortStartScheduler+0x64>
 8008ab6:	4b23      	ldr	r3, [pc, #140]	; (8008b44 <xPortStartScheduler+0x10c>)
 8008ab8:	601a      	str	r2, [r3, #0]
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8008aba:	2a03      	cmp	r2, #3
 8008abc:	d132      	bne.n	8008b24 <xPortStartScheduler+0xec>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8008abe:	4a21      	ldr	r2, [pc, #132]	; (8008b44 <xPortStartScheduler+0x10c>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8008ac0:	6813      	ldr	r3, [r2, #0]
 8008ac2:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8008ac4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008ac8:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8008aca:	9b01      	ldr	r3, [sp, #4]
 8008acc:	b2db      	uxtb	r3, r3
 8008ace:	4a1b      	ldr	r2, [pc, #108]	; (8008b3c <xPortStartScheduler+0x104>)
 8008ad0:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8008ad2:	4b1e      	ldr	r3, [pc, #120]	; (8008b4c <xPortStartScheduler+0x114>)
 8008ad4:	681a      	ldr	r2, [r3, #0]
 8008ad6:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8008ada:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8008adc:	681a      	ldr	r2, [r3, #0]
 8008ade:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8008ae2:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8008ae4:	f7ff ff8c 	bl	8008a00 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8008ae8:	4c19      	ldr	r4, [pc, #100]	; (8008b50 <xPortStartScheduler+0x118>)
 8008aea:	2300      	movs	r3, #0
 8008aec:	6023      	str	r3, [r4, #0]
	vPortEnableVFP();
 8008aee:	f7ff fed1 	bl	8008894 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8008af2:	4a18      	ldr	r2, [pc, #96]	; (8008b54 <xPortStartScheduler+0x11c>)
 8008af4:	6813      	ldr	r3, [r2, #0]
 8008af6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8008afa:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8008afc:	f7ff feb6 	bl	800886c <prvPortStartFirstTask>
	configASSERT( uxCriticalNesting == ~0UL );
 8008b00:	6823      	ldr	r3, [r4, #0]
 8008b02:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008b06:	d004      	beq.n	8008b12 <xPortStartScheduler+0xda>
 8008b08:	f240 110b 	movw	r1, #267	; 0x10b
 8008b0c:	480e      	ldr	r0, [pc, #56]	; (8008b48 <xPortStartScheduler+0x110>)
 8008b0e:	f003 f8fd 	bl	800bd0c <vAssertCalled>
	__asm volatile
 8008b12:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008b16:	f383 8811 	msr	BASEPRI, r3
 8008b1a:	f3bf 8f6f 	isb	sy
 8008b1e:	f3bf 8f4f 	dsb	sy
 8008b22:	e7fe      	b.n	8008b22 <xPortStartScheduler+0xea>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8008b24:	f240 1179 	movw	r1, #377	; 0x179
 8008b28:	4807      	ldr	r0, [pc, #28]	; (8008b48 <xPortStartScheduler+0x110>)
 8008b2a:	f003 f8ef 	bl	800bd0c <vAssertCalled>
 8008b2e:	e7c6      	b.n	8008abe <xPortStartScheduler+0x86>
 8008b30:	e000ed00 	.word	0xe000ed00
 8008b34:	410fc271 	.word	0x410fc271
 8008b38:	410fc270 	.word	0x410fc270
 8008b3c:	e000e400 	.word	0xe000e400
 8008b40:	20000954 	.word	0x20000954
 8008b44:	20000958 	.word	0x20000958
 8008b48:	0800c984 	.word	0x0800c984
 8008b4c:	e000ed20 	.word	0xe000ed20
 8008b50:	20000028 	.word	0x20000028
 8008b54:	e000ef34 	.word	0xe000ef34

08008b58 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 8008b58:	b508      	push	{r3, lr}
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8008b5a:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8008b5e:	2b0f      	cmp	r3, #15
 8008b60:	d906      	bls.n	8008b70 <vPortValidateInterruptPriority+0x18>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8008b62:	4a0e      	ldr	r2, [pc, #56]	; (8008b9c <vPortValidateInterruptPriority+0x44>)
 8008b64:	5c9b      	ldrb	r3, [r3, r2]
 8008b66:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8008b68:	4a0d      	ldr	r2, [pc, #52]	; (8008ba0 <vPortValidateInterruptPriority+0x48>)
 8008b6a:	7812      	ldrb	r2, [r2, #0]
 8008b6c:	429a      	cmp	r2, r3
 8008b6e:	d808      	bhi.n	8008b82 <vPortValidateInterruptPriority+0x2a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8008b70:	4b0c      	ldr	r3, [pc, #48]	; (8008ba4 <vPortValidateInterruptPriority+0x4c>)
 8008b72:	681b      	ldr	r3, [r3, #0]
 8008b74:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008b78:	4a0b      	ldr	r2, [pc, #44]	; (8008ba8 <vPortValidateInterruptPriority+0x50>)
 8008b7a:	6812      	ldr	r2, [r2, #0]
 8008b7c:	4293      	cmp	r3, r2
 8008b7e:	d806      	bhi.n	8008b8e <vPortValidateInterruptPriority+0x36>
 8008b80:	bd08      	pop	{r3, pc}
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8008b82:	f240 3101 	movw	r1, #769	; 0x301
 8008b86:	4809      	ldr	r0, [pc, #36]	; (8008bac <vPortValidateInterruptPriority+0x54>)
 8008b88:	f003 f8c0 	bl	800bd0c <vAssertCalled>
 8008b8c:	e7f0      	b.n	8008b70 <vPortValidateInterruptPriority+0x18>
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8008b8e:	f240 3111 	movw	r1, #785	; 0x311
 8008b92:	4806      	ldr	r0, [pc, #24]	; (8008bac <vPortValidateInterruptPriority+0x54>)
 8008b94:	f003 f8ba 	bl	800bd0c <vAssertCalled>
	}
 8008b98:	e7f2      	b.n	8008b80 <vPortValidateInterruptPriority+0x28>
 8008b9a:	bf00      	nop
 8008b9c:	e000e3f0 	.word	0xe000e3f0
 8008ba0:	20000954 	.word	0x20000954
 8008ba4:	e000ed0c 	.word	0xe000ed0c
 8008ba8:	20000958 	.word	0x20000958
 8008bac:	0800c984 	.word	0x0800c984

08008bb0 <prvInsertBlockIntoFreeList>:
	return xMinimumEverFreeBytesRemaining;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8008bb0:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8008bb2:	4a13      	ldr	r2, [pc, #76]	; (8008c00 <prvInsertBlockIntoFreeList+0x50>)
 8008bb4:	e000      	b.n	8008bb8 <prvInsertBlockIntoFreeList+0x8>
 8008bb6:	461a      	mov	r2, r3
 8008bb8:	6813      	ldr	r3, [r2, #0]
 8008bba:	4283      	cmp	r3, r0
 8008bbc:	d3fb      	bcc.n	8008bb6 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8008bbe:	6851      	ldr	r1, [r2, #4]
 8008bc0:	1854      	adds	r4, r2, r1
 8008bc2:	42a0      	cmp	r0, r4
 8008bc4:	d00a      	beq.n	8008bdc <prvInsertBlockIntoFreeList+0x2c>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8008bc6:	6841      	ldr	r1, [r0, #4]
 8008bc8:	1844      	adds	r4, r0, r1
 8008bca:	42a3      	cmp	r3, r4
 8008bcc:	d00b      	beq.n	8008be6 <prvInsertBlockIntoFreeList+0x36>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8008bce:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8008bd0:	4290      	cmp	r0, r2
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8008bd2:	bf18      	it	ne
 8008bd4:	6010      	strne	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8008bd6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008bda:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8008bdc:	6840      	ldr	r0, [r0, #4]
 8008bde:	4401      	add	r1, r0
 8008be0:	6051      	str	r1, [r2, #4]
 8008be2:	4610      	mov	r0, r2
 8008be4:	e7ef      	b.n	8008bc6 <prvInsertBlockIntoFreeList+0x16>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8008be6:	4c07      	ldr	r4, [pc, #28]	; (8008c04 <prvInsertBlockIntoFreeList+0x54>)
 8008be8:	6824      	ldr	r4, [r4, #0]
 8008bea:	42a3      	cmp	r3, r4
 8008bec:	d006      	beq.n	8008bfc <prvInsertBlockIntoFreeList+0x4c>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8008bee:	685b      	ldr	r3, [r3, #4]
 8008bf0:	4419      	add	r1, r3
 8008bf2:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8008bf4:	6813      	ldr	r3, [r2, #0]
 8008bf6:	681b      	ldr	r3, [r3, #0]
 8008bf8:	6003      	str	r3, [r0, #0]
 8008bfa:	e7e9      	b.n	8008bd0 <prvInsertBlockIntoFreeList+0x20>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8008bfc:	6003      	str	r3, [r0, #0]
 8008bfe:	e7e7      	b.n	8008bd0 <prvInsertBlockIntoFreeList+0x20>
 8008c00:	2000096c 	.word	0x2000096c
 8008c04:	2000095c 	.word	0x2000095c

08008c08 <pvPortMalloc>:
{
 8008c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008c0a:	4604      	mov	r4, r0
	configASSERT( pxEnd );
 8008c0c:	4b2b      	ldr	r3, [pc, #172]	; (8008cbc <pvPortMalloc+0xb4>)
 8008c0e:	681b      	ldr	r3, [r3, #0]
 8008c10:	b1c3      	cbz	r3, 8008c44 <pvPortMalloc+0x3c>
	vTaskSuspendAll();
 8008c12:	f000 fecd 	bl	80099b0 <vTaskSuspendAll>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8008c16:	4b2a      	ldr	r3, [pc, #168]	; (8008cc0 <pvPortMalloc+0xb8>)
 8008c18:	681d      	ldr	r5, [r3, #0]
 8008c1a:	4225      	tst	r5, r4
 8008c1c:	d144      	bne.n	8008ca8 <pvPortMalloc+0xa0>
			if( xWantedSize > 0 )
 8008c1e:	2c00      	cmp	r4, #0
 8008c20:	d045      	beq.n	8008cae <pvPortMalloc+0xa6>
				xWantedSize += xHeapStructSize;
 8008c22:	f104 0208 	add.w	r2, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8008c26:	f012 0f07 	tst.w	r2, #7
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8008c2a:	bf1c      	itt	ne
 8008c2c:	f022 0207 	bicne.w	r2, r2, #7
 8008c30:	3208      	addne	r2, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8008c32:	2a00      	cmp	r2, #0
 8008c34:	d038      	beq.n	8008ca8 <pvPortMalloc+0xa0>
 8008c36:	4b23      	ldr	r3, [pc, #140]	; (8008cc4 <pvPortMalloc+0xbc>)
 8008c38:	681e      	ldr	r6, [r3, #0]
 8008c3a:	42b2      	cmp	r2, r6
 8008c3c:	d834      	bhi.n	8008ca8 <pvPortMalloc+0xa0>
				pxBlock = xStart.pxNextFreeBlock;
 8008c3e:	4922      	ldr	r1, [pc, #136]	; (8008cc8 <pvPortMalloc+0xc0>)
 8008c40:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8008c42:	e006      	b.n	8008c52 <pvPortMalloc+0x4a>
	configASSERT( pxEnd );
 8008c44:	21b5      	movs	r1, #181	; 0xb5
 8008c46:	4821      	ldr	r0, [pc, #132]	; (8008ccc <pvPortMalloc+0xc4>)
 8008c48:	f003 f860 	bl	800bd0c <vAssertCalled>
 8008c4c:	e7e1      	b.n	8008c12 <pvPortMalloc+0xa>
 8008c4e:	4621      	mov	r1, r4
					pxBlock = pxBlock->pxNextFreeBlock;
 8008c50:	461c      	mov	r4, r3
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8008c52:	6863      	ldr	r3, [r4, #4]
 8008c54:	429a      	cmp	r2, r3
 8008c56:	d902      	bls.n	8008c5e <pvPortMalloc+0x56>
 8008c58:	6823      	ldr	r3, [r4, #0]
 8008c5a:	2b00      	cmp	r3, #0
 8008c5c:	d1f7      	bne.n	8008c4e <pvPortMalloc+0x46>
				if( pxBlock != pxEnd )
 8008c5e:	4b17      	ldr	r3, [pc, #92]	; (8008cbc <pvPortMalloc+0xb4>)
 8008c60:	681b      	ldr	r3, [r3, #0]
 8008c62:	429c      	cmp	r4, r3
 8008c64:	d020      	beq.n	8008ca8 <pvPortMalloc+0xa0>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8008c66:	680f      	ldr	r7, [r1, #0]
 8008c68:	3708      	adds	r7, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8008c6a:	6823      	ldr	r3, [r4, #0]
 8008c6c:	600b      	str	r3, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8008c6e:	6863      	ldr	r3, [r4, #4]
 8008c70:	1a9b      	subs	r3, r3, r2
 8008c72:	2b10      	cmp	r3, #16
 8008c74:	d812      	bhi.n	8008c9c <pvPortMalloc+0x94>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8008c76:	6862      	ldr	r2, [r4, #4]
 8008c78:	1ab6      	subs	r6, r6, r2
 8008c7a:	4912      	ldr	r1, [pc, #72]	; (8008cc4 <pvPortMalloc+0xbc>)
 8008c7c:	600e      	str	r6, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8008c7e:	4914      	ldr	r1, [pc, #80]	; (8008cd0 <pvPortMalloc+0xc8>)
 8008c80:	6809      	ldr	r1, [r1, #0]
 8008c82:	428e      	cmp	r6, r1
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8008c84:	bf3c      	itt	cc
 8008c86:	4912      	ldrcc	r1, [pc, #72]	; (8008cd0 <pvPortMalloc+0xc8>)
 8008c88:	600e      	strcc	r6, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8008c8a:	4315      	orrs	r5, r2
 8008c8c:	6065      	str	r5, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8008c8e:	2300      	movs	r3, #0
 8008c90:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 8008c92:	f000 ff67 	bl	8009b64 <xTaskResumeAll>
		if( pvReturn == NULL )
 8008c96:	b167      	cbz	r7, 8008cb2 <pvPortMalloc+0xaa>
}
 8008c98:	4638      	mov	r0, r7
 8008c9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8008c9c:	18a0      	adds	r0, r4, r2
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8008c9e:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8008ca0:	6062      	str	r2, [r4, #4]
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8008ca2:	f7ff ff85 	bl	8008bb0 <prvInsertBlockIntoFreeList>
 8008ca6:	e7e6      	b.n	8008c76 <pvPortMalloc+0x6e>
	( void ) xTaskResumeAll();
 8008ca8:	f000 ff5c 	bl	8009b64 <xTaskResumeAll>
 8008cac:	e001      	b.n	8008cb2 <pvPortMalloc+0xaa>
 8008cae:	f000 ff59 	bl	8009b64 <xTaskResumeAll>
			vApplicationMallocFailedHook();
 8008cb2:	f003 f8df 	bl	800be74 <vApplicationMallocFailedHook>
 8008cb6:	2700      	movs	r7, #0
	return pvReturn;
 8008cb8:	e7ee      	b.n	8008c98 <pvPortMalloc+0x90>
 8008cba:	bf00      	nop
 8008cbc:	2000095c 	.word	0x2000095c
 8008cc0:	20000960 	.word	0x20000960
 8008cc4:	20000964 	.word	0x20000964
 8008cc8:	2000096c 	.word	0x2000096c
 8008ccc:	0800c9c0 	.word	0x0800c9c0
 8008cd0:	20000968 	.word	0x20000968

08008cd4 <vPortFree>:
	if( pv != NULL )
 8008cd4:	2800      	cmp	r0, #0
 8008cd6:	d040      	beq.n	8008d5a <vPortFree+0x86>
{
 8008cd8:	b510      	push	{r4, lr}
 8008cda:	4604      	mov	r4, r0
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8008cdc:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8008ce0:	4b1e      	ldr	r3, [pc, #120]	; (8008d5c <vPortFree+0x88>)
 8008ce2:	681b      	ldr	r3, [r3, #0]
 8008ce4:	421a      	tst	r2, r3
 8008ce6:	d011      	beq.n	8008d0c <vPortFree+0x38>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8008ce8:	f850 3c08 	ldr.w	r3, [r0, #-8]
 8008cec:	b1f3      	cbz	r3, 8008d2c <vPortFree+0x58>
 8008cee:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 8008cf2:	481b      	ldr	r0, [pc, #108]	; (8008d60 <vPortFree+0x8c>)
 8008cf4:	f003 f80a 	bl	800bd0c <vAssertCalled>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 8008cf8:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8008cfc:	4a17      	ldr	r2, [pc, #92]	; (8008d5c <vPortFree+0x88>)
 8008cfe:	6812      	ldr	r2, [r2, #0]
 8008d00:	4213      	tst	r3, r2
 8008d02:	d002      	beq.n	8008d0a <vPortFree+0x36>
			if( pxLink->pxNextFreeBlock == NULL )
 8008d04:	f854 1c08 	ldr.w	r1, [r4, #-8]
 8008d08:	b1a1      	cbz	r1, 8008d34 <vPortFree+0x60>
 8008d0a:	bd10      	pop	{r4, pc}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8008d0c:	f240 1149 	movw	r1, #329	; 0x149
 8008d10:	4813      	ldr	r0, [pc, #76]	; (8008d60 <vPortFree+0x8c>)
 8008d12:	f002 fffb 	bl	800bd0c <vAssertCalled>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8008d16:	f854 3c08 	ldr.w	r3, [r4, #-8]
 8008d1a:	2b00      	cmp	r3, #0
 8008d1c:	d1e7      	bne.n	8008cee <vPortFree+0x1a>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 8008d1e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8008d22:	4a0e      	ldr	r2, [pc, #56]	; (8008d5c <vPortFree+0x88>)
 8008d24:	6812      	ldr	r2, [r2, #0]
 8008d26:	4213      	tst	r3, r2
 8008d28:	d0ef      	beq.n	8008d0a <vPortFree+0x36>
 8008d2a:	e003      	b.n	8008d34 <vPortFree+0x60>
 8008d2c:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8008d30:	4a0a      	ldr	r2, [pc, #40]	; (8008d5c <vPortFree+0x88>)
 8008d32:	6812      	ldr	r2, [r2, #0]
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8008d34:	ea23 0302 	bic.w	r3, r3, r2
 8008d38:	f844 3c04 	str.w	r3, [r4, #-4]
				vTaskSuspendAll();
 8008d3c:	f000 fe38 	bl	80099b0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8008d40:	4a08      	ldr	r2, [pc, #32]	; (8008d64 <vPortFree+0x90>)
 8008d42:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8008d46:	6811      	ldr	r1, [r2, #0]
 8008d48:	440b      	add	r3, r1
 8008d4a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8008d4c:	f1a4 0008 	sub.w	r0, r4, #8
 8008d50:	f7ff ff2e 	bl	8008bb0 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 8008d54:	f000 ff06 	bl	8009b64 <xTaskResumeAll>
}
 8008d58:	bd10      	pop	{r4, pc}
 8008d5a:	4770      	bx	lr
 8008d5c:	20000960 	.word	0x20000960
 8008d60:	0800c9c0 	.word	0x0800c9c0
 8008d64:	20000964 	.word	0x20000964

08008d68 <xPortGetFreeHeapSize>:
}
 8008d68:	4b01      	ldr	r3, [pc, #4]	; (8008d70 <xPortGetFreeHeapSize+0x8>)
 8008d6a:	6818      	ldr	r0, [r3, #0]
 8008d6c:	4770      	bx	lr
 8008d6e:	bf00      	nop
 8008d70:	20000964 	.word	0x20000964

08008d74 <xPortGetMinimumEverFreeHeapSize>:
}
 8008d74:	4b01      	ldr	r3, [pc, #4]	; (8008d7c <xPortGetMinimumEverFreeHeapSize+0x8>)
 8008d76:	6818      	ldr	r0, [r3, #0]
 8008d78:	4770      	bx	lr
 8008d7a:	bf00      	nop
 8008d7c:	20000968 	.word	0x20000968

08008d80 <vPortDefineHeapRegions>:
/*-----------------------------------------------------------*/

void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )
{
 8008d80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008d84:	4605      	mov	r5, r0
BaseType_t xDefinedRegions = 0;
size_t xAddress;
const HeapRegion_t *pxHeapRegion;

	/* Can only call once! */
	configASSERT( pxEnd == NULL );
 8008d86:	4b37      	ldr	r3, [pc, #220]	; (8008e64 <vPortDefineHeapRegions+0xe4>)
 8008d88:	681b      	ldr	r3, [r3, #0]
 8008d8a:	b123      	cbz	r3, 8008d96 <vPortDefineHeapRegions+0x16>
 8008d8c:	f240 11bd 	movw	r1, #445	; 0x1bd
 8008d90:	4835      	ldr	r0, [pc, #212]	; (8008e68 <vPortDefineHeapRegions+0xe8>)
 8008d92:	f002 ffbb 	bl	800bd0c <vAssertCalled>

	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );

	while( pxHeapRegion->xSizeInBytes > 0 )
 8008d96:	f8d5 b004 	ldr.w	fp, [r5, #4]
 8008d9a:	f1bb 0f00 	cmp.w	fp, #0
 8008d9e:	d055      	beq.n	8008e4c <vPortDefineHeapRegions+0xcc>
 8008da0:	3508      	adds	r5, #8
 8008da2:	2600      	movs	r6, #0
 8008da4:	46b0      	mov	r8, r6
		}
		else
		{
			/* Should only get here if one region has already been added to the
			heap. */
			configASSERT( pxEnd != NULL );
 8008da6:	4f2f      	ldr	r7, [pc, #188]	; (8008e64 <vPortDefineHeapRegions+0xe4>)

			/* Check blocks are passed in with increasing start addresses. */
			configASSERT( xAddress > ( size_t ) pxEnd );
 8008da8:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 8008e68 <vPortDefineHeapRegions+0xe8>
			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
 8008dac:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 8008e78 <vPortDefineHeapRegions+0xf8>
 8008db0:	e01d      	b.n	8008dee <vPortDefineHeapRegions+0x6e>
			configASSERT( pxEnd != NULL );
 8008db2:	683b      	ldr	r3, [r7, #0]
 8008db4:	b37b      	cbz	r3, 8008e16 <vPortDefineHeapRegions+0x96>
			configASSERT( xAddress > ( size_t ) pxEnd );
 8008db6:	683b      	ldr	r3, [r7, #0]
 8008db8:	42a3      	cmp	r3, r4
 8008dba:	d232      	bcs.n	8008e22 <vPortDefineHeapRegions+0xa2>
		}

		/* Remember the location of the end marker in the previous region, if
		any. */
		pxPreviousFreeBlock = pxEnd;
 8008dbc:	6839      	ldr	r1, [r7, #0]

		/* pxEnd is used to mark the end of the list of free blocks and is
		inserted at the end of the region space. */
		xAddress = xAlignedHeap + xTotalRegionSize;
 8008dbe:	eb0b 0304 	add.w	r3, fp, r4
		xAddress -= xHeapStructSize;
 8008dc2:	3b08      	subs	r3, #8
		xAddress &= ~portBYTE_ALIGNMENT_MASK;
 8008dc4:	f023 0307 	bic.w	r3, r3, #7
		pxEnd = ( BlockLink_t * ) xAddress;
 8008dc8:	603b      	str	r3, [r7, #0]
		pxEnd->xBlockSize = 0;
 8008dca:	2200      	movs	r2, #0
 8008dcc:	605a      	str	r2, [r3, #4]
		pxEnd->pxNextFreeBlock = NULL;
 8008dce:	601a      	str	r2, [r3, #0]

		/* To start with there is a single free block in this region that is
		sized to take up the entire heap region minus the space taken by the
		free block structure. */
		pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;
 8008dd0:	4622      	mov	r2, r4
		pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;
 8008dd2:	1b18      	subs	r0, r3, r4
 8008dd4:	6060      	str	r0, [r4, #4]
		pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;
 8008dd6:	6023      	str	r3, [r4, #0]

		/* If this is not the first region that makes up the entire heap space
		then link the previous region to this region. */
		if( pxPreviousFreeBlock != NULL )
 8008dd8:	b101      	cbz	r1, 8008ddc <vPortDefineHeapRegions+0x5c>
		{
			pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;
 8008dda:	600c      	str	r4, [r1, #0]
		}

		xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;
 8008ddc:	6853      	ldr	r3, [r2, #4]
 8008dde:	4498      	add	r8, r3

		/* Move onto the next HeapRegion_t structure. */
		xDefinedRegions++;
 8008de0:	3601      	adds	r6, #1
 8008de2:	3508      	adds	r5, #8
	while( pxHeapRegion->xSizeInBytes > 0 )
 8008de4:	f855 bc04 	ldr.w	fp, [r5, #-4]
 8008de8:	f1bb 0f00 	cmp.w	fp, #0
 8008dec:	d01f      	beq.n	8008e2e <vPortDefineHeapRegions+0xae>
		xAddress = ( size_t ) pxHeapRegion->pucStartAddress;
 8008dee:	f855 4c08 	ldr.w	r4, [r5, #-8]
		if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8008df2:	f014 0f07 	tst.w	r4, #7
 8008df6:	d006      	beq.n	8008e06 <vPortDefineHeapRegions+0x86>
			xAddress += ( portBYTE_ALIGNMENT - 1 );
 8008df8:	1de2      	adds	r2, r4, #7
			xAddress &= ~portBYTE_ALIGNMENT_MASK;
 8008dfa:	f022 0207 	bic.w	r2, r2, #7
			xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;
 8008dfe:	44a3      	add	fp, r4
 8008e00:	ebab 0b02 	sub.w	fp, fp, r2
			xAddress &= ~portBYTE_ALIGNMENT_MASK;
 8008e04:	4614      	mov	r4, r2
		if( xDefinedRegions == 0 )
 8008e06:	2e00      	cmp	r6, #0
 8008e08:	d1d3      	bne.n	8008db2 <vPortDefineHeapRegions+0x32>
			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
 8008e0a:	f8c9 4000 	str.w	r4, [r9]
			xStart.xBlockSize = ( size_t ) 0;
 8008e0e:	2300      	movs	r3, #0
 8008e10:	f8c9 3004 	str.w	r3, [r9, #4]
 8008e14:	e7d2      	b.n	8008dbc <vPortDefineHeapRegions+0x3c>
			configASSERT( pxEnd != NULL );
 8008e16:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 8008e1a:	4650      	mov	r0, sl
 8008e1c:	f002 ff76 	bl	800bd0c <vAssertCalled>
 8008e20:	e7c9      	b.n	8008db6 <vPortDefineHeapRegions+0x36>
			configASSERT( xAddress > ( size_t ) pxEnd );
 8008e22:	f240 11e1 	movw	r1, #481	; 0x1e1
 8008e26:	4650      	mov	r0, sl
 8008e28:	f002 ff70 	bl	800bd0c <vAssertCalled>
 8008e2c:	e7c6      	b.n	8008dbc <vPortDefineHeapRegions+0x3c>
		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
	}

	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
 8008e2e:	4b0f      	ldr	r3, [pc, #60]	; (8008e6c <vPortDefineHeapRegions+0xec>)
 8008e30:	f8c3 8000 	str.w	r8, [r3]
	xFreeBytesRemaining = xTotalHeapSize;
 8008e34:	4b0e      	ldr	r3, [pc, #56]	; (8008e70 <vPortDefineHeapRegions+0xf0>)
 8008e36:	f8c3 8000 	str.w	r8, [r3]

	/* Check something was actually defined before it is accessed. */
	configASSERT( xTotalHeapSize );
 8008e3a:	f1b8 0f00 	cmp.w	r8, #0
 8008e3e:	d00a      	beq.n	8008e56 <vPortDefineHeapRegions+0xd6>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8008e40:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8008e44:	4b0b      	ldr	r3, [pc, #44]	; (8008e74 <vPortDefineHeapRegions+0xf4>)
 8008e46:	601a      	str	r2, [r3, #0]
}
 8008e48:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
 8008e4c:	2300      	movs	r3, #0
 8008e4e:	4a07      	ldr	r2, [pc, #28]	; (8008e6c <vPortDefineHeapRegions+0xec>)
 8008e50:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = xTotalHeapSize;
 8008e52:	4a07      	ldr	r2, [pc, #28]	; (8008e70 <vPortDefineHeapRegions+0xf0>)
 8008e54:	6013      	str	r3, [r2, #0]
	configASSERT( xTotalHeapSize );
 8008e56:	f240 210a 	movw	r1, #522	; 0x20a
 8008e5a:	4803      	ldr	r0, [pc, #12]	; (8008e68 <vPortDefineHeapRegions+0xe8>)
 8008e5c:	f002 ff56 	bl	800bd0c <vAssertCalled>
 8008e60:	e7ee      	b.n	8008e40 <vPortDefineHeapRegions+0xc0>
 8008e62:	bf00      	nop
 8008e64:	2000095c 	.word	0x2000095c
 8008e68:	0800c9c0 	.word	0x0800c9c0
 8008e6c:	20000968 	.word	0x20000968
 8008e70:	20000964 	.word	0x20000964
 8008e74:	20000960 	.word	0x20000960
 8008e78:	2000096c 	.word	0x2000096c

08008e7c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8008e7c:	b570      	push	{r4, r5, r6, lr}
 8008e7e:	4604      	mov	r4, r0
 8008e80:	4616      	mov	r6, r2
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8008e82:	6b85      	ldr	r5, [r0, #56]	; 0x38

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8008e84:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8008e86:	b95a      	cbnz	r2, 8008ea0 <prvCopyDataToQueue+0x24>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8008e88:	6803      	ldr	r3, [r0, #0]
BaseType_t xReturn = pdFALSE;
 8008e8a:	2000      	movs	r0, #0
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8008e8c:	b113      	cbz	r3, 8008e94 <prvCopyDataToQueue+0x18>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8008e8e:	3501      	adds	r5, #1
 8008e90:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 8008e92:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8008e94:	6860      	ldr	r0, [r4, #4]
 8008e96:	f001 fa1d 	bl	800a2d4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8008e9a:	2300      	movs	r3, #0
 8008e9c:	6063      	str	r3, [r4, #4]
 8008e9e:	e7f6      	b.n	8008e8e <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 8008ea0:	b96e      	cbnz	r6, 8008ebe <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8008ea2:	6880      	ldr	r0, [r0, #8]
 8008ea4:	f003 f8d9 	bl	800c05a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8008ea8:	68a3      	ldr	r3, [r4, #8]
 8008eaa:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008eac:	4413      	add	r3, r2
 8008eae:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8008eb0:	6862      	ldr	r2, [r4, #4]
 8008eb2:	4293      	cmp	r3, r2
 8008eb4:	d319      	bcc.n	8008eea <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8008eb6:	6823      	ldr	r3, [r4, #0]
 8008eb8:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8008eba:	2000      	movs	r0, #0
 8008ebc:	e7e7      	b.n	8008e8e <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008ebe:	68c0      	ldr	r0, [r0, #12]
 8008ec0:	f003 f8cb 	bl	800c05a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8008ec4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008ec6:	4252      	negs	r2, r2
 8008ec8:	68e3      	ldr	r3, [r4, #12]
 8008eca:	4413      	add	r3, r2
 8008ecc:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8008ece:	6821      	ldr	r1, [r4, #0]
 8008ed0:	428b      	cmp	r3, r1
 8008ed2:	d202      	bcs.n	8008eda <prvCopyDataToQueue+0x5e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8008ed4:	6863      	ldr	r3, [r4, #4]
 8008ed6:	441a      	add	r2, r3
 8008ed8:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8008eda:	2e02      	cmp	r6, #2
 8008edc:	d001      	beq.n	8008ee2 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 8008ede:	2000      	movs	r0, #0
 8008ee0:	e7d5      	b.n	8008e8e <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8008ee2:	b125      	cbz	r5, 8008eee <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 8008ee4:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
 8008ee6:	2000      	movs	r0, #0
 8008ee8:	e7d1      	b.n	8008e8e <prvCopyDataToQueue+0x12>
 8008eea:	2000      	movs	r0, #0
 8008eec:	e7cf      	b.n	8008e8e <prvCopyDataToQueue+0x12>
 8008eee:	2000      	movs	r0, #0
 8008ef0:	e7cd      	b.n	8008e8e <prvCopyDataToQueue+0x12>

08008ef2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8008ef2:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8008ef4:	b172      	cbz	r2, 8008f14 <prvCopyDataFromQueue+0x22>
{
 8008ef6:	b510      	push	{r4, lr}
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8008ef8:	68c3      	ldr	r3, [r0, #12]
 8008efa:	4413      	add	r3, r2
 8008efc:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8008efe:	6844      	ldr	r4, [r0, #4]
 8008f00:	42a3      	cmp	r3, r4
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8008f02:	bf24      	itt	cs
 8008f04:	6803      	ldrcs	r3, [r0, #0]
 8008f06:	60c3      	strcs	r3, [r0, #12]
 8008f08:	460c      	mov	r4, r1
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8008f0a:	68c1      	ldr	r1, [r0, #12]
 8008f0c:	4620      	mov	r0, r4
 8008f0e:	f003 f8a4 	bl	800c05a <memcpy>
 8008f12:	bd10      	pop	{r4, pc}
 8008f14:	4770      	bx	lr

08008f16 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8008f16:	b570      	push	{r4, r5, r6, lr}
 8008f18:	4605      	mov	r5, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8008f1a:	f7ff fceb 	bl	80088f4 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8008f1e:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8008f22:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8008f24:	2c00      	cmp	r4, #0
 8008f26:	dd03      	ble.n	8008f30 <prvUnlockQueue+0x1a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008f28:	6a6b      	ldr	r3, [r5, #36]	; 0x24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008f2a:	f105 0624 	add.w	r6, r5, #36	; 0x24
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008f2e:	b9e3      	cbnz	r3, 8008f6a <prvUnlockQueue+0x54>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8008f30:	23ff      	movs	r3, #255	; 0xff
 8008f32:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8008f36:	f7ff fcff 	bl	8008938 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8008f3a:	f7ff fcdb 	bl	80088f4 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8008f3e:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 8008f42:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8008f44:	2c00      	cmp	r4, #0
 8008f46:	dd03      	ble.n	8008f50 <prvUnlockQueue+0x3a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008f48:	692b      	ldr	r3, [r5, #16]
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8008f4a:	f105 0610 	add.w	r6, r5, #16
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008f4e:	b9db      	cbnz	r3, 8008f88 <prvUnlockQueue+0x72>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8008f50:	23ff      	movs	r3, #255	; 0xff
 8008f52:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 8008f56:	f7ff fcef 	bl	8008938 <vPortExitCritical>
 8008f5a:	bd70      	pop	{r4, r5, r6, pc}
 8008f5c:	3c01      	subs	r4, #1
 8008f5e:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8008f60:	2c00      	cmp	r4, #0
 8008f62:	d0e5      	beq.n	8008f30 <prvUnlockQueue+0x1a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8008f64:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8008f66:	2b00      	cmp	r3, #0
 8008f68:	d0e2      	beq.n	8008f30 <prvUnlockQueue+0x1a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8008f6a:	4630      	mov	r0, r6
 8008f6c:	f000 ff94 	bl	8009e98 <xTaskRemoveFromEventList>
 8008f70:	2800      	cmp	r0, #0
 8008f72:	d0f3      	beq.n	8008f5c <prvUnlockQueue+0x46>
						vTaskMissedYield();
 8008f74:	f001 f86a 	bl	800a04c <vTaskMissedYield>
 8008f78:	e7f0      	b.n	8008f5c <prvUnlockQueue+0x46>
 8008f7a:	3c01      	subs	r4, #1
 8008f7c:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8008f7e:	2c00      	cmp	r4, #0
 8008f80:	d0e6      	beq.n	8008f50 <prvUnlockQueue+0x3a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008f82:	692b      	ldr	r3, [r5, #16]
 8008f84:	2b00      	cmp	r3, #0
 8008f86:	d0e3      	beq.n	8008f50 <prvUnlockQueue+0x3a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8008f88:	4630      	mov	r0, r6
 8008f8a:	f000 ff85 	bl	8009e98 <xTaskRemoveFromEventList>
 8008f8e:	2800      	cmp	r0, #0
 8008f90:	d0f3      	beq.n	8008f7a <prvUnlockQueue+0x64>
					vTaskMissedYield();
 8008f92:	f001 f85b 	bl	800a04c <vTaskMissedYield>
 8008f96:	e7f0      	b.n	8008f7a <prvUnlockQueue+0x64>

08008f98 <xQueueGenericReset>:
{
 8008f98:	b538      	push	{r3, r4, r5, lr}
 8008f9a:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8008f9c:	4604      	mov	r4, r0
 8008f9e:	b1d0      	cbz	r0, 8008fd6 <xQueueGenericReset+0x3e>
	taskENTER_CRITICAL();
 8008fa0:	f7ff fca8 	bl	80088f4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8008fa4:	6822      	ldr	r2, [r4, #0]
 8008fa6:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8008fa8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008faa:	fb03 f301 	mul.w	r3, r3, r1
 8008fae:	18d0      	adds	r0, r2, r3
 8008fb0:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8008fb2:	2000      	movs	r0, #0
 8008fb4:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8008fb6:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8008fb8:	1a5b      	subs	r3, r3, r1
 8008fba:	4413      	add	r3, r2
 8008fbc:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8008fbe:	23ff      	movs	r3, #255	; 0xff
 8008fc0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8008fc4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 8008fc8:	b9d5      	cbnz	r5, 8009000 <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8008fca:	6923      	ldr	r3, [r4, #16]
 8008fcc:	b94b      	cbnz	r3, 8008fe2 <xQueueGenericReset+0x4a>
	taskEXIT_CRITICAL();
 8008fce:	f7ff fcb3 	bl	8008938 <vPortExitCritical>
}
 8008fd2:	2001      	movs	r0, #1
 8008fd4:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxQueue );
 8008fd6:	f240 111b 	movw	r1, #283	; 0x11b
 8008fda:	480e      	ldr	r0, [pc, #56]	; (8009014 <xQueueGenericReset+0x7c>)
 8008fdc:	f002 fe96 	bl	800bd0c <vAssertCalled>
 8008fe0:	e7de      	b.n	8008fa0 <xQueueGenericReset+0x8>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8008fe2:	f104 0010 	add.w	r0, r4, #16
 8008fe6:	f000 ff57 	bl	8009e98 <xTaskRemoveFromEventList>
 8008fea:	2800      	cmp	r0, #0
 8008fec:	d0ef      	beq.n	8008fce <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 8008fee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008ff2:	4b09      	ldr	r3, [pc, #36]	; (8009018 <xQueueGenericReset+0x80>)
 8008ff4:	601a      	str	r2, [r3, #0]
 8008ff6:	f3bf 8f4f 	dsb	sy
 8008ffa:	f3bf 8f6f 	isb	sy
 8008ffe:	e7e6      	b.n	8008fce <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009000:	f104 0010 	add.w	r0, r4, #16
 8009004:	f7ff fbec 	bl	80087e0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8009008:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800900c:	f7ff fbe8 	bl	80087e0 <vListInitialise>
 8009010:	e7dd      	b.n	8008fce <xQueueGenericReset+0x36>
 8009012:	bf00      	nop
 8009014:	0800c9f8 	.word	0x0800c9f8
 8009018:	e000ed04 	.word	0xe000ed04

0800901c <xQueueGenericCreate>:
	{
 800901c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800901e:	460d      	mov	r5, r1
 8009020:	4617      	mov	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8009022:	4606      	mov	r6, r0
 8009024:	b1a0      	cbz	r0, 8009050 <xQueueGenericCreate+0x34>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009026:	fb05 f006 	mul.w	r0, r5, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800902a:	3050      	adds	r0, #80	; 0x50
 800902c:	f7ff fdec 	bl	8008c08 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8009030:	4604      	mov	r4, r0
 8009032:	b158      	cbz	r0, 800904c <xQueueGenericCreate+0x30>
	if( uxItemSize == ( UBaseType_t ) 0 )
 8009034:	b195      	cbz	r5, 800905c <xQueueGenericCreate+0x40>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8009036:	f100 0350 	add.w	r3, r0, #80	; 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800903a:	6003      	str	r3, [r0, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800903c:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800903e:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8009040:	2101      	movs	r1, #1
 8009042:	4620      	mov	r0, r4
 8009044:	f7ff ffa8 	bl	8008f98 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 8009048:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
	}
 800904c:	4620      	mov	r0, r4
 800904e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8009050:	f44f 71c4 	mov.w	r1, #392	; 0x188
 8009054:	4802      	ldr	r0, [pc, #8]	; (8009060 <xQueueGenericCreate+0x44>)
 8009056:	f002 fe59 	bl	800bd0c <vAssertCalled>
 800905a:	e7e4      	b.n	8009026 <xQueueGenericCreate+0xa>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800905c:	6020      	str	r0, [r4, #0]
 800905e:	e7ed      	b.n	800903c <xQueueGenericCreate+0x20>
 8009060:	0800c9f8 	.word	0x0800c9f8

08009064 <xQueueCreateCountingSemaphore>:
	{
 8009064:	b538      	push	{r3, r4, r5, lr}
 8009066:	460d      	mov	r5, r1
		configASSERT( uxMaxCount != 0 );
 8009068:	4604      	mov	r4, r0
 800906a:	b158      	cbz	r0, 8009084 <xQueueCreateCountingSemaphore+0x20>
		configASSERT( uxInitialCount <= uxMaxCount );
 800906c:	42ac      	cmp	r4, r5
 800906e:	d30f      	bcc.n	8009090 <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8009070:	2202      	movs	r2, #2
 8009072:	2100      	movs	r1, #0
 8009074:	4620      	mov	r0, r4
 8009076:	f7ff ffd1 	bl	800901c <xQueueGenericCreate>
		if( xHandle != NULL )
 800907a:	4603      	mov	r3, r0
 800907c:	b100      	cbz	r0, 8009080 <xQueueCreateCountingSemaphore+0x1c>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800907e:	6385      	str	r5, [r0, #56]	; 0x38
	}
 8009080:	4618      	mov	r0, r3
 8009082:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( uxMaxCount != 0 );
 8009084:	f240 21d7 	movw	r1, #727	; 0x2d7
 8009088:	4804      	ldr	r0, [pc, #16]	; (800909c <xQueueCreateCountingSemaphore+0x38>)
 800908a:	f002 fe3f 	bl	800bd0c <vAssertCalled>
 800908e:	e7ed      	b.n	800906c <xQueueCreateCountingSemaphore+0x8>
		configASSERT( uxInitialCount <= uxMaxCount );
 8009090:	f44f 7136 	mov.w	r1, #728	; 0x2d8
 8009094:	4801      	ldr	r0, [pc, #4]	; (800909c <xQueueCreateCountingSemaphore+0x38>)
 8009096:	f002 fe39 	bl	800bd0c <vAssertCalled>
 800909a:	e7e9      	b.n	8009070 <xQueueCreateCountingSemaphore+0xc>
 800909c:	0800c9f8 	.word	0x0800c9f8

080090a0 <xQueueGenericSend>:
{
 80090a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80090a4:	b084      	sub	sp, #16
 80090a6:	4688      	mov	r8, r1
 80090a8:	9201      	str	r2, [sp, #4]
 80090aa:	461d      	mov	r5, r3
	configASSERT( pxQueue );
 80090ac:	4604      	mov	r4, r0
 80090ae:	b198      	cbz	r0, 80090d8 <xQueueGenericSend+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80090b0:	f1b8 0f00 	cmp.w	r8, #0
 80090b4:	d016      	beq.n	80090e4 <xQueueGenericSend+0x44>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80090b6:	2d02      	cmp	r5, #2
 80090b8:	d01d      	beq.n	80090f6 <xQueueGenericSend+0x56>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80090ba:	f001 f8ad 	bl	800a218 <xTaskGetSchedulerState>
 80090be:	b930      	cbnz	r0, 80090ce <xQueueGenericSend+0x2e>
 80090c0:	9b01      	ldr	r3, [sp, #4]
 80090c2:	b123      	cbz	r3, 80090ce <xQueueGenericSend+0x2e>
 80090c4:	f44f 713e 	mov.w	r1, #760	; 0x2f8
 80090c8:	4851      	ldr	r0, [pc, #324]	; (8009210 <xQueueGenericSend+0x170>)
 80090ca:	f002 fe1f 	bl	800bd0c <vAssertCalled>
{
 80090ce:	f04f 0900 	mov.w	r9, #0
		prvLockQueue( pxQueue );
 80090d2:	464e      	mov	r6, r9
					portYIELD_WITHIN_API();
 80090d4:	4f4f      	ldr	r7, [pc, #316]	; (8009214 <xQueueGenericSend+0x174>)
 80090d6:	e04b      	b.n	8009170 <xQueueGenericSend+0xd0>
	configASSERT( pxQueue );
 80090d8:	f240 21f3 	movw	r1, #755	; 0x2f3
 80090dc:	484c      	ldr	r0, [pc, #304]	; (8009210 <xQueueGenericSend+0x170>)
 80090de:	f002 fe15 	bl	800bd0c <vAssertCalled>
 80090e2:	e7e5      	b.n	80090b0 <xQueueGenericSend+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80090e4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80090e6:	2b00      	cmp	r3, #0
 80090e8:	d0e5      	beq.n	80090b6 <xQueueGenericSend+0x16>
 80090ea:	f44f 713d 	mov.w	r1, #756	; 0x2f4
 80090ee:	4848      	ldr	r0, [pc, #288]	; (8009210 <xQueueGenericSend+0x170>)
 80090f0:	f002 fe0c 	bl	800bd0c <vAssertCalled>
 80090f4:	e7df      	b.n	80090b6 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80090f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80090f8:	2b01      	cmp	r3, #1
 80090fa:	d0de      	beq.n	80090ba <xQueueGenericSend+0x1a>
 80090fc:	f240 21f5 	movw	r1, #757	; 0x2f5
 8009100:	4843      	ldr	r0, [pc, #268]	; (8009210 <xQueueGenericSend+0x170>)
 8009102:	f002 fe03 	bl	800bd0c <vAssertCalled>
 8009106:	e7d8      	b.n	80090ba <xQueueGenericSend+0x1a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8009108:	462a      	mov	r2, r5
 800910a:	4641      	mov	r1, r8
 800910c:	4620      	mov	r0, r4
 800910e:	f7ff feb5 	bl	8008e7c <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009112:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009114:	b973      	cbnz	r3, 8009134 <xQueueGenericSend+0x94>
					else if( xYieldRequired != pdFALSE )
 8009116:	b138      	cbz	r0, 8009128 <xQueueGenericSend+0x88>
						queueYIELD_IF_USING_PREEMPTION();
 8009118:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800911c:	4b3d      	ldr	r3, [pc, #244]	; (8009214 <xQueueGenericSend+0x174>)
 800911e:	601a      	str	r2, [r3, #0]
 8009120:	f3bf 8f4f 	dsb	sy
 8009124:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8009128:	f7ff fc06 	bl	8008938 <vPortExitCritical>
				return pdPASS;
 800912c:	2001      	movs	r0, #1
}
 800912e:	b004      	add	sp, #16
 8009130:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009134:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009138:	f000 feae 	bl	8009e98 <xTaskRemoveFromEventList>
 800913c:	2800      	cmp	r0, #0
 800913e:	d0f3      	beq.n	8009128 <xQueueGenericSend+0x88>
							queueYIELD_IF_USING_PREEMPTION();
 8009140:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009144:	4b33      	ldr	r3, [pc, #204]	; (8009214 <xQueueGenericSend+0x174>)
 8009146:	601a      	str	r2, [r3, #0]
 8009148:	f3bf 8f4f 	dsb	sy
 800914c:	f3bf 8f6f 	isb	sy
 8009150:	e7ea      	b.n	8009128 <xQueueGenericSend+0x88>
					taskEXIT_CRITICAL();
 8009152:	f7ff fbf1 	bl	8008938 <vPortExitCritical>
					return errQUEUE_FULL;
 8009156:	2000      	movs	r0, #0
 8009158:	e7e9      	b.n	800912e <xQueueGenericSend+0x8e>
					vTaskSetTimeOutState( &xTimeOut );
 800915a:	a802      	add	r0, sp, #8
 800915c:	f000 ff24 	bl	8009fa8 <vTaskSetTimeOutState>
 8009160:	e014      	b.n	800918c <xQueueGenericSend+0xec>
				prvUnlockQueue( pxQueue );
 8009162:	4620      	mov	r0, r4
 8009164:	f7ff fed7 	bl	8008f16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8009168:	f000 fcfc 	bl	8009b64 <xTaskResumeAll>
 800916c:	f04f 0901 	mov.w	r9, #1
		taskENTER_CRITICAL();
 8009170:	f7ff fbc0 	bl	80088f4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8009174:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009176:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009178:	429a      	cmp	r2, r3
 800917a:	d3c5      	bcc.n	8009108 <xQueueGenericSend+0x68>
 800917c:	2d02      	cmp	r5, #2
 800917e:	d0c3      	beq.n	8009108 <xQueueGenericSend+0x68>
				if( xTicksToWait == ( TickType_t ) 0 )
 8009180:	9b01      	ldr	r3, [sp, #4]
 8009182:	2b00      	cmp	r3, #0
 8009184:	d0e5      	beq.n	8009152 <xQueueGenericSend+0xb2>
				else if( xEntryTimeSet == pdFALSE )
 8009186:	f1b9 0f00 	cmp.w	r9, #0
 800918a:	d0e6      	beq.n	800915a <xQueueGenericSend+0xba>
		taskEXIT_CRITICAL();
 800918c:	f7ff fbd4 	bl	8008938 <vPortExitCritical>
		vTaskSuspendAll();
 8009190:	f000 fc0e 	bl	80099b0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8009194:	f7ff fbae 	bl	80088f4 <vPortEnterCritical>
 8009198:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800919c:	b25b      	sxtb	r3, r3
 800919e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80091a2:	bf08      	it	eq
 80091a4:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
 80091a8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80091ac:	b25b      	sxtb	r3, r3
 80091ae:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80091b2:	bf08      	it	eq
 80091b4:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
 80091b8:	f7ff fbbe 	bl	8008938 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80091bc:	a901      	add	r1, sp, #4
 80091be:	a802      	add	r0, sp, #8
 80091c0:	f000 ff08 	bl	8009fd4 <xTaskCheckForTimeOut>
 80091c4:	b9e8      	cbnz	r0, 8009202 <xQueueGenericSend+0x162>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80091c6:	f7ff fb95 	bl	80088f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80091ca:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
 80091ce:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80091d2:	f7ff fbb1 	bl	8008938 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80091d6:	45ca      	cmp	sl, r9
 80091d8:	d1c3      	bne.n	8009162 <xQueueGenericSend+0xc2>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80091da:	9901      	ldr	r1, [sp, #4]
 80091dc:	f104 0010 	add.w	r0, r4, #16
 80091e0:	f000 fe16 	bl	8009e10 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80091e4:	4620      	mov	r0, r4
 80091e6:	f7ff fe96 	bl	8008f16 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80091ea:	f000 fcbb 	bl	8009b64 <xTaskResumeAll>
 80091ee:	2800      	cmp	r0, #0
 80091f0:	d1bc      	bne.n	800916c <xQueueGenericSend+0xcc>
					portYIELD_WITHIN_API();
 80091f2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80091f6:	603b      	str	r3, [r7, #0]
 80091f8:	f3bf 8f4f 	dsb	sy
 80091fc:	f3bf 8f6f 	isb	sy
 8009200:	e7b4      	b.n	800916c <xQueueGenericSend+0xcc>
			prvUnlockQueue( pxQueue );
 8009202:	4620      	mov	r0, r4
 8009204:	f7ff fe87 	bl	8008f16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8009208:	f000 fcac 	bl	8009b64 <xTaskResumeAll>
			return errQUEUE_FULL;
 800920c:	2000      	movs	r0, #0
 800920e:	e78e      	b.n	800912e <xQueueGenericSend+0x8e>
 8009210:	0800c9f8 	.word	0x0800c9f8
 8009214:	e000ed04 	.word	0xe000ed04

08009218 <xQueueGiveFromISR>:
{
 8009218:	b570      	push	{r4, r5, r6, lr}
 800921a:	460e      	mov	r6, r1
	configASSERT( pxQueue );
 800921c:	4604      	mov	r4, r0
 800921e:	b318      	cbz	r0, 8009268 <xQueueGiveFromISR+0x50>
	configASSERT( pxQueue->uxItemSize == 0 );
 8009220:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009222:	bb3b      	cbnz	r3, 8009274 <xQueueGiveFromISR+0x5c>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8009224:	6823      	ldr	r3, [r4, #0]
 8009226:	b35b      	cbz	r3, 8009280 <xQueueGiveFromISR+0x68>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8009228:	f7ff fc96 	bl	8008b58 <vPortValidateInterruptPriority>
	__asm volatile
 800922c:	f3ef 8511 	mrs	r5, BASEPRI
 8009230:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009234:	f383 8811 	msr	BASEPRI, r3
 8009238:	f3bf 8f6f 	isb	sy
 800923c:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8009240:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8009242:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009244:	429a      	cmp	r2, r3
 8009246:	d231      	bcs.n	80092ac <xQueueGiveFromISR+0x94>
			const int8_t cTxLock = pxQueue->cTxLock;
 8009248:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800924c:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800924e:	3201      	adds	r2, #1
 8009250:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8009252:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009256:	d01c      	beq.n	8009292 <xQueueGiveFromISR+0x7a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8009258:	3301      	adds	r3, #1
 800925a:	b25b      	sxtb	r3, r3
 800925c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 8009260:	2001      	movs	r0, #1
	__asm volatile
 8009262:	f385 8811 	msr	BASEPRI, r5
}
 8009266:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
 8009268:	f240 4156 	movw	r1, #1110	; 0x456
 800926c:	4812      	ldr	r0, [pc, #72]	; (80092b8 <xQueueGiveFromISR+0xa0>)
 800926e:	f002 fd4d 	bl	800bd0c <vAssertCalled>
 8009272:	e7d5      	b.n	8009220 <xQueueGiveFromISR+0x8>
	configASSERT( pxQueue->uxItemSize == 0 );
 8009274:	f240 415a 	movw	r1, #1114	; 0x45a
 8009278:	480f      	ldr	r0, [pc, #60]	; (80092b8 <xQueueGiveFromISR+0xa0>)
 800927a:	f002 fd47 	bl	800bd0c <vAssertCalled>
 800927e:	e7d1      	b.n	8009224 <xQueueGiveFromISR+0xc>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8009280:	6863      	ldr	r3, [r4, #4]
 8009282:	2b00      	cmp	r3, #0
 8009284:	d0d0      	beq.n	8009228 <xQueueGiveFromISR+0x10>
 8009286:	f240 415f 	movw	r1, #1119	; 0x45f
 800928a:	480b      	ldr	r0, [pc, #44]	; (80092b8 <xQueueGiveFromISR+0xa0>)
 800928c:	f002 fd3e 	bl	800bd0c <vAssertCalled>
 8009290:	e7ca      	b.n	8009228 <xQueueGiveFromISR+0x10>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009292:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009294:	b90b      	cbnz	r3, 800929a <xQueueGiveFromISR+0x82>
			xReturn = pdPASS;
 8009296:	2001      	movs	r0, #1
 8009298:	e7e3      	b.n	8009262 <xQueueGiveFromISR+0x4a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800929a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800929e:	f000 fdfb 	bl	8009e98 <xTaskRemoveFromEventList>
 80092a2:	b128      	cbz	r0, 80092b0 <xQueueGiveFromISR+0x98>
							if( pxHigherPriorityTaskWoken != NULL )
 80092a4:	b136      	cbz	r6, 80092b4 <xQueueGiveFromISR+0x9c>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80092a6:	2001      	movs	r0, #1
 80092a8:	6030      	str	r0, [r6, #0]
 80092aa:	e7da      	b.n	8009262 <xQueueGiveFromISR+0x4a>
			xReturn = errQUEUE_FULL;
 80092ac:	2000      	movs	r0, #0
 80092ae:	e7d8      	b.n	8009262 <xQueueGiveFromISR+0x4a>
			xReturn = pdPASS;
 80092b0:	2001      	movs	r0, #1
 80092b2:	e7d6      	b.n	8009262 <xQueueGiveFromISR+0x4a>
 80092b4:	2001      	movs	r0, #1
 80092b6:	e7d4      	b.n	8009262 <xQueueGiveFromISR+0x4a>
 80092b8:	0800c9f8 	.word	0x0800c9f8

080092bc <xQueueGenericReceive>:
{
 80092bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80092c0:	b084      	sub	sp, #16
 80092c2:	4689      	mov	r9, r1
 80092c4:	9201      	str	r2, [sp, #4]
 80092c6:	4698      	mov	r8, r3
	configASSERT( pxQueue );
 80092c8:	4604      	mov	r4, r0
 80092ca:	b188      	cbz	r0, 80092f0 <xQueueGenericReceive+0x34>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80092cc:	f1b9 0f00 	cmp.w	r9, #0
 80092d0:	d014      	beq.n	80092fc <xQueueGenericReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80092d2:	f000 ffa1 	bl	800a218 <xTaskGetSchedulerState>
 80092d6:	b930      	cbnz	r0, 80092e6 <xQueueGenericReceive+0x2a>
 80092d8:	9b01      	ldr	r3, [sp, #4]
 80092da:	b123      	cbz	r3, 80092e6 <xQueueGenericReceive+0x2a>
 80092dc:	f240 41fa 	movw	r1, #1274	; 0x4fa
 80092e0:	485e      	ldr	r0, [pc, #376]	; (800945c <xQueueGenericReceive+0x1a0>)
 80092e2:	f002 fd13 	bl	800bd0c <vAssertCalled>
{
 80092e6:	f04f 0a00 	mov.w	sl, #0
		prvLockQueue( pxQueue );
 80092ea:	4655      	mov	r5, sl
					portYIELD_WITHIN_API();
 80092ec:	4e5c      	ldr	r6, [pc, #368]	; (8009460 <xQueueGenericReceive+0x1a4>)
 80092ee:	e06c      	b.n	80093ca <xQueueGenericReceive+0x10e>
	configASSERT( pxQueue );
 80092f0:	f240 41f6 	movw	r1, #1270	; 0x4f6
 80092f4:	4859      	ldr	r0, [pc, #356]	; (800945c <xQueueGenericReceive+0x1a0>)
 80092f6:	f002 fd09 	bl	800bd0c <vAssertCalled>
 80092fa:	e7e7      	b.n	80092cc <xQueueGenericReceive+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80092fc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80092fe:	2b00      	cmp	r3, #0
 8009300:	d0e7      	beq.n	80092d2 <xQueueGenericReceive+0x16>
 8009302:	f240 41f7 	movw	r1, #1271	; 0x4f7
 8009306:	4855      	ldr	r0, [pc, #340]	; (800945c <xQueueGenericReceive+0x1a0>)
 8009308:	f002 fd00 	bl	800bd0c <vAssertCalled>
 800930c:	e7e1      	b.n	80092d2 <xQueueGenericReceive+0x16>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800930e:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8009310:	4649      	mov	r1, r9
 8009312:	4620      	mov	r0, r4
 8009314:	f7ff fded 	bl	8008ef2 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8009318:	f1b8 0f00 	cmp.w	r8, #0
 800931c:	d11e      	bne.n	800935c <xQueueGenericReceive+0xa0>
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800931e:	1e7b      	subs	r3, r7, #1
 8009320:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8009322:	6823      	ldr	r3, [r4, #0]
 8009324:	b13b      	cbz	r3, 8009336 <xQueueGenericReceive+0x7a>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8009326:	6923      	ldr	r3, [r4, #16]
 8009328:	b94b      	cbnz	r3, 800933e <xQueueGenericReceive+0x82>
				taskEXIT_CRITICAL();
 800932a:	f7ff fb05 	bl	8008938 <vPortExitCritical>
				return pdPASS;
 800932e:	2001      	movs	r0, #1
}
 8009330:	b004      	add	sp, #16
 8009332:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8009336:	f001 f913 	bl	800a560 <pvTaskIncrementMutexHeldCount>
 800933a:	6060      	str	r0, [r4, #4]
 800933c:	e7f3      	b.n	8009326 <xQueueGenericReceive+0x6a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800933e:	f104 0010 	add.w	r0, r4, #16
 8009342:	f000 fda9 	bl	8009e98 <xTaskRemoveFromEventList>
 8009346:	2800      	cmp	r0, #0
 8009348:	d0ef      	beq.n	800932a <xQueueGenericReceive+0x6e>
							queueYIELD_IF_USING_PREEMPTION();
 800934a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800934e:	4b44      	ldr	r3, [pc, #272]	; (8009460 <xQueueGenericReceive+0x1a4>)
 8009350:	601a      	str	r2, [r3, #0]
 8009352:	f3bf 8f4f 	dsb	sy
 8009356:	f3bf 8f6f 	isb	sy
 800935a:	e7e6      	b.n	800932a <xQueueGenericReceive+0x6e>
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800935c:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800935e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009360:	2b00      	cmp	r3, #0
 8009362:	d0e2      	beq.n	800932a <xQueueGenericReceive+0x6e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009364:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009368:	f000 fd96 	bl	8009e98 <xTaskRemoveFromEventList>
 800936c:	2800      	cmp	r0, #0
 800936e:	d0dc      	beq.n	800932a <xQueueGenericReceive+0x6e>
							queueYIELD_IF_USING_PREEMPTION();
 8009370:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009374:	4b3a      	ldr	r3, [pc, #232]	; (8009460 <xQueueGenericReceive+0x1a4>)
 8009376:	601a      	str	r2, [r3, #0]
 8009378:	f3bf 8f4f 	dsb	sy
 800937c:	f3bf 8f6f 	isb	sy
 8009380:	e7d3      	b.n	800932a <xQueueGenericReceive+0x6e>
					taskEXIT_CRITICAL();
 8009382:	f7ff fad9 	bl	8008938 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8009386:	2000      	movs	r0, #0
 8009388:	e7d2      	b.n	8009330 <xQueueGenericReceive+0x74>
					vTaskSetTimeOutState( &xTimeOut );
 800938a:	a802      	add	r0, sp, #8
 800938c:	f000 fe0c 	bl	8009fa8 <vTaskSetTimeOutState>
 8009390:	e026      	b.n	80093e0 <xQueueGenericReceive+0x124>
						taskENTER_CRITICAL();
 8009392:	f7ff faaf 	bl	80088f4 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8009396:	6860      	ldr	r0, [r4, #4]
 8009398:	f000 ff4e 	bl	800a238 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 800939c:	f7ff facc 	bl	8008938 <vPortExitCritical>
 80093a0:	e046      	b.n	8009430 <xQueueGenericReceive+0x174>
				prvUnlockQueue( pxQueue );
 80093a2:	4620      	mov	r0, r4
 80093a4:	f7ff fdb7 	bl	8008f16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80093a8:	f000 fbdc 	bl	8009b64 <xTaskResumeAll>
 80093ac:	e00b      	b.n	80093c6 <xQueueGenericReceive+0x10a>
			prvUnlockQueue( pxQueue );
 80093ae:	4620      	mov	r0, r4
 80093b0:	f7ff fdb1 	bl	8008f16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80093b4:	f000 fbd6 	bl	8009b64 <xTaskResumeAll>
	taskENTER_CRITICAL();
 80093b8:	f7ff fa9c 	bl	80088f4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80093bc:	6ba7      	ldr	r7, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 80093be:	f7ff fabb 	bl	8008938 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80093c2:	2f00      	cmp	r7, #0
 80093c4:	d048      	beq.n	8009458 <xQueueGenericReceive+0x19c>
 80093c6:	f04f 0a01 	mov.w	sl, #1
		taskENTER_CRITICAL();
 80093ca:	f7ff fa93 	bl	80088f4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80093ce:	6ba7      	ldr	r7, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80093d0:	2f00      	cmp	r7, #0
 80093d2:	d19c      	bne.n	800930e <xQueueGenericReceive+0x52>
				if( xTicksToWait == ( TickType_t ) 0 )
 80093d4:	9b01      	ldr	r3, [sp, #4]
 80093d6:	2b00      	cmp	r3, #0
 80093d8:	d0d3      	beq.n	8009382 <xQueueGenericReceive+0xc6>
				else if( xEntryTimeSet == pdFALSE )
 80093da:	f1ba 0f00 	cmp.w	sl, #0
 80093de:	d0d4      	beq.n	800938a <xQueueGenericReceive+0xce>
		taskEXIT_CRITICAL();
 80093e0:	f7ff faaa 	bl	8008938 <vPortExitCritical>
		vTaskSuspendAll();
 80093e4:	f000 fae4 	bl	80099b0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80093e8:	f7ff fa84 	bl	80088f4 <vPortEnterCritical>
 80093ec:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80093f0:	b25b      	sxtb	r3, r3
 80093f2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80093f6:	bf08      	it	eq
 80093f8:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
 80093fc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8009400:	b25b      	sxtb	r3, r3
 8009402:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009406:	bf08      	it	eq
 8009408:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
 800940c:	f7ff fa94 	bl	8008938 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8009410:	a901      	add	r1, sp, #4
 8009412:	a802      	add	r0, sp, #8
 8009414:	f000 fdde 	bl	8009fd4 <xTaskCheckForTimeOut>
 8009418:	2800      	cmp	r0, #0
 800941a:	d1c8      	bne.n	80093ae <xQueueGenericReceive+0xf2>
	taskENTER_CRITICAL();
 800941c:	f7ff fa6a 	bl	80088f4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8009420:	6ba7      	ldr	r7, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8009422:	f7ff fa89 	bl	8008938 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8009426:	2f00      	cmp	r7, #0
 8009428:	d1bb      	bne.n	80093a2 <xQueueGenericReceive+0xe6>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800942a:	6823      	ldr	r3, [r4, #0]
 800942c:	2b00      	cmp	r3, #0
 800942e:	d0b0      	beq.n	8009392 <xQueueGenericReceive+0xd6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8009430:	9901      	ldr	r1, [sp, #4]
 8009432:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009436:	f000 fceb 	bl	8009e10 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800943a:	4620      	mov	r0, r4
 800943c:	f7ff fd6b 	bl	8008f16 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8009440:	f000 fb90 	bl	8009b64 <xTaskResumeAll>
 8009444:	2800      	cmp	r0, #0
 8009446:	d1be      	bne.n	80093c6 <xQueueGenericReceive+0x10a>
					portYIELD_WITHIN_API();
 8009448:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800944c:	6033      	str	r3, [r6, #0]
 800944e:	f3bf 8f4f 	dsb	sy
 8009452:	f3bf 8f6f 	isb	sy
 8009456:	e7b6      	b.n	80093c6 <xQueueGenericReceive+0x10a>
				return errQUEUE_EMPTY;
 8009458:	2000      	movs	r0, #0
 800945a:	e769      	b.n	8009330 <xQueueGenericReceive+0x74>
 800945c:	0800c9f8 	.word	0x0800c9f8
 8009460:	e000ed04 	.word	0xe000ed04

08009464 <uxQueueMessagesWaiting>:
{
 8009464:	b510      	push	{r4, lr}
	configASSERT( xQueue );
 8009466:	4604      	mov	r4, r0
 8009468:	b130      	cbz	r0, 8009478 <uxQueueMessagesWaiting+0x14>
	taskENTER_CRITICAL();
 800946a:	f7ff fa43 	bl	80088f4 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 800946e:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8009470:	f7ff fa62 	bl	8008938 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8009474:	4620      	mov	r0, r4
 8009476:	bd10      	pop	{r4, pc}
	configASSERT( xQueue );
 8009478:	f240 6149 	movw	r1, #1609	; 0x649
 800947c:	4801      	ldr	r0, [pc, #4]	; (8009484 <uxQueueMessagesWaiting+0x20>)
 800947e:	f002 fc45 	bl	800bd0c <vAssertCalled>
 8009482:	e7f2      	b.n	800946a <uxQueueMessagesWaiting+0x6>
 8009484:	0800c9f8 	.word	0x0800c9f8

08009488 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8009488:	b410      	push	{r4}

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800948a:	4b0b      	ldr	r3, [pc, #44]	; (80094b8 <vQueueAddToRegistry+0x30>)
 800948c:	681b      	ldr	r3, [r3, #0]
 800948e:	b153      	cbz	r3, 80094a6 <vQueueAddToRegistry+0x1e>
 8009490:	2301      	movs	r3, #1
 8009492:	4c09      	ldr	r4, [pc, #36]	; (80094b8 <vQueueAddToRegistry+0x30>)
 8009494:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
 8009498:	b132      	cbz	r2, 80094a8 <vQueueAddToRegistry+0x20>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800949a:	3301      	adds	r3, #1
 800949c:	2b08      	cmp	r3, #8
 800949e:	d1f9      	bne.n	8009494 <vQueueAddToRegistry+0xc>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80094a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80094a4:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80094a6:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 80094a8:	4a03      	ldr	r2, [pc, #12]	; (80094b8 <vQueueAddToRegistry+0x30>)
 80094aa:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 80094ae:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80094b2:	6058      	str	r0, [r3, #4]
				break;
 80094b4:	e7f4      	b.n	80094a0 <vQueueAddToRegistry+0x18>
 80094b6:	bf00      	nop
 80094b8:	20004ca4 	.word	0x20004ca4

080094bc <vQueueUnregisterQueue>:

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80094bc:	4b0b      	ldr	r3, [pc, #44]	; (80094ec <vQueueUnregisterQueue+0x30>)
 80094be:	685b      	ldr	r3, [r3, #4]
 80094c0:	4298      	cmp	r0, r3
 80094c2:	d009      	beq.n	80094d8 <vQueueUnregisterQueue+0x1c>
 80094c4:	4a09      	ldr	r2, [pc, #36]	; (80094ec <vQueueUnregisterQueue+0x30>)
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80094c6:	2301      	movs	r3, #1
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80094c8:	68d1      	ldr	r1, [r2, #12]
 80094ca:	4281      	cmp	r1, r0
 80094cc:	d005      	beq.n	80094da <vQueueUnregisterQueue+0x1e>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80094ce:	3301      	adds	r3, #1
 80094d0:	3208      	adds	r2, #8
 80094d2:	2b08      	cmp	r3, #8
 80094d4:	d1f8      	bne.n	80094c8 <vQueueUnregisterQueue+0xc>
 80094d6:	4770      	bx	lr
 80094d8:	2300      	movs	r3, #0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 80094da:	4a04      	ldr	r2, [pc, #16]	; (80094ec <vQueueUnregisterQueue+0x30>)
 80094dc:	2100      	movs	r1, #0
 80094de:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 80094e2:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80094e6:	6059      	str	r1, [r3, #4]
				break;
 80094e8:	4770      	bx	lr
 80094ea:	bf00      	nop
 80094ec:	20004ca4 	.word	0x20004ca4

080094f0 <vQueueDelete>:
{
 80094f0:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
 80094f2:	4604      	mov	r4, r0
 80094f4:	b130      	cbz	r0, 8009504 <vQueueDelete+0x14>
		vQueueUnregisterQueue( pxQueue );
 80094f6:	4620      	mov	r0, r4
 80094f8:	f7ff ffe0 	bl	80094bc <vQueueUnregisterQueue>
		vPortFree( pxQueue );
 80094fc:	4620      	mov	r0, r4
 80094fe:	f7ff fbe9 	bl	8008cd4 <vPortFree>
 8009502:	bd10      	pop	{r4, pc}
	configASSERT( pxQueue );
 8009504:	f240 6177 	movw	r1, #1655	; 0x677
 8009508:	4801      	ldr	r0, [pc, #4]	; (8009510 <vQueueDelete+0x20>)
 800950a:	f002 fbff 	bl	800bd0c <vAssertCalled>
 800950e:	e7f2      	b.n	80094f6 <vQueueDelete+0x6>
 8009510:	0800c9f8 	.word	0x0800c9f8

08009514 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009514:	4b08      	ldr	r3, [pc, #32]	; (8009538 <prvResetNextTaskUnblockTime+0x24>)
 8009516:	681b      	ldr	r3, [r3, #0]
 8009518:	681b      	ldr	r3, [r3, #0]
 800951a:	b13b      	cbz	r3, 800952c <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800951c:	4b06      	ldr	r3, [pc, #24]	; (8009538 <prvResetNextTaskUnblockTime+0x24>)
 800951e:	681b      	ldr	r3, [r3, #0]
 8009520:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8009522:	68db      	ldr	r3, [r3, #12]
 8009524:	685a      	ldr	r2, [r3, #4]
 8009526:	4b05      	ldr	r3, [pc, #20]	; (800953c <prvResetNextTaskUnblockTime+0x28>)
 8009528:	601a      	str	r2, [r3, #0]
 800952a:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
 800952c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009530:	4b02      	ldr	r3, [pc, #8]	; (800953c <prvResetNextTaskUnblockTime+0x28>)
 8009532:	601a      	str	r2, [r3, #0]
 8009534:	4770      	bx	lr
 8009536:	bf00      	nop
 8009538:	20000978 	.word	0x20000978
 800953c:	20000a54 	.word	0x20000a54

08009540 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8009540:	b570      	push	{r4, r5, r6, lr}
 8009542:	4604      	mov	r4, r0
 8009544:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8009546:	4b1d      	ldr	r3, [pc, #116]	; (80095bc <prvAddCurrentTaskToDelayedList+0x7c>)
 8009548:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800954a:	4b1d      	ldr	r3, [pc, #116]	; (80095c0 <prvAddCurrentTaskToDelayedList+0x80>)
 800954c:	6818      	ldr	r0, [r3, #0]
 800954e:	3004      	adds	r0, #4
 8009550:	f7ff f97a 	bl	8008848 <uxListRemove>
 8009554:	b948      	cbnz	r0, 800956a <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8009556:	4b1a      	ldr	r3, [pc, #104]	; (80095c0 <prvAddCurrentTaskToDelayedList+0x80>)
 8009558:	681a      	ldr	r2, [r3, #0]
 800955a:	491a      	ldr	r1, [pc, #104]	; (80095c4 <prvAddCurrentTaskToDelayedList+0x84>)
 800955c:	680b      	ldr	r3, [r1, #0]
 800955e:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8009560:	2201      	movs	r2, #1
 8009562:	4082      	lsls	r2, r0
 8009564:	ea23 0302 	bic.w	r3, r3, r2
 8009568:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800956a:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 800956e:	d013      	beq.n	8009598 <prvAddCurrentTaskToDelayedList+0x58>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8009570:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8009572:	4b13      	ldr	r3, [pc, #76]	; (80095c0 <prvAddCurrentTaskToDelayedList+0x80>)
 8009574:	681b      	ldr	r3, [r3, #0]
 8009576:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8009578:	42a5      	cmp	r5, r4
 800957a:	d816      	bhi.n	80095aa <prvAddCurrentTaskToDelayedList+0x6a>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800957c:	4b12      	ldr	r3, [pc, #72]	; (80095c8 <prvAddCurrentTaskToDelayedList+0x88>)
 800957e:	6818      	ldr	r0, [r3, #0]
 8009580:	4b0f      	ldr	r3, [pc, #60]	; (80095c0 <prvAddCurrentTaskToDelayedList+0x80>)
 8009582:	6819      	ldr	r1, [r3, #0]
 8009584:	3104      	adds	r1, #4
 8009586:	f7ff f945 	bl	8008814 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 800958a:	4b10      	ldr	r3, [pc, #64]	; (80095cc <prvAddCurrentTaskToDelayedList+0x8c>)
 800958c:	681b      	ldr	r3, [r3, #0]
 800958e:	429c      	cmp	r4, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
 8009590:	bf3c      	itt	cc
 8009592:	4b0e      	ldrcc	r3, [pc, #56]	; (80095cc <prvAddCurrentTaskToDelayedList+0x8c>)
 8009594:	601c      	strcc	r4, [r3, #0]
 8009596:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8009598:	2e00      	cmp	r6, #0
 800959a:	d0e9      	beq.n	8009570 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800959c:	4b08      	ldr	r3, [pc, #32]	; (80095c0 <prvAddCurrentTaskToDelayedList+0x80>)
 800959e:	6819      	ldr	r1, [r3, #0]
 80095a0:	3104      	adds	r1, #4
 80095a2:	480b      	ldr	r0, [pc, #44]	; (80095d0 <prvAddCurrentTaskToDelayedList+0x90>)
 80095a4:	f7ff f92a 	bl	80087fc <vListInsertEnd>
 80095a8:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80095aa:	4b0a      	ldr	r3, [pc, #40]	; (80095d4 <prvAddCurrentTaskToDelayedList+0x94>)
 80095ac:	6818      	ldr	r0, [r3, #0]
 80095ae:	4b04      	ldr	r3, [pc, #16]	; (80095c0 <prvAddCurrentTaskToDelayedList+0x80>)
 80095b0:	6819      	ldr	r1, [r3, #0]
 80095b2:	3104      	adds	r1, #4
 80095b4:	f7ff f92e 	bl	8008814 <vListInsert>
 80095b8:	bd70      	pop	{r4, r5, r6, pc}
 80095ba:	bf00      	nop
 80095bc:	20000a9c 	.word	0x20000a9c
 80095c0:	20000974 	.word	0x20000974
 80095c4:	20000a24 	.word	0x20000a24
 80095c8:	20000978 	.word	0x20000978
 80095cc:	20000a54 	.word	0x20000a54
 80095d0:	20000a74 	.word	0x20000a74
 80095d4:	2000097c 	.word	0x2000097c

080095d8 <prvWriteNameToBuffer>:
	{
 80095d8:	b510      	push	{r4, lr}
 80095da:	4604      	mov	r4, r0
		strcpy( pcBuffer, pcTaskName );
 80095dc:	f002 fd6a 	bl	800c0b4 <strcpy>
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 80095e0:	4620      	mov	r0, r4
 80095e2:	f7f6 fdf5 	bl	80001d0 <strlen>
 80095e6:	280e      	cmp	r0, #14
 80095e8:	d808      	bhi.n	80095fc <prvWriteNameToBuffer+0x24>
 80095ea:	4420      	add	r0, r4
 80095ec:	f104 020f 	add.w	r2, r4, #15
			pcBuffer[ x ] = ' ';
 80095f0:	2320      	movs	r3, #32
 80095f2:	f800 3b01 	strb.w	r3, [r0], #1
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 80095f6:	4290      	cmp	r0, r2
 80095f8:	d1fb      	bne.n	80095f2 <prvWriteNameToBuffer+0x1a>
 80095fa:	200f      	movs	r0, #15
		pcBuffer[ x ] = 0x00;
 80095fc:	2300      	movs	r3, #0
 80095fe:	5423      	strb	r3, [r4, r0]
	}
 8009600:	4420      	add	r0, r4
 8009602:	bd10      	pop	{r4, pc}

08009604 <xTaskCreate>:
	{
 8009604:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009608:	b083      	sub	sp, #12
 800960a:	9001      	str	r0, [sp, #4]
 800960c:	4689      	mov	r9, r1
 800960e:	4698      	mov	r8, r3
 8009610:	9e0d      	ldr	r6, [sp, #52]	; 0x34
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009612:	0095      	lsls	r5, r2, #2
 8009614:	4628      	mov	r0, r5
 8009616:	f7ff faf7 	bl	8008c08 <pvPortMalloc>
			if( pxStack != NULL )
 800961a:	2800      	cmp	r0, #0
 800961c:	f000 8091 	beq.w	8009742 <xTaskCreate+0x13e>
 8009620:	4607      	mov	r7, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8009622:	206c      	movs	r0, #108	; 0x6c
 8009624:	f7ff faf0 	bl	8008c08 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8009628:	4604      	mov	r4, r0
 800962a:	2800      	cmp	r0, #0
 800962c:	f000 8086 	beq.w	800973c <xTaskCreate+0x138>
					pxNewTCB->pxStack = pxStack;
 8009630:	6307      	str	r7, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8009632:	462a      	mov	r2, r5
 8009634:	21a5      	movs	r1, #165	; 0xa5
 8009636:	4638      	mov	r0, r7
 8009638:	f002 fd34 	bl	800c0a4 <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800963c:	3d04      	subs	r5, #4
 800963e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009640:	441d      	add	r5, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8009642:	f025 0507 	bic.w	r5, r5, #7
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8009646:	f899 3000 	ldrb.w	r3, [r9]
 800964a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
 800964e:	f899 3000 	ldrb.w	r3, [r9]
 8009652:	b163      	cbz	r3, 800966e <xTaskCreate+0x6a>
 8009654:	464b      	mov	r3, r9
 8009656:	f104 0234 	add.w	r2, r4, #52	; 0x34
 800965a:	f109 010f 	add.w	r1, r9, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800965e:	7858      	ldrb	r0, [r3, #1]
 8009660:	f802 0f01 	strb.w	r0, [r2, #1]!
		if( pcName[ x ] == 0x00 )
 8009664:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8009668:	b108      	cbz	r0, 800966e <xTaskCreate+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800966a:	428b      	cmp	r3, r1
 800966c:	d1f7      	bne.n	800965e <xTaskCreate+0x5a>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800966e:	2700      	movs	r7, #0
 8009670:	f884 7043 	strb.w	r7, [r4, #67]	; 0x43
 8009674:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009676:	2b06      	cmp	r3, #6
 8009678:	bf28      	it	cs
 800967a:	2306      	movcs	r3, #6
 800967c:	469a      	mov	sl, r3
	pxNewTCB->uxPriority = uxPriority;
 800967e:	62e3      	str	r3, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8009680:	64e3      	str	r3, [r4, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8009682:	6527      	str	r7, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8009684:	f104 0b04 	add.w	fp, r4, #4
 8009688:	4658      	mov	r0, fp
 800968a:	f7ff f8b4 	bl	80087f6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800968e:	f104 0018 	add.w	r0, r4, #24
 8009692:	f7ff f8b0 	bl	80087f6 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8009696:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009698:	f1ca 0307 	rsb	r3, sl, #7
 800969c:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800969e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulRunTimeCounter = 0UL;
 80096a0:	6627      	str	r7, [r4, #96]	; 0x60
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 80096a2:	6567      	str	r7, [r4, #84]	; 0x54
 80096a4:	65a7      	str	r7, [r4, #88]	; 0x58
 80096a6:	65e7      	str	r7, [r4, #92]	; 0x5c
		pxNewTCB->ulNotifiedValue = 0;
 80096a8:	6667      	str	r7, [r4, #100]	; 0x64
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80096aa:	f884 7068 	strb.w	r7, [r4, #104]	; 0x68
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80096ae:	4642      	mov	r2, r8
 80096b0:	9901      	ldr	r1, [sp, #4]
 80096b2:	4628      	mov	r0, r5
 80096b4:	f7ff f8f8 	bl	80088a8 <pxPortInitialiseStack>
 80096b8:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 80096ba:	b106      	cbz	r6, 80096be <xTaskCreate+0xba>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80096bc:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 80096be:	f7ff f919 	bl	80088f4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 80096c2:	4a36      	ldr	r2, [pc, #216]	; (800979c <xTaskCreate+0x198>)
 80096c4:	6813      	ldr	r3, [r2, #0]
 80096c6:	3301      	adds	r3, #1
 80096c8:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 80096ca:	4b35      	ldr	r3, [pc, #212]	; (80097a0 <xTaskCreate+0x19c>)
 80096cc:	681b      	ldr	r3, [r3, #0]
 80096ce:	2b00      	cmp	r3, #0
 80096d0:	d03a      	beq.n	8009748 <xTaskCreate+0x144>
			if( xSchedulerRunning == pdFALSE )
 80096d2:	4b34      	ldr	r3, [pc, #208]	; (80097a4 <xTaskCreate+0x1a0>)
 80096d4:	681b      	ldr	r3, [r3, #0]
 80096d6:	b93b      	cbnz	r3, 80096e8 <xTaskCreate+0xe4>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80096d8:	4b31      	ldr	r3, [pc, #196]	; (80097a0 <xTaskCreate+0x19c>)
 80096da:	681b      	ldr	r3, [r3, #0]
 80096dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80096de:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80096e0:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 80096e2:	bf9c      	itt	ls
 80096e4:	4b2e      	ldrls	r3, [pc, #184]	; (80097a0 <xTaskCreate+0x19c>)
 80096e6:	601c      	strls	r4, [r3, #0]
		uxTaskNumber++;
 80096e8:	4a2f      	ldr	r2, [pc, #188]	; (80097a8 <xTaskCreate+0x1a4>)
 80096ea:	6813      	ldr	r3, [r2, #0]
 80096ec:	3301      	adds	r3, #1
 80096ee:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 80096f0:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 80096f2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80096f4:	4a2d      	ldr	r2, [pc, #180]	; (80097ac <xTaskCreate+0x1a8>)
 80096f6:	6811      	ldr	r1, [r2, #0]
 80096f8:	2301      	movs	r3, #1
 80096fa:	4083      	lsls	r3, r0
 80096fc:	430b      	orrs	r3, r1
 80096fe:	6013      	str	r3, [r2, #0]
 8009700:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009704:	4659      	mov	r1, fp
 8009706:	4b2a      	ldr	r3, [pc, #168]	; (80097b0 <xTaskCreate+0x1ac>)
 8009708:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800970c:	f7ff f876 	bl	80087fc <vListInsertEnd>
	taskEXIT_CRITICAL();
 8009710:	f7ff f912 	bl	8008938 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8009714:	4b23      	ldr	r3, [pc, #140]	; (80097a4 <xTaskCreate+0x1a0>)
 8009716:	681b      	ldr	r3, [r3, #0]
 8009718:	2b00      	cmp	r3, #0
 800971a:	d039      	beq.n	8009790 <xTaskCreate+0x18c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800971c:	4b20      	ldr	r3, [pc, #128]	; (80097a0 <xTaskCreate+0x19c>)
 800971e:	681b      	ldr	r3, [r3, #0]
 8009720:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009722:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009724:	429a      	cmp	r2, r3
 8009726:	d237      	bcs.n	8009798 <xTaskCreate+0x194>
			taskYIELD_IF_USING_PREEMPTION();
 8009728:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800972c:	4b21      	ldr	r3, [pc, #132]	; (80097b4 <xTaskCreate+0x1b0>)
 800972e:	601a      	str	r2, [r3, #0]
 8009730:	f3bf 8f4f 	dsb	sy
 8009734:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 8009738:	2001      	movs	r0, #1
 800973a:	e02a      	b.n	8009792 <xTaskCreate+0x18e>
					vPortFree( pxStack );
 800973c:	4638      	mov	r0, r7
 800973e:	f7ff fac9 	bl	8008cd4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8009742:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8009746:	e024      	b.n	8009792 <xTaskCreate+0x18e>
			pxCurrentTCB = pxNewTCB;
 8009748:	4b15      	ldr	r3, [pc, #84]	; (80097a0 <xTaskCreate+0x19c>)
 800974a:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800974c:	6813      	ldr	r3, [r2, #0]
 800974e:	2b01      	cmp	r3, #1
 8009750:	d1ca      	bne.n	80096e8 <xTaskCreate+0xe4>
 8009752:	4d17      	ldr	r5, [pc, #92]	; (80097b0 <xTaskCreate+0x1ac>)
 8009754:	f105 068c 	add.w	r6, r5, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8009758:	4628      	mov	r0, r5
 800975a:	f7ff f841 	bl	80087e0 <vListInitialise>
 800975e:	3514      	adds	r5, #20
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8009760:	42ae      	cmp	r6, r5
 8009762:	d1f9      	bne.n	8009758 <xTaskCreate+0x154>
	vListInitialise( &xDelayedTaskList1 );
 8009764:	4e14      	ldr	r6, [pc, #80]	; (80097b8 <xTaskCreate+0x1b4>)
 8009766:	4630      	mov	r0, r6
 8009768:	f7ff f83a 	bl	80087e0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800976c:	4d13      	ldr	r5, [pc, #76]	; (80097bc <xTaskCreate+0x1b8>)
 800976e:	4628      	mov	r0, r5
 8009770:	f7ff f836 	bl	80087e0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8009774:	4812      	ldr	r0, [pc, #72]	; (80097c0 <xTaskCreate+0x1bc>)
 8009776:	f7ff f833 	bl	80087e0 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 800977a:	4812      	ldr	r0, [pc, #72]	; (80097c4 <xTaskCreate+0x1c0>)
 800977c:	f7ff f830 	bl	80087e0 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8009780:	4811      	ldr	r0, [pc, #68]	; (80097c8 <xTaskCreate+0x1c4>)
 8009782:	f7ff f82d 	bl	80087e0 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8009786:	4b11      	ldr	r3, [pc, #68]	; (80097cc <xTaskCreate+0x1c8>)
 8009788:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800978a:	4b11      	ldr	r3, [pc, #68]	; (80097d0 <xTaskCreate+0x1cc>)
 800978c:	601d      	str	r5, [r3, #0]
 800978e:	e7ab      	b.n	80096e8 <xTaskCreate+0xe4>
			xReturn = pdPASS;
 8009790:	2001      	movs	r0, #1
	}
 8009792:	b003      	add	sp, #12
 8009794:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
 8009798:	2001      	movs	r0, #1
		return xReturn;
 800979a:	e7fa      	b.n	8009792 <xTaskCreate+0x18e>
 800979c:	20000a10 	.word	0x20000a10
 80097a0:	20000974 	.word	0x20000974
 80097a4:	20000a70 	.word	0x20000a70
 80097a8:	20000a20 	.word	0x20000a20
 80097ac:	20000a24 	.word	0x20000a24
 80097b0:	20000980 	.word	0x20000980
 80097b4:	e000ed04 	.word	0xe000ed04
 80097b8:	20000a28 	.word	0x20000a28
 80097bc:	20000a3c 	.word	0x20000a3c
 80097c0:	20000a5c 	.word	0x20000a5c
 80097c4:	20000a88 	.word	0x20000a88
 80097c8:	20000a74 	.word	0x20000a74
 80097cc:	20000978 	.word	0x20000978
 80097d0:	2000097c 	.word	0x2000097c

080097d4 <vTaskDelete>:
	{
 80097d4:	b538      	push	{r3, r4, r5, lr}
 80097d6:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 80097d8:	f7ff f88c 	bl	80088f4 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80097dc:	2c00      	cmp	r4, #0
 80097de:	d037      	beq.n	8009850 <vTaskDelete+0x7c>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80097e0:	1d25      	adds	r5, r4, #4
 80097e2:	4628      	mov	r0, r5
 80097e4:	f7ff f830 	bl	8008848 <uxListRemove>
 80097e8:	b970      	cbnz	r0, 8009808 <vTaskDelete+0x34>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80097ea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80097ec:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 80097f0:	4a26      	ldr	r2, [pc, #152]	; (800988c <vTaskDelete+0xb8>)
 80097f2:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80097f6:	b93a      	cbnz	r2, 8009808 <vTaskDelete+0x34>
 80097f8:	4825      	ldr	r0, [pc, #148]	; (8009890 <vTaskDelete+0xbc>)
 80097fa:	6802      	ldr	r2, [r0, #0]
 80097fc:	2101      	movs	r1, #1
 80097fe:	fa01 f303 	lsl.w	r3, r1, r3
 8009802:	ea22 0303 	bic.w	r3, r2, r3
 8009806:	6003      	str	r3, [r0, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8009808:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800980a:	b11b      	cbz	r3, 8009814 <vTaskDelete+0x40>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800980c:	f104 0018 	add.w	r0, r4, #24
 8009810:	f7ff f81a 	bl	8008848 <uxListRemove>
			uxTaskNumber++;
 8009814:	4a1f      	ldr	r2, [pc, #124]	; (8009894 <vTaskDelete+0xc0>)
 8009816:	6813      	ldr	r3, [r2, #0]
 8009818:	3301      	adds	r3, #1
 800981a:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 800981c:	4b1e      	ldr	r3, [pc, #120]	; (8009898 <vTaskDelete+0xc4>)
 800981e:	681b      	ldr	r3, [r3, #0]
 8009820:	429c      	cmp	r4, r3
 8009822:	d018      	beq.n	8009856 <vTaskDelete+0x82>
				--uxCurrentNumberOfTasks;
 8009824:	4a1d      	ldr	r2, [pc, #116]	; (800989c <vTaskDelete+0xc8>)
 8009826:	6813      	ldr	r3, [r2, #0]
 8009828:	3b01      	subs	r3, #1
 800982a:	6013      	str	r3, [r2, #0]
			vPortFree( pxTCB->pxStack );
 800982c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800982e:	f7ff fa51 	bl	8008cd4 <vPortFree>
			vPortFree( pxTCB );
 8009832:	4620      	mov	r0, r4
 8009834:	f7ff fa4e 	bl	8008cd4 <vPortFree>
				prvResetNextTaskUnblockTime();
 8009838:	f7ff fe6c 	bl	8009514 <prvResetNextTaskUnblockTime>
		taskEXIT_CRITICAL();
 800983c:	f7ff f87c 	bl	8008938 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8009840:	4b17      	ldr	r3, [pc, #92]	; (80098a0 <vTaskDelete+0xcc>)
 8009842:	681b      	ldr	r3, [r3, #0]
 8009844:	b11b      	cbz	r3, 800984e <vTaskDelete+0x7a>
			if( pxTCB == pxCurrentTCB )
 8009846:	4b14      	ldr	r3, [pc, #80]	; (8009898 <vTaskDelete+0xc4>)
 8009848:	681b      	ldr	r3, [r3, #0]
 800984a:	429c      	cmp	r4, r3
 800984c:	d00c      	beq.n	8009868 <vTaskDelete+0x94>
 800984e:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8009850:	4b11      	ldr	r3, [pc, #68]	; (8009898 <vTaskDelete+0xc4>)
 8009852:	681c      	ldr	r4, [r3, #0]
 8009854:	e7c4      	b.n	80097e0 <vTaskDelete+0xc>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8009856:	4629      	mov	r1, r5
 8009858:	4812      	ldr	r0, [pc, #72]	; (80098a4 <vTaskDelete+0xd0>)
 800985a:	f7fe ffcf 	bl	80087fc <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 800985e:	4a12      	ldr	r2, [pc, #72]	; (80098a8 <vTaskDelete+0xd4>)
 8009860:	6813      	ldr	r3, [r2, #0]
 8009862:	3301      	adds	r3, #1
 8009864:	6013      	str	r3, [r2, #0]
 8009866:	e7e9      	b.n	800983c <vTaskDelete+0x68>
				configASSERT( uxSchedulerSuspended == 0 );
 8009868:	4b10      	ldr	r3, [pc, #64]	; (80098ac <vTaskDelete+0xd8>)
 800986a:	681b      	ldr	r3, [r3, #0]
 800986c:	b943      	cbnz	r3, 8009880 <vTaskDelete+0xac>
				portYIELD_WITHIN_API();
 800986e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009872:	4b0f      	ldr	r3, [pc, #60]	; (80098b0 <vTaskDelete+0xdc>)
 8009874:	601a      	str	r2, [r3, #0]
 8009876:	f3bf 8f4f 	dsb	sy
 800987a:	f3bf 8f6f 	isb	sy
	}
 800987e:	e7e6      	b.n	800984e <vTaskDelete+0x7a>
				configASSERT( uxSchedulerSuspended == 0 );
 8009880:	f240 4165 	movw	r1, #1125	; 0x465
 8009884:	480b      	ldr	r0, [pc, #44]	; (80098b4 <vTaskDelete+0xe0>)
 8009886:	f002 fa41 	bl	800bd0c <vAssertCalled>
 800988a:	e7f0      	b.n	800986e <vTaskDelete+0x9a>
 800988c:	20000980 	.word	0x20000980
 8009890:	20000a24 	.word	0x20000a24
 8009894:	20000a20 	.word	0x20000a20
 8009898:	20000974 	.word	0x20000974
 800989c:	20000a10 	.word	0x20000a10
 80098a0:	20000a70 	.word	0x20000a70
 80098a4:	20000a88 	.word	0x20000a88
 80098a8:	20000a14 	.word	0x20000a14
 80098ac:	20000a1c 	.word	0x20000a1c
 80098b0:	e000ed04 	.word	0xe000ed04
 80098b4:	0800ca1c 	.word	0x0800ca1c

080098b8 <eTaskGetState>:
	{
 80098b8:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxTCB );
 80098ba:	4605      	mov	r5, r0
 80098bc:	b1d8      	cbz	r0, 80098f6 <eTaskGetState+0x3e>
		if( pxTCB == pxCurrentTCB )
 80098be:	4b18      	ldr	r3, [pc, #96]	; (8009920 <eTaskGetState+0x68>)
 80098c0:	681b      	ldr	r3, [r3, #0]
 80098c2:	429d      	cmp	r5, r3
 80098c4:	d023      	beq.n	800990e <eTaskGetState+0x56>
			taskENTER_CRITICAL();
 80098c6:	f7ff f815 	bl	80088f4 <vPortEnterCritical>
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 80098ca:	696c      	ldr	r4, [r5, #20]
			taskEXIT_CRITICAL();
 80098cc:	f7ff f834 	bl	8008938 <vPortExitCritical>
			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 80098d0:	4b14      	ldr	r3, [pc, #80]	; (8009924 <eTaskGetState+0x6c>)
 80098d2:	681b      	ldr	r3, [r3, #0]
 80098d4:	429c      	cmp	r4, r3
 80098d6:	d01c      	beq.n	8009912 <eTaskGetState+0x5a>
 80098d8:	4b13      	ldr	r3, [pc, #76]	; (8009928 <eTaskGetState+0x70>)
 80098da:	681b      	ldr	r3, [r3, #0]
 80098dc:	429c      	cmp	r4, r3
 80098de:	d01a      	beq.n	8009916 <eTaskGetState+0x5e>
				else if( pxStateList == &xSuspendedTaskList )
 80098e0:	4b12      	ldr	r3, [pc, #72]	; (800992c <eTaskGetState+0x74>)
 80098e2:	429c      	cmp	r4, r3
 80098e4:	d00d      	beq.n	8009902 <eTaskGetState+0x4a>
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 80098e6:	4b12      	ldr	r3, [pc, #72]	; (8009930 <eTaskGetState+0x78>)
 80098e8:	429c      	cmp	r4, r3
 80098ea:	d016      	beq.n	800991a <eTaskGetState+0x62>
				eReturn = eReady;
 80098ec:	2c00      	cmp	r4, #0
 80098ee:	bf0c      	ite	eq
 80098f0:	2004      	moveq	r0, #4
 80098f2:	2001      	movne	r0, #1
 80098f4:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pxTCB );
 80098f6:	f240 41fb 	movw	r1, #1275	; 0x4fb
 80098fa:	480e      	ldr	r0, [pc, #56]	; (8009934 <eTaskGetState+0x7c>)
 80098fc:	f002 fa06 	bl	800bd0c <vAssertCalled>
 8009900:	e7dd      	b.n	80098be <eTaskGetState+0x6>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 8009902:	6aab      	ldr	r3, [r5, #40]	; 0x28
						eReturn = eBlocked;
 8009904:	2b00      	cmp	r3, #0
 8009906:	bf0c      	ite	eq
 8009908:	2003      	moveq	r0, #3
 800990a:	2002      	movne	r0, #2
 800990c:	bd38      	pop	{r3, r4, r5, pc}
			eReturn = eRunning;
 800990e:	2000      	movs	r0, #0
 8009910:	bd38      	pop	{r3, r4, r5, pc}
				eReturn = eBlocked;
 8009912:	2002      	movs	r0, #2
 8009914:	bd38      	pop	{r3, r4, r5, pc}
 8009916:	2002      	movs	r0, #2
 8009918:	bd38      	pop	{r3, r4, r5, pc}
					eReturn = eDeleted;
 800991a:	2004      	movs	r0, #4
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 800991c:	bd38      	pop	{r3, r4, r5, pc}
 800991e:	bf00      	nop
 8009920:	20000974 	.word	0x20000974
 8009924:	20000978 	.word	0x20000978
 8009928:	2000097c 	.word	0x2000097c
 800992c:	20000a74 	.word	0x20000a74
 8009930:	20000a88 	.word	0x20000a88
 8009934:	0800ca1c 	.word	0x0800ca1c

08009938 <vTaskStartScheduler>:
{
 8009938:	b500      	push	{lr}
 800993a:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 800993c:	4b15      	ldr	r3, [pc, #84]	; (8009994 <vTaskStartScheduler+0x5c>)
 800993e:	9301      	str	r3, [sp, #4]
 8009940:	2300      	movs	r3, #0
 8009942:	9300      	str	r3, [sp, #0]
 8009944:	2280      	movs	r2, #128	; 0x80
 8009946:	4914      	ldr	r1, [pc, #80]	; (8009998 <vTaskStartScheduler+0x60>)
 8009948:	4814      	ldr	r0, [pc, #80]	; (800999c <vTaskStartScheduler+0x64>)
 800994a:	f7ff fe5b 	bl	8009604 <xTaskCreate>
	if( xReturn == pdPASS )
 800994e:	2801      	cmp	r0, #1
 8009950:	d005      	beq.n	800995e <vTaskStartScheduler+0x26>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8009952:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8009956:	d017      	beq.n	8009988 <vTaskStartScheduler+0x50>
}
 8009958:	b003      	add	sp, #12
 800995a:	f85d fb04 	ldr.w	pc, [sp], #4
	__asm volatile
 800995e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009962:	f383 8811 	msr	BASEPRI, r3
 8009966:	f3bf 8f6f 	isb	sy
 800996a:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 800996e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009972:	4b0b      	ldr	r3, [pc, #44]	; (80099a0 <vTaskStartScheduler+0x68>)
 8009974:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8009976:	2201      	movs	r2, #1
 8009978:	4b0a      	ldr	r3, [pc, #40]	; (80099a4 <vTaskStartScheduler+0x6c>)
 800997a:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 800997c:	2200      	movs	r2, #0
 800997e:	4b0a      	ldr	r3, [pc, #40]	; (80099a8 <vTaskStartScheduler+0x70>)
 8009980:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8009982:	f7ff f859 	bl	8008a38 <xPortStartScheduler>
 8009986:	e7e7      	b.n	8009958 <vTaskStartScheduler+0x20>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8009988:	f240 7187 	movw	r1, #1927	; 0x787
 800998c:	4807      	ldr	r0, [pc, #28]	; (80099ac <vTaskStartScheduler+0x74>)
 800998e:	f002 f9bd 	bl	800bd0c <vAssertCalled>
}
 8009992:	e7e1      	b.n	8009958 <vTaskStartScheduler+0x20>
 8009994:	20000a50 	.word	0x20000a50
 8009998:	0800ca68 	.word	0x0800ca68
 800999c:	08009cad 	.word	0x08009cad
 80099a0:	20000a54 	.word	0x20000a54
 80099a4:	20000a70 	.word	0x20000a70
 80099a8:	20000a9c 	.word	0x20000a9c
 80099ac:	0800ca1c 	.word	0x0800ca1c

080099b0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 80099b0:	4a02      	ldr	r2, [pc, #8]	; (80099bc <vTaskSuspendAll+0xc>)
 80099b2:	6813      	ldr	r3, [r2, #0]
 80099b4:	3301      	adds	r3, #1
 80099b6:	6013      	str	r3, [r2, #0]
 80099b8:	4770      	bx	lr
 80099ba:	bf00      	nop
 80099bc:	20000a1c 	.word	0x20000a1c

080099c0 <xTaskGetTickCount>:
		xTicks = xTickCount;
 80099c0:	4b01      	ldr	r3, [pc, #4]	; (80099c8 <xTaskGetTickCount+0x8>)
 80099c2:	6818      	ldr	r0, [r3, #0]
}
 80099c4:	4770      	bx	lr
 80099c6:	bf00      	nop
 80099c8:	20000a9c 	.word	0x20000a9c

080099cc <pcTaskGetName>:
{
 80099cc:	b510      	push	{r4, lr}
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80099ce:	4604      	mov	r4, r0
 80099d0:	b110      	cbz	r0, 80099d8 <pcTaskGetName+0xc>
}
 80099d2:	f104 0034 	add.w	r0, r4, #52	; 0x34
 80099d6:	bd10      	pop	{r4, pc}
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80099d8:	4b04      	ldr	r3, [pc, #16]	; (80099ec <pcTaskGetName+0x20>)
 80099da:	681c      	ldr	r4, [r3, #0]
	configASSERT( pxTCB );
 80099dc:	2c00      	cmp	r4, #0
 80099de:	d1f8      	bne.n	80099d2 <pcTaskGetName+0x6>
 80099e0:	f640 018f 	movw	r1, #2191	; 0x88f
 80099e4:	4802      	ldr	r0, [pc, #8]	; (80099f0 <pcTaskGetName+0x24>)
 80099e6:	f002 f991 	bl	800bd0c <vAssertCalled>
 80099ea:	e7f2      	b.n	80099d2 <pcTaskGetName+0x6>
 80099ec:	20000974 	.word	0x20000974
 80099f0:	0800ca1c 	.word	0x0800ca1c

080099f4 <xTaskIncrementTick>:
{
 80099f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	traceTASK_INCREMENT_TICK( xTickCount );
 80099f8:	4b4c      	ldr	r3, [pc, #304]	; (8009b2c <xTaskIncrementTick+0x138>)
 80099fa:	681b      	ldr	r3, [r3, #0]
 80099fc:	b93b      	cbnz	r3, 8009a0e <xTaskIncrementTick+0x1a>
 80099fe:	4b4c      	ldr	r3, [pc, #304]	; (8009b30 <xTaskIncrementTick+0x13c>)
 8009a00:	681b      	ldr	r3, [r3, #0]
 8009a02:	3301      	adds	r3, #1
 8009a04:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8009a08:	d23c      	bcs.n	8009a84 <xTaskIncrementTick+0x90>
 8009a0a:	4a49      	ldr	r2, [pc, #292]	; (8009b30 <xTaskIncrementTick+0x13c>)
 8009a0c:	6013      	str	r3, [r2, #0]
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8009a0e:	4b47      	ldr	r3, [pc, #284]	; (8009b2c <xTaskIncrementTick+0x138>)
 8009a10:	681b      	ldr	r3, [r3, #0]
 8009a12:	2b00      	cmp	r3, #0
 8009a14:	f040 8082 	bne.w	8009b1c <xTaskIncrementTick+0x128>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8009a18:	4b46      	ldr	r3, [pc, #280]	; (8009b34 <xTaskIncrementTick+0x140>)
 8009a1a:	681a      	ldr	r2, [r3, #0]
 8009a1c:	f102 0801 	add.w	r8, r2, #1
		xTickCount = xConstTickCount;
 8009a20:	f8c3 8000 	str.w	r8, [r3]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8009a24:	f1b8 0f00 	cmp.w	r8, #0
 8009a28:	d110      	bne.n	8009a4c <xTaskIncrementTick+0x58>
			taskSWITCH_DELAYED_LISTS();
 8009a2a:	4b43      	ldr	r3, [pc, #268]	; (8009b38 <xTaskIncrementTick+0x144>)
 8009a2c:	681b      	ldr	r3, [r3, #0]
 8009a2e:	681b      	ldr	r3, [r3, #0]
 8009a30:	2b00      	cmp	r3, #0
 8009a32:	d12f      	bne.n	8009a94 <xTaskIncrementTick+0xa0>
 8009a34:	4a40      	ldr	r2, [pc, #256]	; (8009b38 <xTaskIncrementTick+0x144>)
 8009a36:	6811      	ldr	r1, [r2, #0]
 8009a38:	4b40      	ldr	r3, [pc, #256]	; (8009b3c <xTaskIncrementTick+0x148>)
 8009a3a:	6818      	ldr	r0, [r3, #0]
 8009a3c:	6010      	str	r0, [r2, #0]
 8009a3e:	6019      	str	r1, [r3, #0]
 8009a40:	4a3f      	ldr	r2, [pc, #252]	; (8009b40 <xTaskIncrementTick+0x14c>)
 8009a42:	6813      	ldr	r3, [r2, #0]
 8009a44:	3301      	adds	r3, #1
 8009a46:	6013      	str	r3, [r2, #0]
 8009a48:	f7ff fd64 	bl	8009514 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8009a4c:	4b3d      	ldr	r3, [pc, #244]	; (8009b44 <xTaskIncrementTick+0x150>)
 8009a4e:	681b      	ldr	r3, [r3, #0]
 8009a50:	4598      	cmp	r8, r3
 8009a52:	d225      	bcs.n	8009aa0 <xTaskIncrementTick+0xac>
BaseType_t xSwitchRequired = pdFALSE;
 8009a54:	2600      	movs	r6, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8009a56:	4b3c      	ldr	r3, [pc, #240]	; (8009b48 <xTaskIncrementTick+0x154>)
 8009a58:	681b      	ldr	r3, [r3, #0]
 8009a5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009a5c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8009a60:	4a3a      	ldr	r2, [pc, #232]	; (8009b4c <xTaskIncrementTick+0x158>)
 8009a62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
				xSwitchRequired = pdTRUE;
 8009a66:	2b02      	cmp	r3, #2
 8009a68:	bf28      	it	cs
 8009a6a:	2601      	movcs	r6, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 8009a6c:	4b38      	ldr	r3, [pc, #224]	; (8009b50 <xTaskIncrementTick+0x15c>)
 8009a6e:	681b      	ldr	r3, [r3, #0]
 8009a70:	2b00      	cmp	r3, #0
 8009a72:	d050      	beq.n	8009b16 <xTaskIncrementTick+0x122>
		if( xYieldPending != pdFALSE )
 8009a74:	4b37      	ldr	r3, [pc, #220]	; (8009b54 <xTaskIncrementTick+0x160>)
 8009a76:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 8009a78:	2b00      	cmp	r3, #0
}
 8009a7a:	bf0c      	ite	eq
 8009a7c:	4630      	moveq	r0, r6
 8009a7e:	2001      	movne	r0, #1
 8009a80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	traceTASK_INCREMENT_TICK( xTickCount );
 8009a84:	2200      	movs	r2, #0
 8009a86:	4b2a      	ldr	r3, [pc, #168]	; (8009b30 <xTaskIncrementTick+0x13c>)
 8009a88:	601a      	str	r2, [r3, #0]
 8009a8a:	4a33      	ldr	r2, [pc, #204]	; (8009b58 <xTaskIncrementTick+0x164>)
 8009a8c:	6813      	ldr	r3, [r2, #0]
 8009a8e:	3301      	adds	r3, #1
 8009a90:	6013      	str	r3, [r2, #0]
 8009a92:	e7bc      	b.n	8009a0e <xTaskIncrementTick+0x1a>
			taskSWITCH_DELAYED_LISTS();
 8009a94:	f640 11dc 	movw	r1, #2524	; 0x9dc
 8009a98:	4830      	ldr	r0, [pc, #192]	; (8009b5c <xTaskIncrementTick+0x168>)
 8009a9a:	f002 f937 	bl	800bd0c <vAssertCalled>
 8009a9e:	e7c9      	b.n	8009a34 <xTaskIncrementTick+0x40>
 8009aa0:	2600      	movs	r6, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009aa2:	4f25      	ldr	r7, [pc, #148]	; (8009b38 <xTaskIncrementTick+0x144>)
					prvAddTaskToReadyList( pxTCB );
 8009aa4:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 8009b60 <xTaskIncrementTick+0x16c>
 8009aa8:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 8009b4c <xTaskIncrementTick+0x158>
 8009aac:	e021      	b.n	8009af2 <xTaskIncrementTick+0xfe>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009aae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009ab2:	4b24      	ldr	r3, [pc, #144]	; (8009b44 <xTaskIncrementTick+0x150>)
 8009ab4:	601a      	str	r2, [r3, #0]
					break;
 8009ab6:	e7ce      	b.n	8009a56 <xTaskIncrementTick+0x62>
						xNextTaskUnblockTime = xItemValue;
 8009ab8:	4a22      	ldr	r2, [pc, #136]	; (8009b44 <xTaskIncrementTick+0x150>)
 8009aba:	6013      	str	r3, [r2, #0]
						break;
 8009abc:	e7cb      	b.n	8009a56 <xTaskIncrementTick+0x62>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8009abe:	f104 0018 	add.w	r0, r4, #24
 8009ac2:	f7fe fec1 	bl	8008848 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8009ac6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8009ac8:	f8d9 2000 	ldr.w	r2, [r9]
 8009acc:	2301      	movs	r3, #1
 8009ace:	4083      	lsls	r3, r0
 8009ad0:	4313      	orrs	r3, r2
 8009ad2:	f8c9 3000 	str.w	r3, [r9]
 8009ad6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ada:	4629      	mov	r1, r5
 8009adc:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 8009ae0:	f7fe fe8c 	bl	80087fc <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8009ae4:	4b18      	ldr	r3, [pc, #96]	; (8009b48 <xTaskIncrementTick+0x154>)
 8009ae6:	681b      	ldr	r3, [r3, #0]
 8009ae8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009aea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8009aec:	429a      	cmp	r2, r3
 8009aee:	bf28      	it	cs
 8009af0:	2601      	movcs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009af2:	683b      	ldr	r3, [r7, #0]
 8009af4:	681b      	ldr	r3, [r3, #0]
 8009af6:	2b00      	cmp	r3, #0
 8009af8:	d0d9      	beq.n	8009aae <xTaskIncrementTick+0xba>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8009afa:	683b      	ldr	r3, [r7, #0]
 8009afc:	68db      	ldr	r3, [r3, #12]
 8009afe:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8009b00:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
 8009b02:	4598      	cmp	r8, r3
 8009b04:	d3d8      	bcc.n	8009ab8 <xTaskIncrementTick+0xc4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8009b06:	1d25      	adds	r5, r4, #4
 8009b08:	4628      	mov	r0, r5
 8009b0a:	f7fe fe9d 	bl	8008848 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8009b0e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009b10:	2b00      	cmp	r3, #0
 8009b12:	d1d4      	bne.n	8009abe <xTaskIncrementTick+0xca>
 8009b14:	e7d7      	b.n	8009ac6 <xTaskIncrementTick+0xd2>
				vApplicationTickHook();
 8009b16:	f002 fa03 	bl	800bf20 <vApplicationTickHook>
 8009b1a:	e7ab      	b.n	8009a74 <xTaskIncrementTick+0x80>
		++uxPendedTicks;
 8009b1c:	4a0c      	ldr	r2, [pc, #48]	; (8009b50 <xTaskIncrementTick+0x15c>)
 8009b1e:	6813      	ldr	r3, [r2, #0]
 8009b20:	3301      	adds	r3, #1
 8009b22:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
 8009b24:	f002 f9fc 	bl	800bf20 <vApplicationTickHook>
BaseType_t xSwitchRequired = pdFALSE;
 8009b28:	2600      	movs	r6, #0
 8009b2a:	e7a3      	b.n	8009a74 <xTaskIncrementTick+0x80>
 8009b2c:	20000a1c 	.word	0x20000a1c
 8009b30:	20004ce4 	.word	0x20004ce4
 8009b34:	20000a9c 	.word	0x20000a9c
 8009b38:	20000978 	.word	0x20000978
 8009b3c:	2000097c 	.word	0x2000097c
 8009b40:	20000a58 	.word	0x20000a58
 8009b44:	20000a54 	.word	0x20000a54
 8009b48:	20000974 	.word	0x20000974
 8009b4c:	20000980 	.word	0x20000980
 8009b50:	20000a18 	.word	0x20000a18
 8009b54:	20000aa0 	.word	0x20000aa0
 8009b58:	20004cec 	.word	0x20004cec
 8009b5c:	0800ca1c 	.word	0x0800ca1c
 8009b60:	20000a24 	.word	0x20000a24

08009b64 <xTaskResumeAll>:
{
 8009b64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( uxSchedulerSuspended );
 8009b68:	4b34      	ldr	r3, [pc, #208]	; (8009c3c <xTaskResumeAll+0xd8>)
 8009b6a:	681b      	ldr	r3, [r3, #0]
 8009b6c:	2b00      	cmp	r3, #0
 8009b6e:	d033      	beq.n	8009bd8 <xTaskResumeAll+0x74>
	taskENTER_CRITICAL();
 8009b70:	f7fe fec0 	bl	80088f4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8009b74:	4b31      	ldr	r3, [pc, #196]	; (8009c3c <xTaskResumeAll+0xd8>)
 8009b76:	681a      	ldr	r2, [r3, #0]
 8009b78:	3a01      	subs	r2, #1
 8009b7a:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8009b7c:	681b      	ldr	r3, [r3, #0]
 8009b7e:	2b00      	cmp	r3, #0
 8009b80:	d153      	bne.n	8009c2a <xTaskResumeAll+0xc6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8009b82:	4b2f      	ldr	r3, [pc, #188]	; (8009c40 <xTaskResumeAll+0xdc>)
 8009b84:	681b      	ldr	r3, [r3, #0]
 8009b86:	b36b      	cbz	r3, 8009be4 <xTaskResumeAll+0x80>
 8009b88:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8009b8a:	4e2e      	ldr	r6, [pc, #184]	; (8009c44 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList( pxTCB );
 8009b8c:	4f2e      	ldr	r7, [pc, #184]	; (8009c48 <xTaskResumeAll+0xe4>)
 8009b8e:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8009c60 <xTaskResumeAll+0xfc>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8009b92:	6833      	ldr	r3, [r6, #0]
 8009b94:	b343      	cbz	r3, 8009be8 <xTaskResumeAll+0x84>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8009b96:	68f3      	ldr	r3, [r6, #12]
 8009b98:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8009b9a:	f104 0018 	add.w	r0, r4, #24
 8009b9e:	f7fe fe53 	bl	8008848 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8009ba2:	1d25      	adds	r5, r4, #4
 8009ba4:	4628      	mov	r0, r5
 8009ba6:	f7fe fe4f 	bl	8008848 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8009baa:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8009bac:	683a      	ldr	r2, [r7, #0]
 8009bae:	2301      	movs	r3, #1
 8009bb0:	4083      	lsls	r3, r0
 8009bb2:	4313      	orrs	r3, r2
 8009bb4:	603b      	str	r3, [r7, #0]
 8009bb6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009bba:	4629      	mov	r1, r5
 8009bbc:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8009bc0:	f7fe fe1c 	bl	80087fc <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8009bc4:	4b21      	ldr	r3, [pc, #132]	; (8009c4c <xTaskResumeAll+0xe8>)
 8009bc6:	681b      	ldr	r3, [r3, #0]
 8009bc8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009bca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009bcc:	429a      	cmp	r2, r3
 8009bce:	d3e0      	bcc.n	8009b92 <xTaskResumeAll+0x2e>
						xYieldPending = pdTRUE;
 8009bd0:	2201      	movs	r2, #1
 8009bd2:	4b1f      	ldr	r3, [pc, #124]	; (8009c50 <xTaskResumeAll+0xec>)
 8009bd4:	601a      	str	r2, [r3, #0]
 8009bd6:	e7dc      	b.n	8009b92 <xTaskResumeAll+0x2e>
	configASSERT( uxSchedulerSuspended );
 8009bd8:	f240 71eb 	movw	r1, #2027	; 0x7eb
 8009bdc:	481d      	ldr	r0, [pc, #116]	; (8009c54 <xTaskResumeAll+0xf0>)
 8009bde:	f002 f895 	bl	800bd0c <vAssertCalled>
 8009be2:	e7c5      	b.n	8009b70 <xTaskResumeAll+0xc>
BaseType_t xAlreadyYielded = pdFALSE;
 8009be4:	2400      	movs	r4, #0
 8009be6:	e021      	b.n	8009c2c <xTaskResumeAll+0xc8>
				if( pxTCB != NULL )
 8009be8:	b10c      	cbz	r4, 8009bee <xTaskResumeAll+0x8a>
					prvResetNextTaskUnblockTime();
 8009bea:	f7ff fc93 	bl	8009514 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8009bee:	4b1a      	ldr	r3, [pc, #104]	; (8009c58 <xTaskResumeAll+0xf4>)
 8009bf0:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8009bf2:	b16c      	cbz	r4, 8009c10 <xTaskResumeAll+0xac>
								xYieldPending = pdTRUE;
 8009bf4:	4e16      	ldr	r6, [pc, #88]	; (8009c50 <xTaskResumeAll+0xec>)
 8009bf6:	2501      	movs	r5, #1
 8009bf8:	e001      	b.n	8009bfe <xTaskResumeAll+0x9a>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8009bfa:	3c01      	subs	r4, #1
 8009bfc:	d005      	beq.n	8009c0a <xTaskResumeAll+0xa6>
							if( xTaskIncrementTick() != pdFALSE )
 8009bfe:	f7ff fef9 	bl	80099f4 <xTaskIncrementTick>
 8009c02:	2800      	cmp	r0, #0
 8009c04:	d0f9      	beq.n	8009bfa <xTaskResumeAll+0x96>
								xYieldPending = pdTRUE;
 8009c06:	6035      	str	r5, [r6, #0]
 8009c08:	e7f7      	b.n	8009bfa <xTaskResumeAll+0x96>
						uxPendedTicks = 0;
 8009c0a:	2200      	movs	r2, #0
 8009c0c:	4b12      	ldr	r3, [pc, #72]	; (8009c58 <xTaskResumeAll+0xf4>)
 8009c0e:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
 8009c10:	4b0f      	ldr	r3, [pc, #60]	; (8009c50 <xTaskResumeAll+0xec>)
 8009c12:	681b      	ldr	r3, [r3, #0]
 8009c14:	b17b      	cbz	r3, 8009c36 <xTaskResumeAll+0xd2>
					taskYIELD_IF_USING_PREEMPTION();
 8009c16:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009c1a:	4b10      	ldr	r3, [pc, #64]	; (8009c5c <xTaskResumeAll+0xf8>)
 8009c1c:	601a      	str	r2, [r3, #0]
 8009c1e:	f3bf 8f4f 	dsb	sy
 8009c22:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8009c26:	2401      	movs	r4, #1
 8009c28:	e000      	b.n	8009c2c <xTaskResumeAll+0xc8>
BaseType_t xAlreadyYielded = pdFALSE;
 8009c2a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8009c2c:	f7fe fe84 	bl	8008938 <vPortExitCritical>
}
 8009c30:	4620      	mov	r0, r4
 8009c32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
BaseType_t xAlreadyYielded = pdFALSE;
 8009c36:	2400      	movs	r4, #0
 8009c38:	e7f8      	b.n	8009c2c <xTaskResumeAll+0xc8>
 8009c3a:	bf00      	nop
 8009c3c:	20000a1c 	.word	0x20000a1c
 8009c40:	20000a10 	.word	0x20000a10
 8009c44:	20000a5c 	.word	0x20000a5c
 8009c48:	20000a24 	.word	0x20000a24
 8009c4c:	20000974 	.word	0x20000974
 8009c50:	20000aa0 	.word	0x20000aa0
 8009c54:	0800ca1c 	.word	0x0800ca1c
 8009c58:	20000a18 	.word	0x20000a18
 8009c5c:	e000ed04 	.word	0xe000ed04
 8009c60:	20000980 	.word	0x20000980

08009c64 <vTaskDelay>:
	{
 8009c64:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8009c66:	b160      	cbz	r0, 8009c82 <vTaskDelay+0x1e>
 8009c68:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 8009c6a:	4b0d      	ldr	r3, [pc, #52]	; (8009ca0 <vTaskDelay+0x3c>)
 8009c6c:	681b      	ldr	r3, [r3, #0]
 8009c6e:	b98b      	cbnz	r3, 8009c94 <vTaskDelay+0x30>
			vTaskSuspendAll();
 8009c70:	f7ff fe9e 	bl	80099b0 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8009c74:	2100      	movs	r1, #0
 8009c76:	4620      	mov	r0, r4
 8009c78:	f7ff fc62 	bl	8009540 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8009c7c:	f7ff ff72 	bl	8009b64 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8009c80:	b938      	cbnz	r0, 8009c92 <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
 8009c82:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009c86:	4b07      	ldr	r3, [pc, #28]	; (8009ca4 <vTaskDelay+0x40>)
 8009c88:	601a      	str	r2, [r3, #0]
 8009c8a:	f3bf 8f4f 	dsb	sy
 8009c8e:	f3bf 8f6f 	isb	sy
 8009c92:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8009c94:	f240 41cf 	movw	r1, #1231	; 0x4cf
 8009c98:	4803      	ldr	r0, [pc, #12]	; (8009ca8 <vTaskDelay+0x44>)
 8009c9a:	f002 f837 	bl	800bd0c <vAssertCalled>
 8009c9e:	e7e7      	b.n	8009c70 <vTaskDelay+0xc>
 8009ca0:	20000a1c 	.word	0x20000a1c
 8009ca4:	e000ed04 	.word	0xe000ed04
 8009ca8:	0800ca1c 	.word	0x0800ca1c

08009cac <prvIdleTask>:
{
 8009cac:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8009cae:	4d1a      	ldr	r5, [pc, #104]	; (8009d18 <prvIdleTask+0x6c>)
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8009cb0:	4e1a      	ldr	r6, [pc, #104]	; (8009d1c <prvIdleTask+0x70>)
					--uxCurrentNumberOfTasks;
 8009cb2:	4f1b      	ldr	r7, [pc, #108]	; (8009d20 <prvIdleTask+0x74>)
				taskYIELD();
 8009cb4:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8009d28 <prvIdleTask+0x7c>
 8009cb8:	e00d      	b.n	8009cd6 <prvIdleTask+0x2a>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8009cba:	4b1a      	ldr	r3, [pc, #104]	; (8009d24 <prvIdleTask+0x78>)
 8009cbc:	681b      	ldr	r3, [r3, #0]
 8009cbe:	2b01      	cmp	r3, #1
 8009cc0:	d907      	bls.n	8009cd2 <prvIdleTask+0x26>
				taskYIELD();
 8009cc2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8009cc6:	f8c8 3000 	str.w	r3, [r8]
 8009cca:	f3bf 8f4f 	dsb	sy
 8009cce:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 8009cd2:	f002 f801 	bl	800bcd8 <vApplicationIdleHook>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8009cd6:	682b      	ldr	r3, [r5, #0]
 8009cd8:	2b00      	cmp	r3, #0
 8009cda:	d0ee      	beq.n	8009cba <prvIdleTask+0xe>
			vTaskSuspendAll();
 8009cdc:	f7ff fe68 	bl	80099b0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8009ce0:	6834      	ldr	r4, [r6, #0]
			( void ) xTaskResumeAll();
 8009ce2:	f7ff ff3f 	bl	8009b64 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 8009ce6:	2c00      	cmp	r4, #0
 8009ce8:	d0f5      	beq.n	8009cd6 <prvIdleTask+0x2a>
				taskENTER_CRITICAL();
 8009cea:	f7fe fe03 	bl	80088f4 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8009cee:	68f3      	ldr	r3, [r6, #12]
 8009cf0:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8009cf2:	1d20      	adds	r0, r4, #4
 8009cf4:	f7fe fda8 	bl	8008848 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8009cf8:	683b      	ldr	r3, [r7, #0]
 8009cfa:	3b01      	subs	r3, #1
 8009cfc:	603b      	str	r3, [r7, #0]
					--uxDeletedTasksWaitingCleanUp;
 8009cfe:	682b      	ldr	r3, [r5, #0]
 8009d00:	3b01      	subs	r3, #1
 8009d02:	602b      	str	r3, [r5, #0]
				taskEXIT_CRITICAL();
 8009d04:	f7fe fe18 	bl	8008938 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 8009d08:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8009d0a:	f7fe ffe3 	bl	8008cd4 <vPortFree>
			vPortFree( pxTCB );
 8009d0e:	4620      	mov	r0, r4
 8009d10:	f7fe ffe0 	bl	8008cd4 <vPortFree>
 8009d14:	e7df      	b.n	8009cd6 <prvIdleTask+0x2a>
 8009d16:	bf00      	nop
 8009d18:	20000a14 	.word	0x20000a14
 8009d1c:	20000a88 	.word	0x20000a88
 8009d20:	20000a10 	.word	0x20000a10
 8009d24:	20000980 	.word	0x20000980
 8009d28:	e000ed04 	.word	0xe000ed04

08009d2c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8009d2c:	4b31      	ldr	r3, [pc, #196]	; (8009df4 <vTaskSwitchContext+0xc8>)
 8009d2e:	681b      	ldr	r3, [r3, #0]
 8009d30:	b11b      	cbz	r3, 8009d3a <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8009d32:	2201      	movs	r2, #1
 8009d34:	4b30      	ldr	r3, [pc, #192]	; (8009df8 <vTaskSwitchContext+0xcc>)
 8009d36:	601a      	str	r2, [r3, #0]
 8009d38:	4770      	bx	lr
{
 8009d3a:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
 8009d3c:	2200      	movs	r2, #0
 8009d3e:	4b2e      	ldr	r3, [pc, #184]	; (8009df8 <vTaskSwitchContext+0xcc>)
 8009d40:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 8009d42:	f002 f8e9 	bl	800bf18 <xGetRunTimeCounterValue>
				if( ulTotalRunTime > ulTaskSwitchedInTime )
 8009d46:	4b2d      	ldr	r3, [pc, #180]	; (8009dfc <vTaskSwitchContext+0xd0>)
 8009d48:	681a      	ldr	r2, [r3, #0]
 8009d4a:	4290      	cmp	r0, r2
 8009d4c:	d905      	bls.n	8009d5a <vTaskSwitchContext+0x2e>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 8009d4e:	4b2c      	ldr	r3, [pc, #176]	; (8009e00 <vTaskSwitchContext+0xd4>)
 8009d50:	6819      	ldr	r1, [r3, #0]
 8009d52:	6e0b      	ldr	r3, [r1, #96]	; 0x60
 8009d54:	1a9b      	subs	r3, r3, r2
 8009d56:	4403      	add	r3, r0
 8009d58:	660b      	str	r3, [r1, #96]	; 0x60
				ulTaskSwitchedInTime = ulTotalRunTime;
 8009d5a:	4b28      	ldr	r3, [pc, #160]	; (8009dfc <vTaskSwitchContext+0xd0>)
 8009d5c:	6018      	str	r0, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 8009d5e:	4b28      	ldr	r3, [pc, #160]	; (8009e00 <vTaskSwitchContext+0xd4>)
 8009d60:	681b      	ldr	r3, [r3, #0]
 8009d62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d64:	681a      	ldr	r2, [r3, #0]
 8009d66:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8009d6a:	d029      	beq.n	8009dc0 <vTaskSwitchContext+0x94>
 8009d6c:	4b24      	ldr	r3, [pc, #144]	; (8009e00 <vTaskSwitchContext+0xd4>)
 8009d6e:	6818      	ldr	r0, [r3, #0]
 8009d70:	6819      	ldr	r1, [r3, #0]
 8009d72:	3134      	adds	r1, #52	; 0x34
 8009d74:	f002 f886 	bl	800be84 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8009d78:	4b22      	ldr	r3, [pc, #136]	; (8009e04 <vTaskSwitchContext+0xd8>)
 8009d7a:	681c      	ldr	r4, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8009d7c:	fab4 f484 	clz	r4, r4
 8009d80:	b2e4      	uxtb	r4, r4
 8009d82:	f1c4 041f 	rsb	r4, r4, #31
 8009d86:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8009d8a:	4b1f      	ldr	r3, [pc, #124]	; (8009e08 <vTaskSwitchContext+0xdc>)
 8009d8c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8009d90:	b31b      	cbz	r3, 8009dda <vTaskSwitchContext+0xae>
 8009d92:	4b1d      	ldr	r3, [pc, #116]	; (8009e08 <vTaskSwitchContext+0xdc>)
 8009d94:	00a2      	lsls	r2, r4, #2
 8009d96:	1911      	adds	r1, r2, r4
 8009d98:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8009d9c:	6848      	ldr	r0, [r1, #4]
 8009d9e:	6840      	ldr	r0, [r0, #4]
 8009da0:	6048      	str	r0, [r1, #4]
 8009da2:	4422      	add	r2, r4
 8009da4:	460b      	mov	r3, r1
 8009da6:	3308      	adds	r3, #8
 8009da8:	4298      	cmp	r0, r3
 8009daa:	d01c      	beq.n	8009de6 <vTaskSwitchContext+0xba>
 8009dac:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8009db0:	4b15      	ldr	r3, [pc, #84]	; (8009e08 <vTaskSwitchContext+0xdc>)
 8009db2:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8009db6:	6863      	ldr	r3, [r4, #4]
 8009db8:	68da      	ldr	r2, [r3, #12]
 8009dba:	4b11      	ldr	r3, [pc, #68]	; (8009e00 <vTaskSwitchContext+0xd4>)
 8009dbc:	601a      	str	r2, [r3, #0]
 8009dbe:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
 8009dc0:	685a      	ldr	r2, [r3, #4]
 8009dc2:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8009dc6:	d1d1      	bne.n	8009d6c <vTaskSwitchContext+0x40>
 8009dc8:	689a      	ldr	r2, [r3, #8]
 8009dca:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8009dce:	d1cd      	bne.n	8009d6c <vTaskSwitchContext+0x40>
 8009dd0:	68db      	ldr	r3, [r3, #12]
 8009dd2:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 8009dd6:	d1c9      	bne.n	8009d6c <vTaskSwitchContext+0x40>
 8009dd8:	e7ce      	b.n	8009d78 <vTaskSwitchContext+0x4c>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8009dda:	f640 21f9 	movw	r1, #2809	; 0xaf9
 8009dde:	480b      	ldr	r0, [pc, #44]	; (8009e0c <vTaskSwitchContext+0xe0>)
 8009de0:	f001 ff94 	bl	800bd0c <vAssertCalled>
 8009de4:	e7d5      	b.n	8009d92 <vTaskSwitchContext+0x66>
 8009de6:	6841      	ldr	r1, [r0, #4]
 8009de8:	4613      	mov	r3, r2
 8009dea:	4a07      	ldr	r2, [pc, #28]	; (8009e08 <vTaskSwitchContext+0xdc>)
 8009dec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8009df0:	6059      	str	r1, [r3, #4]
 8009df2:	e7db      	b.n	8009dac <vTaskSwitchContext+0x80>
 8009df4:	20000a1c 	.word	0x20000a1c
 8009df8:	20000aa0 	.word	0x20000aa0
 8009dfc:	20000a0c 	.word	0x20000a0c
 8009e00:	20000974 	.word	0x20000974
 8009e04:	20000a24 	.word	0x20000a24
 8009e08:	20000980 	.word	0x20000980
 8009e0c:	0800ca1c 	.word	0x0800ca1c

08009e10 <vTaskPlaceOnEventList>:
{
 8009e10:	b538      	push	{r3, r4, r5, lr}
 8009e12:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 8009e14:	4605      	mov	r5, r0
 8009e16:	b150      	cbz	r0, 8009e2e <vTaskPlaceOnEventList+0x1e>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8009e18:	4b08      	ldr	r3, [pc, #32]	; (8009e3c <vTaskPlaceOnEventList+0x2c>)
 8009e1a:	6819      	ldr	r1, [r3, #0]
 8009e1c:	3118      	adds	r1, #24
 8009e1e:	4628      	mov	r0, r5
 8009e20:	f7fe fcf8 	bl	8008814 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8009e24:	2101      	movs	r1, #1
 8009e26:	4620      	mov	r0, r4
 8009e28:	f7ff fb8a 	bl	8009540 <prvAddCurrentTaskToDelayedList>
 8009e2c:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxEventList );
 8009e2e:	f640 3109 	movw	r1, #2825	; 0xb09
 8009e32:	4803      	ldr	r0, [pc, #12]	; (8009e40 <vTaskPlaceOnEventList+0x30>)
 8009e34:	f001 ff6a 	bl	800bd0c <vAssertCalled>
 8009e38:	e7ee      	b.n	8009e18 <vTaskPlaceOnEventList+0x8>
 8009e3a:	bf00      	nop
 8009e3c:	20000974 	.word	0x20000974
 8009e40:	0800ca1c 	.word	0x0800ca1c

08009e44 <vTaskPlaceOnUnorderedEventList>:
{
 8009e44:	b570      	push	{r4, r5, r6, lr}
 8009e46:	460c      	mov	r4, r1
 8009e48:	4615      	mov	r5, r2
	configASSERT( pxEventList );
 8009e4a:	4606      	mov	r6, r0
 8009e4c:	b188      	cbz	r0, 8009e72 <vTaskPlaceOnUnorderedEventList+0x2e>
	configASSERT( uxSchedulerSuspended != 0 );
 8009e4e:	4b0f      	ldr	r3, [pc, #60]	; (8009e8c <vTaskPlaceOnUnorderedEventList+0x48>)
 8009e50:	681b      	ldr	r3, [r3, #0]
 8009e52:	b1a3      	cbz	r3, 8009e7e <vTaskPlaceOnUnorderedEventList+0x3a>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8009e54:	4b0e      	ldr	r3, [pc, #56]	; (8009e90 <vTaskPlaceOnUnorderedEventList+0x4c>)
 8009e56:	681a      	ldr	r2, [r3, #0]
 8009e58:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8009e5c:	6194      	str	r4, [r2, #24]
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8009e5e:	6819      	ldr	r1, [r3, #0]
 8009e60:	3118      	adds	r1, #24
 8009e62:	4630      	mov	r0, r6
 8009e64:	f7fe fcca 	bl	80087fc <vListInsertEnd>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8009e68:	2101      	movs	r1, #1
 8009e6a:	4628      	mov	r0, r5
 8009e6c:	f7ff fb68 	bl	8009540 <prvAddCurrentTaskToDelayedList>
 8009e70:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxEventList );
 8009e72:	f640 311a 	movw	r1, #2842	; 0xb1a
 8009e76:	4807      	ldr	r0, [pc, #28]	; (8009e94 <vTaskPlaceOnUnorderedEventList+0x50>)
 8009e78:	f001 ff48 	bl	800bd0c <vAssertCalled>
 8009e7c:	e7e7      	b.n	8009e4e <vTaskPlaceOnUnorderedEventList+0xa>
	configASSERT( uxSchedulerSuspended != 0 );
 8009e7e:	f640 311e 	movw	r1, #2846	; 0xb1e
 8009e82:	4804      	ldr	r0, [pc, #16]	; (8009e94 <vTaskPlaceOnUnorderedEventList+0x50>)
 8009e84:	f001 ff42 	bl	800bd0c <vAssertCalled>
 8009e88:	e7e4      	b.n	8009e54 <vTaskPlaceOnUnorderedEventList+0x10>
 8009e8a:	bf00      	nop
 8009e8c:	20000a1c 	.word	0x20000a1c
 8009e90:	20000974 	.word	0x20000974
 8009e94:	0800ca1c 	.word	0x0800ca1c

08009e98 <xTaskRemoveFromEventList>:
{
 8009e98:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8009e9a:	68c3      	ldr	r3, [r0, #12]
 8009e9c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8009e9e:	b32c      	cbz	r4, 8009eec <xTaskRemoveFromEventList+0x54>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8009ea0:	f104 0518 	add.w	r5, r4, #24
 8009ea4:	4628      	mov	r0, r5
 8009ea6:	f7fe fccf 	bl	8008848 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8009eaa:	4b16      	ldr	r3, [pc, #88]	; (8009f04 <xTaskRemoveFromEventList+0x6c>)
 8009eac:	681b      	ldr	r3, [r3, #0]
 8009eae:	bb1b      	cbnz	r3, 8009ef8 <xTaskRemoveFromEventList+0x60>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8009eb0:	1d25      	adds	r5, r4, #4
 8009eb2:	4628      	mov	r0, r5
 8009eb4:	f7fe fcc8 	bl	8008848 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8009eb8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8009eba:	4a13      	ldr	r2, [pc, #76]	; (8009f08 <xTaskRemoveFromEventList+0x70>)
 8009ebc:	6811      	ldr	r1, [r2, #0]
 8009ebe:	2301      	movs	r3, #1
 8009ec0:	4083      	lsls	r3, r0
 8009ec2:	430b      	orrs	r3, r1
 8009ec4:	6013      	str	r3, [r2, #0]
 8009ec6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009eca:	4629      	mov	r1, r5
 8009ecc:	4b0f      	ldr	r3, [pc, #60]	; (8009f0c <xTaskRemoveFromEventList+0x74>)
 8009ece:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8009ed2:	f7fe fc93 	bl	80087fc <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8009ed6:	4b0e      	ldr	r3, [pc, #56]	; (8009f10 <xTaskRemoveFromEventList+0x78>)
 8009ed8:	681b      	ldr	r3, [r3, #0]
 8009eda:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009edc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009ede:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8009ee0:	bf83      	ittte	hi
 8009ee2:	2001      	movhi	r0, #1
 8009ee4:	4b0b      	ldrhi	r3, [pc, #44]	; (8009f14 <xTaskRemoveFromEventList+0x7c>)
 8009ee6:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 8009ee8:	2000      	movls	r0, #0
}
 8009eea:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxUnblockedTCB );
 8009eec:	f640 3164 	movw	r1, #2916	; 0xb64
 8009ef0:	4809      	ldr	r0, [pc, #36]	; (8009f18 <xTaskRemoveFromEventList+0x80>)
 8009ef2:	f001 ff0b 	bl	800bd0c <vAssertCalled>
 8009ef6:	e7d3      	b.n	8009ea0 <xTaskRemoveFromEventList+0x8>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8009ef8:	4629      	mov	r1, r5
 8009efa:	4808      	ldr	r0, [pc, #32]	; (8009f1c <xTaskRemoveFromEventList+0x84>)
 8009efc:	f7fe fc7e 	bl	80087fc <vListInsertEnd>
 8009f00:	e7e9      	b.n	8009ed6 <xTaskRemoveFromEventList+0x3e>
 8009f02:	bf00      	nop
 8009f04:	20000a1c 	.word	0x20000a1c
 8009f08:	20000a24 	.word	0x20000a24
 8009f0c:	20000980 	.word	0x20000980
 8009f10:	20000974 	.word	0x20000974
 8009f14:	20000aa0 	.word	0x20000aa0
 8009f18:	0800ca1c 	.word	0x0800ca1c
 8009f1c:	20000a5c 	.word	0x20000a5c

08009f20 <vTaskRemoveFromUnorderedEventList>:
{
 8009f20:	b538      	push	{r3, r4, r5, lr}
 8009f22:	4605      	mov	r5, r0
 8009f24:	460c      	mov	r4, r1
	configASSERT( uxSchedulerSuspended != pdFALSE );
 8009f26:	4b1a      	ldr	r3, [pc, #104]	; (8009f90 <vTaskRemoveFromUnorderedEventList+0x70>)
 8009f28:	681b      	ldr	r3, [r3, #0]
 8009f2a:	b323      	cbz	r3, 8009f76 <vTaskRemoveFromUnorderedEventList+0x56>
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8009f2c:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 8009f30:	602c      	str	r4, [r5, #0]
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 8009f32:	68ec      	ldr	r4, [r5, #12]
	configASSERT( pxUnblockedTCB );
 8009f34:	b32c      	cbz	r4, 8009f82 <vTaskRemoveFromUnorderedEventList+0x62>
	( void ) uxListRemove( pxEventListItem );
 8009f36:	4628      	mov	r0, r5
 8009f38:	f7fe fc86 	bl	8008848 <uxListRemove>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8009f3c:	1d25      	adds	r5, r4, #4
 8009f3e:	4628      	mov	r0, r5
 8009f40:	f7fe fc82 	bl	8008848 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 8009f44:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8009f46:	4a13      	ldr	r2, [pc, #76]	; (8009f94 <vTaskRemoveFromUnorderedEventList+0x74>)
 8009f48:	6811      	ldr	r1, [r2, #0]
 8009f4a:	2301      	movs	r3, #1
 8009f4c:	4083      	lsls	r3, r0
 8009f4e:	430b      	orrs	r3, r1
 8009f50:	6013      	str	r3, [r2, #0]
 8009f52:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f56:	4629      	mov	r1, r5
 8009f58:	4b0f      	ldr	r3, [pc, #60]	; (8009f98 <vTaskRemoveFromUnorderedEventList+0x78>)
 8009f5a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8009f5e:	f7fe fc4d 	bl	80087fc <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8009f62:	4b0e      	ldr	r3, [pc, #56]	; (8009f9c <vTaskRemoveFromUnorderedEventList+0x7c>)
 8009f64:	681b      	ldr	r3, [r3, #0]
 8009f66:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009f68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009f6a:	429a      	cmp	r2, r3
 8009f6c:	d902      	bls.n	8009f74 <vTaskRemoveFromUnorderedEventList+0x54>
		xYieldPending = pdTRUE;
 8009f6e:	2201      	movs	r2, #1
 8009f70:	4b0b      	ldr	r3, [pc, #44]	; (8009fa0 <vTaskRemoveFromUnorderedEventList+0x80>)
 8009f72:	601a      	str	r2, [r3, #0]
 8009f74:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( uxSchedulerSuspended != pdFALSE );
 8009f76:	f640 319b 	movw	r1, #2971	; 0xb9b
 8009f7a:	480a      	ldr	r0, [pc, #40]	; (8009fa4 <vTaskRemoveFromUnorderedEventList+0x84>)
 8009f7c:	f001 fec6 	bl	800bd0c <vAssertCalled>
 8009f80:	e7d4      	b.n	8009f2c <vTaskRemoveFromUnorderedEventList+0xc>
	configASSERT( pxUnblockedTCB );
 8009f82:	f640 31a3 	movw	r1, #2979	; 0xba3
 8009f86:	4807      	ldr	r0, [pc, #28]	; (8009fa4 <vTaskRemoveFromUnorderedEventList+0x84>)
 8009f88:	f001 fec0 	bl	800bd0c <vAssertCalled>
 8009f8c:	e7d3      	b.n	8009f36 <vTaskRemoveFromUnorderedEventList+0x16>
 8009f8e:	bf00      	nop
 8009f90:	20000a1c 	.word	0x20000a1c
 8009f94:	20000a24 	.word	0x20000a24
 8009f98:	20000980 	.word	0x20000980
 8009f9c:	20000974 	.word	0x20000974
 8009fa0:	20000aa0 	.word	0x20000aa0
 8009fa4:	0800ca1c 	.word	0x0800ca1c

08009fa8 <vTaskSetTimeOutState>:
{
 8009fa8:	b510      	push	{r4, lr}
	configASSERT( pxTimeOut );
 8009faa:	4604      	mov	r4, r0
 8009fac:	b130      	cbz	r0, 8009fbc <vTaskSetTimeOutState+0x14>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8009fae:	4b06      	ldr	r3, [pc, #24]	; (8009fc8 <vTaskSetTimeOutState+0x20>)
 8009fb0:	681b      	ldr	r3, [r3, #0]
 8009fb2:	6023      	str	r3, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8009fb4:	4b05      	ldr	r3, [pc, #20]	; (8009fcc <vTaskSetTimeOutState+0x24>)
 8009fb6:	681b      	ldr	r3, [r3, #0]
 8009fb8:	6063      	str	r3, [r4, #4]
 8009fba:	bd10      	pop	{r4, pc}
	configASSERT( pxTimeOut );
 8009fbc:	f640 31b9 	movw	r1, #3001	; 0xbb9
 8009fc0:	4803      	ldr	r0, [pc, #12]	; (8009fd0 <vTaskSetTimeOutState+0x28>)
 8009fc2:	f001 fea3 	bl	800bd0c <vAssertCalled>
 8009fc6:	e7f2      	b.n	8009fae <vTaskSetTimeOutState+0x6>
 8009fc8:	20000a58 	.word	0x20000a58
 8009fcc:	20000a9c 	.word	0x20000a9c
 8009fd0:	0800ca1c 	.word	0x0800ca1c

08009fd4 <xTaskCheckForTimeOut>:
{
 8009fd4:	b538      	push	{r3, r4, r5, lr}
 8009fd6:	460c      	mov	r4, r1
	configASSERT( pxTimeOut );
 8009fd8:	4605      	mov	r5, r0
 8009fda:	b1c8      	cbz	r0, 800a010 <xTaskCheckForTimeOut+0x3c>
	configASSERT( pxTicksToWait );
 8009fdc:	b1f4      	cbz	r4, 800a01c <xTaskCheckForTimeOut+0x48>
	taskENTER_CRITICAL();
 8009fde:	f7fe fc89 	bl	80088f4 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8009fe2:	4b17      	ldr	r3, [pc, #92]	; (800a040 <xTaskCheckForTimeOut+0x6c>)
 8009fe4:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8009fe6:	6823      	ldr	r3, [r4, #0]
 8009fe8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009fec:	d024      	beq.n	800a038 <xTaskCheckForTimeOut+0x64>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8009fee:	4915      	ldr	r1, [pc, #84]	; (800a044 <xTaskCheckForTimeOut+0x70>)
 8009ff0:	6809      	ldr	r1, [r1, #0]
 8009ff2:	6828      	ldr	r0, [r5, #0]
 8009ff4:	4288      	cmp	r0, r1
 8009ff6:	d002      	beq.n	8009ffe <xTaskCheckForTimeOut+0x2a>
 8009ff8:	6869      	ldr	r1, [r5, #4]
 8009ffa:	428a      	cmp	r2, r1
 8009ffc:	d21e      	bcs.n	800a03c <xTaskCheckForTimeOut+0x68>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8009ffe:	6869      	ldr	r1, [r5, #4]
 800a000:	1a50      	subs	r0, r2, r1
 800a002:	4283      	cmp	r3, r0
 800a004:	d810      	bhi.n	800a028 <xTaskCheckForTimeOut+0x54>
			xReturn = pdTRUE;
 800a006:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 800a008:	f7fe fc96 	bl	8008938 <vPortExitCritical>
}
 800a00c:	4620      	mov	r0, r4
 800a00e:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxTimeOut );
 800a010:	f640 31c3 	movw	r1, #3011	; 0xbc3
 800a014:	480c      	ldr	r0, [pc, #48]	; (800a048 <xTaskCheckForTimeOut+0x74>)
 800a016:	f001 fe79 	bl	800bd0c <vAssertCalled>
 800a01a:	e7df      	b.n	8009fdc <xTaskCheckForTimeOut+0x8>
	configASSERT( pxTicksToWait );
 800a01c:	f640 31c4 	movw	r1, #3012	; 0xbc4
 800a020:	4809      	ldr	r0, [pc, #36]	; (800a048 <xTaskCheckForTimeOut+0x74>)
 800a022:	f001 fe73 	bl	800bd0c <vAssertCalled>
 800a026:	e7da      	b.n	8009fde <xTaskCheckForTimeOut+0xa>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800a028:	1a9b      	subs	r3, r3, r2
 800a02a:	440b      	add	r3, r1
 800a02c:	6023      	str	r3, [r4, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800a02e:	4628      	mov	r0, r5
 800a030:	f7ff ffba 	bl	8009fa8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800a034:	2400      	movs	r4, #0
 800a036:	e7e7      	b.n	800a008 <xTaskCheckForTimeOut+0x34>
				xReturn = pdFALSE;
 800a038:	2400      	movs	r4, #0
 800a03a:	e7e5      	b.n	800a008 <xTaskCheckForTimeOut+0x34>
			xReturn = pdTRUE;
 800a03c:	2401      	movs	r4, #1
 800a03e:	e7e3      	b.n	800a008 <xTaskCheckForTimeOut+0x34>
 800a040:	20000a9c 	.word	0x20000a9c
 800a044:	20000a58 	.word	0x20000a58
 800a048:	0800ca1c 	.word	0x0800ca1c

0800a04c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800a04c:	2201      	movs	r2, #1
 800a04e:	4b01      	ldr	r3, [pc, #4]	; (800a054 <vTaskMissedYield+0x8>)
 800a050:	601a      	str	r2, [r3, #0]
 800a052:	4770      	bx	lr
 800a054:	20000aa0 	.word	0x20000aa0

0800a058 <pvTaskGetThreadLocalStoragePointer>:
		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
 800a058:	2902      	cmp	r1, #2
 800a05a:	dc07      	bgt.n	800a06c <pvTaskGetThreadLocalStoragePointer+0x14>
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800a05c:	b118      	cbz	r0, 800a066 <pvTaskGetThreadLocalStoragePointer+0xe>
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 800a05e:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 800a062:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800a064:	4770      	bx	lr
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800a066:	4b02      	ldr	r3, [pc, #8]	; (800a070 <pvTaskGetThreadLocalStoragePointer+0x18>)
 800a068:	6818      	ldr	r0, [r3, #0]
 800a06a:	e7f8      	b.n	800a05e <pvTaskGetThreadLocalStoragePointer+0x6>
			pvReturn = NULL;
 800a06c:	2000      	movs	r0, #0
	}
 800a06e:	4770      	bx	lr
 800a070:	20000974 	.word	0x20000974

0800a074 <vTaskGetInfo>:
	{
 800a074:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a078:	460c      	mov	r4, r1
 800a07a:	4617      	mov	r7, r2
 800a07c:	461e      	mov	r6, r3
		pxTCB = prvGetTCBFromHandle( xTask );
 800a07e:	4680      	mov	r8, r0
 800a080:	b1c8      	cbz	r0, 800a0b6 <vTaskGetInfo+0x42>
 800a082:	4605      	mov	r5, r0
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 800a084:	6025      	str	r5, [r4, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 800a086:	f105 0334 	add.w	r3, r5, #52	; 0x34
 800a08a:	6063      	str	r3, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 800a08c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a08e:	6123      	str	r3, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 800a090:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800a092:	61e3      	str	r3, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 800a094:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800a096:	60a3      	str	r3, [r4, #8]
			if( pxTaskStatus->eCurrentState == eSuspended )
 800a098:	7b23      	ldrb	r3, [r4, #12]
 800a09a:	2b03      	cmp	r3, #3
 800a09c:	d00e      	beq.n	800a0bc <vTaskGetInfo+0x48>
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 800a09e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800a0a0:	6163      	str	r3, [r4, #20]
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
 800a0a2:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800a0a4:	61a3      	str	r3, [r4, #24]
		if( eState != eInvalid )
 800a0a6:	2e05      	cmp	r6, #5
 800a0a8:	d011      	beq.n	800a0ce <vTaskGetInfo+0x5a>
			pxTaskStatus->eCurrentState = eState;
 800a0aa:	7326      	strb	r6, [r4, #12]
		if( xGetFreeStackSpace != pdFALSE )
 800a0ac:	b9a7      	cbnz	r7, 800a0d8 <vTaskGetInfo+0x64>
			pxTaskStatus->usStackHighWaterMark = 0;
 800a0ae:	2300      	movs	r3, #0
 800a0b0:	8423      	strh	r3, [r4, #32]
 800a0b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 800a0b6:	4b10      	ldr	r3, [pc, #64]	; (800a0f8 <vTaskGetInfo+0x84>)
 800a0b8:	681d      	ldr	r5, [r3, #0]
 800a0ba:	e7e3      	b.n	800a084 <vTaskGetInfo+0x10>
				vTaskSuspendAll();
 800a0bc:	f7ff fc78 	bl	80099b0 <vTaskSuspendAll>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800a0c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a0c2:	b10b      	cbz	r3, 800a0c8 <vTaskGetInfo+0x54>
						pxTaskStatus->eCurrentState = eBlocked;
 800a0c4:	2302      	movs	r3, #2
 800a0c6:	7323      	strb	r3, [r4, #12]
				( void ) xTaskResumeAll();
 800a0c8:	f7ff fd4c 	bl	8009b64 <xTaskResumeAll>
 800a0cc:	e7e7      	b.n	800a09e <vTaskGetInfo+0x2a>
			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
 800a0ce:	4640      	mov	r0, r8
 800a0d0:	f7ff fbf2 	bl	80098b8 <eTaskGetState>
 800a0d4:	7320      	strb	r0, [r4, #12]
 800a0d6:	e7e9      	b.n	800a0ac <vTaskGetInfo+0x38>
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 800a0d8:	6b28      	ldr	r0, [r5, #48]	; 0x30
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800a0da:	7803      	ldrb	r3, [r0, #0]
 800a0dc:	2ba5      	cmp	r3, #165	; 0xa5
 800a0de:	d109      	bne.n	800a0f4 <vTaskGetInfo+0x80>
 800a0e0:	1c43      	adds	r3, r0, #1
 800a0e2:	1a19      	subs	r1, r3, r0
 800a0e4:	f813 2b01 	ldrb.w	r2, [r3], #1
 800a0e8:	2aa5      	cmp	r2, #165	; 0xa5
 800a0ea:	d0fa      	beq.n	800a0e2 <vTaskGetInfo+0x6e>
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 800a0ec:	0889      	lsrs	r1, r1, #2
		return ( uint16_t ) ulCount;
 800a0ee:	8421      	strh	r1, [r4, #32]
 800a0f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t ulCount = 0U;
 800a0f4:	2100      	movs	r1, #0
 800a0f6:	e7f9      	b.n	800a0ec <vTaskGetInfo+0x78>
 800a0f8:	20000974 	.word	0x20000974

0800a0fc <prvListTasksWithinSingleList>:
	{
 800a0fc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800a100:	680f      	ldr	r7, [r1, #0]
 800a102:	b327      	cbz	r7, 800a14e <prvListTasksWithinSingleList+0x52>
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 800a104:	684b      	ldr	r3, [r1, #4]
 800a106:	685b      	ldr	r3, [r3, #4]
 800a108:	604b      	str	r3, [r1, #4]
 800a10a:	f101 0908 	add.w	r9, r1, #8
 800a10e:	454b      	cmp	r3, r9
 800a110:	bf04      	itt	eq
 800a112:	68cb      	ldreq	r3, [r1, #12]
 800a114:	604b      	streq	r3, [r1, #4]
 800a116:	4690      	mov	r8, r2
 800a118:	460c      	mov	r4, r1
 800a11a:	684b      	ldr	r3, [r1, #4]
 800a11c:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 800a120:	4605      	mov	r5, r0
	UBaseType_t uxTask = 0;
 800a122:	2700      	movs	r7, #0
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 800a124:	f04f 0a01 	mov.w	sl, #1
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 800a128:	6863      	ldr	r3, [r4, #4]
 800a12a:	685b      	ldr	r3, [r3, #4]
 800a12c:	6063      	str	r3, [r4, #4]
 800a12e:	4599      	cmp	r9, r3
 800a130:	bf04      	itt	eq
 800a132:	68e3      	ldreq	r3, [r4, #12]
 800a134:	6063      	streq	r3, [r4, #4]
 800a136:	6863      	ldr	r3, [r4, #4]
 800a138:	68de      	ldr	r6, [r3, #12]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 800a13a:	4643      	mov	r3, r8
 800a13c:	4652      	mov	r2, sl
 800a13e:	4629      	mov	r1, r5
 800a140:	4630      	mov	r0, r6
 800a142:	f7ff ff97 	bl	800a074 <vTaskGetInfo>
				uxTask++;
 800a146:	3701      	adds	r7, #1
 800a148:	3524      	adds	r5, #36	; 0x24
			} while( pxNextTCB != pxFirstTCB );
 800a14a:	45b3      	cmp	fp, r6
 800a14c:	d1ec      	bne.n	800a128 <prvListTasksWithinSingleList+0x2c>
	}
 800a14e:	4638      	mov	r0, r7
 800a150:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800a154 <uxTaskGetSystemState>:
	{
 800a154:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a158:	4607      	mov	r7, r0
 800a15a:	460c      	mov	r4, r1
 800a15c:	4616      	mov	r6, r2
		vTaskSuspendAll();
 800a15e:	f7ff fc27 	bl	80099b0 <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 800a162:	4b24      	ldr	r3, [pc, #144]	; (800a1f4 <uxTaskGetSystemState+0xa0>)
 800a164:	681b      	ldr	r3, [r3, #0]
 800a166:	42a3      	cmp	r3, r4
 800a168:	d842      	bhi.n	800a1f0 <uxTaskGetSystemState+0x9c>
 800a16a:	4b23      	ldr	r3, [pc, #140]	; (800a1f8 <uxTaskGetSystemState+0xa4>)
 800a16c:	f103 0578 	add.w	r5, r3, #120	; 0x78
 800a170:	f1a3 0814 	sub.w	r8, r3, #20
 800a174:	2400      	movs	r4, #0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 800a176:	f04f 0901 	mov.w	r9, #1
 800a17a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a17e:	464a      	mov	r2, r9
 800a180:	4629      	mov	r1, r5
 800a182:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a186:	f7ff ffb9 	bl	800a0fc <prvListTasksWithinSingleList>
 800a18a:	4404      	add	r4, r0
 800a18c:	3d14      	subs	r5, #20
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a18e:	4545      	cmp	r5, r8
 800a190:	d1f3      	bne.n	800a17a <uxTaskGetSystemState+0x26>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 800a192:	4b1a      	ldr	r3, [pc, #104]	; (800a1fc <uxTaskGetSystemState+0xa8>)
 800a194:	6819      	ldr	r1, [r3, #0]
 800a196:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a19a:	2202      	movs	r2, #2
 800a19c:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a1a0:	f7ff ffac 	bl	800a0fc <prvListTasksWithinSingleList>
 800a1a4:	4404      	add	r4, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800a1a6:	4b16      	ldr	r3, [pc, #88]	; (800a200 <uxTaskGetSystemState+0xac>)
 800a1a8:	6819      	ldr	r1, [r3, #0]
 800a1aa:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a1ae:	2202      	movs	r2, #2
 800a1b0:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a1b4:	f7ff ffa2 	bl	800a0fc <prvListTasksWithinSingleList>
 800a1b8:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 800a1ba:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a1be:	2204      	movs	r2, #4
 800a1c0:	4910      	ldr	r1, [pc, #64]	; (800a204 <uxTaskGetSystemState+0xb0>)
 800a1c2:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a1c6:	f7ff ff99 	bl	800a0fc <prvListTasksWithinSingleList>
 800a1ca:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 800a1cc:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a1d0:	2203      	movs	r2, #3
 800a1d2:	490d      	ldr	r1, [pc, #52]	; (800a208 <uxTaskGetSystemState+0xb4>)
 800a1d4:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a1d8:	f7ff ff90 	bl	800a0fc <prvListTasksWithinSingleList>
 800a1dc:	4404      	add	r4, r0
					if( pulTotalRunTime != NULL )
 800a1de:	b116      	cbz	r6, 800a1e6 <uxTaskGetSystemState+0x92>
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 800a1e0:	f001 fe9a 	bl	800bf18 <xGetRunTimeCounterValue>
 800a1e4:	6030      	str	r0, [r6, #0]
		( void ) xTaskResumeAll();
 800a1e6:	f7ff fcbd 	bl	8009b64 <xTaskResumeAll>
	}
 800a1ea:	4620      	mov	r0, r4
 800a1ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 800a1f0:	2400      	movs	r4, #0
 800a1f2:	e7f8      	b.n	800a1e6 <uxTaskGetSystemState+0x92>
 800a1f4:	20000a10 	.word	0x20000a10
 800a1f8:	20000980 	.word	0x20000980
 800a1fc:	20000978 	.word	0x20000978
 800a200:	2000097c 	.word	0x2000097c
 800a204:	20000a88 	.word	0x20000a88
 800a208:	20000a74 	.word	0x20000a74

0800a20c <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 800a20c:	4b01      	ldr	r3, [pc, #4]	; (800a214 <xTaskGetCurrentTaskHandle+0x8>)
 800a20e:	6818      	ldr	r0, [r3, #0]
	}
 800a210:	4770      	bx	lr
 800a212:	bf00      	nop
 800a214:	20000974 	.word	0x20000974

0800a218 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 800a218:	4b05      	ldr	r3, [pc, #20]	; (800a230 <xTaskGetSchedulerState+0x18>)
 800a21a:	681b      	ldr	r3, [r3, #0]
 800a21c:	b133      	cbz	r3, 800a22c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800a21e:	4b05      	ldr	r3, [pc, #20]	; (800a234 <xTaskGetSchedulerState+0x1c>)
 800a220:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
 800a222:	2b00      	cmp	r3, #0
 800a224:	bf0c      	ite	eq
 800a226:	2002      	moveq	r0, #2
 800a228:	2000      	movne	r0, #0
 800a22a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 800a22c:	2001      	movs	r0, #1
	}
 800a22e:	4770      	bx	lr
 800a230:	20000a70 	.word	0x20000a70
 800a234:	20000a1c 	.word	0x20000a1c

0800a238 <vTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 800a238:	2800      	cmp	r0, #0
 800a23a:	d044      	beq.n	800a2c6 <vTaskPriorityInherit+0x8e>
	{
 800a23c:	b538      	push	{r3, r4, r5, lr}
 800a23e:	4604      	mov	r4, r0
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800a240:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800a242:	4921      	ldr	r1, [pc, #132]	; (800a2c8 <vTaskPriorityInherit+0x90>)
 800a244:	6809      	ldr	r1, [r1, #0]
 800a246:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800a248:	428a      	cmp	r2, r1
 800a24a:	d214      	bcs.n	800a276 <vTaskPriorityInherit+0x3e>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800a24c:	6981      	ldr	r1, [r0, #24]
 800a24e:	2900      	cmp	r1, #0
 800a250:	db05      	blt.n	800a25e <vTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a252:	491d      	ldr	r1, [pc, #116]	; (800a2c8 <vTaskPriorityInherit+0x90>)
 800a254:	6809      	ldr	r1, [r1, #0]
 800a256:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800a258:	f1c1 0107 	rsb	r1, r1, #7
 800a25c:	6181      	str	r1, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800a25e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800a262:	491a      	ldr	r1, [pc, #104]	; (800a2cc <vTaskPriorityInherit+0x94>)
 800a264:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800a268:	6961      	ldr	r1, [r4, #20]
 800a26a:	4291      	cmp	r1, r2
 800a26c:	d004      	beq.n	800a278 <vTaskPriorityInherit+0x40>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800a26e:	4a16      	ldr	r2, [pc, #88]	; (800a2c8 <vTaskPriorityInherit+0x90>)
 800a270:	6812      	ldr	r2, [r2, #0]
 800a272:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a274:	62e2      	str	r2, [r4, #44]	; 0x2c
 800a276:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800a278:	1d25      	adds	r5, r4, #4
 800a27a:	4628      	mov	r0, r5
 800a27c:	f7fe fae4 	bl	8008848 <uxListRemove>
 800a280:	b970      	cbnz	r0, 800a2a0 <vTaskPriorityInherit+0x68>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800a282:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a284:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800a288:	4a10      	ldr	r2, [pc, #64]	; (800a2cc <vTaskPriorityInherit+0x94>)
 800a28a:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800a28e:	b93a      	cbnz	r2, 800a2a0 <vTaskPriorityInherit+0x68>
 800a290:	480f      	ldr	r0, [pc, #60]	; (800a2d0 <vTaskPriorityInherit+0x98>)
 800a292:	6802      	ldr	r2, [r0, #0]
 800a294:	2101      	movs	r1, #1
 800a296:	fa01 f303 	lsl.w	r3, r1, r3
 800a29a:	ea22 0303 	bic.w	r3, r2, r3
 800a29e:	6003      	str	r3, [r0, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800a2a0:	4b09      	ldr	r3, [pc, #36]	; (800a2c8 <vTaskPriorityInherit+0x90>)
 800a2a2:	681b      	ldr	r3, [r3, #0]
 800a2a4:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800a2a6:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 800a2a8:	4a09      	ldr	r2, [pc, #36]	; (800a2d0 <vTaskPriorityInherit+0x98>)
 800a2aa:	6811      	ldr	r1, [r2, #0]
 800a2ac:	2301      	movs	r3, #1
 800a2ae:	4083      	lsls	r3, r0
 800a2b0:	430b      	orrs	r3, r1
 800a2b2:	6013      	str	r3, [r2, #0]
 800a2b4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a2b8:	4629      	mov	r1, r5
 800a2ba:	4b04      	ldr	r3, [pc, #16]	; (800a2cc <vTaskPriorityInherit+0x94>)
 800a2bc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a2c0:	f7fe fa9c 	bl	80087fc <vListInsertEnd>
 800a2c4:	bd38      	pop	{r3, r4, r5, pc}
 800a2c6:	4770      	bx	lr
 800a2c8:	20000974 	.word	0x20000974
 800a2cc:	20000980 	.word	0x20000980
 800a2d0:	20000a24 	.word	0x20000a24

0800a2d4 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 800a2d4:	2800      	cmp	r0, #0
 800a2d6:	d046      	beq.n	800a366 <xTaskPriorityDisinherit+0x92>
	{
 800a2d8:	b538      	push	{r3, r4, r5, lr}
 800a2da:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 800a2dc:	4b24      	ldr	r3, [pc, #144]	; (800a370 <xTaskPriorityDisinherit+0x9c>)
 800a2de:	681b      	ldr	r3, [r3, #0]
 800a2e0:	4298      	cmp	r0, r3
 800a2e2:	d004      	beq.n	800a2ee <xTaskPriorityDisinherit+0x1a>
 800a2e4:	f640 61bf 	movw	r1, #3775	; 0xebf
 800a2e8:	4822      	ldr	r0, [pc, #136]	; (800a374 <xTaskPriorityDisinherit+0xa0>)
 800a2ea:	f001 fd0f 	bl	800bd0c <vAssertCalled>
			configASSERT( pxTCB->uxMutexesHeld );
 800a2ee:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800a2f0:	b14b      	cbz	r3, 800a306 <xTaskPriorityDisinherit+0x32>
			( pxTCB->uxMutexesHeld )--;
 800a2f2:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800a2f4:	3b01      	subs	r3, #1
 800a2f6:	6523      	str	r3, [r4, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800a2f8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800a2fa:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800a2fc:	4291      	cmp	r1, r2
 800a2fe:	d034      	beq.n	800a36a <xTaskPriorityDisinherit+0x96>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800a300:	b13b      	cbz	r3, 800a312 <xTaskPriorityDisinherit+0x3e>
	BaseType_t xReturn = pdFALSE;
 800a302:	2000      	movs	r0, #0
	}
 800a304:	bd38      	pop	{r3, r4, r5, pc}
			configASSERT( pxTCB->uxMutexesHeld );
 800a306:	f640 61c1 	movw	r1, #3777	; 0xec1
 800a30a:	481a      	ldr	r0, [pc, #104]	; (800a374 <xTaskPriorityDisinherit+0xa0>)
 800a30c:	f001 fcfe 	bl	800bd0c <vAssertCalled>
 800a310:	e7ef      	b.n	800a2f2 <xTaskPriorityDisinherit+0x1e>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800a312:	1d25      	adds	r5, r4, #4
 800a314:	4628      	mov	r0, r5
 800a316:	f7fe fa97 	bl	8008848 <uxListRemove>
 800a31a:	b970      	cbnz	r0, 800a33a <xTaskPriorityDisinherit+0x66>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800a31c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a31e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800a322:	4a15      	ldr	r2, [pc, #84]	; (800a378 <xTaskPriorityDisinherit+0xa4>)
 800a324:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800a328:	b93a      	cbnz	r2, 800a33a <xTaskPriorityDisinherit+0x66>
 800a32a:	4814      	ldr	r0, [pc, #80]	; (800a37c <xTaskPriorityDisinherit+0xa8>)
 800a32c:	6802      	ldr	r2, [r0, #0]
 800a32e:	2101      	movs	r1, #1
 800a330:	fa01 f303 	lsl.w	r3, r1, r3
 800a334:	ea22 0303 	bic.w	r3, r2, r3
 800a338:	6003      	str	r3, [r0, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800a33a:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800a33c:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a33e:	f1c0 0307 	rsb	r3, r0, #7
 800a342:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 800a344:	4a0d      	ldr	r2, [pc, #52]	; (800a37c <xTaskPriorityDisinherit+0xa8>)
 800a346:	6811      	ldr	r1, [r2, #0]
 800a348:	2401      	movs	r4, #1
 800a34a:	fa04 f300 	lsl.w	r3, r4, r0
 800a34e:	430b      	orrs	r3, r1
 800a350:	6013      	str	r3, [r2, #0]
 800a352:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a356:	4629      	mov	r1, r5
 800a358:	4b07      	ldr	r3, [pc, #28]	; (800a378 <xTaskPriorityDisinherit+0xa4>)
 800a35a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a35e:	f7fe fa4d 	bl	80087fc <vListInsertEnd>
					xReturn = pdTRUE;
 800a362:	4620      	mov	r0, r4
 800a364:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
 800a366:	2000      	movs	r0, #0
 800a368:	4770      	bx	lr
 800a36a:	2000      	movs	r0, #0
 800a36c:	bd38      	pop	{r3, r4, r5, pc}
 800a36e:	bf00      	nop
 800a370:	20000974 	.word	0x20000974
 800a374:	0800ca1c 	.word	0x0800ca1c
 800a378:	20000980 	.word	0x20000980
 800a37c:	20000a24 	.word	0x20000a24

0800a380 <vTaskList>:
	{
 800a380:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a384:	b085      	sub	sp, #20
 800a386:	4605      	mov	r5, r0
		*pcWriteBuffer = 0x00;
 800a388:	2300      	movs	r3, #0
 800a38a:	7003      	strb	r3, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 800a38c:	4b36      	ldr	r3, [pc, #216]	; (800a468 <vTaskList+0xe8>)
 800a38e:	681a      	ldr	r2, [r3, #0]
 800a390:	9203      	str	r2, [sp, #12]
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
 800a392:	6818      	ldr	r0, [r3, #0]
 800a394:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800a398:	0080      	lsls	r0, r0, #2
 800a39a:	f7fe fc35 	bl	8008c08 <pvPortMalloc>
		if( pxTaskStatusArray != NULL )
 800a39e:	2800      	cmp	r0, #0
 800a3a0:	d05f      	beq.n	800a462 <vTaskList+0xe2>
 800a3a2:	4604      	mov	r4, r0
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
 800a3a4:	9903      	ldr	r1, [sp, #12]
 800a3a6:	2200      	movs	r2, #0
 800a3a8:	f7ff fed4 	bl	800a154 <uxTaskGetSystemState>
 800a3ac:	9003      	str	r0, [sp, #12]
			for( x = 0; x < uxArraySize; x++ )
 800a3ae:	2300      	movs	r3, #0
 800a3b0:	9302      	str	r3, [sp, #8]
 800a3b2:	9a02      	ldr	r2, [sp, #8]
 800a3b4:	9b03      	ldr	r3, [sp, #12]
 800a3b6:	429a      	cmp	r2, r3
 800a3b8:	d250      	bcs.n	800a45c <vTaskList+0xdc>
					case eBlocked:		cStatus = tskBLOCKED_CHAR;
 800a3ba:	f04f 0942 	mov.w	r9, #66	; 0x42
					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
 800a3be:	f04f 0853 	mov.w	r8, #83	; 0x53
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
 800a3c2:	4f2a      	ldr	r7, [pc, #168]	; (800a46c <vTaskList+0xec>)
 800a3c4:	e035      	b.n	800a432 <vTaskList+0xb2>
					case eBlocked:		cStatus = tskBLOCKED_CHAR;
 800a3c6:	464e      	mov	r6, r9
 800a3c8:	e006      	b.n	800a3d8 <vTaskList+0x58>
					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
 800a3ca:	4646      	mov	r6, r8
										break;
 800a3cc:	e004      	b.n	800a3d8 <vTaskList+0x58>
					case eDeleted:		cStatus = tskDELETED_CHAR;
 800a3ce:	2644      	movs	r6, #68	; 0x44
										break;
 800a3d0:	e002      	b.n	800a3d8 <vTaskList+0x58>
										cStatus = 0x00;
 800a3d2:	2600      	movs	r6, #0
										break;
 800a3d4:	e000      	b.n	800a3d8 <vTaskList+0x58>
					case eReady:		cStatus = tskREADY_CHAR;
 800a3d6:	2652      	movs	r6, #82	; 0x52
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 800a3d8:	9b02      	ldr	r3, [sp, #8]
 800a3da:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a3de:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800a3e2:	6859      	ldr	r1, [r3, #4]
 800a3e4:	4628      	mov	r0, r5
 800a3e6:	f7ff f8f7 	bl	80095d8 <prvWriteNameToBuffer>
 800a3ea:	4605      	mov	r5, r0
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
 800a3ec:	9b02      	ldr	r3, [sp, #8]
 800a3ee:	9a02      	ldr	r2, [sp, #8]
 800a3f0:	9902      	ldr	r1, [sp, #8]
 800a3f2:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a3f6:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800a3fa:	691b      	ldr	r3, [r3, #16]
 800a3fc:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 800a400:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800a404:	6889      	ldr	r1, [r1, #8]
 800a406:	9101      	str	r1, [sp, #4]
 800a408:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 800a40c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800a410:	8c12      	ldrh	r2, [r2, #32]
 800a412:	9200      	str	r2, [sp, #0]
 800a414:	4632      	mov	r2, r6
 800a416:	4639      	mov	r1, r7
 800a418:	f001 f9c1 	bl	800b79e <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer );
 800a41c:	4628      	mov	r0, r5
 800a41e:	f7f5 fed7 	bl	80001d0 <strlen>
 800a422:	4405      	add	r5, r0
			for( x = 0; x < uxArraySize; x++ )
 800a424:	9b02      	ldr	r3, [sp, #8]
 800a426:	3301      	adds	r3, #1
 800a428:	9302      	str	r3, [sp, #8]
 800a42a:	9a02      	ldr	r2, [sp, #8]
 800a42c:	9b03      	ldr	r3, [sp, #12]
 800a42e:	429a      	cmp	r2, r3
 800a430:	d214      	bcs.n	800a45c <vTaskList+0xdc>
				switch( pxTaskStatusArray[ x ].eCurrentState )
 800a432:	9b02      	ldr	r3, [sp, #8]
 800a434:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a438:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800a43c:	7b1b      	ldrb	r3, [r3, #12]
 800a43e:	3b01      	subs	r3, #1
 800a440:	2b03      	cmp	r3, #3
 800a442:	d8c6      	bhi.n	800a3d2 <vTaskList+0x52>
 800a444:	a201      	add	r2, pc, #4	; (adr r2, 800a44c <vTaskList+0xcc>)
 800a446:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a44a:	bf00      	nop
 800a44c:	0800a3d7 	.word	0x0800a3d7
 800a450:	0800a3c7 	.word	0x0800a3c7
 800a454:	0800a3cb 	.word	0x0800a3cb
 800a458:	0800a3cf 	.word	0x0800a3cf
			vPortFree( pxTaskStatusArray );
 800a45c:	4620      	mov	r0, r4
 800a45e:	f7fe fc39 	bl	8008cd4 <vPortFree>
	}
 800a462:	b005      	add	sp, #20
 800a464:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a468:	20000a10 	.word	0x20000a10
 800a46c:	0800ca58 	.word	0x0800ca58

0800a470 <vTaskGetRunTimeStats>:
	{
 800a470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a474:	b084      	sub	sp, #16
 800a476:	4604      	mov	r4, r0
		*pcWriteBuffer = 0x00;
 800a478:	2300      	movs	r3, #0
 800a47a:	7003      	strb	r3, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 800a47c:	4b2e      	ldr	r3, [pc, #184]	; (800a538 <vTaskGetRunTimeStats+0xc8>)
 800a47e:	681a      	ldr	r2, [r3, #0]
 800a480:	9203      	str	r2, [sp, #12]
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
 800a482:	6818      	ldr	r0, [r3, #0]
 800a484:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800a488:	0080      	lsls	r0, r0, #2
 800a48a:	f7fe fbbd 	bl	8008c08 <pvPortMalloc>
		if( pxTaskStatusArray != NULL )
 800a48e:	2800      	cmp	r0, #0
 800a490:	d04e      	beq.n	800a530 <vTaskGetRunTimeStats+0xc0>
 800a492:	4605      	mov	r5, r0
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
 800a494:	9903      	ldr	r1, [sp, #12]
 800a496:	aa01      	add	r2, sp, #4
 800a498:	f7ff fe5c 	bl	800a154 <uxTaskGetSystemState>
 800a49c:	9003      	str	r0, [sp, #12]
			ulTotalTime /= 100UL;
 800a49e:	4a27      	ldr	r2, [pc, #156]	; (800a53c <vTaskGetRunTimeStats+0xcc>)
 800a4a0:	9b01      	ldr	r3, [sp, #4]
 800a4a2:	fba2 2303 	umull	r2, r3, r2, r3
 800a4a6:	095b      	lsrs	r3, r3, #5
 800a4a8:	9301      	str	r3, [sp, #4]
			if( ulTotalTime > 0 )
 800a4aa:	2b00      	cmp	r3, #0
 800a4ac:	d03d      	beq.n	800a52a <vTaskGetRunTimeStats+0xba>
				for( x = 0; x < uxArraySize; x++ )
 800a4ae:	2300      	movs	r3, #0
 800a4b0:	9302      	str	r3, [sp, #8]
 800a4b2:	9a02      	ldr	r2, [sp, #8]
 800a4b4:	9b03      	ldr	r3, [sp, #12]
 800a4b6:	429a      	cmp	r2, r3
 800a4b8:	d237      	bcs.n	800a52a <vTaskGetRunTimeStats+0xba>
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
 800a4ba:	4f21      	ldr	r7, [pc, #132]	; (800a540 <vTaskGetRunTimeStats+0xd0>)
							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
 800a4bc:	f8df 8084 	ldr.w	r8, [pc, #132]	; 800a544 <vTaskGetRunTimeStats+0xd4>
 800a4c0:	e013      	b.n	800a4ea <vTaskGetRunTimeStats+0x7a>
 800a4c2:	9b02      	ldr	r3, [sp, #8]
 800a4c4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a4c8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800a4cc:	699a      	ldr	r2, [r3, #24]
 800a4ce:	4641      	mov	r1, r8
 800a4d0:	f001 f965 	bl	800b79e <sprintf>
					pcWriteBuffer += strlen( pcWriteBuffer );
 800a4d4:	4620      	mov	r0, r4
 800a4d6:	f7f5 fe7b 	bl	80001d0 <strlen>
 800a4da:	4404      	add	r4, r0
				for( x = 0; x < uxArraySize; x++ )
 800a4dc:	9b02      	ldr	r3, [sp, #8]
 800a4de:	3301      	adds	r3, #1
 800a4e0:	9302      	str	r3, [sp, #8]
 800a4e2:	9a02      	ldr	r2, [sp, #8]
 800a4e4:	9b03      	ldr	r3, [sp, #12]
 800a4e6:	429a      	cmp	r2, r3
 800a4e8:	d21f      	bcs.n	800a52a <vTaskGetRunTimeStats+0xba>
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
 800a4ea:	9b02      	ldr	r3, [sp, #8]
 800a4ec:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a4f0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800a4f4:	699e      	ldr	r6, [r3, #24]
 800a4f6:	9b01      	ldr	r3, [sp, #4]
 800a4f8:	fbb6 f6f3 	udiv	r6, r6, r3
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 800a4fc:	9b02      	ldr	r3, [sp, #8]
 800a4fe:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a502:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800a506:	6859      	ldr	r1, [r3, #4]
 800a508:	4620      	mov	r0, r4
 800a50a:	f7ff f865 	bl	80095d8 <prvWriteNameToBuffer>
 800a50e:	4604      	mov	r4, r0
					if( ulStatsAsPercentage > 0UL )
 800a510:	2e00      	cmp	r6, #0
 800a512:	d0d6      	beq.n	800a4c2 <vTaskGetRunTimeStats+0x52>
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
 800a514:	9b02      	ldr	r3, [sp, #8]
 800a516:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800a51a:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 800a51e:	4633      	mov	r3, r6
 800a520:	6992      	ldr	r2, [r2, #24]
 800a522:	4639      	mov	r1, r7
 800a524:	f001 f93b 	bl	800b79e <sprintf>
 800a528:	e7d4      	b.n	800a4d4 <vTaskGetRunTimeStats+0x64>
			vPortFree( pxTaskStatusArray );
 800a52a:	4628      	mov	r0, r5
 800a52c:	f7fe fbd2 	bl	8008cd4 <vPortFree>
	}
 800a530:	b004      	add	sp, #16
 800a532:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a536:	bf00      	nop
 800a538:	20000a10 	.word	0x20000a10
 800a53c:	51eb851f 	.word	0x51eb851f
 800a540:	0800ca40 	.word	0x0800ca40
 800a544:	0800ca4c 	.word	0x0800ca4c

0800a548 <uxTaskResetEventItemValue>:
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 800a548:	4b04      	ldr	r3, [pc, #16]	; (800a55c <uxTaskResetEventItemValue+0x14>)
 800a54a:	681a      	ldr	r2, [r3, #0]
 800a54c:	6990      	ldr	r0, [r2, #24]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a54e:	681a      	ldr	r2, [r3, #0]
 800a550:	681b      	ldr	r3, [r3, #0]
 800a552:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a554:	f1c3 0307 	rsb	r3, r3, #7
 800a558:	6193      	str	r3, [r2, #24]
}
 800a55a:	4770      	bx	lr
 800a55c:	20000974 	.word	0x20000974

0800a560 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 800a560:	4b05      	ldr	r3, [pc, #20]	; (800a578 <pvTaskIncrementMutexHeldCount+0x18>)
 800a562:	681b      	ldr	r3, [r3, #0]
 800a564:	b123      	cbz	r3, 800a570 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 800a566:	4b04      	ldr	r3, [pc, #16]	; (800a578 <pvTaskIncrementMutexHeldCount+0x18>)
 800a568:	681a      	ldr	r2, [r3, #0]
 800a56a:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800a56c:	3301      	adds	r3, #1
 800a56e:	6513      	str	r3, [r2, #80]	; 0x50
		return pxCurrentTCB;
 800a570:	4b01      	ldr	r3, [pc, #4]	; (800a578 <pvTaskIncrementMutexHeldCount+0x18>)
 800a572:	6818      	ldr	r0, [r3, #0]
	}
 800a574:	4770      	bx	lr
 800a576:	bf00      	nop
 800a578:	20000974 	.word	0x20000974

0800a57c <ulTaskNotifyTake>:
	{
 800a57c:	b538      	push	{r3, r4, r5, lr}
 800a57e:	4605      	mov	r5, r0
 800a580:	460c      	mov	r4, r1
		taskENTER_CRITICAL();
 800a582:	f7fe f9b7 	bl	80088f4 <vPortEnterCritical>
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 800a586:	4b19      	ldr	r3, [pc, #100]	; (800a5ec <ulTaskNotifyTake+0x70>)
 800a588:	681b      	ldr	r3, [r3, #0]
 800a58a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a58c:	b92b      	cbnz	r3, 800a59a <ulTaskNotifyTake+0x1e>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 800a58e:	4b17      	ldr	r3, [pc, #92]	; (800a5ec <ulTaskNotifyTake+0x70>)
 800a590:	681b      	ldr	r3, [r3, #0]
 800a592:	2201      	movs	r2, #1
 800a594:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
				if( xTicksToWait > ( TickType_t ) 0 )
 800a598:	b9ac      	cbnz	r4, 800a5c6 <ulTaskNotifyTake+0x4a>
		taskEXIT_CRITICAL();
 800a59a:	f7fe f9cd 	bl	8008938 <vPortExitCritical>
		taskENTER_CRITICAL();
 800a59e:	f7fe f9a9 	bl	80088f4 <vPortEnterCritical>
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 800a5a2:	4b12      	ldr	r3, [pc, #72]	; (800a5ec <ulTaskNotifyTake+0x70>)
 800a5a4:	681b      	ldr	r3, [r3, #0]
 800a5a6:	6e5c      	ldr	r4, [r3, #100]	; 0x64
			if( ulReturn != 0UL )
 800a5a8:	b124      	cbz	r4, 800a5b4 <ulTaskNotifyTake+0x38>
				if( xClearCountOnExit != pdFALSE )
 800a5aa:	b9cd      	cbnz	r5, 800a5e0 <ulTaskNotifyTake+0x64>
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 800a5ac:	4b0f      	ldr	r3, [pc, #60]	; (800a5ec <ulTaskNotifyTake+0x70>)
 800a5ae:	681b      	ldr	r3, [r3, #0]
 800a5b0:	1e62      	subs	r2, r4, #1
 800a5b2:	665a      	str	r2, [r3, #100]	; 0x64
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800a5b4:	4b0d      	ldr	r3, [pc, #52]	; (800a5ec <ulTaskNotifyTake+0x70>)
 800a5b6:	681b      	ldr	r3, [r3, #0]
 800a5b8:	2200      	movs	r2, #0
 800a5ba:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		taskEXIT_CRITICAL();
 800a5be:	f7fe f9bb 	bl	8008938 <vPortExitCritical>
	}
 800a5c2:	4620      	mov	r0, r4
 800a5c4:	bd38      	pop	{r3, r4, r5, pc}
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800a5c6:	4611      	mov	r1, r2
 800a5c8:	4620      	mov	r0, r4
 800a5ca:	f7fe ffb9 	bl	8009540 <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 800a5ce:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a5d2:	4b07      	ldr	r3, [pc, #28]	; (800a5f0 <ulTaskNotifyTake+0x74>)
 800a5d4:	601a      	str	r2, [r3, #0]
 800a5d6:	f3bf 8f4f 	dsb	sy
 800a5da:	f3bf 8f6f 	isb	sy
 800a5de:	e7dc      	b.n	800a59a <ulTaskNotifyTake+0x1e>
					pxCurrentTCB->ulNotifiedValue = 0UL;
 800a5e0:	4b02      	ldr	r3, [pc, #8]	; (800a5ec <ulTaskNotifyTake+0x70>)
 800a5e2:	681b      	ldr	r3, [r3, #0]
 800a5e4:	2200      	movs	r2, #0
 800a5e6:	665a      	str	r2, [r3, #100]	; 0x64
 800a5e8:	e7e4      	b.n	800a5b4 <ulTaskNotifyTake+0x38>
 800a5ea:	bf00      	nop
 800a5ec:	20000974 	.word	0x20000974
 800a5f0:	e000ed04 	.word	0xe000ed04

0800a5f4 <xTaskGenericNotify>:
	{
 800a5f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a5f6:	460f      	mov	r7, r1
 800a5f8:	4615      	mov	r5, r2
 800a5fa:	461e      	mov	r6, r3
		configASSERT( xTaskToNotify );
 800a5fc:	4604      	mov	r4, r0
 800a5fe:	b188      	cbz	r0, 800a624 <xTaskGenericNotify+0x30>
		taskENTER_CRITICAL();
 800a600:	f7fe f978 	bl	80088f4 <vPortEnterCritical>
			if( pulPreviousNotificationValue != NULL )
 800a604:	b10e      	cbz	r6, 800a60a <xTaskGenericNotify+0x16>
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 800a606:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a608:	6033      	str	r3, [r6, #0]
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800a60a:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800a60e:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800a610:	2202      	movs	r2, #2
 800a612:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			switch( eAction )
 800a616:	1e6a      	subs	r2, r5, #1
 800a618:	2a03      	cmp	r2, #3
 800a61a:	d80c      	bhi.n	800a636 <xTaskGenericNotify+0x42>
 800a61c:	e8df f002 	tbb	[pc, r2]
 800a620:	18161208 	.word	0x18161208
		configASSERT( xTaskToNotify );
 800a624:	f241 01f5 	movw	r1, #4341	; 0x10f5
 800a628:	4822      	ldr	r0, [pc, #136]	; (800a6b4 <xTaskGenericNotify+0xc0>)
 800a62a:	f001 fb6f 	bl	800bd0c <vAssertCalled>
 800a62e:	e7e7      	b.n	800a600 <xTaskGenericNotify+0xc>
					pxTCB->ulNotifiedValue |= ulValue;
 800a630:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800a632:	4317      	orrs	r7, r2
 800a634:	6667      	str	r7, [r4, #100]	; 0x64
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800a636:	2b01      	cmp	r3, #1
 800a638:	d00e      	beq.n	800a658 <xTaskGenericNotify+0x64>
 800a63a:	2401      	movs	r4, #1
		taskEXIT_CRITICAL();
 800a63c:	f7fe f97c 	bl	8008938 <vPortExitCritical>
	}
 800a640:	4620      	mov	r0, r4
 800a642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					( pxTCB->ulNotifiedValue )++;
 800a644:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800a646:	3201      	adds	r2, #1
 800a648:	6662      	str	r2, [r4, #100]	; 0x64
					break;
 800a64a:	e7f4      	b.n	800a636 <xTaskGenericNotify+0x42>
					pxTCB->ulNotifiedValue = ulValue;
 800a64c:	6667      	str	r7, [r4, #100]	; 0x64
					break;
 800a64e:	e7f2      	b.n	800a636 <xTaskGenericNotify+0x42>
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 800a650:	2b02      	cmp	r3, #2
 800a652:	d02b      	beq.n	800a6ac <xTaskGenericNotify+0xb8>
						pxTCB->ulNotifiedValue = ulValue;
 800a654:	6667      	str	r7, [r4, #100]	; 0x64
 800a656:	e7ee      	b.n	800a636 <xTaskGenericNotify+0x42>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800a658:	1d25      	adds	r5, r4, #4
 800a65a:	4628      	mov	r0, r5
 800a65c:	f7fe f8f4 	bl	8008848 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 800a660:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a662:	4a15      	ldr	r2, [pc, #84]	; (800a6b8 <xTaskGenericNotify+0xc4>)
 800a664:	6811      	ldr	r1, [r2, #0]
 800a666:	2301      	movs	r3, #1
 800a668:	4083      	lsls	r3, r0
 800a66a:	430b      	orrs	r3, r1
 800a66c:	6013      	str	r3, [r2, #0]
 800a66e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a672:	4629      	mov	r1, r5
 800a674:	4b11      	ldr	r3, [pc, #68]	; (800a6bc <xTaskGenericNotify+0xc8>)
 800a676:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a67a:	f7fe f8bf 	bl	80087fc <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800a67e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a680:	b123      	cbz	r3, 800a68c <xTaskGenericNotify+0x98>
 800a682:	f241 112d 	movw	r1, #4397	; 0x112d
 800a686:	480b      	ldr	r0, [pc, #44]	; (800a6b4 <xTaskGenericNotify+0xc0>)
 800a688:	f001 fb40 	bl	800bd0c <vAssertCalled>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800a68c:	4b0c      	ldr	r3, [pc, #48]	; (800a6c0 <xTaskGenericNotify+0xcc>)
 800a68e:	681b      	ldr	r3, [r3, #0]
 800a690:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a692:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a694:	429a      	cmp	r2, r3
 800a696:	d90b      	bls.n	800a6b0 <xTaskGenericNotify+0xbc>
					taskYIELD_IF_USING_PREEMPTION();
 800a698:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a69c:	4b09      	ldr	r3, [pc, #36]	; (800a6c4 <xTaskGenericNotify+0xd0>)
 800a69e:	601a      	str	r2, [r3, #0]
 800a6a0:	f3bf 8f4f 	dsb	sy
 800a6a4:	f3bf 8f6f 	isb	sy
 800a6a8:	2401      	movs	r4, #1
 800a6aa:	e7c7      	b.n	800a63c <xTaskGenericNotify+0x48>
						xReturn = pdFAIL;
 800a6ac:	2400      	movs	r4, #0
 800a6ae:	e7c5      	b.n	800a63c <xTaskGenericNotify+0x48>
 800a6b0:	2401      	movs	r4, #1
 800a6b2:	e7c3      	b.n	800a63c <xTaskGenericNotify+0x48>
 800a6b4:	0800ca1c 	.word	0x0800ca1c
 800a6b8:	20000a24 	.word	0x20000a24
 800a6bc:	20000980 	.word	0x20000980
 800a6c0:	20000974 	.word	0x20000974
 800a6c4:	e000ed04 	.word	0xe000ed04

0800a6c8 <vTaskNotifyGiveFromISR>:
	{
 800a6c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a6ca:	460e      	mov	r6, r1
		configASSERT( xTaskToNotify );
 800a6cc:	4604      	mov	r4, r0
 800a6ce:	b1c8      	cbz	r0, 800a704 <vTaskNotifyGiveFromISR+0x3c>
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800a6d0:	f7fe fa42 	bl	8008b58 <vPortValidateInterruptPriority>
	__asm volatile
 800a6d4:	f3ef 8511 	mrs	r5, BASEPRI
 800a6d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a6dc:	f383 8811 	msr	BASEPRI, r3
 800a6e0:	f3bf 8f6f 	isb	sy
 800a6e4:	f3bf 8f4f 	dsb	sy
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800a6e8:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800a6ec:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800a6ee:	2202      	movs	r2, #2
 800a6f0:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			( pxTCB->ulNotifiedValue )++;
 800a6f4:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800a6f6:	3201      	adds	r2, #1
 800a6f8:	6662      	str	r2, [r4, #100]	; 0x64
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800a6fa:	2b01      	cmp	r3, #1
 800a6fc:	d008      	beq.n	800a710 <vTaskNotifyGiveFromISR+0x48>
	__asm volatile
 800a6fe:	f385 8811 	msr	BASEPRI, r5
 800a702:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		configASSERT( xTaskToNotify );
 800a704:	f241 11db 	movw	r1, #4571	; 0x11db
 800a708:	481a      	ldr	r0, [pc, #104]	; (800a774 <vTaskNotifyGiveFromISR+0xac>)
 800a70a:	f001 faff 	bl	800bd0c <vAssertCalled>
 800a70e:	e7df      	b.n	800a6d0 <vTaskNotifyGiveFromISR+0x8>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800a710:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a712:	b123      	cbz	r3, 800a71e <vTaskNotifyGiveFromISR+0x56>
 800a714:	f241 2101 	movw	r1, #4609	; 0x1201
 800a718:	4816      	ldr	r0, [pc, #88]	; (800a774 <vTaskNotifyGiveFromISR+0xac>)
 800a71a:	f001 faf7 	bl	800bd0c <vAssertCalled>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800a71e:	4b16      	ldr	r3, [pc, #88]	; (800a778 <vTaskNotifyGiveFromISR+0xb0>)
 800a720:	681b      	ldr	r3, [r3, #0]
 800a722:	b9e3      	cbnz	r3, 800a75e <vTaskNotifyGiveFromISR+0x96>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800a724:	1d27      	adds	r7, r4, #4
 800a726:	4638      	mov	r0, r7
 800a728:	f7fe f88e 	bl	8008848 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800a72c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a72e:	4a13      	ldr	r2, [pc, #76]	; (800a77c <vTaskNotifyGiveFromISR+0xb4>)
 800a730:	6811      	ldr	r1, [r2, #0]
 800a732:	2301      	movs	r3, #1
 800a734:	4083      	lsls	r3, r0
 800a736:	430b      	orrs	r3, r1
 800a738:	6013      	str	r3, [r2, #0]
 800a73a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a73e:	4639      	mov	r1, r7
 800a740:	4b0f      	ldr	r3, [pc, #60]	; (800a780 <vTaskNotifyGiveFromISR+0xb8>)
 800a742:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a746:	f7fe f859 	bl	80087fc <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800a74a:	4b0e      	ldr	r3, [pc, #56]	; (800a784 <vTaskNotifyGiveFromISR+0xbc>)
 800a74c:	681b      	ldr	r3, [r3, #0]
 800a74e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a750:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a752:	429a      	cmp	r2, r3
 800a754:	d9d3      	bls.n	800a6fe <vTaskNotifyGiveFromISR+0x36>
					if( pxHigherPriorityTaskWoken != NULL )
 800a756:	b146      	cbz	r6, 800a76a <vTaskNotifyGiveFromISR+0xa2>
						*pxHigherPriorityTaskWoken = pdTRUE;
 800a758:	2301      	movs	r3, #1
 800a75a:	6033      	str	r3, [r6, #0]
 800a75c:	e7cf      	b.n	800a6fe <vTaskNotifyGiveFromISR+0x36>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800a75e:	f104 0118 	add.w	r1, r4, #24
 800a762:	4809      	ldr	r0, [pc, #36]	; (800a788 <vTaskNotifyGiveFromISR+0xc0>)
 800a764:	f7fe f84a 	bl	80087fc <vListInsertEnd>
 800a768:	e7ef      	b.n	800a74a <vTaskNotifyGiveFromISR+0x82>
						xYieldPending = pdTRUE;
 800a76a:	2201      	movs	r2, #1
 800a76c:	4b07      	ldr	r3, [pc, #28]	; (800a78c <vTaskNotifyGiveFromISR+0xc4>)
 800a76e:	601a      	str	r2, [r3, #0]
 800a770:	e7c5      	b.n	800a6fe <vTaskNotifyGiveFromISR+0x36>
 800a772:	bf00      	nop
 800a774:	0800ca1c 	.word	0x0800ca1c
 800a778:	20000a1c 	.word	0x20000a1c
 800a77c:	20000a24 	.word	0x20000a24
 800a780:	20000980 	.word	0x20000980
 800a784:	20000974 	.word	0x20000974
 800a788:	20000a5c 	.word	0x20000a5c
 800a78c:	20000aa0 	.word	0x20000aa0

0800a790 <prvQueryHeapCommand>:
/*-----------------------------------------------------------*/

#if( configINCLUDE_QUERY_HEAP_COMMAND == 1 )

	static BaseType_t prvQueryHeapCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
	{
 800a790:	b538      	push	{r3, r4, r5, lr}
		/* Remove compile time warnings about unused parameters, and check the
		write buffer is not NULL.  NOTE - for simplicity, this example assumes the
		write buffer length is adequate, so does not check for buffer overflows. */
		( void ) pcCommandString;
		( void ) xWriteBufferLen;
		configASSERT( pcWriteBuffer );
 800a792:	4604      	mov	r4, r0
 800a794:	b160      	cbz	r0, 800a7b0 <prvQueryHeapCommand+0x20>

		sprintf( pcWriteBuffer, "Current free heap %d bytes, minimum ever free heap %d bytes\r\n", ( int ) xPortGetFreeHeapSize(), ( int ) xPortGetMinimumEverFreeHeapSize() );
 800a796:	f7fe fae7 	bl	8008d68 <xPortGetFreeHeapSize>
 800a79a:	4605      	mov	r5, r0
 800a79c:	f7fe faea 	bl	8008d74 <xPortGetMinimumEverFreeHeapSize>
 800a7a0:	4603      	mov	r3, r0
 800a7a2:	462a      	mov	r2, r5
 800a7a4:	4905      	ldr	r1, [pc, #20]	; (800a7bc <prvQueryHeapCommand+0x2c>)
 800a7a6:	4620      	mov	r0, r4
 800a7a8:	f000 fff9 	bl	800b79e <sprintf>

		/* There is no more data to return after this single string, so return
		pdFALSE. */
		return pdFALSE;
	}
 800a7ac:	2000      	movs	r0, #0
 800a7ae:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pcWriteBuffer );
 800a7b0:	f44f 7194 	mov.w	r1, #296	; 0x128
 800a7b4:	4802      	ldr	r0, [pc, #8]	; (800a7c0 <prvQueryHeapCommand+0x30>)
 800a7b6:	f001 faa9 	bl	800bd0c <vAssertCalled>
 800a7ba:	e7ec      	b.n	800a796 <prvQueryHeapCommand+0x6>
 800a7bc:	0800cacc 	.word	0x0800cacc
 800a7c0:	0800ca90 	.word	0x0800ca90

0800a7c4 <prvRunTimeStatsCommand>:
/*-----------------------------------------------------------*/

#if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static BaseType_t prvRunTimeStatsCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
	{
 800a7c4:	b510      	push	{r4, lr}
		/* Remove compile time warnings about unused parameters, and check the
		write buffer is not NULL.  NOTE - for simplicity, this example assumes the
		write buffer length is adequate, so does not check for buffer overflows. */
		( void ) pcCommandString;
		( void ) xWriteBufferLen;
		configASSERT( pcWriteBuffer );
 800a7c6:	4604      	mov	r4, r0
 800a7c8:	b150      	cbz	r0, 800a7e0 <prvRunTimeStatsCommand+0x1c>

		/* Generate a table of task stats. */
		strcpy( pcWriteBuffer, pcHeader );
 800a7ca:	2251      	movs	r2, #81	; 0x51
 800a7cc:	4907      	ldr	r1, [pc, #28]	; (800a7ec <prvRunTimeStatsCommand+0x28>)
 800a7ce:	4620      	mov	r0, r4
 800a7d0:	f001 fc43 	bl	800c05a <memcpy>
		vTaskGetRunTimeStats( pcWriteBuffer + strlen( pcHeader ) );
 800a7d4:	f104 0050 	add.w	r0, r4, #80	; 0x50
 800a7d8:	f7ff fe4a 	bl	800a470 <vTaskGetRunTimeStats>

		/* There is no more data to return after this single string, so return
		pdFALSE. */
		return pdFALSE;
	}
 800a7dc:	2000      	movs	r0, #0
 800a7de:	bd10      	pop	{r4, pc}
		configASSERT( pcWriteBuffer );
 800a7e0:	f240 113f 	movw	r1, #319	; 0x13f
 800a7e4:	4802      	ldr	r0, [pc, #8]	; (800a7f0 <prvRunTimeStatsCommand+0x2c>)
 800a7e6:	f001 fa91 	bl	800bd0c <vAssertCalled>
 800a7ea:	e7ee      	b.n	800a7ca <prvRunTimeStatsCommand+0x6>
 800a7ec:	0800cb0c 	.word	0x0800cb0c
 800a7f0:	0800ca90 	.word	0x0800ca90

0800a7f4 <prvTaskStatsCommand>:
	{
 800a7f4:	b510      	push	{r4, lr}
		configASSERT( pcWriteBuffer );
 800a7f6:	4604      	mov	r4, r0
 800a7f8:	b1e0      	cbz	r0, 800a834 <prvTaskStatsCommand+0x40>
		strcpy( pcWriteBuffer, "Task" );
 800a7fa:	4b11      	ldr	r3, [pc, #68]	; (800a840 <prvTaskStatsCommand+0x4c>)
 800a7fc:	6818      	ldr	r0, [r3, #0]
 800a7fe:	6020      	str	r0, [r4, #0]
 800a800:	791b      	ldrb	r3, [r3, #4]
 800a802:	7123      	strb	r3, [r4, #4]
		pcWriteBuffer += strlen( pcWriteBuffer );
 800a804:	4620      	mov	r0, r4
 800a806:	f7f5 fce3 	bl	80001d0 <strlen>
 800a80a:	4404      	add	r4, r0
 800a80c:	f104 0109 	add.w	r1, r4, #9
 800a810:	4620      	mov	r0, r4
			*pcWriteBuffer = ' ';
 800a812:	2220      	movs	r2, #32
			*pcWriteBuffer = 0x00;
 800a814:	2300      	movs	r3, #0
			*pcWriteBuffer = ' ';
 800a816:	7002      	strb	r2, [r0, #0]
			*pcWriteBuffer = 0x00;
 800a818:	f800 3f01 	strb.w	r3, [r0, #1]!
		for( xSpacePadding = strlen( "Task" ); xSpacePadding < ( configMAX_TASK_NAME_LEN - 3 ); xSpacePadding++ )
 800a81c:	4281      	cmp	r1, r0
 800a81e:	d1fa      	bne.n	800a816 <prvTaskStatsCommand+0x22>
		strcpy( pcWriteBuffer, pcHeader );
 800a820:	224c      	movs	r2, #76	; 0x4c
 800a822:	4908      	ldr	r1, [pc, #32]	; (800a844 <prvTaskStatsCommand+0x50>)
 800a824:	f001 fc19 	bl	800c05a <memcpy>
		vTaskList( pcWriteBuffer + strlen( pcHeader ) );
 800a828:	f104 0054 	add.w	r0, r4, #84	; 0x54
 800a82c:	f7ff fda8 	bl	800a380 <vTaskList>
	}
 800a830:	2000      	movs	r0, #0
 800a832:	bd10      	pop	{r4, pc}
		configASSERT( pcWriteBuffer );
 800a834:	f44f 7181 	mov.w	r1, #258	; 0x102
 800a838:	4803      	ldr	r0, [pc, #12]	; (800a848 <prvTaskStatsCommand+0x54>)
 800a83a:	f001 fa67 	bl	800bd0c <vAssertCalled>
 800a83e:	e7dc      	b.n	800a7fa <prvTaskStatsCommand+0x6>
 800a840:	0800cb60 	.word	0x0800cb60
 800a844:	0800cb68 	.word	0x0800cb68
 800a848:	0800ca90 	.word	0x0800ca90

0800a84c <prvParameterEchoCommand>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvParameterEchoCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 800a84c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a84e:	b083      	sub	sp, #12
 800a850:	460e      	mov	r6, r1
 800a852:	4615      	mov	r5, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) pcCommandString;
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 800a854:	4604      	mov	r4, r0
 800a856:	b338      	cbz	r0, 800a8a8 <prvParameterEchoCommand+0x5c>

	if( lParameterNumber == 0 )
 800a858:	4b21      	ldr	r3, [pc, #132]	; (800a8e0 <prvParameterEchoCommand+0x94>)
 800a85a:	6819      	ldr	r1, [r3, #0]
 800a85c:	b351      	cbz	r1, 800a8b4 <prvParameterEchoCommand+0x68>
		xReturn = pdPASS;
	}
	else
	{
		/* Obtain the parameter string. */
		pcParameter = FreeRTOS_CLIGetParameter
 800a85e:	aa01      	add	r2, sp, #4
 800a860:	4628      	mov	r0, r5
 800a862:	f7f8 fbf3 	bl	800304c <FreeRTOS_CLIGetParameter>
							pcCommandString,		/* The command string itself. */
							lParameterNumber,		/* Return the next parameter. */
							&xParameterStringLength	/* Store the parameter string length. */
						);

		if( pcParameter != NULL )
 800a866:	4607      	mov	r7, r0
 800a868:	2800      	cmp	r0, #0
 800a86a:	d034      	beq.n	800a8d6 <prvParameterEchoCommand+0x8a>
		{
			/* Return the parameter string. */
			memset( pcWriteBuffer, 0x00, xWriteBufferLen );
 800a86c:	4632      	mov	r2, r6
 800a86e:	2100      	movs	r1, #0
 800a870:	4620      	mov	r0, r4
 800a872:	f001 fc17 	bl	800c0a4 <memset>
			sprintf( pcWriteBuffer, "%d: ", ( int ) lParameterNumber );
 800a876:	4d1a      	ldr	r5, [pc, #104]	; (800a8e0 <prvParameterEchoCommand+0x94>)
 800a878:	682a      	ldr	r2, [r5, #0]
 800a87a:	491a      	ldr	r1, [pc, #104]	; (800a8e4 <prvParameterEchoCommand+0x98>)
 800a87c:	4620      	mov	r0, r4
 800a87e:	f000 ff8e 	bl	800b79e <sprintf>
			strncat( pcWriteBuffer, pcParameter, xParameterStringLength );
 800a882:	9a01      	ldr	r2, [sp, #4]
 800a884:	4639      	mov	r1, r7
 800a886:	4620      	mov	r0, r4
 800a888:	f001 fc1c 	bl	800c0c4 <strncat>
			strncat( pcWriteBuffer, "\r\n", strlen( "\r\n" ) );
 800a88c:	4620      	mov	r0, r4
 800a88e:	f7f5 fc9f 	bl	80001d0 <strlen>
 800a892:	1822      	adds	r2, r4, r0
 800a894:	4b14      	ldr	r3, [pc, #80]	; (800a8e8 <prvParameterEchoCommand+0x9c>)
 800a896:	8819      	ldrh	r1, [r3, #0]
 800a898:	789b      	ldrb	r3, [r3, #2]
 800a89a:	5221      	strh	r1, [r4, r0]
 800a89c:	7093      	strb	r3, [r2, #2]

			/* There might be more parameters to return after this one. */
			xReturn = pdTRUE;
			lParameterNumber++;
 800a89e:	682b      	ldr	r3, [r5, #0]
 800a8a0:	3301      	adds	r3, #1
 800a8a2:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 800a8a4:	2001      	movs	r0, #1
 800a8a6:	e014      	b.n	800a8d2 <prvParameterEchoCommand+0x86>
	configASSERT( pcWriteBuffer );
 800a8a8:	f240 119b 	movw	r1, #411	; 0x19b
 800a8ac:	480f      	ldr	r0, [pc, #60]	; (800a8ec <prvParameterEchoCommand+0xa0>)
 800a8ae:	f001 fa2d 	bl	800bd0c <vAssertCalled>
 800a8b2:	e7d1      	b.n	800a858 <prvParameterEchoCommand+0xc>
		sprintf( pcWriteBuffer, "The parameters were:\r\n" );
 800a8b4:	4d0e      	ldr	r5, [pc, #56]	; (800a8f0 <prvParameterEchoCommand+0xa4>)
 800a8b6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800a8b8:	6020      	str	r0, [r4, #0]
 800a8ba:	6061      	str	r1, [r4, #4]
 800a8bc:	60a2      	str	r2, [r4, #8]
 800a8be:	60e3      	str	r3, [r4, #12]
 800a8c0:	6828      	ldr	r0, [r5, #0]
 800a8c2:	6120      	str	r0, [r4, #16]
 800a8c4:	88aa      	ldrh	r2, [r5, #4]
 800a8c6:	79ab      	ldrb	r3, [r5, #6]
 800a8c8:	82a2      	strh	r2, [r4, #20]
 800a8ca:	75a3      	strb	r3, [r4, #22]
		lParameterNumber = 1L;
 800a8cc:	2001      	movs	r0, #1
 800a8ce:	4b04      	ldr	r3, [pc, #16]	; (800a8e0 <prvParameterEchoCommand+0x94>)
 800a8d0:	6018      	str	r0, [r3, #0]
			lParameterNumber = 0;
		}
	}

	return xReturn;
}
 800a8d2:	b003      	add	sp, #12
 800a8d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			pcWriteBuffer[ 0 ] = 0x00;
 800a8d6:	2000      	movs	r0, #0
 800a8d8:	7020      	strb	r0, [r4, #0]
			lParameterNumber = 0;
 800a8da:	4b01      	ldr	r3, [pc, #4]	; (800a8e0 <prvParameterEchoCommand+0x94>)
 800a8dc:	6018      	str	r0, [r3, #0]
	return xReturn;
 800a8de:	e7f8      	b.n	800a8d2 <prvParameterEchoCommand+0x86>
 800a8e0:	20000aa8 	.word	0x20000aa8
 800a8e4:	0800ca88 	.word	0x0800ca88
 800a8e8:	0800ca84 	.word	0x0800ca84
 800a8ec:	0800ca90 	.word	0x0800ca90
 800a8f0:	0800ca70 	.word	0x0800ca70

0800a8f4 <prvThreeParameterEchoCommand>:
{
 800a8f4:	b570      	push	{r4, r5, r6, lr}
 800a8f6:	b082      	sub	sp, #8
 800a8f8:	460d      	mov	r5, r1
 800a8fa:	4616      	mov	r6, r2
	configASSERT( pcWriteBuffer );
 800a8fc:	4604      	mov	r4, r0
 800a8fe:	b358      	cbz	r0, 800a958 <prvThreeParameterEchoCommand+0x64>
	if( lParameterNumber == 0 )
 800a900:	4b25      	ldr	r3, [pc, #148]	; (800a998 <prvThreeParameterEchoCommand+0xa4>)
 800a902:	6819      	ldr	r1, [r3, #0]
 800a904:	b371      	cbz	r1, 800a964 <prvThreeParameterEchoCommand+0x70>
		pcParameter = FreeRTOS_CLIGetParameter
 800a906:	aa01      	add	r2, sp, #4
 800a908:	4630      	mov	r0, r6
 800a90a:	f7f8 fb9f 	bl	800304c <FreeRTOS_CLIGetParameter>
		configASSERT( pcParameter );
 800a90e:	4606      	mov	r6, r0
 800a910:	2800      	cmp	r0, #0
 800a912:	d037      	beq.n	800a984 <prvThreeParameterEchoCommand+0x90>
		memset( pcWriteBuffer, 0x00, xWriteBufferLen );
 800a914:	462a      	mov	r2, r5
 800a916:	2100      	movs	r1, #0
 800a918:	4620      	mov	r0, r4
 800a91a:	f001 fbc3 	bl	800c0a4 <memset>
		sprintf( pcWriteBuffer, "%d: ", ( int ) lParameterNumber );
 800a91e:	4d1e      	ldr	r5, [pc, #120]	; (800a998 <prvThreeParameterEchoCommand+0xa4>)
 800a920:	682a      	ldr	r2, [r5, #0]
 800a922:	491e      	ldr	r1, [pc, #120]	; (800a99c <prvThreeParameterEchoCommand+0xa8>)
 800a924:	4620      	mov	r0, r4
 800a926:	f000 ff3a 	bl	800b79e <sprintf>
		strncat( pcWriteBuffer, pcParameter, xParameterStringLength );
 800a92a:	9a01      	ldr	r2, [sp, #4]
 800a92c:	4631      	mov	r1, r6
 800a92e:	4620      	mov	r0, r4
 800a930:	f001 fbc8 	bl	800c0c4 <strncat>
		strncat( pcWriteBuffer, "\r\n", strlen( "\r\n" ) );
 800a934:	4620      	mov	r0, r4
 800a936:	f7f5 fc4b 	bl	80001d0 <strlen>
 800a93a:	1822      	adds	r2, r4, r0
 800a93c:	4b18      	ldr	r3, [pc, #96]	; (800a9a0 <prvThreeParameterEchoCommand+0xac>)
 800a93e:	8819      	ldrh	r1, [r3, #0]
 800a940:	789b      	ldrb	r3, [r3, #2]
 800a942:	5221      	strh	r1, [r4, r0]
 800a944:	7093      	strb	r3, [r2, #2]
		if( lParameterNumber == 3L )
 800a946:	682b      	ldr	r3, [r5, #0]
 800a948:	2b03      	cmp	r3, #3
 800a94a:	d021      	beq.n	800a990 <prvThreeParameterEchoCommand+0x9c>
			lParameterNumber++;
 800a94c:	3301      	adds	r3, #1
 800a94e:	4a12      	ldr	r2, [pc, #72]	; (800a998 <prvThreeParameterEchoCommand+0xa4>)
 800a950:	6013      	str	r3, [r2, #0]
			xReturn = pdTRUE;
 800a952:	2001      	movs	r0, #1
}
 800a954:	b002      	add	sp, #8
 800a956:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pcWriteBuffer );
 800a958:	f44f 71ac 	mov.w	r1, #344	; 0x158
 800a95c:	4811      	ldr	r0, [pc, #68]	; (800a9a4 <prvThreeParameterEchoCommand+0xb0>)
 800a95e:	f001 f9d5 	bl	800bd0c <vAssertCalled>
 800a962:	e7cd      	b.n	800a900 <prvThreeParameterEchoCommand+0xc>
		sprintf( pcWriteBuffer, "The three parameters were:\r\n" );
 800a964:	4d10      	ldr	r5, [pc, #64]	; (800a9a8 <prvThreeParameterEchoCommand+0xb4>)
 800a966:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800a968:	6020      	str	r0, [r4, #0]
 800a96a:	6061      	str	r1, [r4, #4]
 800a96c:	60a2      	str	r2, [r4, #8]
 800a96e:	60e3      	str	r3, [r4, #12]
 800a970:	cd07      	ldmia	r5!, {r0, r1, r2}
 800a972:	6120      	str	r0, [r4, #16]
 800a974:	6161      	str	r1, [r4, #20]
 800a976:	61a2      	str	r2, [r4, #24]
 800a978:	782b      	ldrb	r3, [r5, #0]
 800a97a:	7723      	strb	r3, [r4, #28]
		lParameterNumber = 1L;
 800a97c:	2001      	movs	r0, #1
 800a97e:	4b06      	ldr	r3, [pc, #24]	; (800a998 <prvThreeParameterEchoCommand+0xa4>)
 800a980:	6018      	str	r0, [r3, #0]
 800a982:	e7e7      	b.n	800a954 <prvThreeParameterEchoCommand+0x60>
		configASSERT( pcParameter );
 800a984:	f240 1173 	movw	r1, #371	; 0x173
 800a988:	4806      	ldr	r0, [pc, #24]	; (800a9a4 <prvThreeParameterEchoCommand+0xb0>)
 800a98a:	f001 f9bf 	bl	800bd0c <vAssertCalled>
 800a98e:	e7c1      	b.n	800a914 <prvThreeParameterEchoCommand+0x20>
			lParameterNumber = 0L;
 800a990:	2000      	movs	r0, #0
 800a992:	6028      	str	r0, [r5, #0]
 800a994:	e7de      	b.n	800a954 <prvThreeParameterEchoCommand+0x60>
 800a996:	bf00      	nop
 800a998:	20000aa4 	.word	0x20000aa4
 800a99c:	0800ca88 	.word	0x0800ca88
 800a9a0:	0800ca84 	.word	0x0800ca84
 800a9a4:	0800ca90 	.word	0x0800ca90
 800a9a8:	0800cbb4 	.word	0x0800cbb4

0800a9ac <vRegisterSampleCLICommands>:
{
 800a9ac:	b508      	push	{r3, lr}
	FreeRTOS_CLIRegisterCommand( &xThreeParameterEcho );
 800a9ae:	4808      	ldr	r0, [pc, #32]	; (800a9d0 <vRegisterSampleCLICommands+0x24>)
 800a9b0:	f7f8 fab8 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &xParameterEcho );
 800a9b4:	4807      	ldr	r0, [pc, #28]	; (800a9d4 <vRegisterSampleCLICommands+0x28>)
 800a9b6:	f7f8 fab5 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xTaskStats );
 800a9ba:	4807      	ldr	r0, [pc, #28]	; (800a9d8 <vRegisterSampleCLICommands+0x2c>)
 800a9bc:	f7f8 fab2 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xRunTimeStats );
 800a9c0:	4806      	ldr	r0, [pc, #24]	; (800a9dc <vRegisterSampleCLICommands+0x30>)
 800a9c2:	f7f8 faaf 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xQueryHeap );
 800a9c6:	4806      	ldr	r0, [pc, #24]	; (800a9e0 <vRegisterSampleCLICommands+0x34>)
 800a9c8:	f7f8 faac 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
 800a9cc:	bd08      	pop	{r3, pc}
 800a9ce:	bf00      	nop
 800a9d0:	0800ce1c 	.word	0x0800ce1c
 800a9d4:	0800cddc 	.word	0x0800cddc
 800a9d8:	0800ce0c 	.word	0x0800ce0c
 800a9dc:	0800cdfc 	.word	0x0800cdfc
 800a9e0:	0800cdec 	.word	0x0800cdec

0800a9e4 <prvNetStatCommand>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvNetStatCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 800a9e4:	b538      	push	{r3, r4, r5, lr}
 800a9e6:	4604      	mov	r4, r0
 800a9e8:	460d      	mov	r5, r1
	( void ) pcWriteBuffer;
	( void ) xWriteBufferLen;
	( void ) pcCommandString;

	FreeRTOS_netstat();
 800a9ea:	f7fa ff71 	bl	80058d0 <FreeRTOS_netstat>
	snprintf( pcWriteBuffer, xWriteBufferLen, "FreeRTOS_netstat() called - output uses FreeRTOS_printf\r\n" );
 800a9ee:	4a03      	ldr	r2, [pc, #12]	; (800a9fc <prvNetStatCommand+0x18>)
 800a9f0:	4629      	mov	r1, r5
 800a9f2:	4620      	mov	r0, r4
 800a9f4:	f001 f82d 	bl	800ba52 <snprintf>
	return pdFALSE;
}
 800a9f8:	2000      	movs	r0, #0
 800a9fa:	bd38      	pop	{r3, r4, r5, pc}
 800a9fc:	0800ce84 	.word	0x0800ce84

0800aa00 <prvPingCommand>:
	{
 800aa00:	b570      	push	{r4, r5, r6, lr}
 800aa02:	b088      	sub	sp, #32
 800aa04:	4615      	mov	r5, r2
		configASSERT( pcWriteBuffer );
 800aa06:	4604      	mov	r4, r0
 800aa08:	2800      	cmp	r0, #0
 800aa0a:	d035      	beq.n	800aa78 <prvPingCommand+0x78>
		pcWriteBuffer[ 0 ] = 0x00;
 800aa0c:	2300      	movs	r3, #0
 800aa0e:	7023      	strb	r3, [r4, #0]
		pcParameter = ( char * ) FreeRTOS_CLIGetParameter
 800aa10:	aa07      	add	r2, sp, #28
 800aa12:	2102      	movs	r1, #2
 800aa14:	4628      	mov	r0, r5
 800aa16:	f7f8 fb19 	bl	800304c <FreeRTOS_CLIGetParameter>
		if( pcParameter == NULL )
 800aa1a:	b390      	cbz	r0, 800aa82 <prvPingCommand+0x82>
			ulBytesToPing = atol( pcParameter );
 800aa1c:	f001 fae6 	bl	800bfec <atol>
 800aa20:	4606      	mov	r6, r0
		pcParameter = ( char * ) FreeRTOS_CLIGetParameter
 800aa22:	aa07      	add	r2, sp, #28
 800aa24:	2101      	movs	r1, #1
 800aa26:	4628      	mov	r0, r5
 800aa28:	f7f8 fb10 	bl	800304c <FreeRTOS_CLIGetParameter>
		if( pcParameter != NULL )
 800aa2c:	b1b8      	cbz	r0, 800aa5e <prvPingCommand+0x5e>
			pcParameter[ lParameterStringLength ] = 0x00;
 800aa2e:	2100      	movs	r1, #0
 800aa30:	9b07      	ldr	r3, [sp, #28]
 800aa32:	54c1      	strb	r1, [r0, r3]
			if( ( *pcParameter >= '0' ) && ( *pcParameter <= '9' ) )
 800aa34:	7803      	ldrb	r3, [r0, #0]
 800aa36:	3b30      	subs	r3, #48	; 0x30
 800aa38:	b2db      	uxtb	r3, r3
 800aa3a:	2b09      	cmp	r3, #9
 800aa3c:	d823      	bhi.n	800aa86 <prvPingCommand+0x86>
				ulIPAddress = FreeRTOS_inet_addr( pcParameter );
 800aa3e:	f7fa f945 	bl	8004ccc <FreeRTOS_inet_addr>
 800aa42:	4605      	mov	r5, r0
			FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
 800aa44:	0e2b      	lsrs	r3, r5, #24
 800aa46:	9301      	str	r3, [sp, #4]
 800aa48:	f3c5 4307 	ubfx	r3, r5, #16, #8
 800aa4c:	9300      	str	r3, [sp, #0]
 800aa4e:	f3c5 2307 	ubfx	r3, r5, #8, #8
 800aa52:	b2ea      	uxtb	r2, r5
 800aa54:	4916      	ldr	r1, [pc, #88]	; (800aab0 <prvPingCommand+0xb0>)
 800aa56:	a803      	add	r0, sp, #12
 800aa58:	f000 fea1 	bl	800b79e <sprintf>
			if( ulIPAddress != 0 )
 800aa5c:	b9bd      	cbnz	r5, 800aa8e <prvPingCommand+0x8e>
			sprintf( pcWriteBuffer, "%s", "Could not send ping request\r\n" );
 800aa5e:	4d15      	ldr	r5, [pc, #84]	; (800aab4 <prvPingCommand+0xb4>)
 800aa60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800aa62:	6020      	str	r0, [r4, #0]
 800aa64:	6061      	str	r1, [r4, #4]
 800aa66:	60a2      	str	r2, [r4, #8]
 800aa68:	60e3      	str	r3, [r4, #12]
 800aa6a:	cd07      	ldmia	r5!, {r0, r1, r2}
 800aa6c:	6120      	str	r0, [r4, #16]
 800aa6e:	6161      	str	r1, [r4, #20]
 800aa70:	61a2      	str	r2, [r4, #24]
 800aa72:	882b      	ldrh	r3, [r5, #0]
 800aa74:	83a3      	strh	r3, [r4, #28]
 800aa76:	e018      	b.n	800aaaa <prvPingCommand+0xaa>
		configASSERT( pcWriteBuffer );
 800aa78:	21c2      	movs	r1, #194	; 0xc2
 800aa7a:	480f      	ldr	r0, [pc, #60]	; (800aab8 <prvPingCommand+0xb8>)
 800aa7c:	f001 f946 	bl	800bd0c <vAssertCalled>
 800aa80:	e7c4      	b.n	800aa0c <prvPingCommand+0xc>
			ulBytesToPing = ulDefaultBytesToPing;
 800aa82:	2608      	movs	r6, #8
 800aa84:	e7cd      	b.n	800aa22 <prvPingCommand+0x22>
				ulIPAddress = FreeRTOS_gethostbyname( pcParameter );
 800aa86:	f7f9 f92f 	bl	8003ce8 <FreeRTOS_gethostbyname>
 800aa8a:	4605      	mov	r5, r0
 800aa8c:	e7da      	b.n	800aa44 <prvPingCommand+0x44>
				xReturn = FreeRTOS_SendPingRequest( ulIPAddress, ( uint16_t ) ulBytesToPing, portMAX_DELAY );
 800aa8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800aa92:	b2b1      	uxth	r1, r6
 800aa94:	4628      	mov	r0, r5
 800aa96:	f7f9 fac7 	bl	8004028 <FreeRTOS_SendPingRequest>
		if( xReturn == pdFALSE )
 800aa9a:	4603      	mov	r3, r0
 800aa9c:	2800      	cmp	r0, #0
 800aa9e:	d0de      	beq.n	800aa5e <prvPingCommand+0x5e>
			sprintf( pcWriteBuffer, "Ping sent to %s with identifier %d\r\n", cBuffer, ( int ) xReturn );
 800aaa0:	aa03      	add	r2, sp, #12
 800aaa2:	4906      	ldr	r1, [pc, #24]	; (800aabc <prvPingCommand+0xbc>)
 800aaa4:	4620      	mov	r0, r4
 800aaa6:	f000 fe7a 	bl	800b79e <sprintf>
	}
 800aaaa:	2000      	movs	r0, #0
 800aaac:	b008      	add	sp, #32
 800aaae:	bd70      	pop	{r4, r5, r6, pc}
 800aab0:	0800cf00 	.word	0x0800cf00
 800aab4:	0800cf0c 	.word	0x0800cf0c
 800aab8:	0800cec0 	.word	0x0800cec0
 800aabc:	0800cf2c 	.word	0x0800cf2c

0800aac0 <prvDisplayIPDebugStats>:
	{
 800aac0:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pcWriteBuffer );
 800aac2:	4605      	mov	r5, r0
 800aac4:	b178      	cbz	r0, 800aae6 <prvDisplayIPDebugStats+0x26>
		xIndex++;
 800aac6:	4c10      	ldr	r4, [pc, #64]	; (800ab08 <prvDisplayIPDebugStats+0x48>)
 800aac8:	6823      	ldr	r3, [r4, #0]
 800aaca:	3301      	adds	r3, #1
 800aacc:	6023      	str	r3, [r4, #0]
		if( xIndex < xExampleDebugStatEntries() )
 800aace:	f000 fb84 	bl	800b1da <xExampleDebugStatEntries>
 800aad2:	6823      	ldr	r3, [r4, #0]
 800aad4:	4298      	cmp	r0, r3
 800aad6:	dc0c      	bgt.n	800aaf2 <prvDisplayIPDebugStats+0x32>
			xIndex = -1;
 800aad8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800aadc:	4b0a      	ldr	r3, [pc, #40]	; (800ab08 <prvDisplayIPDebugStats+0x48>)
 800aade:	601a      	str	r2, [r3, #0]
			pcWriteBuffer[ 0 ] = 0x00;
 800aae0:	2000      	movs	r0, #0
 800aae2:	7028      	strb	r0, [r5, #0]
	}
 800aae4:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pcWriteBuffer );
 800aae6:	f240 1117 	movw	r1, #279	; 0x117
 800aaea:	4808      	ldr	r0, [pc, #32]	; (800ab0c <prvDisplayIPDebugStats+0x4c>)
 800aaec:	f001 f90e 	bl	800bd0c <vAssertCalled>
 800aaf0:	e7e9      	b.n	800aac6 <prvDisplayIPDebugStats+0x6>
			sprintf( pcWriteBuffer, "%s %d\r\n", ( char * ) xIPTraceValues[ xIndex ].pucDescription, ( int ) xIPTraceValues[ xIndex ].ulData );
 800aaf2:	4a07      	ldr	r2, [pc, #28]	; (800ab10 <prvDisplayIPDebugStats+0x50>)
 800aaf4:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 800aaf8:	68d3      	ldr	r3, [r2, #12]
 800aafa:	6852      	ldr	r2, [r2, #4]
 800aafc:	4905      	ldr	r1, [pc, #20]	; (800ab14 <prvDisplayIPDebugStats+0x54>)
 800aafe:	4628      	mov	r0, r5
 800ab00:	f000 fe4d 	bl	800b79e <sprintf>
			xReturn = pdPASS;
 800ab04:	2001      	movs	r0, #1
 800ab06:	bd38      	pop	{r3, r4, r5, pc}
 800ab08:	2000002c 	.word	0x2000002c
 800ab0c:	0800cec0 	.word	0x0800cec0
 800ab10:	20000034 	.word	0x20000034
 800ab14:	0800ce7c 	.word	0x0800ce7c

0800ab18 <prvDisplayIPConfig>:
{
 800ab18:	b530      	push	{r4, r5, lr}
 800ab1a:	b085      	sub	sp, #20
	configASSERT( pcWriteBuffer );
 800ab1c:	4604      	mov	r4, r0
 800ab1e:	b138      	cbz	r0, 800ab30 <prvDisplayIPConfig+0x18>
	switch( xIndex )
 800ab20:	4b3c      	ldr	r3, [pc, #240]	; (800ac14 <prvDisplayIPConfig+0xfc>)
 800ab22:	681b      	ldr	r3, [r3, #0]
 800ab24:	2b03      	cmp	r3, #3
 800ab26:	d85a      	bhi.n	800abde <prvDisplayIPConfig+0xc6>
 800ab28:	e8df f003 	tbb	[pc, r3]
 800ab2c:	442f1f08 	.word	0x442f1f08
	configASSERT( pcWriteBuffer );
 800ab30:	f240 113b 	movw	r1, #315	; 0x13b
 800ab34:	4838      	ldr	r0, [pc, #224]	; (800ac18 <prvDisplayIPConfig+0x100>)
 800ab36:	f001 f8e9 	bl	800bd0c <vAssertCalled>
 800ab3a:	e7f1      	b.n	800ab20 <prvDisplayIPConfig+0x8>
			FreeRTOS_GetAddressConfiguration( &ulAddress, NULL, NULL, NULL );
 800ab3c:	2300      	movs	r3, #0
 800ab3e:	461a      	mov	r2, r3
 800ab40:	4619      	mov	r1, r3
 800ab42:	a803      	add	r0, sp, #12
 800ab44:	f7f9 fa00 	bl	8003f48 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nIP address " );
 800ab48:	4b34      	ldr	r3, [pc, #208]	; (800ac1c <prvDisplayIPConfig+0x104>)
 800ab4a:	cb07      	ldmia	r3!, {r0, r1, r2}
 800ab4c:	6020      	str	r0, [r4, #0]
 800ab4e:	6061      	str	r1, [r4, #4]
 800ab50:	60a2      	str	r2, [r4, #8]
 800ab52:	881b      	ldrh	r3, [r3, #0]
 800ab54:	81a3      	strh	r3, [r4, #12]
			xIndex++;
 800ab56:	4a2f      	ldr	r2, [pc, #188]	; (800ac14 <prvDisplayIPConfig+0xfc>)
 800ab58:	6813      	ldr	r3, [r2, #0]
 800ab5a:	3301      	adds	r3, #1
 800ab5c:	6013      	str	r3, [r2, #0]
	if( ulAddress != 0 )
 800ab5e:	9d03      	ldr	r5, [sp, #12]
 800ab60:	2d00      	cmp	r5, #0
 800ab62:	d145      	bne.n	800abf0 <prvDisplayIPConfig+0xd8>
 800ab64:	2001      	movs	r0, #1
}
 800ab66:	b005      	add	sp, #20
 800ab68:	bd30      	pop	{r4, r5, pc}
			FreeRTOS_GetAddressConfiguration( NULL, &ulAddress, NULL, NULL );
 800ab6a:	2300      	movs	r3, #0
 800ab6c:	461a      	mov	r2, r3
 800ab6e:	a903      	add	r1, sp, #12
 800ab70:	4618      	mov	r0, r3
 800ab72:	f7f9 f9e9 	bl	8003f48 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nNet mask " );
 800ab76:	4b2a      	ldr	r3, [pc, #168]	; (800ac20 <prvDisplayIPConfig+0x108>)
 800ab78:	cb07      	ldmia	r3!, {r0, r1, r2}
 800ab7a:	6020      	str	r0, [r4, #0]
 800ab7c:	6061      	str	r1, [r4, #4]
 800ab7e:	60a2      	str	r2, [r4, #8]
			xIndex++;
 800ab80:	4a24      	ldr	r2, [pc, #144]	; (800ac14 <prvDisplayIPConfig+0xfc>)
 800ab82:	6813      	ldr	r3, [r2, #0]
 800ab84:	3301      	adds	r3, #1
 800ab86:	6013      	str	r3, [r2, #0]
			break;
 800ab88:	e7e9      	b.n	800ab5e <prvDisplayIPConfig+0x46>
			FreeRTOS_GetAddressConfiguration( NULL, NULL, &ulAddress, NULL );
 800ab8a:	2300      	movs	r3, #0
 800ab8c:	aa03      	add	r2, sp, #12
 800ab8e:	4619      	mov	r1, r3
 800ab90:	4618      	mov	r0, r3
 800ab92:	f7f9 f9d9 	bl	8003f48 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nGateway address " );
 800ab96:	4d23      	ldr	r5, [pc, #140]	; (800ac24 <prvDisplayIPConfig+0x10c>)
 800ab98:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ab9a:	6020      	str	r0, [r4, #0]
 800ab9c:	6061      	str	r1, [r4, #4]
 800ab9e:	60a2      	str	r2, [r4, #8]
 800aba0:	60e3      	str	r3, [r4, #12]
 800aba2:	882a      	ldrh	r2, [r5, #0]
 800aba4:	78ab      	ldrb	r3, [r5, #2]
 800aba6:	8222      	strh	r2, [r4, #16]
 800aba8:	74a3      	strb	r3, [r4, #18]
			xIndex++;
 800abaa:	4a1a      	ldr	r2, [pc, #104]	; (800ac14 <prvDisplayIPConfig+0xfc>)
 800abac:	6813      	ldr	r3, [r2, #0]
 800abae:	3301      	adds	r3, #1
 800abb0:	6013      	str	r3, [r2, #0]
			break;
 800abb2:	e7d4      	b.n	800ab5e <prvDisplayIPConfig+0x46>
			FreeRTOS_GetAddressConfiguration( NULL, NULL, NULL, &ulAddress );
 800abb4:	ab03      	add	r3, sp, #12
 800abb6:	2200      	movs	r2, #0
 800abb8:	4611      	mov	r1, r2
 800abba:	4610      	mov	r0, r2
 800abbc:	f7f9 f9c4 	bl	8003f48 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nDNS server address " );
 800abc0:	4d19      	ldr	r5, [pc, #100]	; (800ac28 <prvDisplayIPConfig+0x110>)
 800abc2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800abc4:	6020      	str	r0, [r4, #0]
 800abc6:	6061      	str	r1, [r4, #4]
 800abc8:	60a2      	str	r2, [r4, #8]
 800abca:	60e3      	str	r3, [r4, #12]
 800abcc:	6828      	ldr	r0, [r5, #0]
 800abce:	6120      	str	r0, [r4, #16]
 800abd0:	88ab      	ldrh	r3, [r5, #4]
 800abd2:	82a3      	strh	r3, [r4, #20]
			xIndex++;
 800abd4:	4a0f      	ldr	r2, [pc, #60]	; (800ac14 <prvDisplayIPConfig+0xfc>)
 800abd6:	6813      	ldr	r3, [r2, #0]
 800abd8:	3301      	adds	r3, #1
 800abda:	6013      	str	r3, [r2, #0]
			break;
 800abdc:	e7bf      	b.n	800ab5e <prvDisplayIPConfig+0x46>
			sprintf( pcWriteBuffer, "\r\n\r\n" );
 800abde:	4b13      	ldr	r3, [pc, #76]	; (800ac2c <prvDisplayIPConfig+0x114>)
 800abe0:	6818      	ldr	r0, [r3, #0]
 800abe2:	6020      	str	r0, [r4, #0]
 800abe4:	791b      	ldrb	r3, [r3, #4]
 800abe6:	7123      	strb	r3, [r4, #4]
			xIndex = 0;
 800abe8:	2000      	movs	r0, #0
 800abea:	4b0a      	ldr	r3, [pc, #40]	; (800ac14 <prvDisplayIPConfig+0xfc>)
 800abec:	6018      	str	r0, [r3, #0]
 800abee:	e7ba      	b.n	800ab66 <prvDisplayIPConfig+0x4e>
		FreeRTOS_inet_ntoa( ulAddress, ( &( pcWriteBuffer[ strlen( pcWriteBuffer ) ] ) ) );
 800abf0:	4620      	mov	r0, r4
 800abf2:	f7f5 faed 	bl	80001d0 <strlen>
 800abf6:	0e2b      	lsrs	r3, r5, #24
 800abf8:	9301      	str	r3, [sp, #4]
 800abfa:	f3c5 4307 	ubfx	r3, r5, #16, #8
 800abfe:	9300      	str	r3, [sp, #0]
 800ac00:	f3c5 2307 	ubfx	r3, r5, #8, #8
 800ac04:	b2ea      	uxtb	r2, r5
 800ac06:	490a      	ldr	r1, [pc, #40]	; (800ac30 <prvDisplayIPConfig+0x118>)
 800ac08:	4420      	add	r0, r4
 800ac0a:	f000 fdc8 	bl	800b79e <sprintf>
 800ac0e:	2001      	movs	r0, #1
 800ac10:	e7a9      	b.n	800ab66 <prvDisplayIPConfig+0x4e>
 800ac12:	bf00      	nop
 800ac14:	20000aac 	.word	0x20000aac
 800ac18:	0800cec0 	.word	0x0800cec0
 800ac1c:	0800ce2c 	.word	0x0800ce2c
 800ac20:	0800ce3c 	.word	0x0800ce3c
 800ac24:	0800ce48 	.word	0x0800ce48
 800ac28:	0800ce5c 	.word	0x0800ce5c
 800ac2c:	0800ce74 	.word	0x0800ce74
 800ac30:	0800cf00 	.word	0x0800cf00

0800ac34 <vRegisterTCPCLICommands>:
{
 800ac34:	b508      	push	{r3, lr}
	FreeRTOS_CLIRegisterCommand( &xIPConfig );
 800ac36:	4806      	ldr	r0, [pc, #24]	; (800ac50 <vRegisterTCPCLICommands+0x1c>)
 800ac38:	f7f8 f974 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xIPDebugStats );
 800ac3c:	4805      	ldr	r0, [pc, #20]	; (800ac54 <vRegisterTCPCLICommands+0x20>)
 800ac3e:	f7f8 f971 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xPing );
 800ac42:	4805      	ldr	r0, [pc, #20]	; (800ac58 <vRegisterTCPCLICommands+0x24>)
 800ac44:	f7f8 f96e 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &xNetStats );
 800ac48:	4804      	ldr	r0, [pc, #16]	; (800ac5c <vRegisterTCPCLICommands+0x28>)
 800ac4a:	f7f8 f96b 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
 800ac4e:	bd08      	pop	{r3, pc}
 800ac50:	0800d0a4 	.word	0x0800d0a4
 800ac54:	0800d0b4 	.word	0x0800d0b4
 800ac58:	0800d0d4 	.word	0x0800d0d4
 800ac5c:	0800d0c4 	.word	0x0800d0c4

0800ac60 <prvUDPCommandInterpreterTask>:
	xTaskCreate( prvUDPCommandInterpreterTask, "UDP CLI", usStackSize, ( void * ) ulPort, uxPriority, NULL );
}
/*-----------------------------------------------------------*/

void prvUDPCommandInterpreterTask( void *pvParameters )
{
 800ac60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ac64:	b08b      	sub	sp, #44	; 0x2c
 800ac66:	4604      	mov	r4, r0
static char cOutputString[ cmdMAX_OUTPUT_SIZE ], cLocalBuffer[ cmdSOCKET_INPUT_BUFFER_SIZE ];
static char cLastInputString[ cmdMAX_INPUT_SIZE ], cInputString[ cmdMAX_INPUT_SIZE ];
BaseType_t xMoreDataToFollow;
struct freertos_sockaddr xClient;

	memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
 800ac68:	223c      	movs	r2, #60	; 0x3c
 800ac6a:	2100      	movs	r1, #0
 800ac6c:	4856      	ldr	r0, [pc, #344]	; (800adc8 <prvUDPCommandInterpreterTask+0x168>)
 800ac6e:	f001 fa19 	bl	800c0a4 <memset>

static Socket_t prvOpenUDPServerSocket( uint16_t usPort )
{
struct freertos_sockaddr xServer;
Socket_t xServerSocket = FREERTOS_INVALID_SOCKET;
TickType_t xSendTimeOut = 0;
 800ac72:	2300      	movs	r3, #0
 800ac74:	9305      	str	r3, [sp, #20]

	xServerSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800ac76:	2211      	movs	r2, #17
 800ac78:	2102      	movs	r1, #2
 800ac7a:	4608      	mov	r0, r1
 800ac7c:	f7f9 fd3e 	bl	80046fc <FreeRTOS_socket>
	if( xServerSocket != FREERTOS_INVALID_SOCKET)
 800ac80:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800ac84:	d01f      	beq.n	800acc6 <prvUDPCommandInterpreterTask+0x66>
 800ac86:	b2a6      	uxth	r6, r4
 800ac88:	4605      	mov	r5, r0
	{
		/* Set to non-blocking sends with a timeout of zero as the socket might
		also be used for debug prints which should not block. */
		FreeRTOS_setsockopt( xServerSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800ac8a:	2304      	movs	r3, #4
 800ac8c:	9300      	str	r3, [sp, #0]
 800ac8e:	ab05      	add	r3, sp, #20
 800ac90:	2201      	movs	r2, #1
 800ac92:	2100      	movs	r1, #0
 800ac94:	f7fa fc38 	bl	8005508 <FreeRTOS_setsockopt>

		/* Zero out the server structure. */
		memset( ( void * ) &xServer, 0x00, sizeof( xServer ) );
 800ac98:	2300      	movs	r3, #0
 800ac9a:	9306      	str	r3, [sp, #24]
 800ac9c:	9307      	str	r3, [sp, #28]

		/* Set family and port. */
		xServer.sin_port = FreeRTOS_htons( usPort );
 800ac9e:	0223      	lsls	r3, r4, #8
 800aca0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800aca4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800aca8:	ea43 2316 	orr.w	r3, r3, r6, lsr #8
 800acac:	f8ad 301a 	strh.w	r3, [sp, #26]

		/* Bind the address to the socket. */
		if( FreeRTOS_bind( xServerSocket, &xServer, sizeof( xServer ) ) == -1 )
 800acb0:	2208      	movs	r2, #8
 800acb2:	a906      	add	r1, sp, #24
 800acb4:	4628      	mov	r0, r5
 800acb6:	f7f9 fe48 	bl	800494a <FreeRTOS_bind>
 800acba:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800acbe:	d16a      	bne.n	800ad96 <prvUDPCommandInterpreterTask+0x136>
		{
			FreeRTOS_closesocket( xServerSocket );
 800acc0:	4628      	mov	r0, r5
 800acc2:	f7f9 ff7d 	bl	8004bc0 <FreeRTOS_closesocket>
	xSocket = prvOpenUDPServerSocket( ( uint16_t ) ( ( uint32_t ) pvParameters ) & 0xffffUL );
 800acc6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800acca:	4b40      	ldr	r3, [pc, #256]	; (800adcc <prvUDPCommandInterpreterTask+0x16c>)
 800accc:	601a      	str	r2, [r3, #0]
		vTaskDelete( NULL );
 800acce:	2000      	movs	r0, #0
 800acd0:	f7fe fd80 	bl	80097d4 <vTaskDelete>
}
 800acd4:	b00b      	add	sp, #44	; 0x2c
 800acd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						FreeRTOS_sendto( xSocket, pcNewLine,  strlen( pcNewLine ), 0, &xClient, xClientAddressLength );
 800acda:	683b      	ldr	r3, [r7, #0]
 800acdc:	9301      	str	r3, [sp, #4]
 800acde:	ab08      	add	r3, sp, #32
 800ace0:	9300      	str	r3, [sp, #0]
 800ace2:	2300      	movs	r3, #0
 800ace4:	2202      	movs	r2, #2
 800ace6:	493a      	ldr	r1, [pc, #232]	; (800add0 <prvUDPCommandInterpreterTask+0x170>)
 800ace8:	6830      	ldr	r0, [r6, #0]
 800acea:	f7f9 fe65 	bl	80049b8 <FreeRTOS_sendto>
						if( cInputIndex == 0 )
 800acee:	2c00      	cmp	r4, #0
 800acf0:	d044      	beq.n	800ad7c <prvUDPCommandInterpreterTask+0x11c>
							cOutputString[ 0 ] = 0x00;
 800acf2:	4c38      	ldr	r4, [pc, #224]	; (800add4 <prvUDPCommandInterpreterTask+0x174>)
 800acf4:	f04f 0900 	mov.w	r9, #0
 800acf8:	f884 9000 	strb.w	r9, [r4]
							xMoreDataToFollow = FreeRTOS_CLIProcessCommand( cInputString, cOutputString, cmdMAX_OUTPUT_SIZE );
 800acfc:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ad00:	4621      	mov	r1, r4
 800ad02:	9803      	ldr	r0, [sp, #12]
 800ad04:	f7f8 f932 	bl	8002f6c <FreeRTOS_CLIProcessCommand>
 800ad08:	4605      	mov	r5, r0
							FreeRTOS_sendto( xSocket, cOutputString,  strlen( ( const char * ) cOutputString ), 0, &xClient, xClientAddressLength );
 800ad0a:	4620      	mov	r0, r4
 800ad0c:	f7f5 fa60 	bl	80001d0 <strlen>
 800ad10:	683b      	ldr	r3, [r7, #0]
 800ad12:	9301      	str	r3, [sp, #4]
 800ad14:	ab08      	add	r3, sp, #32
 800ad16:	9300      	str	r3, [sp, #0]
 800ad18:	2300      	movs	r3, #0
 800ad1a:	4602      	mov	r2, r0
 800ad1c:	4621      	mov	r1, r4
 800ad1e:	6830      	ldr	r0, [r6, #0]
 800ad20:	f7f9 fe4a 	bl	80049b8 <FreeRTOS_sendto>
						} while( xMoreDataToFollow != pdFALSE );
 800ad24:	2d00      	cmp	r5, #0
 800ad26:	d1e7      	bne.n	800acf8 <prvUDPCommandInterpreterTask+0x98>
						strcpy( cLastInputString, cInputString );
 800ad28:	9c03      	ldr	r4, [sp, #12]
 800ad2a:	4621      	mov	r1, r4
 800ad2c:	482a      	ldr	r0, [pc, #168]	; (800add8 <prvUDPCommandInterpreterTask+0x178>)
 800ad2e:	f001 f9c1 	bl	800c0b4 <strcpy>
						memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
 800ad32:	223c      	movs	r2, #60	; 0x3c
 800ad34:	2100      	movs	r1, #0
 800ad36:	4620      	mov	r0, r4
 800ad38:	f001 f9b4 	bl	800c0a4 <memset>
						FreeRTOS_sendto( xSocket, ( void * ) pcEndOfOutputMessage,  strlen( pcEndOfOutputMessage ), 0, &xClient, xClientAddressLength );
 800ad3c:	683b      	ldr	r3, [r7, #0]
 800ad3e:	9301      	str	r3, [sp, #4]
 800ad40:	ab08      	add	r3, sp, #32
 800ad42:	9300      	str	r3, [sp, #0]
 800ad44:	2300      	movs	r3, #0
 800ad46:	2238      	movs	r2, #56	; 0x38
 800ad48:	4924      	ldr	r1, [pc, #144]	; (800addc <prvUDPCommandInterpreterTask+0x17c>)
 800ad4a:	6830      	ldr	r0, [r6, #0]
 800ad4c:	f7f9 fe34 	bl	80049b8 <FreeRTOS_sendto>
						cInputIndex = 0;
 800ad50:	2400      	movs	r4, #0
				while( lByte < lBytes )
 800ad52:	45d0      	cmp	r8, sl
 800ad54:	dd26      	ble.n	800ada4 <prvUDPCommandInterpreterTask+0x144>
					cRxedChar = cLocalBuffer[ lByte ];
 800ad56:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
					lByte++;
 800ad5a:	f10a 0a01 	add.w	sl, sl, #1
					if( cRxedChar == '\n' )
 800ad5e:	2b0a      	cmp	r3, #10
 800ad60:	d0bb      	beq.n	800acda <prvUDPCommandInterpreterTask+0x7a>
						if( cRxedChar == '\r' )
 800ad62:	2b0d      	cmp	r3, #13
 800ad64:	d0f5      	beq.n	800ad52 <prvUDPCommandInterpreterTask+0xf2>
						else if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
 800ad66:	2b08      	cmp	r3, #8
 800ad68:	d00d      	beq.n	800ad86 <prvUDPCommandInterpreterTask+0x126>
 800ad6a:	2b7f      	cmp	r3, #127	; 0x7f
 800ad6c:	d00b      	beq.n	800ad86 <prvUDPCommandInterpreterTask+0x126>
							if( cInputIndex < cmdMAX_INPUT_SIZE )
 800ad6e:	2c3b      	cmp	r4, #59	; 0x3b
 800ad70:	d8ef      	bhi.n	800ad52 <prvUDPCommandInterpreterTask+0xf2>
								cInputString[ ( int ) cInputIndex ] = cRxedChar;
 800ad72:	4a15      	ldr	r2, [pc, #84]	; (800adc8 <prvUDPCommandInterpreterTask+0x168>)
 800ad74:	5513      	strb	r3, [r2, r4]
								cInputIndex++;
 800ad76:	3401      	adds	r4, #1
 800ad78:	b2e4      	uxtb	r4, r4
 800ad7a:	e7ea      	b.n	800ad52 <prvUDPCommandInterpreterTask+0xf2>
							strcpy( cInputString, cLastInputString );
 800ad7c:	4916      	ldr	r1, [pc, #88]	; (800add8 <prvUDPCommandInterpreterTask+0x178>)
 800ad7e:	9803      	ldr	r0, [sp, #12]
 800ad80:	f001 f998 	bl	800c0b4 <strcpy>
 800ad84:	e7b5      	b.n	800acf2 <prvUDPCommandInterpreterTask+0x92>
							if( cInputIndex > 0 )
 800ad86:	2c00      	cmp	r4, #0
 800ad88:	d0e3      	beq.n	800ad52 <prvUDPCommandInterpreterTask+0xf2>
								cInputIndex--;
 800ad8a:	3c01      	subs	r4, #1
 800ad8c:	b2e4      	uxtb	r4, r4
								cInputString[ ( int ) cInputIndex ] = '\0';
 800ad8e:	2300      	movs	r3, #0
 800ad90:	4a0d      	ldr	r2, [pc, #52]	; (800adc8 <prvUDPCommandInterpreterTask+0x168>)
 800ad92:	5513      	strb	r3, [r2, r4]
 800ad94:	e7dd      	b.n	800ad52 <prvUDPCommandInterpreterTask+0xf2>
	xSocket = prvOpenUDPServerSocket( ( uint16_t ) ( ( uint32_t ) pvParameters ) & 0xffffUL );
 800ad96:	4b0d      	ldr	r3, [pc, #52]	; (800adcc <prvUDPCommandInterpreterTask+0x16c>)
 800ad98:	601d      	str	r5, [r3, #0]
 800ad9a:	2400      	movs	r4, #0
			lBytes = FreeRTOS_recvfrom( xSocket, ( void * ) cLocalBuffer, sizeof( cLocalBuffer ), 0, &xClient, &xClientAddressLength );
 800ad9c:	461e      	mov	r6, r3
 800ad9e:	4f10      	ldr	r7, [pc, #64]	; (800ade0 <prvUDPCommandInterpreterTask+0x180>)
								cInputString[ ( int ) cInputIndex ] = '\0';
 800ada0:	4b09      	ldr	r3, [pc, #36]	; (800adc8 <prvUDPCommandInterpreterTask+0x168>)
 800ada2:	9303      	str	r3, [sp, #12]
			lBytes = FreeRTOS_recvfrom( xSocket, ( void * ) cLocalBuffer, sizeof( cLocalBuffer ), 0, &xClient, &xClientAddressLength );
 800ada4:	9701      	str	r7, [sp, #4]
 800ada6:	ab08      	add	r3, sp, #32
 800ada8:	9300      	str	r3, [sp, #0]
 800adaa:	2300      	movs	r3, #0
 800adac:	223c      	movs	r2, #60	; 0x3c
 800adae:	490d      	ldr	r1, [pc, #52]	; (800ade4 <prvUDPCommandInterpreterTask+0x184>)
 800adb0:	6830      	ldr	r0, [r6, #0]
 800adb2:	f7f9 fd3b 	bl	800482c <FreeRTOS_recvfrom>
			if( lBytes > 0 )
 800adb6:	f1b0 0800 	subs.w	r8, r0, #0
 800adba:	ddf3      	ble.n	800ada4 <prvUDPCommandInterpreterTask+0x144>
 800adbc:	4b09      	ldr	r3, [pc, #36]	; (800ade4 <prvUDPCommandInterpreterTask+0x184>)
 800adbe:	f103 3bff 	add.w	fp, r3, #4294967295	; 0xffffffff
 800adc2:	f04f 0a00 	mov.w	sl, #0
 800adc6:	e7c6      	b.n	800ad56 <prvUDPCommandInterpreterTask+0xf6>
 800adc8:	20000ab0 	.word	0x20000ab0
 800adcc:	20000030 	.word	0x20000030
 800add0:	0800ca84 	.word	0x0800ca84
 800add4:	20000b64 	.word	0x20000b64
 800add8:	20000aec 	.word	0x20000aec
 800addc:	0800d0e4 	.word	0x0800d0e4
 800ade0:	20000f64 	.word	0x20000f64
 800ade4:	20000b28 	.word	0x20000b28

0800ade8 <vStartUDPCommandInterpreterTask>:
{
 800ade8:	b500      	push	{lr}
 800adea:	b083      	sub	sp, #12
	xTaskCreate( prvUDPCommandInterpreterTask, "UDP CLI", usStackSize, ( void * ) ulPort, uxPriority, NULL );
 800adec:	2300      	movs	r3, #0
 800adee:	9301      	str	r3, [sp, #4]
 800adf0:	9200      	str	r2, [sp, #0]
 800adf2:	460b      	mov	r3, r1
 800adf4:	4602      	mov	r2, r0
 800adf6:	4903      	ldr	r1, [pc, #12]	; (800ae04 <vStartUDPCommandInterpreterTask+0x1c>)
 800adf8:	4803      	ldr	r0, [pc, #12]	; (800ae08 <vStartUDPCommandInterpreterTask+0x20>)
 800adfa:	f7fe fc03 	bl	8009604 <xTaskCreate>
}
 800adfe:	b003      	add	sp, #12
 800ae00:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae04:	0800d120 	.word	0x0800d120
 800ae08:	0800ac61 	.word	0x0800ac61

0800ae0c <prvConnectionListeningTask>:
	usUsedStackSize = usStackSize;
}
/*-----------------------------------------------------------*/

static void prvConnectionListeningTask( void *pvParameters )
{
 800ae0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ae10:	b08c      	sub	sp, #48	; 0x30
struct freertos_sockaddr xClient, xBindAddress;
Socket_t xListeningSocket, xConnectedSocket;
socklen_t xSize = sizeof( xClient );
 800ae12:	2308      	movs	r3, #8
 800ae14:	9307      	str	r3, [sp, #28]

#if( ipconfigUSE_TCP_WIN == 1 )
	WinProperties_t xWinProps;

	/* Fill in the buffer and window sizes that will be used by the socket. */
	xWinProps.lTxBufSize = ipconfigTCP_TX_BUFFER_LENGTH;
 800ae16:	f640 3368 	movw	r3, #2920	; 0xb68
 800ae1a:	9303      	str	r3, [sp, #12]
	xWinProps.lTxWinSize = configECHO_SERVER_TX_WINDOW_SIZE;
 800ae1c:	2002      	movs	r0, #2
 800ae1e:	9004      	str	r0, [sp, #16]
	xWinProps.lRxBufSize = ipconfigTCP_RX_BUFFER_LENGTH;
 800ae20:	f241 131c 	movw	r3, #4380	; 0x111c
 800ae24:	9305      	str	r3, [sp, #20]
	xWinProps.lRxWinSize = configECHO_SERVER_RX_WINDOW_SIZE;
 800ae26:	9006      	str	r0, [sp, #24]

	/* Just to prevent compiler warnings. */
	( void ) pvParameters;

	/* Attempt to open the socket. */
	xListeningSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800ae28:	2206      	movs	r2, #6
 800ae2a:	2101      	movs	r1, #1
 800ae2c:	f7f9 fc66 	bl	80046fc <FreeRTOS_socket>
 800ae30:	4605      	mov	r5, r0
	configASSERT( xListeningSocket != FREERTOS_INVALID_SOCKET );
 800ae32:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800ae36:	d021      	beq.n	800ae7c <prvConnectionListeningTask+0x70>

	/* Set a time out so accept() will just wait for a connection. */
	FreeRTOS_setsockopt( xListeningSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800ae38:	2304      	movs	r3, #4
 800ae3a:	9300      	str	r3, [sp, #0]
 800ae3c:	4b1d      	ldr	r3, [pc, #116]	; (800aeb4 <prvConnectionListeningTask+0xa8>)
 800ae3e:	2200      	movs	r2, #0
 800ae40:	4611      	mov	r1, r2
 800ae42:	4628      	mov	r0, r5
 800ae44:	f7fa fb60 	bl	8005508 <FreeRTOS_setsockopt>

	/* Set the window and buffer sizes. */
	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		FreeRTOS_setsockopt( xListeningSocket, 0, FREERTOS_SO_WIN_PROPERTIES, ( void * ) &xWinProps, sizeof( xWinProps ) );
 800ae48:	2310      	movs	r3, #16
 800ae4a:	9300      	str	r3, [sp, #0]
 800ae4c:	ab03      	add	r3, sp, #12
 800ae4e:	220d      	movs	r2, #13
 800ae50:	2100      	movs	r1, #0
 800ae52:	4628      	mov	r0, r5
 800ae54:	f7fa fb58 	bl	8005508 <FreeRTOS_setsockopt>
	#endif /* ipconfigUSE_TCP_WIN */

	/* Bind the socket to the port that the client task will send to, then
	listen for incoming connections. */
	xBindAddress.sin_port = tcpechoPORT_NUMBER;
	xBindAddress.sin_port = FreeRTOS_htons( xBindAddress.sin_port );
 800ae58:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 800ae5c:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	FreeRTOS_bind( xListeningSocket, &xBindAddress, sizeof( xBindAddress ) );
 800ae60:	2208      	movs	r2, #8
 800ae62:	a908      	add	r1, sp, #32
 800ae64:	4628      	mov	r0, r5
 800ae66:	f7f9 fd70 	bl	800494a <FreeRTOS_bind>
	FreeRTOS_listen( xListeningSocket, xBacklog );
 800ae6a:	2114      	movs	r1, #20
 800ae6c:	4628      	mov	r0, r5
 800ae6e:	f7fa f9d4 	bl	800521a <FreeRTOS_listen>

	for( ;; )
	{
		/* Wait for a client to connect. */
		xConnectedSocket = FreeRTOS_accept( xListeningSocket, &xClient, &xSize );
		configASSERT( xConnectedSocket != FREERTOS_INVALID_SOCKET );
 800ae72:	f8df 804c 	ldr.w	r8, [pc, #76]	; 800aec0 <prvConnectionListeningTask+0xb4>

		/* Spawn a task to handle the connection. */
		xTaskCreate( prvServerConnectionInstance, "EchoServer", usUsedStackSize, ( void * ) xConnectedSocket, tskIDLE_PRIORITY, NULL );
 800ae76:	4f10      	ldr	r7, [pc, #64]	; (800aeb8 <prvConnectionListeningTask+0xac>)
 800ae78:	4e10      	ldr	r6, [pc, #64]	; (800aebc <prvConnectionListeningTask+0xb0>)
 800ae7a:	e00d      	b.n	800ae98 <prvConnectionListeningTask+0x8c>
	configASSERT( xListeningSocket != FREERTOS_INVALID_SOCKET );
 800ae7c:	21b0      	movs	r1, #176	; 0xb0
 800ae7e:	4810      	ldr	r0, [pc, #64]	; (800aec0 <prvConnectionListeningTask+0xb4>)
 800ae80:	f000 ff44 	bl	800bd0c <vAssertCalled>
 800ae84:	e7d8      	b.n	800ae38 <prvConnectionListeningTask+0x2c>
		xTaskCreate( prvServerConnectionInstance, "EchoServer", usUsedStackSize, ( void * ) xConnectedSocket, tskIDLE_PRIORITY, NULL );
 800ae86:	883a      	ldrh	r2, [r7, #0]
 800ae88:	2300      	movs	r3, #0
 800ae8a:	9301      	str	r3, [sp, #4]
 800ae8c:	9300      	str	r3, [sp, #0]
 800ae8e:	4623      	mov	r3, r4
 800ae90:	4631      	mov	r1, r6
 800ae92:	480c      	ldr	r0, [pc, #48]	; (800aec4 <prvConnectionListeningTask+0xb8>)
 800ae94:	f7fe fbb6 	bl	8009604 <xTaskCreate>
		xConnectedSocket = FreeRTOS_accept( xListeningSocket, &xClient, &xSize );
 800ae98:	aa07      	add	r2, sp, #28
 800ae9a:	a90a      	add	r1, sp, #40	; 0x28
 800ae9c:	4628      	mov	r0, r5
 800ae9e:	f7f9 ff81 	bl	8004da4 <FreeRTOS_accept>
 800aea2:	4604      	mov	r4, r0
		configASSERT( xConnectedSocket != FREERTOS_INVALID_SOCKET );
 800aea4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800aea8:	d1ed      	bne.n	800ae86 <prvConnectionListeningTask+0x7a>
 800aeaa:	21c7      	movs	r1, #199	; 0xc7
 800aeac:	4640      	mov	r0, r8
 800aeae:	f000 ff2d 	bl	800bd0c <vAssertCalled>
 800aeb2:	e7e8      	b.n	800ae86 <prvConnectionListeningTask+0x7a>
 800aeb4:	0800d180 	.word	0x0800d180
 800aeb8:	20000f68 	.word	0x20000f68
 800aebc:	0800d164 	.word	0x0800d164
 800aec0:	0800d128 	.word	0x0800d128
 800aec4:	0800aec9 	.word	0x0800aec9

0800aec8 <prvServerConnectionInstance>:
	}
}
/*-----------------------------------------------------------*/

static void prvServerConnectionInstance( void *pvParameters )
{
 800aec8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800aecc:	b083      	sub	sp, #12
 800aece:	4607      	mov	r7, r0
	xConnectedSocket = ( Socket_t ) pvParameters;

	/* Attempt to create the buffer used to receive the string to be echoed
	back.  This could be avoided using a zero copy interface that just returned
	the same buffer. */
	pucRxBuffer = ( uint8_t * ) pvPortMalloc( ipconfigTCP_MSS );
 800aed0:	f240 50b4 	movw	r0, #1460	; 0x5b4
 800aed4:	f7fd fe98 	bl	8008c08 <pvPortMalloc>

	if( pucRxBuffer != NULL )
 800aed8:	4606      	mov	r6, r0
 800aeda:	b368      	cbz	r0, 800af38 <prvServerConnectionInstance+0x70>
	{
		FreeRTOS_setsockopt( xConnectedSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800aedc:	2404      	movs	r4, #4
 800aede:	9400      	str	r4, [sp, #0]
 800aee0:	4b28      	ldr	r3, [pc, #160]	; (800af84 <prvServerConnectionInstance+0xbc>)
 800aee2:	2200      	movs	r2, #0
 800aee4:	4611      	mov	r1, r2
 800aee6:	4638      	mov	r0, r7
 800aee8:	f7fa fb0e 	bl	8005508 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xConnectedSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xReceiveTimeOut ) );
 800aeec:	9400      	str	r4, [sp, #0]
 800aeee:	4b26      	ldr	r3, [pc, #152]	; (800af88 <prvServerConnectionInstance+0xc0>)
 800aef0:	2201      	movs	r2, #1
 800aef2:	2100      	movs	r1, #0
 800aef4:	4638      	mov	r0, r7
 800aef6:	f7fa fb07 	bl	8005508 <FreeRTOS_setsockopt>

		for( ;; )
		{
			/* Zero out the receive array so there is NULL at the end of the string
			when it is printed out. */
			memset( pucRxBuffer, 0x00, ipconfigTCP_MSS );
 800aefa:	f240 59b4 	movw	r9, #1460	; 0x5b4
 800aefe:	f04f 0800 	mov.w	r8, #0
 800af02:	464a      	mov	r2, r9
 800af04:	4641      	mov	r1, r8
 800af06:	4630      	mov	r0, r6
 800af08:	f001 f8cc 	bl	800c0a4 <memset>

			/* Receive data on the socket. */
			lBytes = FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 );
 800af0c:	4643      	mov	r3, r8
 800af0e:	464a      	mov	r2, r9
 800af10:	4631      	mov	r1, r6
 800af12:	4638      	mov	r0, r7
 800af14:	f7f9 ffdc 	bl	8004ed0 <FreeRTOS_recv>

			/* If data was received, echo it back. */
			if( lBytes >= 0 )
 800af18:	1e05      	subs	r5, r0, #0
 800af1a:	db0d      	blt.n	800af38 <prvServerConnectionInstance+0x70>
			{
				lSent = 0;
				lTotalSent = 0;

				/* Call send() until all the data has been sent. */
				while( ( lSent >= 0 ) && ( lTotalSent < lBytes ) )
 800af1c:	ddf1      	ble.n	800af02 <prvServerConnectionInstance+0x3a>
 800af1e:	2400      	movs	r4, #0
				{
					lSent = FreeRTOS_send( xConnectedSocket, pucRxBuffer, lBytes - lTotalSent, 0 );
 800af20:	4643      	mov	r3, r8
 800af22:	1b2a      	subs	r2, r5, r4
 800af24:	4631      	mov	r1, r6
 800af26:	4638      	mov	r0, r7
 800af28:	f7fa f89c 	bl	8005064 <FreeRTOS_send>
					lTotalSent += lSent;
 800af2c:	4404      	add	r4, r0
				while( ( lSent >= 0 ) && ( lTotalSent < lBytes ) )
 800af2e:	2800      	cmp	r0, #0
 800af30:	db02      	blt.n	800af38 <prvServerConnectionInstance+0x70>
 800af32:	42a5      	cmp	r5, r4
 800af34:	dcf4      	bgt.n	800af20 <prvServerConnectionInstance+0x58>
 800af36:	e7e4      	b.n	800af02 <prvServerConnectionInstance+0x3a>
			}
		}
	}

	/* Initiate a shutdown in case it has not already been initiated. */
	FreeRTOS_shutdown( xConnectedSocket, FREERTOS_SHUT_RDWR );
 800af38:	2102      	movs	r1, #2
 800af3a:	4638      	mov	r0, r7
 800af3c:	f7fa f9b5 	bl	80052aa <FreeRTOS_shutdown>

	/* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
	returning an error. */
	xTimeOnShutdown = xTaskGetTickCount();
 800af40:	f7fe fd3e 	bl	80099c0 <xTaskGetTickCount>
 800af44:	4681      	mov	r9, r0
	do
	{
		if( FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 ) < 0 )
 800af46:	2500      	movs	r5, #0
 800af48:	f240 54b4 	movw	r4, #1460	; 0x5b4
		{
			break;
		}
	} while( ( xTaskGetTickCount() - xTimeOnShutdown ) < tcpechoSHUTDOWN_DELAY );
 800af4c:	f241 3887 	movw	r8, #4999	; 0x1387
		if( FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 ) < 0 )
 800af50:	462b      	mov	r3, r5
 800af52:	4622      	mov	r2, r4
 800af54:	4631      	mov	r1, r6
 800af56:	4638      	mov	r0, r7
 800af58:	f7f9 ffba 	bl	8004ed0 <FreeRTOS_recv>
 800af5c:	2800      	cmp	r0, #0
 800af5e:	db05      	blt.n	800af6c <prvServerConnectionInstance+0xa4>
	} while( ( xTaskGetTickCount() - xTimeOnShutdown ) < tcpechoSHUTDOWN_DELAY );
 800af60:	f7fe fd2e 	bl	80099c0 <xTaskGetTickCount>
 800af64:	eba0 0009 	sub.w	r0, r0, r9
 800af68:	4540      	cmp	r0, r8
 800af6a:	d9f1      	bls.n	800af50 <prvServerConnectionInstance+0x88>

	/* Finished with the socket, buffer, the task. */
	vPortFree( pucRxBuffer );
 800af6c:	4630      	mov	r0, r6
 800af6e:	f7fd feb1 	bl	8008cd4 <vPortFree>
	FreeRTOS_closesocket( xConnectedSocket );
 800af72:	4638      	mov	r0, r7
 800af74:	f7f9 fe24 	bl	8004bc0 <FreeRTOS_closesocket>

	vTaskDelete( NULL );
 800af78:	2000      	movs	r0, #0
 800af7a:	f7fe fc2b 	bl	80097d4 <vTaskDelete>
}
 800af7e:	b003      	add	sp, #12
 800af80:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800af84:	0800d184 	.word	0x0800d184
 800af88:	0800d188 	.word	0x0800d188

0800af8c <vStartSimpleTCPServerTasks>:
{
 800af8c:	b510      	push	{r4, lr}
 800af8e:	b082      	sub	sp, #8
 800af90:	4604      	mov	r4, r0
	xTaskCreate( prvConnectionListeningTask, "ServerListener", usStackSize, NULL, uxPriority + 1, NULL );
 800af92:	2300      	movs	r3, #0
 800af94:	9301      	str	r3, [sp, #4]
 800af96:	3101      	adds	r1, #1
 800af98:	9100      	str	r1, [sp, #0]
 800af9a:	4602      	mov	r2, r0
 800af9c:	4903      	ldr	r1, [pc, #12]	; (800afac <vStartSimpleTCPServerTasks+0x20>)
 800af9e:	4804      	ldr	r0, [pc, #16]	; (800afb0 <vStartSimpleTCPServerTasks+0x24>)
 800afa0:	f7fe fb30 	bl	8009604 <xTaskCreate>
	usUsedStackSize = usStackSize;
 800afa4:	4b03      	ldr	r3, [pc, #12]	; (800afb4 <vStartSimpleTCPServerTasks+0x28>)
 800afa6:	801c      	strh	r4, [r3, #0]
}
 800afa8:	b002      	add	sp, #8
 800afaa:	bd10      	pop	{r4, pc}
 800afac:	0800d170 	.word	0x0800d170
 800afb0:	0800ae0d 	.word	0x0800ae0d
 800afb4:	20000f68 	.word	0x20000f68

0800afb8 <prvEchoClientTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvEchoClientTask( void *pvParameters )
{
 800afb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800afbc:	b08d      	sub	sp, #52	; 0x34
Socket_t xSocket;
struct freertos_sockaddr xEchoServerAddress;
int32_t lLoopCount = 0UL;
const int32_t lMaxLoopCount = 1;
volatile uint32_t ulTxCount = 0UL;
 800afbe:	2300      	movs	r3, #0
 800afc0:	9309      	str	r3, [sp, #36]	; 0x24
	#if( ipconfigUSE_TCP_WIN == 1 )

	WinProperties_t xWinProps;

		/* Fill in the buffer and window sizes that will be used by the socket. */
		xWinProps.lTxBufSize = ipconfigTCP_TX_BUFFER_LENGTH;
 800afc2:	f640 3368 	movw	r3, #2920	; 0xb68
 800afc6:	9305      	str	r3, [sp, #20]
		xWinProps.lTxWinSize = configECHO_CLIENT_TX_WINDOW_SIZE;
 800afc8:	2202      	movs	r2, #2
 800afca:	9206      	str	r2, [sp, #24]
		xWinProps.lRxBufSize = ipconfigTCP_RX_BUFFER_LENGTH;
 800afcc:	f241 111c 	movw	r1, #4380	; 0x111c
 800afd0:	9107      	str	r1, [sp, #28]
		xWinProps.lRxWinSize = configECHO_CLIENT_RX_WINDOW_SIZE;
 800afd2:	9208      	str	r2, [sp, #32]
	#endif /* ipconfigUSE_TCP_WIN */

	/* This task can be created a number of times.  Each instance is numbered
	to enable each instance to use a different Rx and Tx buffer.  The number is
	passed in as the task's parameter. */
	xInstance = ( BaseType_t ) pvParameters;
 800afd4:	4683      	mov	fp, r0
 800afd6:	fb00 f303 	mul.w	r3, r0, r3

	/* Point to the buffers to be used by this instance of this task. */
	pcTransmittedString = &( cTxBuffers[ xInstance ][ 0 ] );
 800afda:	4a67      	ldr	r2, [pc, #412]	; (800b178 <prvEchoClientTask+0x1c0>)
 800afdc:	441a      	add	r2, r3
 800afde:	9202      	str	r2, [sp, #8]
	pcReceivedString = &( cRxBuffers[ xInstance ][ 0 ] );
 800afe0:	4f66      	ldr	r7, [pc, #408]	; (800b17c <prvEchoClientTask+0x1c4>)
 800afe2:	441f      	add	r7, r3

	/* Echo requests are sent to the echo server.  The address of the echo
	server is configured by the constants configECHO_SERVER_ADDR0 to
	configECHO_SERVER_ADDR3 in FreeRTOSConfig.h. */
	xEchoServerAddress.sin_port = FreeRTOS_htons( echoECHO_PORT );
 800afe4:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 800afe8:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
	xEchoServerAddress.sin_addr = FreeRTOS_inet_addr_quick( configECHO_SERVER_ADDR0,
 800afec:	4b64      	ldr	r3, [pc, #400]	; (800b180 <prvEchoClientTask+0x1c8>)
 800afee:	930b      	str	r3, [sp, #44]	; 0x2c

	/* Randomise the number of characters that will be sent in the echo
	request. */
	do
	{
		lCharactersToAdd = ipconfigRAND32() % ( ulBufferLength - 20UL );
 800aff0:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 800b1a0 <prvEchoClientTask+0x1e8>
	} while ( ( lCharactersToAdd == 0 ) || ( lCharactersToAdd < lMinimumLength ) ); /* Must be at least enough to add the unique text to the start of the string later. */

	/* Fill the buffer. */
	for( lCharacter = 0; lCharacter < lCharactersToAdd; lCharacter++ )
	{
		cBuffer[ lCharacter ] = cChar;
 800aff4:	4b60      	ldr	r3, [pc, #384]	; (800b178 <prvEchoClientTask+0x1c0>)
 800aff6:	f640 3268 	movw	r2, #2920	; 0xb68
 800affa:	fb02 3300 	mla	r3, r2, r0, r3
 800affe:	9303      	str	r3, [sp, #12]
 800b000:	e062      	b.n	800b0c8 <prvEchoClientTask+0x110>
		configASSERT( xSocket != FREERTOS_INVALID_SOCKET );
 800b002:	21eb      	movs	r1, #235	; 0xeb
 800b004:	485f      	ldr	r0, [pc, #380]	; (800b184 <prvEchoClientTask+0x1cc>)
 800b006:	f000 fe81 	bl	800bd0c <vAssertCalled>
 800b00a:	e066      	b.n	800b0da <prvEchoClientTask+0x122>
		cBuffer[ lCharacter ] = cChar;
 800b00c:	f802 3b01 	strb.w	r3, [r2], #1
		cChar++;
 800b010:	3301      	adds	r3, #1
 800b012:	b2db      	uxtb	r3, r3

		if( cChar > '~' )
		{
			cChar = '0';
 800b014:	2b7f      	cmp	r3, #127	; 0x7f
 800b016:	bf28      	it	cs
 800b018:	2330      	movcs	r3, #48	; 0x30
	for( lCharacter = 0; lCharacter < lCharactersToAdd; lCharacter++ )
 800b01a:	4291      	cmp	r1, r2
 800b01c:	d1f6      	bne.n	800b00c <prvEchoClientTask+0x54>
				sprintf( pcTransmittedString, "TxRx message number %u", ( unsigned ) ulTxCount );
 800b01e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b020:	4959      	ldr	r1, [pc, #356]	; (800b188 <prvEchoClientTask+0x1d0>)
 800b022:	f8dd 9008 	ldr.w	r9, [sp, #8]
 800b026:	4648      	mov	r0, r9
 800b028:	f000 fbb9 	bl	800b79e <sprintf>
				ulTxCount++;
 800b02c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b02e:	3301      	adds	r3, #1
 800b030:	9309      	str	r3, [sp, #36]	; 0x24
				lTransmitted = FreeRTOS_send(	xSocket,						/* The socket being sent to. */
 800b032:	2300      	movs	r3, #0
 800b034:	4622      	mov	r2, r4
 800b036:	4649      	mov	r1, r9
 800b038:	4630      	mov	r0, r6
 800b03a:	f7fa f813 	bl	8005064 <FreeRTOS_send>
				if( lTransmitted < 0 )
 800b03e:	1e04      	subs	r4, r0, #0
 800b040:	db26      	blt.n	800b090 <prvEchoClientTask+0xd8>
				memset( ( void * ) pcReceivedString, 0x00, echoBUFFER_SIZES );
 800b042:	f640 3268 	movw	r2, #2920	; 0xb68
 800b046:	2100      	movs	r1, #0
 800b048:	4638      	mov	r0, r7
 800b04a:	f001 f82b 	bl	800c0a4 <memset>
				while( xReceivedBytes < lTransmitted )
 800b04e:	2c00      	cmp	r4, #0
 800b050:	dd1e      	ble.n	800b090 <prvEchoClientTask+0xd8>
					xReturned = FreeRTOS_recv( xSocket,								/* The socket being received from. */
 800b052:	2300      	movs	r3, #0
 800b054:	eba8 0205 	sub.w	r2, r8, r5
 800b058:	1979      	adds	r1, r7, r5
 800b05a:	4630      	mov	r0, r6
 800b05c:	f7f9 ff38 	bl	8004ed0 <FreeRTOS_recv>
					if( xReturned < 0 )
 800b060:	2800      	cmp	r0, #0
 800b062:	db06      	blt.n	800b072 <prvEchoClientTask+0xba>
					else if( xReturned == 0 )
 800b064:	b120      	cbz	r0, 800b070 <prvEchoClientTask+0xb8>
						xReceivedBytes += xReturned;
 800b066:	4405      	add	r5, r0
				while( xReceivedBytes < lTransmitted )
 800b068:	42ac      	cmp	r4, r5
 800b06a:	dcf2      	bgt.n	800b052 <prvEchoClientTask+0x9a>
						xReceivedBytes += xReturned;
 800b06c:	4628      	mov	r0, r5
 800b06e:	e000      	b.n	800b072 <prvEchoClientTask+0xba>
 800b070:	4628      	mov	r0, r5
				if( xReceivedBytes > 0 )
 800b072:	2800      	cmp	r0, #0
 800b074:	dd0c      	ble.n	800b090 <prvEchoClientTask+0xd8>
					configASSERT( strncmp( pcReceivedString, pcTransmittedString, lTransmitted ) == 0 );
 800b076:	4622      	mov	r2, r4
 800b078:	9902      	ldr	r1, [sp, #8]
 800b07a:	4638      	mov	r0, r7
 800b07c:	f001 f836 	bl	800c0ec <strncmp>
 800b080:	2800      	cmp	r0, #0
 800b082:	d166      	bne.n	800b152 <prvEchoClientTask+0x19a>
						ulTxRxCycles[ xInstance ]++;
 800b084:	4a41      	ldr	r2, [pc, #260]	; (800b18c <prvEchoClientTask+0x1d4>)
 800b086:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 800b08a:	3301      	adds	r3, #1
 800b08c:	f842 302b 	str.w	r3, [r2, fp, lsl #2]
			FreeRTOS_shutdown( xSocket, FREERTOS_SHUT_RDWR );
 800b090:	2102      	movs	r1, #2
 800b092:	4630      	mov	r0, r6
 800b094:	f7fa f909 	bl	80052aa <FreeRTOS_shutdown>
			xTimeOnEntering = xTaskGetTickCount();
 800b098:	f7fe fc92 	bl	80099c0 <xTaskGetTickCount>
 800b09c:	4604      	mov	r4, r0
				xReturned = FreeRTOS_recv( xSocket,	/* The socket being received from. */
 800b09e:	2300      	movs	r3, #0
 800b0a0:	f640 3268 	movw	r2, #2920	; 0xb68
 800b0a4:	4639      	mov	r1, r7
 800b0a6:	4630      	mov	r0, r6
 800b0a8:	f7f9 ff12 	bl	8004ed0 <FreeRTOS_recv>
				if( xReturned < 0 )
 800b0ac:	2800      	cmp	r0, #0
 800b0ae:	db05      	blt.n	800b0bc <prvEchoClientTask+0x104>
			} while( ( xTaskGetTickCount() - xTimeOnEntering ) < xReceiveTimeOut );
 800b0b0:	f7fe fc86 	bl	80099c0 <xTaskGetTickCount>
 800b0b4:	1b00      	subs	r0, r0, r4
 800b0b6:	f5b0 6f7a 	cmp.w	r0, #4000	; 0xfa0
 800b0ba:	d3f0      	bcc.n	800b09e <prvEchoClientTask+0xe6>
		FreeRTOS_closesocket( xSocket );
 800b0bc:	4630      	mov	r0, r6
 800b0be:	f7f9 fd7f 	bl	8004bc0 <FreeRTOS_closesocket>
		vTaskDelay( echoLOOP_DELAY );
 800b0c2:	2096      	movs	r0, #150	; 0x96
 800b0c4:	f7fe fdce 	bl	8009c64 <vTaskDelay>
		xSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800b0c8:	2206      	movs	r2, #6
 800b0ca:	2101      	movs	r1, #1
 800b0cc:	2002      	movs	r0, #2
 800b0ce:	f7f9 fb15 	bl	80046fc <FreeRTOS_socket>
 800b0d2:	4606      	mov	r6, r0
		configASSERT( xSocket != FREERTOS_INVALID_SOCKET );
 800b0d4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b0d8:	d093      	beq.n	800b002 <prvEchoClientTask+0x4a>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800b0da:	2404      	movs	r4, #4
 800b0dc:	9400      	str	r4, [sp, #0]
 800b0de:	4b2c      	ldr	r3, [pc, #176]	; (800b190 <prvEchoClientTask+0x1d8>)
 800b0e0:	2200      	movs	r2, #0
 800b0e2:	4611      	mov	r1, r2
 800b0e4:	4630      	mov	r0, r6
 800b0e6:	f7fa fa0f 	bl	8005508 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800b0ea:	9400      	str	r4, [sp, #0]
 800b0ec:	4b29      	ldr	r3, [pc, #164]	; (800b194 <prvEchoClientTask+0x1dc>)
 800b0ee:	2201      	movs	r2, #1
 800b0f0:	2100      	movs	r1, #0
 800b0f2:	4630      	mov	r0, r6
 800b0f4:	f7fa fa08 	bl	8005508 <FreeRTOS_setsockopt>
			FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_WIN_PROPERTIES, ( void * ) &xWinProps,	sizeof( xWinProps ) );
 800b0f8:	2310      	movs	r3, #16
 800b0fa:	9300      	str	r3, [sp, #0]
 800b0fc:	ab05      	add	r3, sp, #20
 800b0fe:	220d      	movs	r2, #13
 800b100:	2100      	movs	r1, #0
 800b102:	4630      	mov	r0, r6
 800b104:	f7fa fa00 	bl	8005508 <FreeRTOS_setsockopt>
		if( FreeRTOS_connect( xSocket, &xEchoServerAddress, sizeof( xEchoServerAddress ) ) == 0 )
 800b108:	2208      	movs	r2, #8
 800b10a:	a90a      	add	r1, sp, #40	; 0x28
 800b10c:	4630      	mov	r0, r6
 800b10e:	f7fa fb49 	bl	80057a4 <FreeRTOS_connect>
 800b112:	4605      	mov	r5, r0
 800b114:	2800      	cmp	r0, #0
 800b116:	d1d1      	bne.n	800b0bc <prvEchoClientTask+0x104>
			ulConnections[ xInstance ]++;
 800b118:	4a1f      	ldr	r2, [pc, #124]	; (800b198 <prvEchoClientTask+0x1e0>)
 800b11a:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 800b11e:	3301      	adds	r3, #1
 800b120:	f842 302b 	str.w	r3, [r2, fp, lsl #2]
		lCharactersToAdd = ipconfigRAND32() % ( ulBufferLength - 20UL );
 800b124:	f640 3954 	movw	r9, #2900	; 0xb54
 800b128:	f000 feb6 	bl	800be98 <uxRand>
 800b12c:	fbaa 3400 	umull	r3, r4, sl, r0
 800b130:	0ae4      	lsrs	r4, r4, #11
 800b132:	fb09 0414 	mls	r4, r9, r4, r0
 800b136:	46a0      	mov	r8, r4
	} while ( ( lCharactersToAdd == 0 ) || ( lCharactersToAdd < lMinimumLength ) ); /* Must be at least enough to add the unique text to the start of the string later. */
 800b138:	2c3b      	cmp	r4, #59	; 0x3b
 800b13a:	ddf5      	ble.n	800b128 <prvEchoClientTask+0x170>
	for( lCharacter = 0; lCharacter < lCharactersToAdd; lCharacter++ )
 800b13c:	2c00      	cmp	r4, #0
 800b13e:	f77f af6e 	ble.w	800b01e <prvEchoClientTask+0x66>
		cBuffer[ lCharacter ] = cChar;
 800b142:	2330      	movs	r3, #48	; 0x30
 800b144:	9a03      	ldr	r2, [sp, #12]
 800b146:	7013      	strb	r3, [r2, #0]
 800b148:	9b02      	ldr	r3, [sp, #8]
 800b14a:	1c5a      	adds	r2, r3, #1
 800b14c:	1919      	adds	r1, r3, r4
		cChar++;
 800b14e:	2331      	movs	r3, #49	; 0x31
 800b150:	e763      	b.n	800b01a <prvEchoClientTask+0x62>
					configASSERT( strncmp( pcReceivedString, pcTransmittedString, lTransmitted ) == 0 );
 800b152:	f44f 719d 	mov.w	r1, #314	; 0x13a
 800b156:	480b      	ldr	r0, [pc, #44]	; (800b184 <prvEchoClientTask+0x1cc>)
 800b158:	f000 fdd8 	bl	800bd0c <vAssertCalled>
					if( strncmp( pcReceivedString, pcTransmittedString, lTransmitted ) == 0 )
 800b15c:	4622      	mov	r2, r4
 800b15e:	9902      	ldr	r1, [sp, #8]
 800b160:	4638      	mov	r0, r7
 800b162:	f000 ffc3 	bl	800c0ec <strncmp>
 800b166:	2800      	cmp	r0, #0
 800b168:	d08c      	beq.n	800b084 <prvEchoClientTask+0xcc>
						ulTxRxFailures[ xInstance ]++;
 800b16a:	4a0c      	ldr	r2, [pc, #48]	; (800b19c <prvEchoClientTask+0x1e4>)
 800b16c:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 800b170:	3301      	adds	r3, #1
 800b172:	f842 302b 	str.w	r3, [r2, fp, lsl #2]
						break;
 800b176:	e78b      	b.n	800b090 <prvEchoClientTask+0xd8>
 800b178:	20001ad4 	.word	0x20001ad4
 800b17c:	20000f6c 	.word	0x20000f6c
 800b180:	6400a8c0 	.word	0x6400a8c0
 800b184:	0800d18c 	.word	0x0800d18c
 800b188:	0800d1d0 	.word	0x0800d1d0
 800b18c:	20002640 	.word	0x20002640
 800b190:	0800d1f0 	.word	0x0800d1f0
 800b194:	0800d1f4 	.word	0x0800d1f4
 800b198:	2000263c 	.word	0x2000263c
 800b19c:	20002644 	.word	0x20002644
 800b1a0:	b4c9f9a5 	.word	0xb4c9f9a5

0800b1a4 <vStartTCPEchoClientTasks_SingleTasks>:
{
 800b1a4:	b500      	push	{lr}
 800b1a6:	b083      	sub	sp, #12
		xTaskCreate( 	prvEchoClientTask,	/* The function that implements the task. */
 800b1a8:	2300      	movs	r3, #0
 800b1aa:	9301      	str	r3, [sp, #4]
 800b1ac:	9100      	str	r1, [sp, #0]
 800b1ae:	4602      	mov	r2, r0
 800b1b0:	4903      	ldr	r1, [pc, #12]	; (800b1c0 <vStartTCPEchoClientTasks_SingleTasks+0x1c>)
 800b1b2:	4804      	ldr	r0, [pc, #16]	; (800b1c4 <vStartTCPEchoClientTasks_SingleTasks+0x20>)
 800b1b4:	f7fe fa26 	bl	8009604 <xTaskCreate>
}
 800b1b8:	b003      	add	sp, #12
 800b1ba:	f85d fb04 	ldr.w	pc, [sp], #4
 800b1be:	bf00      	nop
 800b1c0:	0800d1e8 	.word	0x0800d1e8
 800b1c4:	0800afb9 	.word	0x0800afb9

0800b1c8 <prvIncrementEventCount>:
{
	/* Each row in the xIPTraceValues[] table contains a pointer to a function
	that updates the value for that row.  Rows that simply increment an event
	count point to this function. */
	( void ) ulCount;
	( *pulCurrentValue )++;
 800b1c8:	6803      	ldr	r3, [r0, #0]
 800b1ca:	3301      	adds	r3, #1
 800b1cc:	6003      	str	r3, [r0, #0]
 800b1ce:	4770      	bx	lr

0800b1d0 <prvStoreLowest>:
	/* Each row in the xIPTraceValues[] table contains a pointer to a function
	that updates the value for that row.  Rows that latch the lowest value
	point to this function (for example, this function can be used to latch
	the lowest number of network buffers that were available during the
	execution of the stack). */
	if( ulCount < *pulCurrentValue )
 800b1d0:	6803      	ldr	r3, [r0, #0]
 800b1d2:	428b      	cmp	r3, r1
	{
		*pulCurrentValue = ulCount;
 800b1d4:	bf88      	it	hi
 800b1d6:	6001      	strhi	r1, [r0, #0]
 800b1d8:	4770      	bx	lr

0800b1da <xExampleDebugStatEntries>:
}
 800b1da:	2014      	movs	r0, #20
 800b1dc:	4770      	bx	lr
	...

0800b1e0 <vExampleDebugStatUpdate>:
{
 800b1e0:	b510      	push	{r4, lr}
		if( xIPTraceValues[ xIndex ].ucIdentifier == ucIdentifier )
 800b1e2:	4b0f      	ldr	r3, [pc, #60]	; (800b220 <vExampleDebugStatUpdate+0x40>)
 800b1e4:	781b      	ldrb	r3, [r3, #0]
 800b1e6:	4283      	cmp	r3, r0
 800b1e8:	d00d      	beq.n	800b206 <vExampleDebugStatUpdate+0x26>
 800b1ea:	4b0d      	ldr	r3, [pc, #52]	; (800b220 <vExampleDebugStatUpdate+0x40>)
	for( xIndex = 0; xIndex < xEntries; xIndex++ )
 800b1ec:	2401      	movs	r4, #1
		if( xIPTraceValues[ xIndex ].ucIdentifier == ucIdentifier )
 800b1ee:	7c1a      	ldrb	r2, [r3, #16]
 800b1f0:	4282      	cmp	r2, r0
 800b1f2:	d009      	beq.n	800b208 <vExampleDebugStatUpdate+0x28>
	for( xIndex = 0; xIndex < xEntries; xIndex++ )
 800b1f4:	3401      	adds	r4, #1
 800b1f6:	3310      	adds	r3, #16
 800b1f8:	2c14      	cmp	r4, #20
 800b1fa:	d1f8      	bne.n	800b1ee <vExampleDebugStatUpdate+0xe>
	configASSERT( xIndex != xEntries );
 800b1fc:	21bd      	movs	r1, #189	; 0xbd
 800b1fe:	4809      	ldr	r0, [pc, #36]	; (800b224 <vExampleDebugStatUpdate+0x44>)
 800b200:	f000 fd84 	bl	800bd0c <vAssertCalled>
}
 800b204:	e00a      	b.n	800b21c <vExampleDebugStatUpdate+0x3c>
	for( xIndex = 0; xIndex < xEntries; xIndex++ )
 800b206:	2400      	movs	r4, #0
			xIPTraceValues[ xIndex ].vPerformAction( &( xIPTraceValues[ xIndex ].ulData ), ulValue );
 800b208:	4a05      	ldr	r2, [pc, #20]	; (800b220 <vExampleDebugStatUpdate+0x40>)
 800b20a:	0123      	lsls	r3, r4, #4
 800b20c:	f103 000c 	add.w	r0, r3, #12
 800b210:	4413      	add	r3, r2
 800b212:	689b      	ldr	r3, [r3, #8]
 800b214:	4410      	add	r0, r2
 800b216:	4798      	blx	r3
	configASSERT( xIndex != xEntries );
 800b218:	2c14      	cmp	r4, #20
 800b21a:	d0ef      	beq.n	800b1fc <vExampleDebugStatUpdate+0x1c>
 800b21c:	bd10      	pop	{r4, pc}
 800b21e:	bf00      	nop
 800b220:	20000034 	.word	0x20000034
 800b224:	0800d540 	.word	0x0800d540

0800b228 <prvLoggingTask>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void prvLoggingTask( void *pvParameters )
{
 800b228:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b22c:	b089      	sub	sp, #36	; 0x24
	( void ) pvParameters;

	/* A possibility to set some additional task properties. */
	iptraceUDP_LOGGING_TASK_STARTING();

	xRemoteAddress.sin_port = FreeRTOS_htons( configUDP_LOGGING_PORT_REMOTE );
 800b22e:	f64d 4305 	movw	r3, #56325	; 0xdc05
 800b232:	f8ad 3012 	strh.w	r3, [sp, #18]
	#if defined( configUDP_LOGGING_ADDR0 )
	{
		/* Use a fixed address to where the logging will be sent. */
		xRemoteAddress.sin_addr = FreeRTOS_inet_addr_quick( configUDP_LOGGING_ADDR0,
 800b236:	4b62      	ldr	r3, [pc, #392]	; (800b3c0 <prvLoggingTask+0x198>)
 800b238:	9305      	str	r3, [sp, #20]
	#endif

	/* Loop until a socket is created. */
	do
	{
		vTaskDelay( xBlockingTime );
 800b23a:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
		xUDPLoggingSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800b23e:	2511      	movs	r5, #17
 800b240:	4c60      	ldr	r4, [pc, #384]	; (800b3c4 <prvLoggingTask+0x19c>)
		vTaskDelay( xBlockingTime );
 800b242:	4630      	mov	r0, r6
 800b244:	f7fe fd0e 	bl	8009c64 <vTaskDelay>
		xUDPLoggingSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800b248:	462a      	mov	r2, r5
 800b24a:	2102      	movs	r1, #2
 800b24c:	4608      	mov	r0, r1
 800b24e:	f7f9 fa55 	bl	80046fc <FreeRTOS_socket>
 800b252:	6020      	str	r0, [r4, #0]
	} while( xUDPLoggingSocket == FREERTOS_INVALID_SOCKET );
 800b254:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b258:	d0f3      	beq.n	800b242 <prvLoggingTask+0x1a>

	xLocalAddress.sin_port = FreeRTOS_htons( configUDP_LOGGING_PORT_LOCAL );
 800b25a:	f64d 3305 	movw	r3, #56069	; 0xdb05
 800b25e:	f8ad 301a 	strh.w	r3, [sp, #26]
	xLocalAddress.sin_addr = FreeRTOS_GetIPAddress();
 800b262:	f7f9 f9b1 	bl	80045c8 <FreeRTOS_GetIPAddress>
 800b266:	9007      	str	r0, [sp, #28]

	FreeRTOS_bind( xUDPLoggingSocket, &xLocalAddress, sizeof( xLocalAddress ) );
 800b268:	4e56      	ldr	r6, [pc, #344]	; (800b3c4 <prvLoggingTask+0x19c>)
 800b26a:	2208      	movs	r2, #8
 800b26c:	a906      	add	r1, sp, #24
 800b26e:	6830      	ldr	r0, [r6, #0]
 800b270:	f7f9 fb6b 	bl	800494a <FreeRTOS_bind>

	xSendTimeOut = xBlockingTime;
 800b274:	ab08      	add	r3, sp, #32
 800b276:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b27a:	f843 2d14 	str.w	r2, [r3, #-20]!
	FreeRTOS_setsockopt( xUDPLoggingSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800b27e:	2204      	movs	r2, #4
 800b280:	9200      	str	r2, [sp, #0]
 800b282:	2201      	movs	r2, #1
 800b284:	2100      	movs	r1, #0
 800b286:	6830      	ldr	r0, [r6, #0]
 800b288:	f7fa f93e 	bl	8005508 <FreeRTOS_setsockopt>

	/* Send a dummy message to resolve the IP address before sending the logging 
	messages. */
	snprintf( cLoggingLine, configUDP_LOGGING_STRING_LENGTH, "Logging Probe\n" );
 800b28c:	4d4e      	ldr	r5, [pc, #312]	; (800b3c8 <prvLoggingTask+0x1a0>)
 800b28e:	4b4f      	ldr	r3, [pc, #316]	; (800b3cc <prvLoggingTask+0x1a4>)
 800b290:	462c      	mov	r4, r5
 800b292:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800b294:	c407      	stmia	r4!, {r0, r1, r2}
 800b296:	f824 3b02 	strh.w	r3, [r4], #2
 800b29a:	0c1b      	lsrs	r3, r3, #16
 800b29c:	7023      	strb	r3, [r4, #0]
	FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, strlen( cLoggingLine ), 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
 800b29e:	4628      	mov	r0, r5
 800b2a0:	f7f4 ff96 	bl	80001d0 <strlen>
 800b2a4:	6834      	ldr	r4, [r6, #0]
 800b2a6:	2308      	movs	r3, #8
 800b2a8:	9301      	str	r3, [sp, #4]
 800b2aa:	ab04      	add	r3, sp, #16
 800b2ac:	9300      	str	r3, [sp, #0]
 800b2ae:	2300      	movs	r3, #0
 800b2b0:	4602      	mov	r2, r0
 800b2b2:	4629      	mov	r1, r5
 800b2b4:	4620      	mov	r0, r4
 800b2b6:	f7f9 fb7f 	bl	80049b8 <FreeRTOS_sendto>
	vTaskDelay( xResolveDelay );
 800b2ba:	20fa      	movs	r0, #250	; 0xfa
 800b2bc:	f7fe fcd2 	bl	8009c64 <vTaskDelay>
	if( pxStreamBuffer != NULL )
 800b2c0:	4f43      	ldr	r7, [pc, #268]	; (800b3d0 <prvLoggingTask+0x1a8>)
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) xLogEntry.cMessage, xMessageLength, pdFALSE );
 800b2c2:	f8df 8110 	ldr.w	r8, [pc, #272]	; 800b3d4 <prvLoggingTask+0x1ac>
 800b2c6:	e06c      	b.n	800b3a2 <prvLoggingTask+0x17a>
			vTaskSuspendAll();
 800b2c8:	f7fe fb72 	bl	80099b0 <vTaskSuspendAll>
				uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) &xMessageLength, sizeof( xMessageLength ), pdFALSE );
 800b2cc:	2100      	movs	r1, #0
 800b2ce:	9100      	str	r1, [sp, #0]
 800b2d0:	2304      	movs	r3, #4
 800b2d2:	aa02      	add	r2, sp, #8
 800b2d4:	6838      	ldr	r0, [r7, #0]
 800b2d6:	f7fa fcd4 	bl	8005c82 <uxStreamBufferGet>
				if( xBufferLength < xMessageLength )
 800b2da:	9b02      	ldr	r3, [sp, #8]
 800b2dc:	2bc8      	cmp	r3, #200	; 0xc8
 800b2de:	d922      	bls.n	800b326 <prvLoggingTask+0xfe>
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) xLogEntry.cMessage, xMessageLength, pdFALSE );
 800b2e0:	2500      	movs	r5, #0
 800b2e2:	9500      	str	r5, [sp, #0]
 800b2e4:	4642      	mov	r2, r8
 800b2e6:	4629      	mov	r1, r5
 800b2e8:	6838      	ldr	r0, [r7, #0]
 800b2ea:	f7fa fcca 	bl	8005c82 <uxStreamBufferGet>
					memcpy( pcBuffer, xLogEntry.cMessage, xBufferLength );
 800b2ee:	f04f 09c8 	mov.w	r9, #200	; 0xc8
 800b2f2:	464a      	mov	r2, r9
 800b2f4:	4641      	mov	r1, r8
 800b2f6:	4620      	mov	r0, r4
 800b2f8:	f000 feaf 	bl	800c05a <memcpy>
					xMessageLength = xBufferLength;
 800b2fc:	f8cd 9008 	str.w	r9, [sp, #8]
					pcBuffer[ xBufferLength - 1 ] = 0x00;
 800b300:	f884 50c7 	strb.w	r5, [r4, #199]	; 0xc7
			xTaskResumeAll();
 800b304:	f7fe fc2e 	bl	8009b64 <xTaskResumeAll>
	return xMessageLength;
 800b308:	9a02      	ldr	r2, [sp, #8]
			/* Check for messages in the buffer. */
			for( lLines = 0; lLines < configUDP_LOGGING_MAX_MESSAGES_IN_BUFFER; lLines++ )
			{
				xCount = prvGetMessageFromStreamBuffer ( cLoggingLine, sizeof( cLoggingLine ) );

				if( xCount <= 0 )
 800b30a:	2a00      	cmp	r2, #0
 800b30c:	d049      	beq.n	800b3a2 <prvLoggingTask+0x17a>
					newline.  If 'configUDP_LOGGING_NEEDS_CR_LF' is defined as non-zero,
					every "\n" will be translated into a "\r\n". */
					pcTarget = cLoggingLine;
					pcSource = cLoggingLine;

					while( ( *pcSource != 0x00 ) && ( pcSource < ( cLoggingLine + xCount ) ) )
 800b30e:	7820      	ldrb	r0, [r4, #0]
 800b310:	b368      	cbz	r0, 800b36e <prvLoggingTask+0x146>
 800b312:	18a3      	adds	r3, r4, r2
 800b314:	429c      	cmp	r4, r3
 800b316:	d22a      	bcs.n	800b36e <prvLoggingTask+0x146>
 800b318:	4b2b      	ldr	r3, [pc, #172]	; (800b3c8 <prvLoggingTask+0x1a0>)
 800b31a:	4619      	mov	r1, r3
					{
						*pcTarget = *pcSource;

						if( ( ( pcSource == cLoggingLine ) || ( pcSource[ -1 ] != logASCII_CR ) ) && ( pcSource[ 0 ] == logASCII_NL ) )
						{
							pcTarget[ 0 ] = logASCII_CR;
 800b31c:	f04f 0c0d 	mov.w	ip, #13
							pcTarget[ 1 ] = logASCII_NL;
 800b320:	f04f 0e0a 	mov.w	lr, #10
 800b324:	e010      	b.n	800b348 <prvLoggingTask+0x120>
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) pcBuffer, xMessageLength, pdFALSE );
 800b326:	2500      	movs	r5, #0
 800b328:	9500      	str	r5, [sp, #0]
 800b32a:	4622      	mov	r2, r4
 800b32c:	4629      	mov	r1, r5
 800b32e:	6838      	ldr	r0, [r7, #0]
 800b330:	f7fa fca7 	bl	8005c82 <uxStreamBufferGet>
					pcBuffer[ xMessageLength ] = 0x00;
 800b334:	9b02      	ldr	r3, [sp, #8]
 800b336:	54e5      	strb	r5, [r4, r3]
 800b338:	e7e4      	b.n	800b304 <prvLoggingTask+0xdc>
								xCount++;
								pcTarget++;
							}
						}

						pcTarget++;
 800b33a:	3101      	adds	r1, #1
					while( ( *pcSource != 0x00 ) && ( pcSource < ( cLoggingLine + xCount ) ) )
 800b33c:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 800b340:	b1a8      	cbz	r0, 800b36e <prvLoggingTask+0x146>
 800b342:	18a5      	adds	r5, r4, r2
 800b344:	42ab      	cmp	r3, r5
 800b346:	d212      	bcs.n	800b36e <prvLoggingTask+0x146>
						*pcTarget = *pcSource;
 800b348:	7008      	strb	r0, [r1, #0]
						if( ( ( pcSource == cLoggingLine ) || ( pcSource[ -1 ] != logASCII_CR ) ) && ( pcSource[ 0 ] == logASCII_NL ) )
 800b34a:	42a3      	cmp	r3, r4
 800b34c:	d003      	beq.n	800b356 <prvLoggingTask+0x12e>
 800b34e:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 800b352:	280d      	cmp	r0, #13
 800b354:	d0f1      	beq.n	800b33a <prvLoggingTask+0x112>
 800b356:	7818      	ldrb	r0, [r3, #0]
 800b358:	280a      	cmp	r0, #10
 800b35a:	d1ee      	bne.n	800b33a <prvLoggingTask+0x112>
							pcTarget[ 0 ] = logASCII_CR;
 800b35c:	f881 c000 	strb.w	ip, [r1]
							pcTarget[ 1 ] = logASCII_NL;
 800b360:	f881 e001 	strb.w	lr, [r1, #1]
							if( xCount < ( sizeof( cLoggingLine ) - 1 ) )
 800b364:	2ac6      	cmp	r2, #198	; 0xc6
								xCount++;
 800b366:	bf9c      	itt	ls
 800b368:	3201      	addls	r2, #1
								pcTarget++;
 800b36a:	3101      	addls	r1, #1
 800b36c:	e7e5      	b.n	800b33a <prvLoggingTask+0x112>
						pcSource++;
					}
				}
				#endif

				FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, xCount, 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
 800b36e:	4b15      	ldr	r3, [pc, #84]	; (800b3c4 <prvLoggingTask+0x19c>)
 800b370:	6818      	ldr	r0, [r3, #0]
 800b372:	2308      	movs	r3, #8
 800b374:	9301      	str	r3, [sp, #4]
 800b376:	ab04      	add	r3, sp, #16
 800b378:	9300      	str	r3, [sp, #0]
 800b37a:	2300      	movs	r3, #0
 800b37c:	4621      	mov	r1, r4
 800b37e:	f7f9 fb1b 	bl	80049b8 <FreeRTOS_sendto>
			for( lLines = 0; lLines < configUDP_LOGGING_MAX_MESSAGES_IN_BUFFER; lLines++ )
 800b382:	3e01      	subs	r6, #1
 800b384:	d00e      	beq.n	800b3a4 <prvLoggingTask+0x17c>
size_t xMessageLength = 0;
 800b386:	2300      	movs	r3, #0
 800b388:	9302      	str	r3, [sp, #8]
	if( pxStreamBuffer != NULL )
 800b38a:	683a      	ldr	r2, [r7, #0]
 800b38c:	b14a      	cbz	r2, 800b3a2 <prvLoggingTask+0x17a>
size_t uxHead = pxBuffer->uxHead;
 800b38e:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 800b390:	6811      	ldr	r1, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 800b392:	6912      	ldr	r2, [r2, #16]
 800b394:	4413      	add	r3, r2
 800b396:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 800b398:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 800b39a:	bf98      	it	ls
 800b39c:	1a9b      	subls	r3, r3, r2
		if( uxLength > sizeof( size_t ) )
 800b39e:	2b04      	cmp	r3, #4
 800b3a0:	d892      	bhi.n	800b2c8 <prvLoggingTask+0xa0>
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) pcBuffer, xMessageLength, pdFALSE );
 800b3a2:	4c09      	ldr	r4, [pc, #36]	; (800b3c8 <prvLoggingTask+0x1a0>)
		ulTaskNotifyTake( pdTRUE, xBlockingTime );
 800b3a4:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800b3a8:	2501      	movs	r5, #1
 800b3aa:	4631      	mov	r1, r6
 800b3ac:	4628      	mov	r0, r5
 800b3ae:	f7ff f8e5 	bl	800a57c <ulTaskNotifyTake>
		if( xGetPhyLinkStatus() != pdFALSE )
 800b3b2:	f7fd f8e3 	bl	800857c <xGetPhyLinkStatus>
 800b3b6:	2800      	cmp	r0, #0
 800b3b8:	d0f7      	beq.n	800b3aa <prvLoggingTask+0x182>
 800b3ba:	2614      	movs	r6, #20
 800b3bc:	e7e3      	b.n	800b386 <prvLoggingTask+0x15e>
 800b3be:	bf00      	nop
 800b3c0:	6400a8c0 	.word	0x6400a8c0
 800b3c4:	20000174 	.word	0x20000174
 800b3c8:	20002648 	.word	0x20002648
 800b3cc:	0800d5cc 	.word	0x0800d5cc
 800b3d0:	20002710 	.word	0x20002710
 800b3d4:	20002720 	.word	0x20002720

0800b3d8 <lUDPLoggingPrintf>:
{
 800b3d8:	b40f      	push	{r0, r1, r2, r3}
 800b3da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b3de:	b086      	sub	sp, #24
	if( xLoggingInitialised == pdFALSE )
 800b3e0:	4b4a      	ldr	r3, [pc, #296]	; (800b50c <lUDPLoggingPrintf+0x134>)
 800b3e2:	681b      	ldr	r3, [r3, #0]
 800b3e4:	2b00      	cmp	r3, #0
 800b3e6:	d05e      	beq.n	800b4a6 <lUDPLoggingPrintf+0xce>
		va_start (args, pcFormatString);
 800b3e8:	ad0f      	add	r5, sp, #60	; 0x3c
 800b3ea:	9504      	str	r5, [sp, #16]
	configASSERT( pxStreamBuffer );
 800b3ec:	4b48      	ldr	r3, [pc, #288]	; (800b510 <lUDPLoggingPrintf+0x138>)
 800b3ee:	681b      	ldr	r3, [r3, #0]
 800b3f0:	2b00      	cmp	r3, #0
 800b3f2:	d077      	beq.n	800b4e4 <lUDPLoggingPrintf+0x10c>
	vTaskSuspendAll();
 800b3f4:	f7fe fadc 	bl	80099b0 <vTaskSuspendAll>
		ullCurrentTime = ullGetHighResolutionTime();
 800b3f8:	f000 fb86 	bl	800bb08 <ullGetHighResolutionTime>
 800b3fc:	4680      	mov	r8, r0
 800b3fe:	4689      	mov	r9, r1
		ullCurrentTime = ullCurrentTime % 1000000ull;
 800b400:	4a44      	ldr	r2, [pc, #272]	; (800b514 <lUDPLoggingPrintf+0x13c>)
 800b402:	2300      	movs	r3, #0
 800b404:	f7f4 feec 	bl	80001e0 <__aeabi_uldivmod>
 800b408:	4616      	mov	r6, r2
 800b40a:	461f      	mov	r7, r3
		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800b40c:	2000      	movs	r0, #0
 800b40e:	f7fe fadd 	bl	80099cc <pcTaskGetName>
 800b412:	4682      	mov	sl, r0
		ulSeconds = ( uint32_t ) ( ullCurrentTime / 1000000ull );
 800b414:	4a3f      	ldr	r2, [pc, #252]	; (800b514 <lUDPLoggingPrintf+0x13c>)
 800b416:	2300      	movs	r3, #0
 800b418:	4640      	mov	r0, r8
 800b41a:	4649      	mov	r1, r9
 800b41c:	f7f4 fee0 	bl	80001e0 <__aeabi_uldivmod>
 800b420:	4680      	mov	r8, r0
		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800b422:	4c3d      	ldr	r4, [pc, #244]	; (800b518 <lUDPLoggingPrintf+0x140>)
 800b424:	f8cd a008 	str.w	sl, [sp, #8]
		ulMicroSeconds = ( uint32_t ) ( ullCurrentTime % 1000ull );
 800b428:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b42c:	2300      	movs	r3, #0
 800b42e:	4630      	mov	r0, r6
 800b430:	4639      	mov	r1, r7
 800b432:	f7f4 fed5 	bl	80001e0 <__aeabi_uldivmod>
 800b436:	9201      	str	r2, [sp, #4]
		ulMilliSeconds = ( uint32_t ) ( ullCurrentTime / 1000ull );
 800b438:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b43c:	2300      	movs	r3, #0
 800b43e:	4630      	mov	r0, r6
 800b440:	4639      	mov	r1, r7
 800b442:	f7f4 fecd 	bl	80001e0 <__aeabi_uldivmod>
 800b446:	9000      	str	r0, [sp, #0]
		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800b448:	4643      	mov	r3, r8
 800b44a:	4a34      	ldr	r2, [pc, #208]	; (800b51c <lUDPLoggingPrintf+0x144>)
 800b44c:	21c8      	movs	r1, #200	; 0xc8
 800b44e:	4620      	mov	r0, r4
 800b450:	f000 faff 	bl	800ba52 <snprintf>
 800b454:	9005      	str	r0, [sp, #20]
		xLength += ( size_t ) vsnprintf( xLogEntry.cMessage + xLength, sizeof( xLogEntry.cMessage ) - xLength, pcFormatString, xArgs );
 800b456:	462b      	mov	r3, r5
 800b458:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800b45a:	f1c0 01c8 	rsb	r1, r0, #200	; 0xc8
 800b45e:	4420      	add	r0, r4
 800b460:	f000 fae6 	bl	800ba30 <vsnprintf>
 800b464:	9a05      	ldr	r2, [sp, #20]
 800b466:	4402      	add	r2, r0
 800b468:	9205      	str	r2, [sp, #20]
		xSpace = uxStreamBufferGetSpace( pxStreamBuffer );
 800b46a:	4b29      	ldr	r3, [pc, #164]	; (800b510 <lUDPLoggingPrintf+0x138>)
 800b46c:	6818      	ldr	r0, [r3, #0]
size_t uxHead = pxBuffer->uxHead;
 800b46e:	6884      	ldr	r4, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 800b470:	6803      	ldr	r3, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 800b472:	6901      	ldr	r1, [r0, #16]
 800b474:	440b      	add	r3, r1
 800b476:	3b01      	subs	r3, #1
 800b478:	1b1b      	subs	r3, r3, r4
	if( uxCount >= pxBuffer->LENGTH )
 800b47a:	4299      	cmp	r1, r3
		uxCount -= pxBuffer->LENGTH;
 800b47c:	bf98      	it	ls
 800b47e:	1a5b      	subls	r3, r3, r1
		if( xSpace > ( xLength + sizeof( BaseType_t ) ) )
 800b480:	3204      	adds	r2, #4
 800b482:	429a      	cmp	r2, r3
 800b484:	d334      	bcc.n	800b4f0 <lUDPLoggingPrintf+0x118>
	xTaskResumeAll();
 800b486:	f7fe fb6d 	bl	8009b64 <xTaskResumeAll>
	if( xLoggingTask != NULL )
 800b48a:	4b25      	ldr	r3, [pc, #148]	; (800b520 <lUDPLoggingPrintf+0x148>)
 800b48c:	6818      	ldr	r0, [r3, #0]
 800b48e:	b120      	cbz	r0, 800b49a <lUDPLoggingPrintf+0xc2>
		xTaskNotifyGive( xLoggingTask );
 800b490:	2300      	movs	r3, #0
 800b492:	2202      	movs	r2, #2
 800b494:	4619      	mov	r1, r3
 800b496:	f7ff f8ad 	bl	800a5f4 <xTaskGenericNotify>
	return xLength;
 800b49a:	9805      	ldr	r0, [sp, #20]
}
 800b49c:	b006      	add	sp, #24
 800b49e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b4a2:	b004      	add	sp, #16
 800b4a4:	4770      	bx	lr
		if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800b4a6:	f7fe feb7 	bl	800a218 <xTaskGetSchedulerState>
 800b4aa:	2802      	cmp	r0, #2
 800b4ac:	d005      	beq.n	800b4ba <lUDPLoggingPrintf+0xe2>
	return xLoggingInitialised;
 800b4ae:	4b17      	ldr	r3, [pc, #92]	; (800b50c <lUDPLoggingPrintf+0x134>)
	if( prvInitialiseLogging() != pdFALSE )
 800b4b0:	681b      	ldr	r3, [r3, #0]
		xLength = 0;
 800b4b2:	2000      	movs	r0, #0
	if( prvInitialiseLogging() != pdFALSE )
 800b4b4:	2b00      	cmp	r3, #0
 800b4b6:	d0f1      	beq.n	800b49c <lUDPLoggingPrintf+0xc4>
 800b4b8:	e796      	b.n	800b3e8 <lUDPLoggingPrintf+0x10>
			pxStreamBuffer = pvPortMalloc( xSize );
 800b4ba:	f640 70b5 	movw	r0, #4021	; 0xfb5
 800b4be:	f7fd fba3 	bl	8008c08 <pvPortMalloc>
 800b4c2:	4604      	mov	r4, r0
 800b4c4:	4b12      	ldr	r3, [pc, #72]	; (800b510 <lUDPLoggingPrintf+0x138>)
 800b4c6:	6018      	str	r0, [r3, #0]
			if( pxStreamBuffer != NULL )
 800b4c8:	2800      	cmp	r0, #0
 800b4ca:	d0f0      	beq.n	800b4ae <lUDPLoggingPrintf+0xd6>
				memset( pxStreamBuffer, '\0', xSize );
 800b4cc:	f640 72b5 	movw	r2, #4021	; 0xfb5
 800b4d0:	2100      	movs	r1, #0
 800b4d2:	f000 fde7 	bl	800c0a4 <memset>
				pxStreamBuffer->LENGTH = logMESSAGE_BUFFER_SIZE_BYTES + 1;
 800b4d6:	f640 73a1 	movw	r3, #4001	; 0xfa1
 800b4da:	6123      	str	r3, [r4, #16]
				xLoggingInitialised = pdTRUE;
 800b4dc:	2201      	movs	r2, #1
 800b4de:	4b0b      	ldr	r3, [pc, #44]	; (800b50c <lUDPLoggingPrintf+0x134>)
 800b4e0:	601a      	str	r2, [r3, #0]
 800b4e2:	e781      	b.n	800b3e8 <lUDPLoggingPrintf+0x10>
	configASSERT( pxStreamBuffer );
 800b4e4:	f44f 7195 	mov.w	r1, #298	; 0x12a
 800b4e8:	480e      	ldr	r0, [pc, #56]	; (800b524 <lUDPLoggingPrintf+0x14c>)
 800b4ea:	f000 fc0f 	bl	800bd0c <vAssertCalled>
 800b4ee:	e781      	b.n	800b3f4 <lUDPLoggingPrintf+0x1c>
			uxStreamBufferAdd( pxStreamBuffer, 0, ( const uint8_t * ) &xLength, sizeof( xLength ) );
 800b4f0:	2304      	movs	r3, #4
 800b4f2:	aa05      	add	r2, sp, #20
 800b4f4:	2100      	movs	r1, #0
 800b4f6:	f7fa fb60 	bl	8005bba <uxStreamBufferAdd>
			uxStreamBufferAdd( pxStreamBuffer, 0, ( const uint8_t * ) ( xLogEntry.cMessage ), xLength );
 800b4fa:	9b05      	ldr	r3, [sp, #20]
 800b4fc:	4a06      	ldr	r2, [pc, #24]	; (800b518 <lUDPLoggingPrintf+0x140>)
 800b4fe:	2100      	movs	r1, #0
 800b500:	4803      	ldr	r0, [pc, #12]	; (800b510 <lUDPLoggingPrintf+0x138>)
 800b502:	6800      	ldr	r0, [r0, #0]
 800b504:	f7fa fb59 	bl	8005bba <uxStreamBufferAdd>
 800b508:	e7bd      	b.n	800b486 <lUDPLoggingPrintf+0xae>
 800b50a:	bf00      	nop
 800b50c:	200027e8 	.word	0x200027e8
 800b510:	20002710 	.word	0x20002710
 800b514:	000f4240 	.word	0x000f4240
 800b518:	20002720 	.word	0x20002720
 800b51c:	0800d5b4 	.word	0x0800d5b4
 800b520:	200027ec 	.word	0x200027ec
 800b524:	0800d588 	.word	0x0800d588

0800b528 <vUDPLoggingTaskCreate>:
{
 800b528:	b500      	push	{lr}
 800b52a:	b083      	sub	sp, #12
	xTaskCreate( prvLoggingTask, "LogTask", configUDP_LOGGING_TASK_STACK_SIZE, NULL, configUDP_LOGGING_TASK_PRIORITY, &xLoggingTask );
 800b52c:	4b06      	ldr	r3, [pc, #24]	; (800b548 <vUDPLoggingTaskCreate+0x20>)
 800b52e:	9301      	str	r3, [sp, #4]
 800b530:	2301      	movs	r3, #1
 800b532:	9300      	str	r3, [sp, #0]
 800b534:	2300      	movs	r3, #0
 800b536:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b53a:	4904      	ldr	r1, [pc, #16]	; (800b54c <vUDPLoggingTaskCreate+0x24>)
 800b53c:	4804      	ldr	r0, [pc, #16]	; (800b550 <vUDPLoggingTaskCreate+0x28>)
 800b53e:	f7fe f861 	bl	8009604 <xTaskCreate>
}
 800b542:	b003      	add	sp, #12
 800b544:	f85d fb04 	ldr.w	pc, [sp], #4
 800b548:	200027ec 	.word	0x200027ec
 800b54c:	0800d5dc 	.word	0x0800d5dc
 800b550:	0800b229 	.word	0x0800b229

0800b554 <strbuf_init>:
	struct xPrintFlags flags;
};

static void strbuf_init( struct SStringBuf *apStr, char *apBuf, const char *apMaxStr )
{
	apStr->str = apBuf;
 800b554:	6001      	str	r1, [r0, #0]
	apStr->orgStr = apBuf;
 800b556:	6041      	str	r1, [r0, #4]
	apStr->nulPos = apMaxStr-1;
 800b558:	3a01      	subs	r2, #1
 800b55a:	6082      	str	r2, [r0, #8]
	apStr->curLen = 0;
 800b55c:	2300      	movs	r3, #0
 800b55e:	60c3      	str	r3, [r0, #12]

	memset( &apStr->flags, '\0', sizeof( apStr->flags ) );
 800b560:	6103      	str	r3, [r0, #16]
 800b562:	6143      	str	r3, [r0, #20]
 800b564:	6183      	str	r3, [r0, #24]
 800b566:	61c3      	str	r3, [r0, #28]
 800b568:	4770      	bx	lr

0800b56a <strbuf_printchar>:
}
/*-----------------------------------------------------------*/

static BaseType_t strbuf_printchar( struct SStringBuf *apStr, int c )
{
	if( apStr->str == NULL )
 800b56a:	6803      	ldr	r3, [r0, #0]
 800b56c:	b133      	cbz	r3, 800b57c <strbuf_printchar+0x12>
	{
		vOutputChar( ( char ) c, xTicksToWait );
		apStr->curLen++;
		return pdTRUE;
	}
	if( apStr->str < apStr->nulPos )
 800b56e:	6882      	ldr	r2, [r0, #8]
 800b570:	4293      	cmp	r3, r2
 800b572:	d30f      	bcc.n	800b594 <strbuf_printchar+0x2a>
	{
		*( apStr->str++ ) = c;
		apStr->curLen++;
		return pdTRUE;
	}
	if( apStr->str == apStr->nulPos )
 800b574:	4293      	cmp	r3, r2
 800b576:	d015      	beq.n	800b5a4 <strbuf_printchar+0x3a>
	{
		*( apStr->str++ ) = '\0';
	}
	return pdFALSE;
 800b578:	2000      	movs	r0, #0
 800b57a:	4770      	bx	lr
{
 800b57c:	b510      	push	{r4, lr}
 800b57e:	460b      	mov	r3, r1
 800b580:	4604      	mov	r4, r0
		vOutputChar( ( char ) c, xTicksToWait );
 800b582:	2114      	movs	r1, #20
 800b584:	b2d8      	uxtb	r0, r3
 800b586:	f000 fcb2 	bl	800beee <vOutputChar>
		apStr->curLen++;
 800b58a:	68e3      	ldr	r3, [r4, #12]
 800b58c:	3301      	adds	r3, #1
 800b58e:	60e3      	str	r3, [r4, #12]
		return pdTRUE;
 800b590:	2001      	movs	r0, #1
 800b592:	bd10      	pop	{r4, pc}
		*( apStr->str++ ) = c;
 800b594:	1c5a      	adds	r2, r3, #1
 800b596:	6002      	str	r2, [r0, #0]
 800b598:	7019      	strb	r1, [r3, #0]
		apStr->curLen++;
 800b59a:	68c3      	ldr	r3, [r0, #12]
 800b59c:	3301      	adds	r3, #1
 800b59e:	60c3      	str	r3, [r0, #12]
		return pdTRUE;
 800b5a0:	2001      	movs	r0, #1
 800b5a2:	4770      	bx	lr
		*( apStr->str++ ) = '\0';
 800b5a4:	1c5a      	adds	r2, r3, #1
 800b5a6:	6002      	str	r2, [r0, #0]
 800b5a8:	2000      	movs	r0, #0
 800b5aa:	7018      	strb	r0, [r3, #0]
 800b5ac:	4770      	bx	lr
	...

0800b5b0 <prints>:
	return iResult;
}
/*-----------------------------------------------------------*/

static BaseType_t prints(struct SStringBuf *apBuf, const char *apString )
{
 800b5b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b5b4:	4604      	mov	r4, r0
 800b5b6:	460e      	mov	r6, r1
	register int padchar = ' ';
	int i,len;

	if( apBuf->flags.width > 0 )
 800b5b8:	6940      	ldr	r0, [r0, #20]
 800b5ba:	2800      	cmp	r0, #0
 800b5bc:	dd2b      	ble.n	800b616 <prints+0x66>
	{
		register int len = 0;
		register const char *ptr;
		for( ptr = apString; *ptr; ++ptr )
 800b5be:	780b      	ldrb	r3, [r1, #0]
 800b5c0:	b32b      	cbz	r3, 800b60e <prints+0x5e>
 800b5c2:	460a      	mov	r2, r1
 800b5c4:	2300      	movs	r3, #0
		{
			++len;
 800b5c6:	3301      	adds	r3, #1
		for( ptr = apString; *ptr; ++ptr )
 800b5c8:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800b5cc:	2900      	cmp	r1, #0
 800b5ce:	d1fa      	bne.n	800b5c6 <prints+0x16>
		}

		if( len >= apBuf->flags.width )
 800b5d0:	4298      	cmp	r0, r3
 800b5d2:	dc1d      	bgt.n	800b610 <prints+0x60>
		{
			apBuf->flags.width = 0;
 800b5d4:	2300      	movs	r3, #0
 800b5d6:	6163      	str	r3, [r4, #20]
		else
		{
			apBuf->flags.width -= len;
		}

		if( apBuf->flags.pad & PAD_ZERO )
 800b5d8:	7f23      	ldrb	r3, [r4, #28]
 800b5da:	f003 0302 	and.w	r3, r3, #2
		{
			padchar = '0';
 800b5de:	2b00      	cmp	r3, #0
 800b5e0:	bf0c      	ite	eq
 800b5e2:	2520      	moveq	r5, #32
 800b5e4:	2530      	movne	r5, #48	; 0x30
		}
	}
	if( ( apBuf->flags.pad & PAD_RIGHT ) == 0 )
 800b5e6:	7f23      	ldrb	r3, [r4, #28]
 800b5e8:	f013 0f01 	tst.w	r3, #1
 800b5ec:	d114      	bne.n	800b618 <prints+0x68>
	{
		for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800b5ee:	6963      	ldr	r3, [r4, #20]
 800b5f0:	2b00      	cmp	r3, #0
 800b5f2:	dd11      	ble.n	800b618 <prints+0x68>
		{
			if( strbuf_printchar( apBuf, padchar ) == 0 )
 800b5f4:	4629      	mov	r1, r5
 800b5f6:	4620      	mov	r0, r4
 800b5f8:	f7ff ffb7 	bl	800b56a <strbuf_printchar>
 800b5fc:	4603      	mov	r3, r0
 800b5fe:	2800      	cmp	r0, #0
 800b600:	d032      	beq.n	800b668 <prints+0xb8>
		for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800b602:	6963      	ldr	r3, [r4, #20]
 800b604:	3b01      	subs	r3, #1
 800b606:	6163      	str	r3, [r4, #20]
 800b608:	2b00      	cmp	r3, #0
 800b60a:	dcf3      	bgt.n	800b5f4 <prints+0x44>
 800b60c:	e004      	b.n	800b618 <prints+0x68>
		for( ptr = apString; *ptr; ++ptr )
 800b60e:	2300      	movs	r3, #0
			apBuf->flags.width -= len;
 800b610:	1ac3      	subs	r3, r0, r3
 800b612:	6163      	str	r3, [r4, #20]
 800b614:	e7e0      	b.n	800b5d8 <prints+0x28>
	register int padchar = ' ';
 800b616:	2520      	movs	r5, #32
			{
				return pdFALSE;
			}
		}
	}
	if( ( apBuf->flags.isNumber == pdTRUE ) && ( apBuf->flags.pad == pdTRUE ) )
 800b618:	69e3      	ldr	r3, [r4, #28]
 800b61a:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 800b61e:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 800b622:	4a1e      	ldr	r2, [pc, #120]	; (800b69c <prints+0xec>)
 800b624:	4293      	cmp	r3, r2
 800b626:	d022      	beq.n	800b66e <prints+0xbe>
		}
	}
	/* The string to print is not the result of a number conversion to ascii.
	 * For a string, printLimit is the max number of characters to display
	 */
	for( ; apBuf->flags.printLimit && *apString ; ++apString, --apBuf->flags.printLimit )
 800b628:	69a3      	ldr	r3, [r4, #24]
 800b62a:	b173      	cbz	r3, 800b64a <prints+0x9a>
 800b62c:	7831      	ldrb	r1, [r6, #0]
 800b62e:	b161      	cbz	r1, 800b64a <prints+0x9a>
	{
		if( !strbuf_printchar( apBuf, *apString ) )
 800b630:	4620      	mov	r0, r4
 800b632:	f7ff ff9a 	bl	800b56a <strbuf_printchar>
 800b636:	4603      	mov	r3, r0
 800b638:	b1b0      	cbz	r0, 800b668 <prints+0xb8>
	for( ; apBuf->flags.printLimit && *apString ; ++apString, --apBuf->flags.printLimit )
 800b63a:	69a3      	ldr	r3, [r4, #24]
 800b63c:	3b01      	subs	r3, #1
 800b63e:	61a3      	str	r3, [r4, #24]
 800b640:	b11b      	cbz	r3, 800b64a <prints+0x9a>
 800b642:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800b646:	2900      	cmp	r1, #0
 800b648:	d1f2      	bne.n	800b630 <prints+0x80>
		{
			return pdFALSE;
		}
	}

	for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800b64a:	6963      	ldr	r3, [r4, #20]
 800b64c:	2b00      	cmp	r3, #0
 800b64e:	dd22      	ble.n	800b696 <prints+0xe6>
	{
		if( !strbuf_printchar( apBuf, padchar ) )
 800b650:	4629      	mov	r1, r5
 800b652:	4620      	mov	r0, r4
 800b654:	f7ff ff89 	bl	800b56a <strbuf_printchar>
 800b658:	4603      	mov	r3, r0
 800b65a:	b128      	cbz	r0, 800b668 <prints+0xb8>
	for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800b65c:	6963      	ldr	r3, [r4, #20]
 800b65e:	3b01      	subs	r3, #1
 800b660:	6163      	str	r3, [r4, #20]
 800b662:	2b00      	cmp	r3, #0
 800b664:	dcf4      	bgt.n	800b650 <prints+0xa0>
		{
			return pdFALSE;
		}
	}

	return pdTRUE;
 800b666:	2301      	movs	r3, #1
}
 800b668:	4618      	mov	r0, r3
 800b66a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		len = strlen( apString );
 800b66e:	4630      	mov	r0, r6
 800b670:	f7f4 fdae 	bl	80001d0 <strlen>
		if( len < apBuf->flags.printLimit )
 800b674:	69a7      	ldr	r7, [r4, #24]
 800b676:	42b8      	cmp	r0, r7
 800b678:	dad6      	bge.n	800b628 <prints+0x78>
			for( ; i; i-- )
 800b67a:	1a3f      	subs	r7, r7, r0
 800b67c:	d0d4      	beq.n	800b628 <prints+0x78>
				if( strbuf_printchar( apBuf, '0' )  == 0 )
 800b67e:	f04f 0830 	mov.w	r8, #48	; 0x30
 800b682:	4641      	mov	r1, r8
 800b684:	4620      	mov	r0, r4
 800b686:	f7ff ff70 	bl	800b56a <strbuf_printchar>
 800b68a:	4603      	mov	r3, r0
 800b68c:	2800      	cmp	r0, #0
 800b68e:	d0eb      	beq.n	800b668 <prints+0xb8>
			for( ; i; i-- )
 800b690:	3f01      	subs	r7, #1
 800b692:	d1f6      	bne.n	800b682 <prints+0xd2>
 800b694:	e7c8      	b.n	800b628 <prints+0x78>
	return pdTRUE;
 800b696:	2301      	movs	r3, #1
 800b698:	e7e6      	b.n	800b668 <prints+0xb8>
 800b69a:	bf00      	nop
 800b69c:	00020001 	.word	0x00020001

0800b6a0 <printi>:
}
#endif	/* SPRINTF_LONG_LONG */
/*-----------------------------------------------------------*/

static BaseType_t printi( struct SStringBuf *apBuf, int i )
{
 800b6a0:	b570      	push	{r4, r5, r6, lr}
 800b6a2:	b084      	sub	sp, #16
 800b6a4:	4605      	mov	r5, r0
	char print_buf[ PRINT_BUF_LEN ];
	register char *s;
	register int t, neg = 0;
	register unsigned int u = i;
	register unsigned base = apBuf->flags.base;
 800b6a6:	6902      	ldr	r2, [r0, #16]

	apBuf->flags.isNumber = pdTRUE;	/* Parameter for prints */
 800b6a8:	7f84      	ldrb	r4, [r0, #30]
 800b6aa:	f044 0402 	orr.w	r4, r4, #2
 800b6ae:	7784      	strb	r4, [r0, #30]

	if( i == 0 )
 800b6b0:	b199      	cbz	r1, 800b6da <printi+0x3a>
 800b6b2:	460b      	mov	r3, r1
 800b6b4:	4610      	mov	r0, r2
		print_buf[ 0 ] = '0';
		print_buf[ 1 ] = '\0';
		return prints( apBuf, print_buf );
	}

	if( ( apBuf->flags.isSigned == pdTRUE ) && ( base == 10 ) && ( i < 0 ) )
 800b6b6:	7fac      	ldrb	r4, [r5, #30]
 800b6b8:	f014 0f01 	tst.w	r4, #1
 800b6bc:	d001      	beq.n	800b6c2 <printi+0x22>
 800b6be:	2a0a      	cmp	r2, #10
 800b6c0:	d016      	beq.n	800b6f0 <printi+0x50>
		u = -i;
	}

	s = print_buf + sizeof( print_buf ) - 1;

	*s = '\0';
 800b6c2:	2100      	movs	r1, #0
 800b6c4:	f88d 100f 	strb.w	r1, [sp, #15]
	switch( base )
 800b6c8:	2a0a      	cmp	r2, #10
 800b6ca:	d02b      	beq.n	800b724 <printi+0x84>
 800b6cc:	2a10      	cmp	r2, #16
 800b6ce:	d022      	beq.n	800b716 <printi+0x76>
 800b6d0:	2a08      	cmp	r2, #8
 800b6d2:	d027      	beq.n	800b724 <printi+0x84>
	s = print_buf + sizeof( print_buf ) - 1;
 800b6d4:	f10d 010f 	add.w	r1, sp, #15
 800b6d8:	e03f      	b.n	800b75a <printi+0xba>
		print_buf[ 0 ] = '0';
 800b6da:	2330      	movs	r3, #48	; 0x30
 800b6dc:	f88d 3004 	strb.w	r3, [sp, #4]
		print_buf[ 1 ] = '\0';
 800b6e0:	2300      	movs	r3, #0
 800b6e2:	f88d 3005 	strb.w	r3, [sp, #5]
		return prints( apBuf, print_buf );
 800b6e6:	a901      	add	r1, sp, #4
 800b6e8:	f7ff ff62 	bl	800b5b0 <prints>
 800b6ec:	4603      	mov	r3, r0
 800b6ee:	e038      	b.n	800b762 <printi+0xc2>
	if( ( apBuf->flags.isSigned == pdTRUE ) && ( base == 10 ) && ( i < 0 ) )
 800b6f0:	2900      	cmp	r1, #0
 800b6f2:	dae6      	bge.n	800b6c2 <printi+0x22>
		u = -i;
 800b6f4:	424b      	negs	r3, r1
	*s = '\0';
 800b6f6:	2100      	movs	r1, #0
 800b6f8:	f88d 100f 	strb.w	r1, [sp, #15]
	switch( base )
 800b6fc:	2a0a      	cmp	r2, #10
 800b6fe:	d006      	beq.n	800b70e <printi+0x6e>
 800b700:	2a10      	cmp	r2, #16
 800b702:	d006      	beq.n	800b712 <printi+0x72>
 800b704:	2a08      	cmp	r2, #8
	s = print_buf + sizeof( print_buf ) - 1;
 800b706:	bf18      	it	ne
 800b708:	f10d 040f 	addne.w	r4, sp, #15
	switch( base )
 800b70c:	d11b      	bne.n	800b746 <printi+0xa6>
		neg = 1;
 800b70e:	2601      	movs	r6, #1
 800b710:	e009      	b.n	800b726 <printi+0x86>
 800b712:	2601      	movs	r6, #1
 800b714:	e000      	b.n	800b718 <printi+0x78>
	switch( base )
 800b716:	2600      	movs	r6, #0
	{
	case 16:
		while( u != 0 )
 800b718:	f10d 040f 	add.w	r4, sp, #15
 800b71c:	b193      	cbz	r3, 800b744 <printi+0xa4>
 800b71e:	f10d 040f 	add.w	r4, sp, #15
 800b722:	e026      	b.n	800b772 <printi+0xd2>
	switch( base )
 800b724:	2600      	movs	r6, #0
		break;

	case 8:
	case 10:
		/* GCC compiles very efficient */
		while( u )
 800b726:	f10d 040f 	add.w	r4, sp, #15
 800b72a:	b15b      	cbz	r3, 800b744 <printi+0xa4>
 800b72c:	f10d 040f 	add.w	r4, sp, #15
		{
			t = u % base;
 800b730:	fbb3 f2f0 	udiv	r2, r3, r0
 800b734:	fb00 3312 	mls	r3, r0, r2, r3
			*( --s ) = t + '0';
 800b738:	3330      	adds	r3, #48	; 0x30
 800b73a:	f804 3d01 	strb.w	r3, [r4, #-1]!
			u /= base;
 800b73e:	4613      	mov	r3, r2
		while( u )
 800b740:	2a00      	cmp	r2, #0
 800b742:	d1f5      	bne.n	800b730 <printi+0x90>
		}
		break;
*/
	}

	if( neg != 0 )
 800b744:	b34e      	cbz	r6, 800b79a <printi+0xfa>
	{
		if( apBuf->flags.width && (apBuf->flags.pad & PAD_ZERO ) )
 800b746:	696b      	ldr	r3, [r5, #20]
 800b748:	b11b      	cbz	r3, 800b752 <printi+0xb2>
 800b74a:	7f2b      	ldrb	r3, [r5, #28]
 800b74c:	f013 0f02 	tst.w	r3, #2
 800b750:	d117      	bne.n	800b782 <printi+0xe2>
			}
			--apBuf->flags.width;
		}
		else
		{
			*( --s ) = '-';
 800b752:	1e61      	subs	r1, r4, #1
 800b754:	232d      	movs	r3, #45	; 0x2d
 800b756:	f804 3c01 	strb.w	r3, [r4, #-1]
		}
	}

	return prints( apBuf, s );
 800b75a:	4628      	mov	r0, r5
 800b75c:	f7ff ff28 	bl	800b5b0 <prints>
 800b760:	4603      	mov	r3, r0
}
 800b762:	4618      	mov	r0, r3
 800b764:	b004      	add	sp, #16
 800b766:	bd70      	pop	{r4, r5, r6, pc}
			*( --s ) = t + '0';
 800b768:	3230      	adds	r2, #48	; 0x30
 800b76a:	f804 2d01 	strb.w	r2, [r4, #-1]!
		while( u != 0 )
 800b76e:	091b      	lsrs	r3, r3, #4
 800b770:	d0e8      	beq.n	800b744 <printi+0xa4>
			t = u & 0xF;
 800b772:	f003 020f 	and.w	r2, r3, #15
			if( t >= 10 )
 800b776:	2a09      	cmp	r2, #9
 800b778:	ddf6      	ble.n	800b768 <printi+0xc8>
				t += apBuf->flags.letBase - '0' - 10;
 800b77a:	7f69      	ldrb	r1, [r5, #29]
 800b77c:	393a      	subs	r1, #58	; 0x3a
 800b77e:	440a      	add	r2, r1
 800b780:	e7f2      	b.n	800b768 <printi+0xc8>
			if( strbuf_printchar( apBuf, '-' ) == 0 )
 800b782:	212d      	movs	r1, #45	; 0x2d
 800b784:	4628      	mov	r0, r5
 800b786:	f7ff fef0 	bl	800b56a <strbuf_printchar>
 800b78a:	4603      	mov	r3, r0
 800b78c:	2800      	cmp	r0, #0
 800b78e:	d0e8      	beq.n	800b762 <printi+0xc2>
			--apBuf->flags.width;
 800b790:	696b      	ldr	r3, [r5, #20]
 800b792:	3b01      	subs	r3, #1
 800b794:	616b      	str	r3, [r5, #20]
 800b796:	4621      	mov	r1, r4
 800b798:	e7df      	b.n	800b75a <printi+0xba>
 800b79a:	4621      	mov	r1, r4
 800b79c:	e7dd      	b.n	800b75a <printi+0xba>

0800b79e <sprintf>:
	return strBuf.curLen;
}
/*-----------------------------------------------------------*/

int sprintf( char *apBuf, const char *apFmt, ... )
{
 800b79e:	b40e      	push	{r1, r2, r3}
 800b7a0:	b510      	push	{r4, lr}
 800b7a2:	b08b      	sub	sp, #44	; 0x2c
 800b7a4:	4601      	mov	r1, r0
 800b7a6:	ab0d      	add	r3, sp, #52	; 0x34
 800b7a8:	f853 4b04 	ldr.w	r4, [r3], #4
	va_list args;

	va_start( args,  apFmt );
 800b7ac:	9309      	str	r3, [sp, #36]	; 0x24
	struct SStringBuf strBuf;
	strbuf_init( &strBuf, apBuf, ( const char * )apBuf + 1024 );
 800b7ae:	f500 6280 	add.w	r2, r0, #1024	; 0x400
 800b7b2:	a801      	add	r0, sp, #4
 800b7b4:	f7ff fece 	bl	800b554 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800b7b8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b7ba:	4621      	mov	r1, r4
 800b7bc:	a801      	add	r0, sp, #4
 800b7be:	f000 f807 	bl	800b7d0 <tiny_print>
	va_end( args );

	return strBuf.curLen;
}
 800b7c2:	9804      	ldr	r0, [sp, #16]
 800b7c4:	b00b      	add	sp, #44	; 0x2c
 800b7c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800b7ca:	b003      	add	sp, #12
 800b7cc:	4770      	bx	lr
	...

0800b7d0 <tiny_print>:
{
 800b7d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b7d4:	b087      	sub	sp, #28
 800b7d6:	4604      	mov	r4, r0
 800b7d8:	468a      	mov	sl, r1
 800b7da:	4616      	mov	r6, r2
		vOutputChar( ( char ) c, xTicksToWait );
 800b7dc:	f04f 0b14 	mov.w	fp, #20
	sprintf( print_buf, "%u.%u.%u.%u",
 800b7e0:	f8df 9244 	ldr.w	r9, [pc, #580]	; 800ba28 <tiny_print+0x258>
			if( prints( apBuf, s ? s : "(null)" ) == 0 )
 800b7e4:	f8df 8244 	ldr.w	r8, [pc, #580]	; 800ba2c <tiny_print+0x25c>
		int ch = *( format++ );
 800b7e8:	f10a 0501 	add.w	r5, sl, #1
 800b7ec:	f89a 7000 	ldrb.w	r7, [sl]
		if( ch != '%' )
 800b7f0:	2f25      	cmp	r7, #37	; 0x25
 800b7f2:	d163      	bne.n	800b8bc <tiny_print+0xec>
		ch = *( format++ );
 800b7f4:	f105 0a01 	add.w	sl, r5, #1
 800b7f8:	782b      	ldrb	r3, [r5, #0]
		if( ch == '\0' )
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	f000 810e 	beq.w	800ba1c <tiny_print+0x24c>
		if( ch == '%' )
 800b800:	2b25      	cmp	r3, #37	; 0x25
 800b802:	d073      	beq.n	800b8ec <tiny_print+0x11c>
		memset( &apBuf->flags, '\0', sizeof( apBuf->flags ) );
 800b804:	2100      	movs	r1, #0
 800b806:	6121      	str	r1, [r4, #16]
 800b808:	6161      	str	r1, [r4, #20]
 800b80a:	61a1      	str	r1, [r4, #24]
 800b80c:	61e1      	str	r1, [r4, #28]
		if( ch == '-' )
 800b80e:	2b2d      	cmp	r3, #45	; 0x2d
 800b810:	d073      	beq.n	800b8fa <tiny_print+0x12a>
		while( ch == '0' )
 800b812:	2b30      	cmp	r3, #48	; 0x30
 800b814:	d107      	bne.n	800b826 <tiny_print+0x56>
			ch = *( format++ );
 800b816:	f81a 3b01 	ldrb.w	r3, [sl], #1
			apBuf->flags.pad |= PAD_ZERO;
 800b81a:	7f22      	ldrb	r2, [r4, #28]
 800b81c:	f042 0202 	orr.w	r2, r2, #2
 800b820:	7722      	strb	r2, [r4, #28]
		while( ch == '0' )
 800b822:	2b30      	cmp	r3, #48	; 0x30
 800b824:	d0f7      	beq.n	800b816 <tiny_print+0x46>
		if( ch == '*' )
 800b826:	2b2a      	cmp	r3, #42	; 0x2a
 800b828:	d06d      	beq.n	800b906 <tiny_print+0x136>
			while( ch >= '0' && ch <= '9' )
 800b82a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800b82e:	2a09      	cmp	r2, #9
 800b830:	d80c      	bhi.n	800b84c <tiny_print+0x7c>
				apBuf->flags.width *= 10;
 800b832:	6962      	ldr	r2, [r4, #20]
 800b834:	eb02 0282 	add.w	r2, r2, r2, lsl #2
				apBuf->flags.width += ch - '0';
 800b838:	3b30      	subs	r3, #48	; 0x30
 800b83a:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 800b83e:	6162      	str	r2, [r4, #20]
				ch = *( format++ );
 800b840:	f81a 3b01 	ldrb.w	r3, [sl], #1
			while( ch >= '0' && ch <= '9' )
 800b844:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800b848:	2a09      	cmp	r2, #9
 800b84a:	d9f2      	bls.n	800b832 <tiny_print+0x62>
		if( ch == '.' )
 800b84c:	2b2e      	cmp	r3, #46	; 0x2e
 800b84e:	d062      	beq.n	800b916 <tiny_print+0x146>
		if( apBuf->flags.printLimit == 0 )
 800b850:	69a2      	ldr	r2, [r4, #24]
 800b852:	b912      	cbnz	r2, 800b85a <tiny_print+0x8a>
			apBuf->flags.printLimit--;  /* -1: make it unlimited */
 800b854:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b858:	61a2      	str	r2, [r4, #24]
		if( ch == 's' )
 800b85a:	2b73      	cmp	r3, #115	; 0x73
 800b85c:	d07e      	beq.n	800b95c <tiny_print+0x18c>
		if( ch == 'c' )
 800b85e:	2b63      	cmp	r3, #99	; 0x63
 800b860:	f000 8087 	beq.w	800b972 <tiny_print+0x1a2>
		if( ch == 'l' )
 800b864:	2b6c      	cmp	r3, #108	; 0x6c
 800b866:	f000 808c 	beq.w	800b982 <tiny_print+0x1b2>
		if( ch == 'L' )
 800b86a:	2b4c      	cmp	r3, #76	; 0x4c
 800b86c:	f000 8092 	beq.w	800b994 <tiny_print+0x1c4>
		apBuf->flags.base = 10;
 800b870:	220a      	movs	r2, #10
 800b872:	6122      	str	r2, [r4, #16]
		apBuf->flags.letBase = 'a';
 800b874:	2261      	movs	r2, #97	; 0x61
 800b876:	7762      	strb	r2, [r4, #29]
		if( ch == 'd' || ch == 'u' )
 800b878:	2b64      	cmp	r3, #100	; 0x64
 800b87a:	f000 8094 	beq.w	800b9a6 <tiny_print+0x1d6>
 800b87e:	2b75      	cmp	r3, #117	; 0x75
 800b880:	f000 8091 	beq.w	800b9a6 <tiny_print+0x1d6>
		apBuf->flags.base = 16;		/* From here all hexadecimal */
 800b884:	2210      	movs	r2, #16
 800b886:	6122      	str	r2, [r4, #16]
		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800b888:	2b78      	cmp	r3, #120	; 0x78
 800b88a:	f000 809b 	beq.w	800b9c4 <tiny_print+0x1f4>
		if( ch == 'x' || ch == 'X' || ch == 'p' || ch == 'o' )
 800b88e:	2b58      	cmp	r3, #88	; 0x58
 800b890:	f000 80c1 	beq.w	800ba16 <tiny_print+0x246>
 800b894:	2b70      	cmp	r3, #112	; 0x70
 800b896:	f000 8099 	beq.w	800b9cc <tiny_print+0x1fc>
 800b89a:	2b6f      	cmp	r3, #111	; 0x6f
 800b89c:	d1a4      	bne.n	800b7e8 <tiny_print+0x18>
				apBuf->flags.base = 8;
 800b89e:	2308      	movs	r3, #8
 800b8a0:	6123      	str	r3, [r4, #16]
 800b8a2:	e093      	b.n	800b9cc <tiny_print+0x1fc>
		vOutputChar( ( char ) c, xTicksToWait );
 800b8a4:	4659      	mov	r1, fp
 800b8a6:	4638      	mov	r0, r7
 800b8a8:	f000 fb21 	bl	800beee <vOutputChar>
		if( c == 0 )
 800b8ac:	b1b7      	cbz	r7, 800b8dc <tiny_print+0x10c>
		apStr->curLen++;
 800b8ae:	68e3      	ldr	r3, [r4, #12]
 800b8b0:	3301      	adds	r3, #1
 800b8b2:	60e3      	str	r3, [r4, #12]
				ch = *( format++ );
 800b8b4:	f815 7b01 	ldrb.w	r7, [r5], #1
			} while( ch != '%' );
 800b8b8:	2f25      	cmp	r7, #37	; 0x25
 800b8ba:	d09b      	beq.n	800b7f4 <tiny_print+0x24>
	if( apStr->str == NULL )
 800b8bc:	6823      	ldr	r3, [r4, #0]
 800b8be:	2b00      	cmp	r3, #0
 800b8c0:	d0f0      	beq.n	800b8a4 <tiny_print+0xd4>
	if( apStr->str < apStr->nulPos )
 800b8c2:	68a2      	ldr	r2, [r4, #8]
 800b8c4:	4293      	cmp	r3, r2
 800b8c6:	d207      	bcs.n	800b8d8 <tiny_print+0x108>
		*(apStr->str++) = c;
 800b8c8:	1c5a      	adds	r2, r3, #1
 800b8ca:	6022      	str	r2, [r4, #0]
 800b8cc:	701f      	strb	r7, [r3, #0]
		if( c == 0 )
 800b8ce:	b12f      	cbz	r7, 800b8dc <tiny_print+0x10c>
		apStr->curLen++;
 800b8d0:	68e3      	ldr	r3, [r4, #12]
 800b8d2:	3301      	adds	r3, #1
 800b8d4:	60e3      	str	r3, [r4, #12]
 800b8d6:	e7ed      	b.n	800b8b4 <tiny_print+0xe4>
	if( apStr->str == apStr->nulPos )
 800b8d8:	4293      	cmp	r3, r2
 800b8da:	d002      	beq.n	800b8e2 <tiny_print+0x112>
}
 800b8dc:	b007      	add	sp, #28
 800b8de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*( apStr->str++ ) = '\0';
 800b8e2:	1c53      	adds	r3, r2, #1
 800b8e4:	6023      	str	r3, [r4, #0]
 800b8e6:	2300      	movs	r3, #0
 800b8e8:	7013      	strb	r3, [r2, #0]
 800b8ea:	e7f7      	b.n	800b8dc <tiny_print+0x10c>
			if( strbuf_printchar( apBuf, ch ) == 0 )
 800b8ec:	2125      	movs	r1, #37	; 0x25
 800b8ee:	4620      	mov	r0, r4
 800b8f0:	f7ff fe3b 	bl	800b56a <strbuf_printchar>
 800b8f4:	2800      	cmp	r0, #0
 800b8f6:	d0f1      	beq.n	800b8dc <tiny_print+0x10c>
 800b8f8:	e776      	b.n	800b7e8 <tiny_print+0x18>
			ch = *( format++ );
 800b8fa:	f105 0a02 	add.w	sl, r5, #2
 800b8fe:	786b      	ldrb	r3, [r5, #1]
			apBuf->flags.pad = PAD_RIGHT;
 800b900:	2201      	movs	r2, #1
 800b902:	7722      	strb	r2, [r4, #28]
 800b904:	e785      	b.n	800b812 <tiny_print+0x42>
			ch = *( format++ );
 800b906:	f89a 3000 	ldrb.w	r3, [sl]
			apBuf->flags.width = va_arg( args, int );
 800b90a:	6832      	ldr	r2, [r6, #0]
 800b90c:	6162      	str	r2, [r4, #20]
 800b90e:	3604      	adds	r6, #4
			ch = *( format++ );
 800b910:	f10a 0a01 	add.w	sl, sl, #1
 800b914:	e79a      	b.n	800b84c <tiny_print+0x7c>
			ch = *( format++ );
 800b916:	f10a 0101 	add.w	r1, sl, #1
 800b91a:	f89a 2000 	ldrb.w	r2, [sl]
 800b91e:	4613      	mov	r3, r2
			if( ch == '*' )
 800b920:	2a2a      	cmp	r2, #42	; 0x2a
 800b922:	d013      	beq.n	800b94c <tiny_print+0x17c>
				while( ch >= '0' && ch <= '9' )
 800b924:	3a30      	subs	r2, #48	; 0x30
 800b926:	2a09      	cmp	r2, #9
 800b928:	bf88      	it	hi
 800b92a:	468a      	movhi	sl, r1
 800b92c:	d890      	bhi.n	800b850 <tiny_print+0x80>
					apBuf->flags.printLimit *= 10;
 800b92e:	69a2      	ldr	r2, [r4, #24]
 800b930:	eb02 0282 	add.w	r2, r2, r2, lsl #2
					apBuf->flags.printLimit += ch - '0';
 800b934:	3b30      	subs	r3, #48	; 0x30
 800b936:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 800b93a:	61a2      	str	r2, [r4, #24]
					ch = *( format++ );
 800b93c:	f811 3b01 	ldrb.w	r3, [r1], #1
				while( ch >= '0' && ch <= '9' )
 800b940:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800b944:	2a09      	cmp	r2, #9
 800b946:	d9f2      	bls.n	800b92e <tiny_print+0x15e>
					ch = *( format++ );
 800b948:	468a      	mov	sl, r1
 800b94a:	e781      	b.n	800b850 <tiny_print+0x80>
				apBuf->flags.printLimit = va_arg( args, int );
 800b94c:	6833      	ldr	r3, [r6, #0]
 800b94e:	61a3      	str	r3, [r4, #24]
				ch = *( format++ );
 800b950:	f89a 3001 	ldrb.w	r3, [sl, #1]
				apBuf->flags.printLimit = va_arg( args, int );
 800b954:	3604      	adds	r6, #4
				ch = *( format++ );
 800b956:	f10a 0a02 	add.w	sl, sl, #2
 800b95a:	e779      	b.n	800b850 <tiny_print+0x80>
			register char *s = ( char * )va_arg( args, int );
 800b95c:	6831      	ldr	r1, [r6, #0]
			if( prints( apBuf, s ? s : "(null)" ) == 0 )
 800b95e:	2900      	cmp	r1, #0
 800b960:	bf08      	it	eq
 800b962:	4641      	moveq	r1, r8
 800b964:	4620      	mov	r0, r4
 800b966:	f7ff fe23 	bl	800b5b0 <prints>
 800b96a:	2800      	cmp	r0, #0
 800b96c:	d056      	beq.n	800ba1c <tiny_print+0x24c>
			register char *s = ( char * )va_arg( args, int );
 800b96e:	3604      	adds	r6, #4
 800b970:	e73a      	b.n	800b7e8 <tiny_print+0x18>
			if( strbuf_printchar( apBuf, scr[0] )  == 0 )
 800b972:	7831      	ldrb	r1, [r6, #0]
 800b974:	4620      	mov	r0, r4
 800b976:	f7ff fdf8 	bl	800b56a <strbuf_printchar>
 800b97a:	2800      	cmp	r0, #0
 800b97c:	d0ae      	beq.n	800b8dc <tiny_print+0x10c>
			scr[0] = ( char ) va_arg( args, int );
 800b97e:	3604      	adds	r6, #4
 800b980:	e732      	b.n	800b7e8 <tiny_print+0x18>
			ch = *( format++ );
 800b982:	f89a 3000 	ldrb.w	r3, [sl]
			apBuf->flags.long32 = 1;
 800b986:	7fa2      	ldrb	r2, [r4, #30]
 800b988:	f042 0204 	orr.w	r2, r2, #4
 800b98c:	77a2      	strb	r2, [r4, #30]
			ch = *( format++ );
 800b98e:	f10a 0a01 	add.w	sl, sl, #1
 800b992:	e76a      	b.n	800b86a <tiny_print+0x9a>
			ch = *( format++ );
 800b994:	f89a 3000 	ldrb.w	r3, [sl]
			apBuf->flags.long64 = 1;
 800b998:	7fa2      	ldrb	r2, [r4, #30]
 800b99a:	f042 0208 	orr.w	r2, r2, #8
 800b99e:	77a2      	strb	r2, [r4, #30]
			ch = *( format++ );
 800b9a0:	f10a 0a01 	add.w	sl, sl, #1
 800b9a4:	e764      	b.n	800b870 <tiny_print+0xa0>
			apBuf->flags.isSigned = ( ch == 'd' );
 800b9a6:	2b64      	cmp	r3, #100	; 0x64
 800b9a8:	bf14      	ite	ne
 800b9aa:	2300      	movne	r3, #0
 800b9ac:	2301      	moveq	r3, #1
 800b9ae:	7fa2      	ldrb	r2, [r4, #30]
 800b9b0:	f363 0200 	bfi	r2, r3, #0, #1
 800b9b4:	77a2      	strb	r2, [r4, #30]
			if( printi( apBuf, va_arg( args, int ) ) == 0 )
 800b9b6:	6831      	ldr	r1, [r6, #0]
 800b9b8:	4620      	mov	r0, r4
 800b9ba:	f7ff fe71 	bl	800b6a0 <printi>
 800b9be:	b368      	cbz	r0, 800ba1c <tiny_print+0x24c>
 800b9c0:	3604      	adds	r6, #4
 800b9c2:	e711      	b.n	800b7e8 <tiny_print+0x18>
		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800b9c4:	f89a 3000 	ldrb.w	r3, [sl]
 800b9c8:	2b69      	cmp	r3, #105	; 0x69
 800b9ca:	d006      	beq.n	800b9da <tiny_print+0x20a>
			if( printi( apBuf, va_arg( args, int ) ) == 0 )
 800b9cc:	6831      	ldr	r1, [r6, #0]
 800b9ce:	4620      	mov	r0, r4
 800b9d0:	f7ff fe66 	bl	800b6a0 <printi>
 800b9d4:	b310      	cbz	r0, 800ba1c <tiny_print+0x24c>
 800b9d6:	3604      	adds	r6, #4
 800b9d8:	e706      	b.n	800b7e8 <tiny_print+0x18>
		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800b9da:	f89a 3001 	ldrb.w	r3, [sl, #1]
 800b9de:	2b70      	cmp	r3, #112	; 0x70
 800b9e0:	d1f4      	bne.n	800b9cc <tiny_print+0x1fc>
			format += 2;	/* eat the "xi" of "xip" */
 800b9e2:	f10a 0a02 	add.w	sl, sl, #2
			if( printIp( apBuf, va_arg( args, int ) ) == 0 )
 800b9e6:	1d35      	adds	r5, r6, #4
 800b9e8:	6832      	ldr	r2, [r6, #0]
	sprintf( print_buf, "%u.%u.%u.%u",
 800b9ea:	b2d3      	uxtb	r3, r2
 800b9ec:	9301      	str	r3, [sp, #4]
 800b9ee:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800b9f2:	9300      	str	r3, [sp, #0]
 800b9f4:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800b9f8:	0e12      	lsrs	r2, r2, #24
 800b9fa:	4649      	mov	r1, r9
 800b9fc:	a802      	add	r0, sp, #8
 800b9fe:	f7ff fece 	bl	800b79e <sprintf>
	apBuf->flags.isNumber = pdTRUE;	/* Parameter for prints */
 800ba02:	7fa3      	ldrb	r3, [r4, #30]
 800ba04:	f043 0302 	orr.w	r3, r3, #2
 800ba08:	77a3      	strb	r3, [r4, #30]
	prints( apBuf, print_buf );
 800ba0a:	a902      	add	r1, sp, #8
 800ba0c:	4620      	mov	r0, r4
 800ba0e:	f7ff fdcf 	bl	800b5b0 <prints>
			if( printIp( apBuf, va_arg( args, int ) ) == 0 )
 800ba12:	462e      	mov	r6, r5
			continue;
 800ba14:	e6e8      	b.n	800b7e8 <tiny_print+0x18>
				apBuf->flags.letBase = 'A';
 800ba16:	2341      	movs	r3, #65	; 0x41
 800ba18:	7763      	strb	r3, [r4, #29]
 800ba1a:	e7d7      	b.n	800b9cc <tiny_print+0x1fc>
	strbuf_printchar( apBuf, '\0' );
 800ba1c:	2100      	movs	r1, #0
 800ba1e:	4620      	mov	r0, r4
 800ba20:	f7ff fda3 	bl	800b56a <strbuf_printchar>
 800ba24:	e75a      	b.n	800b8dc <tiny_print+0x10c>
 800ba26:	bf00      	nop
 800ba28:	0800cf00 	.word	0x0800cf00
 800ba2c:	0800d5e4 	.word	0x0800d5e4

0800ba30 <vsnprintf>:
{
 800ba30:	b530      	push	{r4, r5, lr}
 800ba32:	b089      	sub	sp, #36	; 0x24
 800ba34:	4614      	mov	r4, r2
 800ba36:	461d      	mov	r5, r3
	strbuf_init( &strBuf, apBuf, ( const char* )apBuf + aMaxLen );
 800ba38:	1842      	adds	r2, r0, r1
 800ba3a:	4601      	mov	r1, r0
 800ba3c:	4668      	mov	r0, sp
 800ba3e:	f7ff fd89 	bl	800b554 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800ba42:	462a      	mov	r2, r5
 800ba44:	4621      	mov	r1, r4
 800ba46:	4668      	mov	r0, sp
 800ba48:	f7ff fec2 	bl	800b7d0 <tiny_print>
}
 800ba4c:	9803      	ldr	r0, [sp, #12]
 800ba4e:	b009      	add	sp, #36	; 0x24
 800ba50:	bd30      	pop	{r4, r5, pc}

0800ba52 <snprintf>:
{
 800ba52:	b40c      	push	{r2, r3}
 800ba54:	b510      	push	{r4, lr}
 800ba56:	b08a      	sub	sp, #40	; 0x28
 800ba58:	ab0c      	add	r3, sp, #48	; 0x30
 800ba5a:	f853 4b04 	ldr.w	r4, [r3], #4
	va_start( args,  apFmt );
 800ba5e:	9309      	str	r3, [sp, #36]	; 0x24
	strbuf_init( &strBuf, apBuf, ( const char* )apBuf + aMaxLen );
 800ba60:	1842      	adds	r2, r0, r1
 800ba62:	4601      	mov	r1, r0
 800ba64:	a801      	add	r0, sp, #4
 800ba66:	f7ff fd75 	bl	800b554 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800ba6a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ba6c:	4621      	mov	r1, r4
 800ba6e:	a801      	add	r0, sp, #4
 800ba70:	f7ff feae 	bl	800b7d0 <tiny_print>
}
 800ba74:	9804      	ldr	r0, [sp, #16]
 800ba76:	b00a      	add	sp, #40	; 0x28
 800ba78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800ba7c:	b002      	add	sp, #8
 800ba7e:	4770      	bx	lr

0800ba80 <TIM2_IRQHandler>:
static uint32_t ulInterruptCount = 0;

uint32_t ulTimer2Flags;
void TIM2_IRQHandler(void)
{
	ulTimer2Flags = tim2_handle.Instance->SR;
 800ba80:	4b07      	ldr	r3, [pc, #28]	; (800baa0 <TIM2_IRQHandler+0x20>)
 800ba82:	681a      	ldr	r2, [r3, #0]
 800ba84:	6913      	ldr	r3, [r2, #16]
 800ba86:	4907      	ldr	r1, [pc, #28]	; (800baa4 <TIM2_IRQHandler+0x24>)
 800ba88:	600b      	str	r3, [r1, #0]
	if( ( ulTimer2Flags & TIM_FLAG_UPDATE ) != 0 )
 800ba8a:	f013 0f01 	tst.w	r3, #1
 800ba8e:	d006      	beq.n	800ba9e <TIM2_IRQHandler+0x1e>
	{
		__HAL_TIM_CLEAR_FLAG( &tim2_handle, TIM_FLAG_UPDATE );
 800ba90:	f06f 0301 	mvn.w	r3, #1
 800ba94:	6113      	str	r3, [r2, #16]
		ulInterruptCount++;
 800ba96:	4a04      	ldr	r2, [pc, #16]	; (800baa8 <TIM2_IRQHandler+0x28>)
 800ba98:	6813      	ldr	r3, [r2, #0]
 800ba9a:	3301      	adds	r3, #1
 800ba9c:	6013      	str	r3, [r2, #0]
 800ba9e:	4770      	bx	lr
 800baa0:	20004cf4 	.word	0x20004cf4
 800baa4:	20004cf0 	.word	0x20004cf0
 800baa8:	200027f0 	.word	0x200027f0

0800baac <vStartHighResolutionTimer>:
}


/* Timer2 initialization function */
void vStartHighResolutionTimer( void )
{
 800baac:	b510      	push	{r4, lr}
	/* TIM2 clock enable */
	__HAL_RCC_TIM2_CLK_ENABLE();
 800baae:	4a12      	ldr	r2, [pc, #72]	; (800baf8 <vStartHighResolutionTimer+0x4c>)
 800bab0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800bab2:	f043 0301 	orr.w	r3, r3, #1
 800bab6:	6413      	str	r3, [r2, #64]	; 0x40

	tim2_handle.Instance = TIM2;     /* Register base address             */
 800bab8:	4c10      	ldr	r4, [pc, #64]	; (800bafc <vStartHighResolutionTimer+0x50>)
 800baba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800babe:	6023      	str	r3, [r4, #0]

	tim2_handle.Init.Prescaler = ( ulPrescale - 1ul );			/* Specifies the prescaler value used to divide the TIM clock. */
 800bac0:	2353      	movs	r3, #83	; 0x53
 800bac2:	6063      	str	r3, [r4, #4]
	tim2_handle.Init.CounterMode = TIM_COUNTERMODE_UP;			/* Specifies the counter mode. */
 800bac4:	2200      	movs	r2, #0
 800bac6:	60a2      	str	r2, [r4, #8]
	tim2_handle.Init.Period = ( ulReloadCount - 1ul );			/* Specifies the period value to be loaded into the active. */
 800bac8:	4b0d      	ldr	r3, [pc, #52]	; (800bb00 <vStartHighResolutionTimer+0x54>)
 800baca:	60e3      	str	r3, [r4, #12]
	tim2_handle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;	/* Specifies the clock division. */
 800bacc:	6122      	str	r2, [r4, #16]
	tim2_handle.Init.RepetitionCounter = 0ul;					/* Specifies the repetition counter value. */
 800bace:	6162      	str	r2, [r4, #20]
	tim2_handle.Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800bad0:	2301      	movs	r3, #1
 800bad2:	7623      	strb	r3, [r4, #24]

	/* NVIC configuration for DMA transfer complete interrupt */
	HAL_NVIC_SetPriority( TIM2_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 1, 0 );
 800bad4:	2106      	movs	r1, #6
 800bad6:	201c      	movs	r0, #28
 800bad8:	f7f4 fdc8 	bl	800066c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ( TIM2_IRQn );
 800badc:	201c      	movs	r0, #28
 800bade:	f7f4 fdf5 	bl	80006cc <HAL_NVIC_EnableIRQ>


	HAL_TIM_Base_Init( &tim2_handle );
 800bae2:	4620      	mov	r0, r4
 800bae4:	f7f7 f9ec 	bl	8002ec0 <HAL_TIM_Base_Init>
	HAL_TIM_Base_Start_IT( &tim2_handle );
 800bae8:	4620      	mov	r0, r4
 800baea:	f7f7 f972 	bl	8002dd2 <HAL_TIM_Base_Start_IT>
	ulTimer2Flags = tim2_handle.Instance->SR;
 800baee:	6823      	ldr	r3, [r4, #0]
 800baf0:	691a      	ldr	r2, [r3, #16]
 800baf2:	4b04      	ldr	r3, [pc, #16]	; (800bb04 <vStartHighResolutionTimer+0x58>)
 800baf4:	601a      	str	r2, [r3, #0]
 800baf6:	bd10      	pop	{r4, pc}
 800baf8:	40023800 	.word	0x40023800
 800bafc:	20004cf4 	.word	0x20004cf4
 800bb00:	0098967f 	.word	0x0098967f
 800bb04:	20004cf0 	.word	0x20004cf0

0800bb08 <ullGetHighResolutionTime>:
}

uint64_t ullGetHighResolutionTime()
{
 800bb08:	b538      	push	{r3, r4, r5, lr}
uint64_t ullReturn;
	if( tim2_handle.Instance == NULL )
 800bb0a:	4b12      	ldr	r3, [pc, #72]	; (800bb54 <ullGetHighResolutionTime+0x4c>)
 800bb0c:	681b      	ldr	r3, [r3, #0]
 800bb0e:	b153      	cbz	r3, 800bb26 <ullGetHighResolutionTime+0x1e>
	uint32_t ulCounts[2];
	uint32_t ulSlowCount;

		for( ;; )
		{
			ulCounts[ 0 ] = tim2_handle.Instance->CNT;
 800bb10:	6a5a      	ldr	r2, [r3, #36]	; 0x24
			ulSlowCount = ulInterruptCount;
			ulCounts[ 1 ] = tim2_handle.Instance->CNT;
 800bb12:	6a58      	ldr	r0, [r3, #36]	; 0x24
			if( ulCounts[ 1 ] >= ulCounts[ 0 ] )
 800bb14:	4282      	cmp	r2, r0
 800bb16:	d8fb      	bhi.n	800bb10 <ullGetHighResolutionTime+0x8>
			ulSlowCount = ulInterruptCount;
 800bb18:	4b0f      	ldr	r3, [pc, #60]	; (800bb58 <ullGetHighResolutionTime+0x50>)
			{
				/* TIM2_IRQHandler() has not occurred in between. */
				break;
			}
		}
		ullReturn = ( uint64_t )ulSlowCount * ulReloadCount + ulCounts[ 1 ];
 800bb1a:	681a      	ldr	r2, [r3, #0]
 800bb1c:	2100      	movs	r1, #0
 800bb1e:	4b0f      	ldr	r3, [pc, #60]	; (800bb5c <ullGetHighResolutionTime+0x54>)
 800bb20:	fbe3 0102 	umlal	r0, r1, r3, r2
	}

	return ullReturn;
}
 800bb24:	bd38      	pop	{r3, r4, r5, pc}
		ullReturn = 1000ull * xTaskGetTickCount();
 800bb26:	f7fd ff4b 	bl	80099c0 <xTaskGetTickCount>
 800bb2a:	4604      	mov	r4, r0
 800bb2c:	2500      	movs	r5, #0
 800bb2e:	0142      	lsls	r2, r0, #5
 800bb30:	0ec3      	lsrs	r3, r0, #27
 800bb32:	1a12      	subs	r2, r2, r0
 800bb34:	eb63 0305 	sbc.w	r3, r3, r5
 800bb38:	009b      	lsls	r3, r3, #2
 800bb3a:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
 800bb3e:	0092      	lsls	r2, r2, #2
 800bb40:	1910      	adds	r0, r2, r4
 800bb42:	eb43 0105 	adc.w	r1, r3, r5
 800bb46:	00cb      	lsls	r3, r1, #3
 800bb48:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 800bb4c:	00c2      	lsls	r2, r0, #3
 800bb4e:	4610      	mov	r0, r2
 800bb50:	4619      	mov	r1, r3
 800bb52:	bd38      	pop	{r3, r4, r5, pc}
 800bb54:	20004cf4 	.word	0x20004cf4
 800bb58:	200027f0 	.word	0x200027f0
 800bb5c:	00989680 	.word	0x00989680

0800bb60 <main>:

/*-----------------------------------------------------------*/

/* See http://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/TCP-IP_FAT_Examples_ST_STM32F407.html */
int main( void )
{
 800bb60:	b580      	push	{r7, lr}
 800bb62:	b098      	sub	sp, #96	; 0x60
static void prvMiscInitialisation( void )
{
GPIO_InitTypeDef GPIO_InitStruct;

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	__asm volatile( "cpsid i" );
 800bb64:	b672      	cpsid	i
	HAL_Init();
 800bb66:	f7f4 fd39 	bl	80005dc <HAL_Init>
	__PWR_CLK_ENABLE();
 800bb6a:	4c4e      	ldr	r4, [pc, #312]	; (800bca4 <main+0x144>)
 800bb6c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800bb6e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800bb72:	6423      	str	r3, [r4, #64]	; 0x40
	__HAL_PWR_VOLTAGESCALING_CONFIG( PWR_REGULATOR_VOLTAGE_SCALE1 );
 800bb74:	4a4c      	ldr	r2, [pc, #304]	; (800bca8 <main+0x148>)
 800bb76:	6813      	ldr	r3, [r2, #0]
 800bb78:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800bb7c:	6013      	str	r3, [r2, #0]
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
 800bb7e:	2309      	movs	r3, #9
 800bb80:	930c      	str	r3, [sp, #48]	; 0x30
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800bb82:	2601      	movs	r6, #1
 800bb84:	960d      	str	r6, [sp, #52]	; 0x34
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800bb86:	9611      	str	r6, [sp, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800bb88:	2702      	movs	r7, #2
 800bb8a:	9712      	str	r7, [sp, #72]	; 0x48
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800bb8c:	f44f 0880 	mov.w	r8, #4194304	; 0x400000
 800bb90:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
	RCC_OscInitStruct.PLL.PLLM = 25;
 800bb94:	2319      	movs	r3, #25
 800bb96:	9314      	str	r3, [sp, #80]	; 0x50
	RCC_OscInitStruct.PLL.PLLN = 336;
 800bb98:	f44f 73a8 	mov.w	r3, #336	; 0x150
 800bb9c:	9315      	str	r3, [sp, #84]	; 0x54
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800bb9e:	9716      	str	r7, [sp, #88]	; 0x58
	RCC_OscInitStruct.PLL.PLLQ = 7;
 800bba0:	2307      	movs	r3, #7
 800bba2:	9317      	str	r3, [sp, #92]	; 0x5c
	HAL_RCC_OscConfig( &RCC_OscInitStruct );
 800bba4:	a80c      	add	r0, sp, #48	; 0x30
 800bba6:	f7f6 fc97 	bl	80024d8 <HAL_RCC_OscConfig>
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800bbaa:	230d      	movs	r3, #13
 800bbac:	9307      	str	r3, [sp, #28]
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800bbae:	9708      	str	r7, [sp, #32]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800bbb0:	2500      	movs	r5, #0
 800bbb2:	9509      	str	r5, [sp, #36]	; 0x24
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800bbb4:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800bbb8:	930a      	str	r3, [sp, #40]	; 0x28
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800bbba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bbbe:	930b      	str	r3, [sp, #44]	; 0x2c
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 800bbc0:	2105      	movs	r1, #5
 800bbc2:	a807      	add	r0, sp, #28
 800bbc4:	f7f6 fe54 	bl	8002870 <HAL_RCC_ClockConfig>
	PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800bbc8:	9703      	str	r7, [sp, #12]
	PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 800bbca:	f44f 7300 	mov.w	r3, #512	; 0x200
 800bbce:	9306      	str	r3, [sp, #24]
	HAL_RCCEx_PeriphCLKConfig( &PeriphClkInitStruct );
 800bbd0:	a803      	add	r0, sp, #12
 800bbd2:	f7f7 f801 	bl	8002bd8 <HAL_RCCEx_PeriphCLKConfig>
	HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSE, RCC_MCODIV_1);
 800bbd6:	462a      	mov	r2, r5
 800bbd8:	4641      	mov	r1, r8
 800bbda:	4628      	mov	r0, r5
 800bbdc:	f7f6 ff60 	bl	8002aa0 <HAL_RCC_MCOConfig>

	/* Configure clocks. */
	prvConfigureClocks();

	/* GPIO Ports Clock Enable */
	__GPIOA_CLK_ENABLE();
 800bbe0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bbe2:	4333      	orrs	r3, r6
 800bbe4:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOG_CLK_ENABLE();
 800bbe6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bbe8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bbec:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOD_CLK_ENABLE();
 800bbee:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bbf0:	f043 0308 	orr.w	r3, r3, #8
 800bbf4:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOE_CLK_ENABLE();
 800bbf6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bbf8:	f043 0310 	orr.w	r3, r3, #16
 800bbfc:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOF_CLK_ENABLE();
 800bbfe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bc00:	f043 0320 	orr.w	r3, r3, #32
 800bc04:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOH_CLK_ENABLE();
 800bc06:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bc08:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800bc0c:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOB_CLK_ENABLE();
 800bc0e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bc10:	433b      	orrs	r3, r7
 800bc12:	6323      	str	r3, [r4, #48]	; 0x30
	__GPIOC_CLK_ENABLE();
 800bc14:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bc16:	f043 0304 	orr.w	r3, r3, #4
 800bc1a:	6323      	str	r3, [r4, #48]	; 0x30

	/* Configure GPIO pins : PE2 PE5 PE6 和JLink相关*/
	GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5|GPIO_PIN_6;
 800bc1c:	2364      	movs	r3, #100	; 0x64
 800bc1e:	930c      	str	r3, [sp, #48]	; 0x30
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bc20:	970d      	str	r7, [sp, #52]	; 0x34
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bc22:	950e      	str	r5, [sp, #56]	; 0x38
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800bc24:	950f      	str	r5, [sp, #60]	; 0x3c
	GPIO_InitStruct.Alternate = GPIO_AF0_TRACE;
 800bc26:	9510      	str	r5, [sp, #64]	; 0x40
	HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800bc28:	a90c      	add	r1, sp, #48	; 0x30
 800bc2a:	4820      	ldr	r0, [pc, #128]	; (800bcac <main+0x14c>)
 800bc2c:	f7f6 fb60 	bl	80022f0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PG12 PG8 PG6 (LED已经ok). */
	GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 800bc30:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800bc34:	930c      	str	r3, [sp, #48]	; 0x30
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800bc36:	960d      	str	r6, [sp, #52]	; 0x34
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 800bc38:	960e      	str	r6, [sp, #56]	; 0x38
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800bc3a:	950f      	str	r5, [sp, #60]	; 0x3c
	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 800bc3c:	a90c      	add	r1, sp, #48	; 0x30
 800bc3e:	481c      	ldr	r0, [pc, #112]	; (800bcb0 <main+0x150>)
 800bc40:	f7f6 fb56 	bl	80022f0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PH13 (SD card detect) */
	GPIO_InitStruct.Pin = GPIO_PIN_13;
 800bc44:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800bc48:	930c      	str	r3, [sp, #48]	; 0x30
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800bc4a:	950d      	str	r5, [sp, #52]	; 0x34
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 800bc4c:	960e      	str	r6, [sp, #56]	; 0x38
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 800bc4e:	a90c      	add	r1, sp, #48	; 0x30
 800bc50:	4818      	ldr	r0, [pc, #96]	; (800bcb4 <main+0x154>)
 800bc52:	f7f6 fb4d 	bl	80022f0 <HAL_GPIO_Init>

	/* Heap_5 is used so the maximum heap size can be calculated and initialised
	at run time. */
	pucHeapStart = ( uint8_t * ) ( ( ( ( uint32_t ) &HEAP_START ) + 7 ) & ~0x07ul );

	ulHeapSize = ( uint32_t ) ( &HEAP_END - &HEAP_START );
 800bc56:	4b18      	ldr	r3, [pc, #96]	; (800bcb8 <main+0x158>)
 800bc58:	4a18      	ldr	r2, [pc, #96]	; (800bcbc <main+0x15c>)
 800bc5a:	1ad2      	subs	r2, r2, r3
 800bc5c:	9203      	str	r2, [sp, #12]
	ulHeapSize &= ~0x07ul;
 800bc5e:	9a03      	ldr	r2, [sp, #12]
 800bc60:	f022 0207 	bic.w	r2, r2, #7
 800bc64:	9203      	str	r2, [sp, #12]
	ulHeapSize -= 1024;
 800bc66:	9a03      	ldr	r2, [sp, #12]
 800bc68:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 800bc6c:	9203      	str	r2, [sp, #12]
	pucHeapStart = ( uint8_t * ) ( ( ( ( uint32_t ) &HEAP_START ) + 7 ) & ~0x07ul );
 800bc6e:	3307      	adds	r3, #7
 800bc70:	f023 0307 	bic.w	r3, r3, #7

	HeapRegion_t xHeapRegions[] =
 800bc74:	9307      	str	r3, [sp, #28]
 800bc76:	9b03      	ldr	r3, [sp, #12]
 800bc78:	9308      	str	r3, [sp, #32]
 800bc7a:	9509      	str	r5, [sp, #36]	; 0x24
 800bc7c:	950a      	str	r5, [sp, #40]	; 0x28
	{
		{ ( unsigned char *) pucHeapStart, ulHeapSize },
		{ NULL, 0 }
 	};

	vPortDefineHeapRegions( xHeapRegions );
 800bc7e:	a807      	add	r0, sp, #28
 800bc80:	f7fd f87e 	bl	8008d80 <vPortDefineHeapRegions>
	vStartHighResolutionTimer();
 800bc84:	f7ff ff12 	bl	800baac <vStartHighResolutionTimer>
	FreeRTOS_printf( ( "FreeRTOS_IPInit\n" ) );
 800bc88:	480d      	ldr	r0, [pc, #52]	; (800bcc0 <main+0x160>)
 800bc8a:	f7ff fba5 	bl	800b3d8 <lUDPLoggingPrintf>
	FreeRTOS_IPInit( ucIPAddress, ucNetMask, ucGatewayAddress, ucDNSServerAddress, ucMACAddress );
 800bc8e:	4b0d      	ldr	r3, [pc, #52]	; (800bcc4 <main+0x164>)
 800bc90:	9300      	str	r3, [sp, #0]
 800bc92:	4b0d      	ldr	r3, [pc, #52]	; (800bcc8 <main+0x168>)
 800bc94:	4a0d      	ldr	r2, [pc, #52]	; (800bccc <main+0x16c>)
 800bc96:	490e      	ldr	r1, [pc, #56]	; (800bcd0 <main+0x170>)
 800bc98:	480e      	ldr	r0, [pc, #56]	; (800bcd4 <main+0x174>)
 800bc9a:	f7f8 f89f 	bl	8003ddc <FreeRTOS_IPInit>
	vTaskStartScheduler();
 800bc9e:	f7fd fe4b 	bl	8009938 <vTaskStartScheduler>
 800bca2:	e7fe      	b.n	800bca2 <main+0x142>
 800bca4:	40023800 	.word	0x40023800
 800bca8:	40007000 	.word	0x40007000
 800bcac:	40021000 	.word	0x40021000
 800bcb0:	40021400 	.word	0x40021400
 800bcb4:	40021c00 	.word	0x40021c00
 800bcb8:	20004d30 	.word	0x20004d30
 800bcbc:	20020000 	.word	0x20020000
 800bcc0:	0800d5ec 	.word	0x0800d5ec
 800bcc4:	0800d618 	.word	0x0800d618
 800bcc8:	0800d60c 	.word	0x0800d60c
 800bccc:	0800d610 	.word	0x0800d610
 800bcd0:	0800d620 	.word	0x0800d620
 800bcd4:	0800d614 	.word	0x0800d614

0800bcd8 <vApplicationIdleHook>:
{
 800bcd8:	b508      	push	{r3, lr}
	xTimeNow = xTaskGetTickCount();
 800bcda:	f7fd fe71 	bl	80099c0 <xTaskGetTickCount>
	if( ( xTimeNow - xLastToggle ) >= xToggleRate )
 800bcde:	4b09      	ldr	r3, [pc, #36]	; (800bd04 <vApplicationIdleHook+0x2c>)
 800bce0:	681b      	ldr	r3, [r3, #0]
 800bce2:	1ac0      	subs	r0, r0, r3
 800bce4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800bce8:	d200      	bcs.n	800bcec <vApplicationIdleHook+0x14>
 800bcea:	bd08      	pop	{r3, pc}
		HAL_GPIO_TogglePin( GPIOF, GPIO_PIN_9 );
 800bcec:	f44f 7100 	mov.w	r1, #512	; 0x200
 800bcf0:	4805      	ldr	r0, [pc, #20]	; (800bd08 <vApplicationIdleHook+0x30>)
 800bcf2:	f7f6 fbdf 	bl	80024b4 <HAL_GPIO_TogglePin>
		xLastToggle += xToggleRate;
 800bcf6:	4a03      	ldr	r2, [pc, #12]	; (800bd04 <vApplicationIdleHook+0x2c>)
 800bcf8:	6813      	ldr	r3, [r2, #0]
 800bcfa:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 800bcfe:	6013      	str	r3, [r2, #0]
}
 800bd00:	e7f3      	b.n	800bcea <vApplicationIdleHook+0x12>
 800bd02:	bf00      	nop
 800bd04:	200027fc 	.word	0x200027fc
 800bd08:	40021400 	.word	0x40021400

0800bd0c <vAssertCalled>:
{
 800bd0c:	b570      	push	{r4, r5, r6, lr}
 800bd0e:	b084      	sub	sp, #16
 800bd10:	4606      	mov	r6, r0
 800bd12:	460d      	mov	r5, r1
volatile uint32_t ulBlockVariable = 0UL;
 800bd14:	2400      	movs	r4, #0
 800bd16:	9403      	str	r4, [sp, #12]
	ulAssertedLine = ulLine;
 800bd18:	9101      	str	r1, [sp, #4]

static portINLINE int stdioGET_ERRNO( void )
{
void *pvResult;

	pvResult = pvTaskGetThreadLocalStoragePointer( NULL, ffconfigCWD_THREAD_LOCAL_INDEX );
 800bd1a:	4621      	mov	r1, r4
 800bd1c:	4620      	mov	r0, r4
 800bd1e:	f7fe f99b 	bl	800a058 <pvTaskGetThreadLocalStoragePointer>
	iAssertedErrno = stdioGET_ERRNO();
 800bd22:	9002      	str	r0, [sp, #8]
 */
static portINLINE FF_Error_t stdioGET_FF_ERROR( void )
{
void *pvResult;

	pvResult = pvTaskGetThreadLocalStoragePointer( NULL, stdioFF_ERROR_THREAD_LOCAL_OFFSET );
 800bd24:	2102      	movs	r1, #2
 800bd26:	4620      	mov	r0, r4
 800bd28:	f7fe f996 	bl	800a058 <pvTaskGetThreadLocalStoragePointer>
	xAssertedFF_Error = stdioGET_FF_ERROR( );
 800bd2c:	9000      	str	r0, [sp, #0]
	( void ) ulAssertedLine;
 800bd2e:	9b01      	ldr	r3, [sp, #4]
	( void ) iAssertedErrno;
 800bd30:	9b02      	ldr	r3, [sp, #8]
	( void ) xAssertedFF_Error;
 800bd32:	9b00      	ldr	r3, [sp, #0]
	FreeRTOS_printf( ( "vAssertCalled( %s, %ld\n", pcFile, ulLine ) );
 800bd34:	462a      	mov	r2, r5
 800bd36:	4631      	mov	r1, r6
 800bd38:	480a      	ldr	r0, [pc, #40]	; (800bd64 <vAssertCalled+0x58>)
 800bd3a:	f7ff fb4d 	bl	800b3d8 <lUDPLoggingPrintf>
	__asm volatile
 800bd3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bd42:	f383 8811 	msr	BASEPRI, r3
 800bd46:	f3bf 8f6f 	isb	sy
 800bd4a:	f3bf 8f4f 	dsb	sy
		while( ulBlockVariable == 0UL )
 800bd4e:	9b03      	ldr	r3, [sp, #12]
 800bd50:	b91b      	cbnz	r3, 800bd5a <vAssertCalled+0x4e>
			__asm volatile( "NOP" );
 800bd52:	bf00      	nop
		while( ulBlockVariable == 0UL )
 800bd54:	9b03      	ldr	r3, [sp, #12]
 800bd56:	2b00      	cmp	r3, #0
 800bd58:	d0fb      	beq.n	800bd52 <vAssertCalled+0x46>
	__asm volatile
 800bd5a:	2300      	movs	r3, #0
 800bd5c:	f383 8811 	msr	BASEPRI, r3
}
 800bd60:	b004      	add	sp, #16
 800bd62:	bd70      	pop	{r4, r5, r6, pc}
 800bd64:	0800d6a4 	.word	0x0800d6a4

0800bd68 <vApplicationCardDetectChangeHookFromISR>:
{
 800bd68:	4770      	bx	lr
	...

0800bd6c <vApplicationIPNetworkEventHook>:
{
 800bd6c:	b510      	push	{r4, lr}
 800bd6e:	b08a      	sub	sp, #40	; 0x28
 800bd70:	4604      	mov	r4, r0
	FreeRTOS_printf( ( "vApplicationIPNetworkEventHook: event %ld\n", eNetworkEvent ) );
 800bd72:	4601      	mov	r1, r0
 800bd74:	4838      	ldr	r0, [pc, #224]	; (800be58 <vApplicationIPNetworkEventHook+0xec>)
 800bd76:	f7ff fb2f 	bl	800b3d8 <lUDPLoggingPrintf>
	if( eNetworkEvent == eNetworkUp )
 800bd7a:	2c00      	cmp	r4, #0
 800bd7c:	d14e      	bne.n	800be1c <vApplicationIPNetworkEventHook+0xb0>
		if( xTasksAlreadyCreated == pdFALSE )
 800bd7e:	4b37      	ldr	r3, [pc, #220]	; (800be5c <vApplicationIPNetworkEventHook+0xf0>)
 800bd80:	681b      	ldr	r3, [r3, #0]
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	d04c      	beq.n	800be20 <vApplicationIPNetworkEventHook+0xb4>
		FreeRTOS_GetAddressConfiguration( &ulIPAddress, &ulNetMask, &ulGatewayAddress, &ulDNSServerAddress );
 800bd86:	ab06      	add	r3, sp, #24
 800bd88:	aa07      	add	r2, sp, #28
 800bd8a:	a908      	add	r1, sp, #32
 800bd8c:	a809      	add	r0, sp, #36	; 0x24
 800bd8e:	f7f8 f8db 	bl	8003f48 <FreeRTOS_GetAddressConfiguration>
		FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
 800bd92:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800bd94:	4c32      	ldr	r4, [pc, #200]	; (800be60 <vApplicationIPNetworkEventHook+0xf4>)
 800bd96:	0e13      	lsrs	r3, r2, #24
 800bd98:	9301      	str	r3, [sp, #4]
 800bd9a:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800bd9e:	9300      	str	r3, [sp, #0]
 800bda0:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800bda4:	b2d2      	uxtb	r2, r2
 800bda6:	4621      	mov	r1, r4
 800bda8:	a802      	add	r0, sp, #8
 800bdaa:	f7ff fcf8 	bl	800b79e <sprintf>
		FreeRTOS_printf( ( "IP Address: %s\n", cBuffer ) );
 800bdae:	a902      	add	r1, sp, #8
 800bdb0:	482c      	ldr	r0, [pc, #176]	; (800be64 <vApplicationIPNetworkEventHook+0xf8>)
 800bdb2:	f7ff fb11 	bl	800b3d8 <lUDPLoggingPrintf>
		FreeRTOS_inet_ntoa( ulNetMask, cBuffer );
 800bdb6:	9a08      	ldr	r2, [sp, #32]
 800bdb8:	0e13      	lsrs	r3, r2, #24
 800bdba:	9301      	str	r3, [sp, #4]
 800bdbc:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800bdc0:	9300      	str	r3, [sp, #0]
 800bdc2:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800bdc6:	b2d2      	uxtb	r2, r2
 800bdc8:	4621      	mov	r1, r4
 800bdca:	a802      	add	r0, sp, #8
 800bdcc:	f7ff fce7 	bl	800b79e <sprintf>
		FreeRTOS_printf( ( "Subnet Mask: %s\n", cBuffer ) );
 800bdd0:	a902      	add	r1, sp, #8
 800bdd2:	4825      	ldr	r0, [pc, #148]	; (800be68 <vApplicationIPNetworkEventHook+0xfc>)
 800bdd4:	f7ff fb00 	bl	800b3d8 <lUDPLoggingPrintf>
		FreeRTOS_inet_ntoa( ulGatewayAddress, cBuffer );
 800bdd8:	9a07      	ldr	r2, [sp, #28]
 800bdda:	0e13      	lsrs	r3, r2, #24
 800bddc:	9301      	str	r3, [sp, #4]
 800bdde:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800bde2:	9300      	str	r3, [sp, #0]
 800bde4:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800bde8:	b2d2      	uxtb	r2, r2
 800bdea:	4621      	mov	r1, r4
 800bdec:	a802      	add	r0, sp, #8
 800bdee:	f7ff fcd6 	bl	800b79e <sprintf>
		FreeRTOS_printf( ( "Gateway Address: %s\n", cBuffer ) );
 800bdf2:	a902      	add	r1, sp, #8
 800bdf4:	481d      	ldr	r0, [pc, #116]	; (800be6c <vApplicationIPNetworkEventHook+0x100>)
 800bdf6:	f7ff faef 	bl	800b3d8 <lUDPLoggingPrintf>
		FreeRTOS_inet_ntoa( ulDNSServerAddress, cBuffer );
 800bdfa:	9a06      	ldr	r2, [sp, #24]
 800bdfc:	0e13      	lsrs	r3, r2, #24
 800bdfe:	9301      	str	r3, [sp, #4]
 800be00:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800be04:	9300      	str	r3, [sp, #0]
 800be06:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800be0a:	b2d2      	uxtb	r2, r2
 800be0c:	4621      	mov	r1, r4
 800be0e:	a802      	add	r0, sp, #8
 800be10:	f7ff fcc5 	bl	800b79e <sprintf>
		FreeRTOS_printf( ( "DNS Server Address: %s\n", cBuffer ) );
 800be14:	a902      	add	r1, sp, #8
 800be16:	4816      	ldr	r0, [pc, #88]	; (800be70 <vApplicationIPNetworkEventHook+0x104>)
 800be18:	f7ff fade 	bl	800b3d8 <lUDPLoggingPrintf>
}
 800be1c:	b00a      	add	sp, #40	; 0x28
 800be1e:	bd10      	pop	{r4, pc}
				vUDPLoggingTaskCreate();
 800be20:	f7ff fb82 	bl	800b528 <vUDPLoggingTaskCreate>
				vStartTCPEchoClientTasks_SingleTasks( mainECHO_CLIENT_TASK_STACK_SIZE, mainECHO_CLIENT_TASK_PRIORITY );
 800be24:	2101      	movs	r1, #1
 800be26:	f44f 7000 	mov.w	r0, #512	; 0x200
 800be2a:	f7ff f9bb 	bl	800b1a4 <vStartTCPEchoClientTasks_SingleTasks>
				vStartSimpleTCPServerTasks( mainECHO_SERVER_STACK_SIZE, mainECHO_SERVER_TASK_PRIORITY );
 800be2e:	2102      	movs	r1, #2
 800be30:	f44f 7000 	mov.w	r0, #512	; 0x200
 800be34:	f7ff f8aa 	bl	800af8c <vStartSimpleTCPServerTasks>
				vRegisterSampleCLICommands();
 800be38:	f7fe fdb8 	bl	800a9ac <vRegisterSampleCLICommands>
				vRegisterTCPCLICommands();
 800be3c:	f7fe fefa 	bl	800ac34 <vRegisterTCPCLICommands>
				vStartUDPCommandInterpreterTask( mainUDP_CLI_TASK_STACK_SIZE, mainUDP_CLI_PORT_NUMBER, mainUDP_CLI_TASK_PRIORITY );
 800be40:	2201      	movs	r2, #1
 800be42:	f241 3189 	movw	r1, #5001	; 0x1389
 800be46:	f44f 7020 	mov.w	r0, #640	; 0x280
 800be4a:	f7fe ffcd 	bl	800ade8 <vStartUDPCommandInterpreterTask>
			xTasksAlreadyCreated = pdTRUE;
 800be4e:	2201      	movs	r2, #1
 800be50:	4b02      	ldr	r3, [pc, #8]	; (800be5c <vApplicationIPNetworkEventHook+0xf0>)
 800be52:	601a      	str	r2, [r3, #0]
 800be54:	e797      	b.n	800bd86 <vApplicationIPNetworkEventHook+0x1a>
 800be56:	bf00      	nop
 800be58:	0800d624 	.word	0x0800d624
 800be5c:	20002800 	.word	0x20002800
 800be60:	0800cf00 	.word	0x0800cf00
 800be64:	0800d650 	.word	0x0800d650
 800be68:	0800d660 	.word	0x0800d660
 800be6c:	0800d674 	.word	0x0800d674
 800be70:	0800d68c 	.word	0x0800d68c

0800be74 <vApplicationMallocFailedHook>:
{
 800be74:	b082      	sub	sp, #8
volatile uint32_t ulMallocFailures = 0;
 800be76:	2300      	movs	r3, #0
 800be78:	9301      	str	r3, [sp, #4]
	ulMallocFailures++;
 800be7a:	9b01      	ldr	r3, [sp, #4]
 800be7c:	3301      	adds	r3, #1
 800be7e:	9301      	str	r3, [sp, #4]
}
 800be80:	b002      	add	sp, #8
 800be82:	4770      	bx	lr

0800be84 <vApplicationStackOverflowHook>:
	__asm volatile
 800be84:	f04f 0350 	mov.w	r3, #80	; 0x50
 800be88:	f383 8811 	msr	BASEPRI, r3
 800be8c:	f3bf 8f6f 	isb	sy
 800be90:	f3bf 8f4f 	dsb	sy
 800be94:	e7fe      	b.n	800be94 <vApplicationStackOverflowHook+0x10>
	...

0800be98 <uxRand>:
{
 800be98:	b500      	push	{lr}
 800be9a:	b085      	sub	sp, #20
	if( xInitialised == pdFALSE )
 800be9c:	4b10      	ldr	r3, [pc, #64]	; (800bee0 <uxRand+0x48>)
 800be9e:	681b      	ldr	r3, [r3, #0]
 800bea0:	b15b      	cbz	r3, 800beba <uxRand+0x22>
	ulNextRand = ( ulMultiplier * ulNextRand ) + ulIncrement;
 800bea2:	4b10      	ldr	r3, [pc, #64]	; (800bee4 <uxRand+0x4c>)
 800bea4:	681a      	ldr	r2, [r3, #0]
 800bea6:	4810      	ldr	r0, [pc, #64]	; (800bee8 <uxRand+0x50>)
 800bea8:	fb00 f002 	mul.w	r0, r0, r2
 800beac:	3001      	adds	r0, #1
 800beae:	6018      	str	r0, [r3, #0]
}
 800beb0:	f3c0 400e 	ubfx	r0, r0, #16, #15
 800beb4:	b005      	add	sp, #20
 800beb6:	f85d fb04 	ldr.w	pc, [sp], #4
		if( xTaskGetSchedulerState() !=  taskSCHEDULER_NOT_STARTED )
 800beba:	f7fe f9ad 	bl	800a218 <xTaskGetSchedulerState>
 800bebe:	2801      	cmp	r0, #1
 800bec0:	d0ef      	beq.n	800bea2 <uxRand+0xa>
			HAL_RNG_Init( &xRND );
 800bec2:	a801      	add	r0, sp, #4
 800bec4:	f7f6 ff39 	bl	8002d3a <HAL_RNG_Init>
			HAL_RNG_GenerateRandomNumber( &xRND, &ulSeed );
 800bec8:	4669      	mov	r1, sp
 800beca:	a801      	add	r0, sp, #4
 800becc:	f7f6 ff52 	bl	8002d74 <HAL_RNG_GenerateRandomNumber>
	ulNextRand = ulSeed;
 800bed0:	9a00      	ldr	r2, [sp, #0]
 800bed2:	4b04      	ldr	r3, [pc, #16]	; (800bee4 <uxRand+0x4c>)
 800bed4:	601a      	str	r2, [r3, #0]
			xInitialised = pdTRUE;
 800bed6:	2201      	movs	r2, #1
 800bed8:	4b01      	ldr	r3, [pc, #4]	; (800bee0 <uxRand+0x48>)
 800beda:	601a      	str	r2, [r3, #0]
 800bedc:	e7e1      	b.n	800bea2 <uxRand+0xa>
 800bede:	bf00      	nop
 800bee0:	200027f8 	.word	0x200027f8
 800bee4:	200027f4 	.word	0x200027f4
 800bee8:	015a4e35 	.word	0x015a4e35

0800beec <vApplicationPingReplyHook>:
{
 800beec:	4770      	bx	lr

0800beee <vOutputChar>:
}
/*-----------------------------------------------------------*/

void vOutputChar( const char cChar, const TickType_t xTicksToWait  )
{
 800beee:	4770      	bx	lr

0800bef0 <xApplicationDNSQueryHook>:
}
/*-----------------------------------------------------------*/


BaseType_t xApplicationDNSQueryHook( const char *pcName )
{
 800bef0:	b510      	push	{r4, lr}
 800bef2:	4604      	mov	r4, r0
BaseType_t xReturn;

	/* Determine if a name lookup is for this node.  Two names are given
	to this node: that returned by pcApplicationHostnameHook() and that set
	by mainDEVICE_NICK_NAME. */
	if( strcasecmp( pcName, pcApplicationHostnameHook() ) == 0 )
 800bef4:	4906      	ldr	r1, [pc, #24]	; (800bf10 <xApplicationDNSQueryHook+0x20>)
 800bef6:	f7f7 f8dd 	bl	80030b4 <strcasecmp>
 800befa:	b138      	cbz	r0, 800bf0c <xApplicationDNSQueryHook+0x1c>
	{
		xReturn = pdPASS;
	}
	else if( strcasecmp( pcName, mainDEVICE_NICK_NAME ) == 0 )
 800befc:	4905      	ldr	r1, [pc, #20]	; (800bf14 <xApplicationDNSQueryHook+0x24>)
 800befe:	4620      	mov	r0, r4
 800bf00:	f7f7 f8d8 	bl	80030b4 <strcasecmp>
 800bf04:	fab0 f080 	clz	r0, r0
 800bf08:	0940      	lsrs	r0, r0, #5
 800bf0a:	bd10      	pop	{r4, pc}
 800bf0c:	2001      	movs	r0, #1
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
 800bf0e:	bd10      	pop	{r4, pc}
 800bf10:	0800d600 	.word	0x0800d600
 800bf14:	0800d6bc 	.word	0x0800d6bc

0800bf18 <xGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

uint32_t xGetRunTimeCounterValue( void )
{
 800bf18:	b508      	push	{r3, lr}
static uint64_t ullHiresTime = 0; /* Is always 0? */

	return ( uint32_t ) ( ullGetHighResolutionTime() - ullHiresTime );
 800bf1a:	f7ff fdf5 	bl	800bb08 <ullGetHighResolutionTime>
}
 800bf1e:	bd08      	pop	{r3, pc}

0800bf20 <vApplicationTickHook>:
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
 800bf20:	b508      	push	{r3, lr}
	/* Call the ST HAL tick function. */
	HAL_IncTick();
 800bf22:	f7f4 fb75 	bl	8000610 <HAL_IncTick>
 800bf26:	bd08      	pop	{r3, pc}

0800bf28 <HAL_ETH_MspInit>:
/* This is an ST HAL driver callback function. */
void HAL_ETH_MspInit( ETH_HandleTypeDef* xETHHandle )
{
GPIO_InitTypeDef GPIO_InitStruct;

	if( xETHHandle->Instance == ETH )
 800bf28:	6802      	ldr	r2, [r0, #0]
 800bf2a:	4b2c      	ldr	r3, [pc, #176]	; (800bfdc <HAL_ETH_MspInit+0xb4>)
 800bf2c:	429a      	cmp	r2, r3
 800bf2e:	d000      	beq.n	800bf32 <HAL_ETH_MspInit+0xa>
 800bf30:	4770      	bx	lr
{
 800bf32:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bf36:	b087      	sub	sp, #28
	{
		/* Peripheral clock enable */
		__ETH_CLK_ENABLE();			/* defined as __HAL_RCC_ETH_CLK_ENABLE. */
 800bf38:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
 800bf3c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bf3e:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800bf42:	631a      	str	r2, [r3, #48]	; 0x30
 800bf44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bf46:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800bf4a:	631a      	str	r2, [r3, #48]	; 0x30
 800bf4c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bf4e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800bf52:	631a      	str	r2, [r3, #48]	; 0x30
		__ETHMACRX_CLK_ENABLE();	/* defined as __HAL_RCC_ETHMACRX_CLK_ENABLE. */
 800bf54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bf56:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800bf5a:	631a      	str	r2, [r3, #48]	; 0x30
		__ETHMACTX_CLK_ENABLE();	/* defined as __HAL_RCC_ETHMACTX_CLK_ENABLE. */
 800bf5c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bf5e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800bf62:	631a      	str	r2, [r3, #48]	; 0x30
	//	GPIO_InitStruct.Pull = GPIO_NOPULL;
	//	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
	//	GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
	//	HAL_GPIO_Init( GPIOB, &GPIO_InitStruct );

		GPIO_InitStruct.Pin = GPIO_PIN_14 | GPIO_PIN_13 | GPIO_PIN_11;
 800bf64:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
 800bf68:	9301      	str	r3, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bf6a:	2702      	movs	r7, #2
 800bf6c:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bf6e:	2400      	movs	r4, #0
 800bf70:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800bf72:	2603      	movs	r6, #3
 800bf74:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800bf76:	250b      	movs	r5, #11
 800bf78:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOG, &GPIO_InitStruct );
 800bf7a:	a901      	add	r1, sp, #4
 800bf7c:	4818      	ldr	r0, [pc, #96]	; (800bfe0 <HAL_ETH_MspInit+0xb8>)
 800bf7e:	f7f6 f9b7 	bl	80022f0 <HAL_GPIO_Init>
	//	GPIO_InitStruct.Pull = GPIO_NOPULL;
	//	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
	//	GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
	//	HAL_GPIO_Init( GPIOH, &GPIO_InitStruct );

		GPIO_InitStruct.Pin = GPIO_PIN_1  | GPIO_PIN_4 | GPIO_PIN_5;
 800bf82:	2332      	movs	r3, #50	; 0x32
 800bf84:	9301      	str	r3, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bf86:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bf88:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800bf8a:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800bf8c:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOC, &GPIO_InitStruct );
 800bf8e:	a901      	add	r1, sp, #4
 800bf90:	4814      	ldr	r0, [pc, #80]	; (800bfe4 <HAL_ETH_MspInit+0xbc>)
 800bf92:	f7f6 f9ad 	bl	80022f0 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
 800bf96:	f04f 0986 	mov.w	r9, #134	; 0x86
 800bf9a:	f8cd 9004 	str.w	r9, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bf9e:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bfa0:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800bfa2:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800bfa4:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOA, &GPIO_InitStruct );
 800bfa6:	f8df 8040 	ldr.w	r8, [pc, #64]	; 800bfe8 <HAL_ETH_MspInit+0xc0>
 800bfaa:	a901      	add	r1, sp, #4
 800bfac:	4640      	mov	r0, r8
 800bfae:	f7f6 f99f 	bl	80022f0 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
 800bfb2:	f8cd 9004 	str.w	r9, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bfb6:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bfb8:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800bfba:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800bfbc:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOA, &GPIO_InitStruct );
 800bfbe:	a901      	add	r1, sp, #4
 800bfc0:	4640      	mov	r0, r8
 800bfc2:	f7f6 f995 	bl	80022f0 <HAL_GPIO_Init>
//		GPIO_InitStruct.Pull = GPIO_NOPULL;
//		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
//		GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
//		HAL_GPIO_Init( GPIOA, &GPIO_InitStruct );

		HAL_NVIC_SetPriority( ETH_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY, 0 );
 800bfc6:	4622      	mov	r2, r4
 800bfc8:	2105      	movs	r1, #5
 800bfca:	203d      	movs	r0, #61	; 0x3d
 800bfcc:	f7f4 fb4e 	bl	800066c <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ( ETH_IRQn );
 800bfd0:	203d      	movs	r0, #61	; 0x3d
 800bfd2:	f7f4 fb7b 	bl	80006cc <HAL_NVIC_EnableIRQ>
	}
}
 800bfd6:	b007      	add	sp, #28
 800bfd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800bfdc:	40028000 	.word	0x40028000
 800bfe0:	40021800 	.word	0x40021800
 800bfe4:	40020800 	.word	0x40020800
 800bfe8:	40020000 	.word	0x40020000

0800bfec <atol>:
 800bfec:	220a      	movs	r2, #10
 800bfee:	2100      	movs	r1, #0
 800bff0:	f000 b924 	b.w	800c23c <strtol>

0800bff4 <__libc_init_array>:
 800bff4:	b570      	push	{r4, r5, r6, lr}
 800bff6:	4e0d      	ldr	r6, [pc, #52]	; (800c02c <__libc_init_array+0x38>)
 800bff8:	4c0d      	ldr	r4, [pc, #52]	; (800c030 <__libc_init_array+0x3c>)
 800bffa:	1ba4      	subs	r4, r4, r6
 800bffc:	10a4      	asrs	r4, r4, #2
 800bffe:	2500      	movs	r5, #0
 800c000:	42a5      	cmp	r5, r4
 800c002:	d109      	bne.n	800c018 <__libc_init_array+0x24>
 800c004:	4e0b      	ldr	r6, [pc, #44]	; (800c034 <__libc_init_array+0x40>)
 800c006:	4c0c      	ldr	r4, [pc, #48]	; (800c038 <__libc_init_array+0x44>)
 800c008:	f000 f950 	bl	800c2ac <_init>
 800c00c:	1ba4      	subs	r4, r4, r6
 800c00e:	10a4      	asrs	r4, r4, #2
 800c010:	2500      	movs	r5, #0
 800c012:	42a5      	cmp	r5, r4
 800c014:	d105      	bne.n	800c022 <__libc_init_array+0x2e>
 800c016:	bd70      	pop	{r4, r5, r6, pc}
 800c018:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c01c:	4798      	blx	r3
 800c01e:	3501      	adds	r5, #1
 800c020:	e7ee      	b.n	800c000 <__libc_init_array+0xc>
 800c022:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c026:	4798      	blx	r3
 800c028:	3501      	adds	r5, #1
 800c02a:	e7f2      	b.n	800c012 <__libc_init_array+0x1e>
 800c02c:	0800d838 	.word	0x0800d838
 800c030:	0800d838 	.word	0x0800d838
 800c034:	0800d838 	.word	0x0800d838
 800c038:	0800d83c 	.word	0x0800d83c

0800c03c <memcmp>:
 800c03c:	b510      	push	{r4, lr}
 800c03e:	3901      	subs	r1, #1
 800c040:	4402      	add	r2, r0
 800c042:	4290      	cmp	r0, r2
 800c044:	d101      	bne.n	800c04a <memcmp+0xe>
 800c046:	2000      	movs	r0, #0
 800c048:	bd10      	pop	{r4, pc}
 800c04a:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c04e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800c052:	42a3      	cmp	r3, r4
 800c054:	d0f5      	beq.n	800c042 <memcmp+0x6>
 800c056:	1b18      	subs	r0, r3, r4
 800c058:	bd10      	pop	{r4, pc}

0800c05a <memcpy>:
 800c05a:	b510      	push	{r4, lr}
 800c05c:	1e43      	subs	r3, r0, #1
 800c05e:	440a      	add	r2, r1
 800c060:	4291      	cmp	r1, r2
 800c062:	d100      	bne.n	800c066 <memcpy+0xc>
 800c064:	bd10      	pop	{r4, pc}
 800c066:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c06a:	f803 4f01 	strb.w	r4, [r3, #1]!
 800c06e:	e7f7      	b.n	800c060 <memcpy+0x6>

0800c070 <memmove>:
 800c070:	4288      	cmp	r0, r1
 800c072:	b510      	push	{r4, lr}
 800c074:	eb01 0302 	add.w	r3, r1, r2
 800c078:	d803      	bhi.n	800c082 <memmove+0x12>
 800c07a:	1e42      	subs	r2, r0, #1
 800c07c:	4299      	cmp	r1, r3
 800c07e:	d10c      	bne.n	800c09a <memmove+0x2a>
 800c080:	bd10      	pop	{r4, pc}
 800c082:	4298      	cmp	r0, r3
 800c084:	d2f9      	bcs.n	800c07a <memmove+0xa>
 800c086:	1881      	adds	r1, r0, r2
 800c088:	1ad2      	subs	r2, r2, r3
 800c08a:	42d3      	cmn	r3, r2
 800c08c:	d100      	bne.n	800c090 <memmove+0x20>
 800c08e:	bd10      	pop	{r4, pc}
 800c090:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800c094:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800c098:	e7f7      	b.n	800c08a <memmove+0x1a>
 800c09a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c09e:	f802 4f01 	strb.w	r4, [r2, #1]!
 800c0a2:	e7eb      	b.n	800c07c <memmove+0xc>

0800c0a4 <memset>:
 800c0a4:	4402      	add	r2, r0
 800c0a6:	4603      	mov	r3, r0
 800c0a8:	4293      	cmp	r3, r2
 800c0aa:	d100      	bne.n	800c0ae <memset+0xa>
 800c0ac:	4770      	bx	lr
 800c0ae:	f803 1b01 	strb.w	r1, [r3], #1
 800c0b2:	e7f9      	b.n	800c0a8 <memset+0x4>

0800c0b4 <strcpy>:
 800c0b4:	4603      	mov	r3, r0
 800c0b6:	f811 2b01 	ldrb.w	r2, [r1], #1
 800c0ba:	f803 2b01 	strb.w	r2, [r3], #1
 800c0be:	2a00      	cmp	r2, #0
 800c0c0:	d1f9      	bne.n	800c0b6 <strcpy+0x2>
 800c0c2:	4770      	bx	lr

0800c0c4 <strncat>:
 800c0c4:	b530      	push	{r4, r5, lr}
 800c0c6:	4603      	mov	r3, r0
 800c0c8:	781c      	ldrb	r4, [r3, #0]
 800c0ca:	1c5d      	adds	r5, r3, #1
 800c0cc:	b944      	cbnz	r4, 800c0e0 <strncat+0x1c>
 800c0ce:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
 800c0d2:	d304      	bcc.n	800c0de <strncat+0x1a>
 800c0d4:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c0d8:	f803 4b01 	strb.w	r4, [r3], #1
 800c0dc:	b914      	cbnz	r4, 800c0e4 <strncat+0x20>
 800c0de:	bd30      	pop	{r4, r5, pc}
 800c0e0:	462b      	mov	r3, r5
 800c0e2:	e7f1      	b.n	800c0c8 <strncat+0x4>
 800c0e4:	2a00      	cmp	r2, #0
 800c0e6:	d1f2      	bne.n	800c0ce <strncat+0xa>
 800c0e8:	701a      	strb	r2, [r3, #0]
 800c0ea:	e7f0      	b.n	800c0ce <strncat+0xa>

0800c0ec <strncmp>:
 800c0ec:	b510      	push	{r4, lr}
 800c0ee:	b16a      	cbz	r2, 800c10c <strncmp+0x20>
 800c0f0:	3901      	subs	r1, #1
 800c0f2:	1884      	adds	r4, r0, r2
 800c0f4:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c0f8:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800c0fc:	4293      	cmp	r3, r2
 800c0fe:	d103      	bne.n	800c108 <strncmp+0x1c>
 800c100:	42a0      	cmp	r0, r4
 800c102:	d001      	beq.n	800c108 <strncmp+0x1c>
 800c104:	2b00      	cmp	r3, #0
 800c106:	d1f5      	bne.n	800c0f4 <strncmp+0x8>
 800c108:	1a98      	subs	r0, r3, r2
 800c10a:	bd10      	pop	{r4, pc}
 800c10c:	4610      	mov	r0, r2
 800c10e:	bd10      	pop	{r4, pc}

0800c110 <strncpy>:
 800c110:	b570      	push	{r4, r5, r6, lr}
 800c112:	4604      	mov	r4, r0
 800c114:	b902      	cbnz	r2, 800c118 <strncpy+0x8>
 800c116:	bd70      	pop	{r4, r5, r6, pc}
 800c118:	4623      	mov	r3, r4
 800c11a:	f811 5b01 	ldrb.w	r5, [r1], #1
 800c11e:	f803 5b01 	strb.w	r5, [r3], #1
 800c122:	1e56      	subs	r6, r2, #1
 800c124:	b91d      	cbnz	r5, 800c12e <strncpy+0x1e>
 800c126:	4414      	add	r4, r2
 800c128:	42a3      	cmp	r3, r4
 800c12a:	d103      	bne.n	800c134 <strncpy+0x24>
 800c12c:	bd70      	pop	{r4, r5, r6, pc}
 800c12e:	461c      	mov	r4, r3
 800c130:	4632      	mov	r2, r6
 800c132:	e7ef      	b.n	800c114 <strncpy+0x4>
 800c134:	f803 5b01 	strb.w	r5, [r3], #1
 800c138:	e7f6      	b.n	800c128 <strncpy+0x18>

0800c13a <_strtol_l.isra.0>:
 800c13a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c13e:	4680      	mov	r8, r0
 800c140:	4689      	mov	r9, r1
 800c142:	4692      	mov	sl, r2
 800c144:	461f      	mov	r7, r3
 800c146:	468b      	mov	fp, r1
 800c148:	465d      	mov	r5, fp
 800c14a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800c14c:	f815 4b01 	ldrb.w	r4, [r5], #1
 800c150:	f000 f88a 	bl	800c268 <__locale_ctype_ptr_l>
 800c154:	4420      	add	r0, r4
 800c156:	7846      	ldrb	r6, [r0, #1]
 800c158:	f016 0608 	ands.w	r6, r6, #8
 800c15c:	d10b      	bne.n	800c176 <_strtol_l.isra.0+0x3c>
 800c15e:	2c2d      	cmp	r4, #45	; 0x2d
 800c160:	d10b      	bne.n	800c17a <_strtol_l.isra.0+0x40>
 800c162:	782c      	ldrb	r4, [r5, #0]
 800c164:	2601      	movs	r6, #1
 800c166:	f10b 0502 	add.w	r5, fp, #2
 800c16a:	b167      	cbz	r7, 800c186 <_strtol_l.isra.0+0x4c>
 800c16c:	2f10      	cmp	r7, #16
 800c16e:	d114      	bne.n	800c19a <_strtol_l.isra.0+0x60>
 800c170:	2c30      	cmp	r4, #48	; 0x30
 800c172:	d00a      	beq.n	800c18a <_strtol_l.isra.0+0x50>
 800c174:	e011      	b.n	800c19a <_strtol_l.isra.0+0x60>
 800c176:	46ab      	mov	fp, r5
 800c178:	e7e6      	b.n	800c148 <_strtol_l.isra.0+0xe>
 800c17a:	2c2b      	cmp	r4, #43	; 0x2b
 800c17c:	bf04      	itt	eq
 800c17e:	782c      	ldrbeq	r4, [r5, #0]
 800c180:	f10b 0502 	addeq.w	r5, fp, #2
 800c184:	e7f1      	b.n	800c16a <_strtol_l.isra.0+0x30>
 800c186:	2c30      	cmp	r4, #48	; 0x30
 800c188:	d127      	bne.n	800c1da <_strtol_l.isra.0+0xa0>
 800c18a:	782b      	ldrb	r3, [r5, #0]
 800c18c:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 800c190:	2b58      	cmp	r3, #88	; 0x58
 800c192:	d14b      	bne.n	800c22c <_strtol_l.isra.0+0xf2>
 800c194:	786c      	ldrb	r4, [r5, #1]
 800c196:	2710      	movs	r7, #16
 800c198:	3502      	adds	r5, #2
 800c19a:	2e00      	cmp	r6, #0
 800c19c:	bf0c      	ite	eq
 800c19e:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 800c1a2:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 800c1a6:	2200      	movs	r2, #0
 800c1a8:	fbb1 fef7 	udiv	lr, r1, r7
 800c1ac:	4610      	mov	r0, r2
 800c1ae:	fb07 1c1e 	mls	ip, r7, lr, r1
 800c1b2:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 800c1b6:	2b09      	cmp	r3, #9
 800c1b8:	d811      	bhi.n	800c1de <_strtol_l.isra.0+0xa4>
 800c1ba:	461c      	mov	r4, r3
 800c1bc:	42a7      	cmp	r7, r4
 800c1be:	dd1d      	ble.n	800c1fc <_strtol_l.isra.0+0xc2>
 800c1c0:	1c53      	adds	r3, r2, #1
 800c1c2:	d007      	beq.n	800c1d4 <_strtol_l.isra.0+0x9a>
 800c1c4:	4586      	cmp	lr, r0
 800c1c6:	d316      	bcc.n	800c1f6 <_strtol_l.isra.0+0xbc>
 800c1c8:	d101      	bne.n	800c1ce <_strtol_l.isra.0+0x94>
 800c1ca:	45a4      	cmp	ip, r4
 800c1cc:	db13      	blt.n	800c1f6 <_strtol_l.isra.0+0xbc>
 800c1ce:	fb00 4007 	mla	r0, r0, r7, r4
 800c1d2:	2201      	movs	r2, #1
 800c1d4:	f815 4b01 	ldrb.w	r4, [r5], #1
 800c1d8:	e7eb      	b.n	800c1b2 <_strtol_l.isra.0+0x78>
 800c1da:	270a      	movs	r7, #10
 800c1dc:	e7dd      	b.n	800c19a <_strtol_l.isra.0+0x60>
 800c1de:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 800c1e2:	2b19      	cmp	r3, #25
 800c1e4:	d801      	bhi.n	800c1ea <_strtol_l.isra.0+0xb0>
 800c1e6:	3c37      	subs	r4, #55	; 0x37
 800c1e8:	e7e8      	b.n	800c1bc <_strtol_l.isra.0+0x82>
 800c1ea:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 800c1ee:	2b19      	cmp	r3, #25
 800c1f0:	d804      	bhi.n	800c1fc <_strtol_l.isra.0+0xc2>
 800c1f2:	3c57      	subs	r4, #87	; 0x57
 800c1f4:	e7e2      	b.n	800c1bc <_strtol_l.isra.0+0x82>
 800c1f6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c1fa:	e7eb      	b.n	800c1d4 <_strtol_l.isra.0+0x9a>
 800c1fc:	1c53      	adds	r3, r2, #1
 800c1fe:	d108      	bne.n	800c212 <_strtol_l.isra.0+0xd8>
 800c200:	2322      	movs	r3, #34	; 0x22
 800c202:	f8c8 3000 	str.w	r3, [r8]
 800c206:	4608      	mov	r0, r1
 800c208:	f1ba 0f00 	cmp.w	sl, #0
 800c20c:	d107      	bne.n	800c21e <_strtol_l.isra.0+0xe4>
 800c20e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c212:	b106      	cbz	r6, 800c216 <_strtol_l.isra.0+0xdc>
 800c214:	4240      	negs	r0, r0
 800c216:	f1ba 0f00 	cmp.w	sl, #0
 800c21a:	d00c      	beq.n	800c236 <_strtol_l.isra.0+0xfc>
 800c21c:	b122      	cbz	r2, 800c228 <_strtol_l.isra.0+0xee>
 800c21e:	3d01      	subs	r5, #1
 800c220:	f8ca 5000 	str.w	r5, [sl]
 800c224:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c228:	464d      	mov	r5, r9
 800c22a:	e7f9      	b.n	800c220 <_strtol_l.isra.0+0xe6>
 800c22c:	2430      	movs	r4, #48	; 0x30
 800c22e:	2f00      	cmp	r7, #0
 800c230:	d1b3      	bne.n	800c19a <_strtol_l.isra.0+0x60>
 800c232:	2708      	movs	r7, #8
 800c234:	e7b1      	b.n	800c19a <_strtol_l.isra.0+0x60>
 800c236:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800c23c <strtol>:
 800c23c:	4b08      	ldr	r3, [pc, #32]	; (800c260 <strtol+0x24>)
 800c23e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800c240:	681c      	ldr	r4, [r3, #0]
 800c242:	4d08      	ldr	r5, [pc, #32]	; (800c264 <strtol+0x28>)
 800c244:	6a23      	ldr	r3, [r4, #32]
 800c246:	2b00      	cmp	r3, #0
 800c248:	bf08      	it	eq
 800c24a:	462b      	moveq	r3, r5
 800c24c:	9300      	str	r3, [sp, #0]
 800c24e:	4613      	mov	r3, r2
 800c250:	460a      	mov	r2, r1
 800c252:	4601      	mov	r1, r0
 800c254:	4620      	mov	r0, r4
 800c256:	f7ff ff70 	bl	800c13a <_strtol_l.isra.0>
 800c25a:	b003      	add	sp, #12
 800c25c:	bd30      	pop	{r4, r5, pc}
 800c25e:	bf00      	nop
 800c260:	20000178 	.word	0x20000178
 800c264:	200001dc 	.word	0x200001dc

0800c268 <__locale_ctype_ptr_l>:
 800c268:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800c26c:	4770      	bx	lr

0800c26e <__ascii_mbtowc>:
 800c26e:	b082      	sub	sp, #8
 800c270:	b901      	cbnz	r1, 800c274 <__ascii_mbtowc+0x6>
 800c272:	a901      	add	r1, sp, #4
 800c274:	b142      	cbz	r2, 800c288 <__ascii_mbtowc+0x1a>
 800c276:	b14b      	cbz	r3, 800c28c <__ascii_mbtowc+0x1e>
 800c278:	7813      	ldrb	r3, [r2, #0]
 800c27a:	600b      	str	r3, [r1, #0]
 800c27c:	7812      	ldrb	r2, [r2, #0]
 800c27e:	1c10      	adds	r0, r2, #0
 800c280:	bf18      	it	ne
 800c282:	2001      	movne	r0, #1
 800c284:	b002      	add	sp, #8
 800c286:	4770      	bx	lr
 800c288:	4610      	mov	r0, r2
 800c28a:	e7fb      	b.n	800c284 <__ascii_mbtowc+0x16>
 800c28c:	f06f 0001 	mvn.w	r0, #1
 800c290:	e7f8      	b.n	800c284 <__ascii_mbtowc+0x16>

0800c292 <__ascii_wctomb>:
 800c292:	b149      	cbz	r1, 800c2a8 <__ascii_wctomb+0x16>
 800c294:	2aff      	cmp	r2, #255	; 0xff
 800c296:	bf85      	ittet	hi
 800c298:	238a      	movhi	r3, #138	; 0x8a
 800c29a:	6003      	strhi	r3, [r0, #0]
 800c29c:	700a      	strbls	r2, [r1, #0]
 800c29e:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
 800c2a2:	bf98      	it	ls
 800c2a4:	2001      	movls	r0, #1
 800c2a6:	4770      	bx	lr
 800c2a8:	4608      	mov	r0, r1
 800c2aa:	4770      	bx	lr

0800c2ac <_init>:
 800c2ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c2ae:	bf00      	nop
 800c2b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c2b2:	bc08      	pop	{r3}
 800c2b4:	469e      	mov	lr, r3
 800c2b6:	4770      	bx	lr

0800c2b8 <_fini>:
 800c2b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c2ba:	bf00      	nop
 800c2bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c2be:	bc08      	pop	{r3}
 800c2c0:	469e      	mov	lr, r3
 800c2c2:	4770      	bx	lr
