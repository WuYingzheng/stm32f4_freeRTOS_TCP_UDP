
RTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c7b0  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000015b4  0800c940  0800c940  0001c940  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0800def4  0800def4  0001def4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800defc  0800defc  0001defc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800df00  0800df00  0001df00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000348  20000000  0800df04  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020348  2**0
                  CONTENTS
  8 .bss          00004a20  20000348  20000348  00020348  2**2
                  ALLOC
  9 ._user_heap_stack 00000400  20004d68  20004d68  00020348  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020348  2**0
                  CONTENTS, READONLY
 11 .debug_line   000123f4  00000000  00000000  00020378  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000408ff  00000000  00000000  0003276c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00007b10  00000000  00000000  0007306b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000017c0  00000000  00000000  0007ab80  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00002480  00000000  00000000  0007c340  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001eeb7  00000000  00000000  0007e7c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000c03d  00000000  00000000  0009d677  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007c  00000000  00000000  000a96b4  2**0
                  CONTENTS, READONLY
 19 .debug_frame  000049ac  00000000  00000000  000a9730  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stabstr      000000df  00000000  00000000  000ae0dc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000348 	.word	0x20000348
 80001ac:	00000000 	.word	0x00000000
 80001b0:	0800c928 	.word	0x0800c928

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	2000034c 	.word	0x2000034c
 80001cc:	0800c928 	.word	0x0800c928

080001d0 <strlen>:
 80001d0:	4603      	mov	r3, r0
 80001d2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001d6:	2a00      	cmp	r2, #0
 80001d8:	d1fb      	bne.n	80001d2 <strlen+0x2>
 80001da:	1a18      	subs	r0, r3, r0
 80001dc:	3801      	subs	r0, #1
 80001de:	4770      	bx	lr

080001e0 <__aeabi_uldivmod>:
 80001e0:	b953      	cbnz	r3, 80001f8 <__aeabi_uldivmod+0x18>
 80001e2:	b94a      	cbnz	r2, 80001f8 <__aeabi_uldivmod+0x18>
 80001e4:	2900      	cmp	r1, #0
 80001e6:	bf08      	it	eq
 80001e8:	2800      	cmpeq	r0, #0
 80001ea:	bf1c      	itt	ne
 80001ec:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80001f0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80001f4:	f000 b97a 	b.w	80004ec <__aeabi_idiv0>
 80001f8:	f1ad 0c08 	sub.w	ip, sp, #8
 80001fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000200:	f000 f806 	bl	8000210 <__udivmoddi4>
 8000204:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000208:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800020c:	b004      	add	sp, #16
 800020e:	4770      	bx	lr

08000210 <__udivmoddi4>:
 8000210:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000214:	468c      	mov	ip, r1
 8000216:	460d      	mov	r5, r1
 8000218:	4604      	mov	r4, r0
 800021a:	9e08      	ldr	r6, [sp, #32]
 800021c:	2b00      	cmp	r3, #0
 800021e:	d151      	bne.n	80002c4 <__udivmoddi4+0xb4>
 8000220:	428a      	cmp	r2, r1
 8000222:	4617      	mov	r7, r2
 8000224:	d96d      	bls.n	8000302 <__udivmoddi4+0xf2>
 8000226:	fab2 fe82 	clz	lr, r2
 800022a:	f1be 0f00 	cmp.w	lr, #0
 800022e:	d00b      	beq.n	8000248 <__udivmoddi4+0x38>
 8000230:	f1ce 0c20 	rsb	ip, lr, #32
 8000234:	fa01 f50e 	lsl.w	r5, r1, lr
 8000238:	fa20 fc0c 	lsr.w	ip, r0, ip
 800023c:	fa02 f70e 	lsl.w	r7, r2, lr
 8000240:	ea4c 0c05 	orr.w	ip, ip, r5
 8000244:	fa00 f40e 	lsl.w	r4, r0, lr
 8000248:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 800024c:	0c25      	lsrs	r5, r4, #16
 800024e:	fbbc f8fa 	udiv	r8, ip, sl
 8000252:	fa1f f987 	uxth.w	r9, r7
 8000256:	fb0a cc18 	mls	ip, sl, r8, ip
 800025a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800025e:	fb08 f309 	mul.w	r3, r8, r9
 8000262:	42ab      	cmp	r3, r5
 8000264:	d90a      	bls.n	800027c <__udivmoddi4+0x6c>
 8000266:	19ed      	adds	r5, r5, r7
 8000268:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 800026c:	f080 8123 	bcs.w	80004b6 <__udivmoddi4+0x2a6>
 8000270:	42ab      	cmp	r3, r5
 8000272:	f240 8120 	bls.w	80004b6 <__udivmoddi4+0x2a6>
 8000276:	f1a8 0802 	sub.w	r8, r8, #2
 800027a:	443d      	add	r5, r7
 800027c:	1aed      	subs	r5, r5, r3
 800027e:	b2a4      	uxth	r4, r4
 8000280:	fbb5 f0fa 	udiv	r0, r5, sl
 8000284:	fb0a 5510 	mls	r5, sl, r0, r5
 8000288:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800028c:	fb00 f909 	mul.w	r9, r0, r9
 8000290:	45a1      	cmp	r9, r4
 8000292:	d909      	bls.n	80002a8 <__udivmoddi4+0x98>
 8000294:	19e4      	adds	r4, r4, r7
 8000296:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800029a:	f080 810a 	bcs.w	80004b2 <__udivmoddi4+0x2a2>
 800029e:	45a1      	cmp	r9, r4
 80002a0:	f240 8107 	bls.w	80004b2 <__udivmoddi4+0x2a2>
 80002a4:	3802      	subs	r0, #2
 80002a6:	443c      	add	r4, r7
 80002a8:	eba4 0409 	sub.w	r4, r4, r9
 80002ac:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80002b0:	2100      	movs	r1, #0
 80002b2:	2e00      	cmp	r6, #0
 80002b4:	d061      	beq.n	800037a <__udivmoddi4+0x16a>
 80002b6:	fa24 f40e 	lsr.w	r4, r4, lr
 80002ba:	2300      	movs	r3, #0
 80002bc:	6034      	str	r4, [r6, #0]
 80002be:	6073      	str	r3, [r6, #4]
 80002c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002c4:	428b      	cmp	r3, r1
 80002c6:	d907      	bls.n	80002d8 <__udivmoddi4+0xc8>
 80002c8:	2e00      	cmp	r6, #0
 80002ca:	d054      	beq.n	8000376 <__udivmoddi4+0x166>
 80002cc:	2100      	movs	r1, #0
 80002ce:	e886 0021 	stmia.w	r6, {r0, r5}
 80002d2:	4608      	mov	r0, r1
 80002d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002d8:	fab3 f183 	clz	r1, r3
 80002dc:	2900      	cmp	r1, #0
 80002de:	f040 808e 	bne.w	80003fe <__udivmoddi4+0x1ee>
 80002e2:	42ab      	cmp	r3, r5
 80002e4:	d302      	bcc.n	80002ec <__udivmoddi4+0xdc>
 80002e6:	4282      	cmp	r2, r0
 80002e8:	f200 80fa 	bhi.w	80004e0 <__udivmoddi4+0x2d0>
 80002ec:	1a84      	subs	r4, r0, r2
 80002ee:	eb65 0503 	sbc.w	r5, r5, r3
 80002f2:	2001      	movs	r0, #1
 80002f4:	46ac      	mov	ip, r5
 80002f6:	2e00      	cmp	r6, #0
 80002f8:	d03f      	beq.n	800037a <__udivmoddi4+0x16a>
 80002fa:	e886 1010 	stmia.w	r6, {r4, ip}
 80002fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000302:	b912      	cbnz	r2, 800030a <__udivmoddi4+0xfa>
 8000304:	2701      	movs	r7, #1
 8000306:	fbb7 f7f2 	udiv	r7, r7, r2
 800030a:	fab7 fe87 	clz	lr, r7
 800030e:	f1be 0f00 	cmp.w	lr, #0
 8000312:	d134      	bne.n	800037e <__udivmoddi4+0x16e>
 8000314:	1beb      	subs	r3, r5, r7
 8000316:	0c3a      	lsrs	r2, r7, #16
 8000318:	fa1f fc87 	uxth.w	ip, r7
 800031c:	2101      	movs	r1, #1
 800031e:	fbb3 f8f2 	udiv	r8, r3, r2
 8000322:	0c25      	lsrs	r5, r4, #16
 8000324:	fb02 3318 	mls	r3, r2, r8, r3
 8000328:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800032c:	fb0c f308 	mul.w	r3, ip, r8
 8000330:	42ab      	cmp	r3, r5
 8000332:	d907      	bls.n	8000344 <__udivmoddi4+0x134>
 8000334:	19ed      	adds	r5, r5, r7
 8000336:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 800033a:	d202      	bcs.n	8000342 <__udivmoddi4+0x132>
 800033c:	42ab      	cmp	r3, r5
 800033e:	f200 80d1 	bhi.w	80004e4 <__udivmoddi4+0x2d4>
 8000342:	4680      	mov	r8, r0
 8000344:	1aed      	subs	r5, r5, r3
 8000346:	b2a3      	uxth	r3, r4
 8000348:	fbb5 f0f2 	udiv	r0, r5, r2
 800034c:	fb02 5510 	mls	r5, r2, r0, r5
 8000350:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000354:	fb0c fc00 	mul.w	ip, ip, r0
 8000358:	45a4      	cmp	ip, r4
 800035a:	d907      	bls.n	800036c <__udivmoddi4+0x15c>
 800035c:	19e4      	adds	r4, r4, r7
 800035e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000362:	d202      	bcs.n	800036a <__udivmoddi4+0x15a>
 8000364:	45a4      	cmp	ip, r4
 8000366:	f200 80b8 	bhi.w	80004da <__udivmoddi4+0x2ca>
 800036a:	4618      	mov	r0, r3
 800036c:	eba4 040c 	sub.w	r4, r4, ip
 8000370:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000374:	e79d      	b.n	80002b2 <__udivmoddi4+0xa2>
 8000376:	4631      	mov	r1, r6
 8000378:	4630      	mov	r0, r6
 800037a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800037e:	f1ce 0420 	rsb	r4, lr, #32
 8000382:	fa05 f30e 	lsl.w	r3, r5, lr
 8000386:	fa07 f70e 	lsl.w	r7, r7, lr
 800038a:	fa20 f804 	lsr.w	r8, r0, r4
 800038e:	0c3a      	lsrs	r2, r7, #16
 8000390:	fa25 f404 	lsr.w	r4, r5, r4
 8000394:	ea48 0803 	orr.w	r8, r8, r3
 8000398:	fbb4 f1f2 	udiv	r1, r4, r2
 800039c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 80003a0:	fb02 4411 	mls	r4, r2, r1, r4
 80003a4:	fa1f fc87 	uxth.w	ip, r7
 80003a8:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 80003ac:	fb01 f30c 	mul.w	r3, r1, ip
 80003b0:	42ab      	cmp	r3, r5
 80003b2:	fa00 f40e 	lsl.w	r4, r0, lr
 80003b6:	d909      	bls.n	80003cc <__udivmoddi4+0x1bc>
 80003b8:	19ed      	adds	r5, r5, r7
 80003ba:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
 80003be:	f080 808a 	bcs.w	80004d6 <__udivmoddi4+0x2c6>
 80003c2:	42ab      	cmp	r3, r5
 80003c4:	f240 8087 	bls.w	80004d6 <__udivmoddi4+0x2c6>
 80003c8:	3902      	subs	r1, #2
 80003ca:	443d      	add	r5, r7
 80003cc:	1aeb      	subs	r3, r5, r3
 80003ce:	fa1f f588 	uxth.w	r5, r8
 80003d2:	fbb3 f0f2 	udiv	r0, r3, r2
 80003d6:	fb02 3310 	mls	r3, r2, r0, r3
 80003da:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 80003de:	fb00 f30c 	mul.w	r3, r0, ip
 80003e2:	42ab      	cmp	r3, r5
 80003e4:	d907      	bls.n	80003f6 <__udivmoddi4+0x1e6>
 80003e6:	19ed      	adds	r5, r5, r7
 80003e8:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 80003ec:	d26f      	bcs.n	80004ce <__udivmoddi4+0x2be>
 80003ee:	42ab      	cmp	r3, r5
 80003f0:	d96d      	bls.n	80004ce <__udivmoddi4+0x2be>
 80003f2:	3802      	subs	r0, #2
 80003f4:	443d      	add	r5, r7
 80003f6:	1aeb      	subs	r3, r5, r3
 80003f8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80003fc:	e78f      	b.n	800031e <__udivmoddi4+0x10e>
 80003fe:	f1c1 0720 	rsb	r7, r1, #32
 8000402:	fa22 f807 	lsr.w	r8, r2, r7
 8000406:	408b      	lsls	r3, r1
 8000408:	fa05 f401 	lsl.w	r4, r5, r1
 800040c:	ea48 0303 	orr.w	r3, r8, r3
 8000410:	fa20 fe07 	lsr.w	lr, r0, r7
 8000414:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000418:	40fd      	lsrs	r5, r7
 800041a:	ea4e 0e04 	orr.w	lr, lr, r4
 800041e:	fbb5 f9fc 	udiv	r9, r5, ip
 8000422:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000426:	fb0c 5519 	mls	r5, ip, r9, r5
 800042a:	fa1f f883 	uxth.w	r8, r3
 800042e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000432:	fb09 f408 	mul.w	r4, r9, r8
 8000436:	42ac      	cmp	r4, r5
 8000438:	fa02 f201 	lsl.w	r2, r2, r1
 800043c:	fa00 fa01 	lsl.w	sl, r0, r1
 8000440:	d908      	bls.n	8000454 <__udivmoddi4+0x244>
 8000442:	18ed      	adds	r5, r5, r3
 8000444:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000448:	d243      	bcs.n	80004d2 <__udivmoddi4+0x2c2>
 800044a:	42ac      	cmp	r4, r5
 800044c:	d941      	bls.n	80004d2 <__udivmoddi4+0x2c2>
 800044e:	f1a9 0902 	sub.w	r9, r9, #2
 8000452:	441d      	add	r5, r3
 8000454:	1b2d      	subs	r5, r5, r4
 8000456:	fa1f fe8e 	uxth.w	lr, lr
 800045a:	fbb5 f0fc 	udiv	r0, r5, ip
 800045e:	fb0c 5510 	mls	r5, ip, r0, r5
 8000462:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000466:	fb00 f808 	mul.w	r8, r0, r8
 800046a:	45a0      	cmp	r8, r4
 800046c:	d907      	bls.n	800047e <__udivmoddi4+0x26e>
 800046e:	18e4      	adds	r4, r4, r3
 8000470:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 8000474:	d229      	bcs.n	80004ca <__udivmoddi4+0x2ba>
 8000476:	45a0      	cmp	r8, r4
 8000478:	d927      	bls.n	80004ca <__udivmoddi4+0x2ba>
 800047a:	3802      	subs	r0, #2
 800047c:	441c      	add	r4, r3
 800047e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000482:	eba4 0408 	sub.w	r4, r4, r8
 8000486:	fba0 8902 	umull	r8, r9, r0, r2
 800048a:	454c      	cmp	r4, r9
 800048c:	46c6      	mov	lr, r8
 800048e:	464d      	mov	r5, r9
 8000490:	d315      	bcc.n	80004be <__udivmoddi4+0x2ae>
 8000492:	d012      	beq.n	80004ba <__udivmoddi4+0x2aa>
 8000494:	b156      	cbz	r6, 80004ac <__udivmoddi4+0x29c>
 8000496:	ebba 030e 	subs.w	r3, sl, lr
 800049a:	eb64 0405 	sbc.w	r4, r4, r5
 800049e:	fa04 f707 	lsl.w	r7, r4, r7
 80004a2:	40cb      	lsrs	r3, r1
 80004a4:	431f      	orrs	r7, r3
 80004a6:	40cc      	lsrs	r4, r1
 80004a8:	6037      	str	r7, [r6, #0]
 80004aa:	6074      	str	r4, [r6, #4]
 80004ac:	2100      	movs	r1, #0
 80004ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004b2:	4618      	mov	r0, r3
 80004b4:	e6f8      	b.n	80002a8 <__udivmoddi4+0x98>
 80004b6:	4690      	mov	r8, r2
 80004b8:	e6e0      	b.n	800027c <__udivmoddi4+0x6c>
 80004ba:	45c2      	cmp	sl, r8
 80004bc:	d2ea      	bcs.n	8000494 <__udivmoddi4+0x284>
 80004be:	ebb8 0e02 	subs.w	lr, r8, r2
 80004c2:	eb69 0503 	sbc.w	r5, r9, r3
 80004c6:	3801      	subs	r0, #1
 80004c8:	e7e4      	b.n	8000494 <__udivmoddi4+0x284>
 80004ca:	4628      	mov	r0, r5
 80004cc:	e7d7      	b.n	800047e <__udivmoddi4+0x26e>
 80004ce:	4640      	mov	r0, r8
 80004d0:	e791      	b.n	80003f6 <__udivmoddi4+0x1e6>
 80004d2:	4681      	mov	r9, r0
 80004d4:	e7be      	b.n	8000454 <__udivmoddi4+0x244>
 80004d6:	4601      	mov	r1, r0
 80004d8:	e778      	b.n	80003cc <__udivmoddi4+0x1bc>
 80004da:	3802      	subs	r0, #2
 80004dc:	443c      	add	r4, r7
 80004de:	e745      	b.n	800036c <__udivmoddi4+0x15c>
 80004e0:	4608      	mov	r0, r1
 80004e2:	e708      	b.n	80002f6 <__udivmoddi4+0xe6>
 80004e4:	f1a8 0802 	sub.w	r8, r8, #2
 80004e8:	443d      	add	r5, r7
 80004ea:	e72b      	b.n	8000344 <__udivmoddi4+0x134>

080004ec <__aeabi_idiv0>:
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop

080004f0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80004f0:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000528 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80004f4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80004f6:	e003      	b.n	8000500 <LoopCopyDataInit>

080004f8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80004f8:	4b0c      	ldr	r3, [pc, #48]	; (800052c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80004fa:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80004fc:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80004fe:	3104      	adds	r1, #4

08000500 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000500:	480b      	ldr	r0, [pc, #44]	; (8000530 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8000502:	4b0c      	ldr	r3, [pc, #48]	; (8000534 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000504:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000506:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000508:	d3f6      	bcc.n	80004f8 <CopyDataInit>
  ldr  r2, =_sbss
 800050a:	4a0b      	ldr	r2, [pc, #44]	; (8000538 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800050c:	e002      	b.n	8000514 <LoopFillZerobss>

0800050e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800050e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8000510:	f842 3b04 	str.w	r3, [r2], #4

08000514 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000514:	4b09      	ldr	r3, [pc, #36]	; (800053c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000516:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000518:	d3f9      	bcc.n	800050e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800051a:	f000 f823 	bl	8000564 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800051e:	f00c f8a7 	bl	800c670 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000522:	f00b fe55 	bl	800c1d0 <main>
  bx  lr    
 8000526:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8000528:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 800052c:	0800df04 	.word	0x0800df04
  ldr  r0, =_sdata
 8000530:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000534:	20000348 	.word	0x20000348
  ldr  r2, =_sbss
 8000538:	20000348 	.word	0x20000348
  ldr  r3, = _ebss
 800053c:	20004d68 	.word	0x20004d68

08000540 <ADC_IRQHandler>:
 * @param  None     
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
  ldr r3, NVIC_INT_CTRL_CONST
 8000540:	4b03      	ldr	r3, [pc, #12]	; (8000550 <NVIC_INT_CTRL_CONST>)
  ldr r2, [r3, #0]
 8000542:	681a      	ldr	r2, [r3, #0]
  uxtb r2, r2
 8000544:	b2d2      	uxtb	r2, r2

08000546 <Infinite_Loop>:
Infinite_Loop:
  /* The number of the active interrupt vector is stored in r2. */
  b  Infinite_Loop
 8000546:	e7fe      	b.n	8000546 <Infinite_Loop>
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <NVIC_INT_CTRL_CONST>:
 8000550:	e000ed04 	.word	0xe000ed04
	...

08000560 <HardFault_Handler>:

    .section  .text.HardFault_Handler,"ax",%progbits
    .align 4
HardFault_Handler:
HardFault_Infinite_Loop:
  b  HardFault_Infinite_Loop
 8000560:	e7fe      	b.n	8000560 <HardFault_Handler>
 8000562:	bf00      	nop

08000564 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000564:	490f      	ldr	r1, [pc, #60]	; (80005a4 <SystemInit+0x40>)
 8000566:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800056a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800056e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000572:	4b0d      	ldr	r3, [pc, #52]	; (80005a8 <SystemInit+0x44>)
 8000574:	681a      	ldr	r2, [r3, #0]
 8000576:	f042 0201 	orr.w	r2, r2, #1
 800057a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800057c:	2000      	movs	r0, #0
 800057e:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000580:	681a      	ldr	r2, [r3, #0]
 8000582:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000586:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800058a:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800058c:	4a07      	ldr	r2, [pc, #28]	; (80005ac <SystemInit+0x48>)
 800058e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000590:	681a      	ldr	r2, [r3, #0]
 8000592:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000596:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000598:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800059a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800059e:	608b      	str	r3, [r1, #8]
 80005a0:	4770      	bx	lr
 80005a2:	bf00      	nop
 80005a4:	e000ed00 	.word	0xe000ed00
 80005a8:	40023800 	.word	0x40023800
 80005ac:	24003010 	.word	0x24003010

080005b0 <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
 80005b0:	4770      	bx	lr
	...

080005b4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80005b4:	b510      	push	{r4, lr}
 80005b6:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80005b8:	f002 faf2 	bl	8002ba0 <HAL_RCC_GetHCLKFreq>
 80005bc:	4b06      	ldr	r3, [pc, #24]	; (80005d8 <HAL_InitTick+0x24>)
 80005be:	fba3 3000 	umull	r3, r0, r3, r0
 80005c2:	0980      	lsrs	r0, r0, #6
 80005c4:	f000 f88e 	bl	80006e4 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 80005c8:	2200      	movs	r2, #0
 80005ca:	4621      	mov	r1, r4
 80005cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80005d0:	f000 f84c 	bl	800066c <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 80005d4:	2000      	movs	r0, #0
 80005d6:	bd10      	pop	{r4, pc}
 80005d8:	10624dd3 	.word	0x10624dd3

080005dc <HAL_Init>:
{
 80005dc:	b508      	push	{r3, lr}
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80005de:	4b0b      	ldr	r3, [pc, #44]	; (800060c <HAL_Init+0x30>)
 80005e0:	681a      	ldr	r2, [r3, #0]
 80005e2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80005e6:	601a      	str	r2, [r3, #0]
   __HAL_FLASH_DATA_CACHE_ENABLE();
 80005e8:	681a      	ldr	r2, [r3, #0]
 80005ea:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80005ee:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80005f0:	681a      	ldr	r2, [r3, #0]
 80005f2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80005f6:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80005f8:	2003      	movs	r0, #3
 80005fa:	f000 f825 	bl	8000648 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80005fe:	2000      	movs	r0, #0
 8000600:	f7ff ffd8 	bl	80005b4 <HAL_InitTick>
  HAL_MspInit();
 8000604:	f7ff ffd4 	bl	80005b0 <HAL_MspInit>
}
 8000608:	2000      	movs	r0, #0
 800060a:	bd08      	pop	{r3, pc}
 800060c:	40023c00 	.word	0x40023c00

08000610 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000610:	4a02      	ldr	r2, [pc, #8]	; (800061c <HAL_IncTick+0xc>)
 8000612:	6813      	ldr	r3, [r2, #0]
 8000614:	3301      	adds	r3, #1
 8000616:	6013      	str	r3, [r2, #0]
 8000618:	4770      	bx	lr
 800061a:	bf00      	nop
 800061c:	20000364 	.word	0x20000364

08000620 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000620:	4b01      	ldr	r3, [pc, #4]	; (8000628 <HAL_GetTick+0x8>)
 8000622:	6818      	ldr	r0, [r3, #0]
}
 8000624:	4770      	bx	lr
 8000626:	bf00      	nop
 8000628:	20000364 	.word	0x20000364

0800062c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800062c:	b510      	push	{r4, lr}
 800062e:	b082      	sub	sp, #8
 8000630:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 8000632:	f7ff fff5 	bl	8000620 <HAL_GetTick>
 8000636:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000638:	f7ff fff2 	bl	8000620 <HAL_GetTick>
 800063c:	9b01      	ldr	r3, [sp, #4]
 800063e:	1b00      	subs	r0, r0, r4
 8000640:	4298      	cmp	r0, r3
 8000642:	d3f9      	bcc.n	8000638 <HAL_Delay+0xc>
  {
  }
}
 8000644:	b002      	add	sp, #8
 8000646:	bd10      	pop	{r4, pc}

08000648 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000648:	4a07      	ldr	r2, [pc, #28]	; (8000668 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800064a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 800064c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000650:	041b      	lsls	r3, r3, #16
 8000652:	0c1b      	lsrs	r3, r3, #16
 8000654:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000658:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 800065c:	0200      	lsls	r0, r0, #8
 800065e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                 |
 8000662:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000664:	60d3      	str	r3, [r2, #12]
 8000666:	4770      	bx	lr
 8000668:	e000ed00 	.word	0xe000ed00

0800066c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800066c:	b430      	push	{r4, r5}

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 800066e:	4b15      	ldr	r3, [pc, #84]	; (80006c4 <HAL_NVIC_SetPriority+0x58>)
 8000670:	68dc      	ldr	r4, [r3, #12]
 8000672:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 8000676:	f1c4 0307 	rsb	r3, r4, #7
 800067a:	2b04      	cmp	r3, #4
 800067c:	bf28      	it	cs
 800067e:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8000680:	1d25      	adds	r5, r4, #4
 8000682:	2d06      	cmp	r5, #6
 8000684:	bf8c      	ite	hi
 8000686:	1ee5      	subhi	r5, r4, #3
 8000688:	2500      	movls	r5, #0

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800068a:	2401      	movs	r4, #1
 800068c:	fa04 f303 	lsl.w	r3, r4, r3
 8000690:	3b01      	subs	r3, #1
 8000692:	4019      	ands	r1, r3
 8000694:	40a9      	lsls	r1, r5
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 8000696:	40ac      	lsls	r4, r5
 8000698:	3c01      	subs	r4, #1
 800069a:	4022      	ands	r2, r4
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800069c:	4311      	orrs	r1, r2
  if(IRQn < 0) {
 800069e:	2800      	cmp	r0, #0
 80006a0:	db09      	blt.n	80006b6 <HAL_NVIC_SetPriority+0x4a>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 80006a2:	0109      	lsls	r1, r1, #4
 80006a4:	b2c9      	uxtb	r1, r1
 80006a6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80006aa:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80006ae:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80006b2:	bc30      	pop	{r4, r5}
 80006b4:	4770      	bx	lr
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80006b6:	f000 000f 	and.w	r0, r0, #15
 80006ba:	0109      	lsls	r1, r1, #4
 80006bc:	b2c9      	uxtb	r1, r1
 80006be:	4b02      	ldr	r3, [pc, #8]	; (80006c8 <HAL_NVIC_SetPriority+0x5c>)
 80006c0:	5419      	strb	r1, [r3, r0]
 80006c2:	e7f6      	b.n	80006b2 <HAL_NVIC_SetPriority+0x46>
 80006c4:	e000ed00 	.word	0xe000ed00
 80006c8:	e000ed14 	.word	0xe000ed14

080006cc <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 80006cc:	0942      	lsrs	r2, r0, #5
 80006ce:	f000 001f 	and.w	r0, r0, #31
 80006d2:	2301      	movs	r3, #1
 80006d4:	fa03 f000 	lsl.w	r0, r3, r0
 80006d8:	4b01      	ldr	r3, [pc, #4]	; (80006e0 <HAL_NVIC_EnableIRQ+0x14>)
 80006da:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80006de:	4770      	bx	lr
 80006e0:	e000e100 	.word	0xe000e100

080006e4 <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 80006e4:	3801      	subs	r0, #1
 80006e6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80006ea:	d20a      	bcs.n	8000702 <HAL_SYSTICK_Config+0x1e>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 80006ec:	4b06      	ldr	r3, [pc, #24]	; (8000708 <HAL_SYSTICK_Config+0x24>)
 80006ee:	6058      	str	r0, [r3, #4]
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80006f0:	21f0      	movs	r1, #240	; 0xf0
 80006f2:	4a06      	ldr	r2, [pc, #24]	; (800070c <HAL_SYSTICK_Config+0x28>)
 80006f4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 80006f8:	2000      	movs	r0, #0
 80006fa:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80006fc:	2207      	movs	r2, #7
 80006fe:	601a      	str	r2, [r3, #0]
 8000700:	4770      	bx	lr
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8000702:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000704:	4770      	bx	lr
 8000706:	bf00      	nop
 8000708:	e000e010 	.word	0xe000e010
 800070c:	e000ed00 	.word	0xe000ed00

08000710 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8000710:	b538      	push	{r3, r4, r5, lr}
 8000712:	4604      	mov	r4, r0
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8000714:	6801      	ldr	r1, [r0, #0]
 8000716:	460b      	mov	r3, r1
 8000718:	4ac2      	ldr	r2, [pc, #776]	; (8000a24 <HAL_DMA_IRQHandler+0x314>)
 800071a:	4291      	cmp	r1, r2
 800071c:	d949      	bls.n	80007b2 <HAL_DMA_IRQHandler+0xa2>
 800071e:	3a58      	subs	r2, #88	; 0x58
 8000720:	6850      	ldr	r0, [r2, #4]
 8000722:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 8000726:	4dc0      	ldr	r5, [pc, #768]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 8000728:	42aa      	cmp	r2, r5
 800072a:	d013      	beq.n	8000754 <HAL_DMA_IRQHandler+0x44>
 800072c:	3560      	adds	r5, #96	; 0x60
 800072e:	42aa      	cmp	r2, r5
 8000730:	d034      	beq.n	800079c <HAL_DMA_IRQHandler+0x8c>
 8000732:	3d48      	subs	r5, #72	; 0x48
 8000734:	42aa      	cmp	r2, r5
 8000736:	d033      	beq.n	80007a0 <HAL_DMA_IRQHandler+0x90>
 8000738:	3560      	adds	r5, #96	; 0x60
 800073a:	42aa      	cmp	r2, r5
 800073c:	d033      	beq.n	80007a6 <HAL_DMA_IRQHandler+0x96>
 800073e:	3d48      	subs	r5, #72	; 0x48
 8000740:	42aa      	cmp	r2, r5
 8000742:	d033      	beq.n	80007ac <HAL_DMA_IRQHandler+0x9c>
 8000744:	3560      	adds	r5, #96	; 0x60
 8000746:	42aa      	cmp	r2, r5
 8000748:	bf0c      	ite	eq
 800074a:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 800074e:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 8000752:	e000      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 8000754:	2208      	movs	r2, #8
 8000756:	4202      	tst	r2, r0
 8000758:	f041 818d 	bne.w	8001a76 <HAL_DMA_IRQHandler+0x1366>
        hdma->XferErrorCallback(hdma);
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 800075c:	4ab3      	ldr	r2, [pc, #716]	; (8000a2c <HAL_DMA_IRQHandler+0x31c>)
 800075e:	6852      	ldr	r2, [r2, #4]
 8000760:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000764:	48b0      	ldr	r0, [pc, #704]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 8000766:	4283      	cmp	r3, r0
 8000768:	f000 81e6 	beq.w	8000b38 <HAL_DMA_IRQHandler+0x428>
 800076c:	3060      	adds	r0, #96	; 0x60
 800076e:	4283      	cmp	r3, r0
 8000770:	f000 8207 	beq.w	8000b82 <HAL_DMA_IRQHandler+0x472>
 8000774:	3848      	subs	r0, #72	; 0x48
 8000776:	4283      	cmp	r3, r0
 8000778:	f000 8205 	beq.w	8000b86 <HAL_DMA_IRQHandler+0x476>
 800077c:	3060      	adds	r0, #96	; 0x60
 800077e:	4283      	cmp	r3, r0
 8000780:	f000 8203 	beq.w	8000b8a <HAL_DMA_IRQHandler+0x47a>
 8000784:	3848      	subs	r0, #72	; 0x48
 8000786:	4283      	cmp	r3, r0
 8000788:	f000 8201 	beq.w	8000b8e <HAL_DMA_IRQHandler+0x47e>
 800078c:	3060      	adds	r0, #96	; 0x60
 800078e:	4283      	cmp	r3, r0
 8000790:	bf0c      	ite	eq
 8000792:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000796:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 800079a:	e1ce      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 800079c:	2208      	movs	r2, #8
 800079e:	e7da      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007a0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80007a4:	e7d7      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007a6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80007aa:	e7d4      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007ac:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 80007b0:	e7d1      	b.n	8000756 <HAL_DMA_IRQHandler+0x46>
 80007b2:	4a9f      	ldr	r2, [pc, #636]	; (8000a30 <HAL_DMA_IRQHandler+0x320>)
 80007b4:	4291      	cmp	r1, r2
 80007b6:	d957      	bls.n	8000868 <HAL_DMA_IRQHandler+0x158>
 80007b8:	f502 7252 	add.w	r2, r2, #840	; 0x348
 80007bc:	6810      	ldr	r0, [r2, #0]
 80007be:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 80007c2:	4d99      	ldr	r5, [pc, #612]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 80007c4:	42aa      	cmp	r2, r5
 80007c6:	d013      	beq.n	80007f0 <HAL_DMA_IRQHandler+0xe0>
 80007c8:	3560      	adds	r5, #96	; 0x60
 80007ca:	42aa      	cmp	r2, r5
 80007cc:	d041      	beq.n	8000852 <HAL_DMA_IRQHandler+0x142>
 80007ce:	3d48      	subs	r5, #72	; 0x48
 80007d0:	42aa      	cmp	r2, r5
 80007d2:	d040      	beq.n	8000856 <HAL_DMA_IRQHandler+0x146>
 80007d4:	3560      	adds	r5, #96	; 0x60
 80007d6:	42aa      	cmp	r2, r5
 80007d8:	d040      	beq.n	800085c <HAL_DMA_IRQHandler+0x14c>
 80007da:	3d48      	subs	r5, #72	; 0x48
 80007dc:	42aa      	cmp	r2, r5
 80007de:	d040      	beq.n	8000862 <HAL_DMA_IRQHandler+0x152>
 80007e0:	3560      	adds	r5, #96	; 0x60
 80007e2:	42aa      	cmp	r2, r5
 80007e4:	bf0c      	ite	eq
 80007e6:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 80007ea:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 80007ee:	e000      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 80007f0:	2208      	movs	r2, #8
 80007f2:	4202      	tst	r2, r0
 80007f4:	f000 80ea 	beq.w	80009cc <HAL_DMA_IRQHandler+0x2bc>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80007f8:	680b      	ldr	r3, [r1, #0]
 80007fa:	f013 0f04 	tst.w	r3, #4
 80007fe:	f001 8124 	beq.w	8001a4a <HAL_DMA_IRQHandler+0x133a>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8000802:	680b      	ldr	r3, [r1, #0]
 8000804:	f023 0304 	bic.w	r3, r3, #4
 8000808:	600b      	str	r3, [r1, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800080a:	6823      	ldr	r3, [r4, #0]
 800080c:	4a85      	ldr	r2, [pc, #532]	; (8000a24 <HAL_DMA_IRQHandler+0x314>)
 800080e:	4293      	cmp	r3, r2
 8000810:	f240 8114 	bls.w	8000a3c <HAL_DMA_IRQHandler+0x32c>
 8000814:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000818:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 800081c:	4293      	cmp	r3, r2
 800081e:	f000 80ba 	beq.w	8000996 <HAL_DMA_IRQHandler+0x286>
 8000822:	3260      	adds	r2, #96	; 0x60
 8000824:	4293      	cmp	r3, r2
 8000826:	f000 80f1 	beq.w	8000a0c <HAL_DMA_IRQHandler+0x2fc>
 800082a:	3a48      	subs	r2, #72	; 0x48
 800082c:	4293      	cmp	r3, r2
 800082e:	f000 80ef 	beq.w	8000a10 <HAL_DMA_IRQHandler+0x300>
 8000832:	3260      	adds	r2, #96	; 0x60
 8000834:	4293      	cmp	r3, r2
 8000836:	f000 80ee 	beq.w	8000a16 <HAL_DMA_IRQHandler+0x306>
 800083a:	3a48      	subs	r2, #72	; 0x48
 800083c:	4293      	cmp	r3, r2
 800083e:	f000 80ed 	beq.w	8000a1c <HAL_DMA_IRQHandler+0x30c>
 8000842:	3260      	adds	r2, #96	; 0x60
 8000844:	4293      	cmp	r3, r2
 8000846:	bf0c      	ite	eq
 8000848:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 800084c:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000850:	e0a2      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8000852:	2208      	movs	r2, #8
 8000854:	e7cd      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 8000856:	f44f 7200 	mov.w	r2, #512	; 0x200
 800085a:	e7ca      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 800085c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000860:	e7c7      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 8000862:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000866:	e7c4      	b.n	80007f2 <HAL_DMA_IRQHandler+0xe2>
 8000868:	4a72      	ldr	r2, [pc, #456]	; (8000a34 <HAL_DMA_IRQHandler+0x324>)
 800086a:	4291      	cmp	r1, r2
 800086c:	d949      	bls.n	8000902 <HAL_DMA_IRQHandler+0x1f2>
 800086e:	3a58      	subs	r2, #88	; 0x58
 8000870:	6850      	ldr	r0, [r2, #4]
 8000872:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 8000876:	4d6c      	ldr	r5, [pc, #432]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 8000878:	42aa      	cmp	r2, r5
 800087a:	d013      	beq.n	80008a4 <HAL_DMA_IRQHandler+0x194>
 800087c:	3560      	adds	r5, #96	; 0x60
 800087e:	42aa      	cmp	r2, r5
 8000880:	d034      	beq.n	80008ec <HAL_DMA_IRQHandler+0x1dc>
 8000882:	3d48      	subs	r5, #72	; 0x48
 8000884:	42aa      	cmp	r2, r5
 8000886:	d033      	beq.n	80008f0 <HAL_DMA_IRQHandler+0x1e0>
 8000888:	3560      	adds	r5, #96	; 0x60
 800088a:	42aa      	cmp	r2, r5
 800088c:	d033      	beq.n	80008f6 <HAL_DMA_IRQHandler+0x1e6>
 800088e:	3d48      	subs	r5, #72	; 0x48
 8000890:	42aa      	cmp	r2, r5
 8000892:	d033      	beq.n	80008fc <HAL_DMA_IRQHandler+0x1ec>
 8000894:	3560      	adds	r5, #96	; 0x60
 8000896:	42aa      	cmp	r2, r5
 8000898:	bf0c      	ite	eq
 800089a:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 800089e:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 80008a2:	e000      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008a4:	2208      	movs	r2, #8
 80008a6:	4202      	tst	r2, r0
 80008a8:	f041 80d3 	bne.w	8001a52 <HAL_DMA_IRQHandler+0x1342>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 80008ac:	4a62      	ldr	r2, [pc, #392]	; (8000a38 <HAL_DMA_IRQHandler+0x328>)
 80008ae:	6852      	ldr	r2, [r2, #4]
 80008b0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80008b4:	485c      	ldr	r0, [pc, #368]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 80008b6:	4283      	cmp	r3, r0
 80008b8:	f000 81aa 	beq.w	8000c10 <HAL_DMA_IRQHandler+0x500>
 80008bc:	3060      	adds	r0, #96	; 0x60
 80008be:	4283      	cmp	r3, r0
 80008c0:	f000 81ac 	beq.w	8000c1c <HAL_DMA_IRQHandler+0x50c>
 80008c4:	3848      	subs	r0, #72	; 0x48
 80008c6:	4283      	cmp	r3, r0
 80008c8:	f000 81aa 	beq.w	8000c20 <HAL_DMA_IRQHandler+0x510>
 80008cc:	3060      	adds	r0, #96	; 0x60
 80008ce:	4283      	cmp	r3, r0
 80008d0:	f000 81a8 	beq.w	8000c24 <HAL_DMA_IRQHandler+0x514>
 80008d4:	3848      	subs	r0, #72	; 0x48
 80008d6:	4283      	cmp	r3, r0
 80008d8:	f000 81a6 	beq.w	8000c28 <HAL_DMA_IRQHandler+0x518>
 80008dc:	3060      	adds	r0, #96	; 0x60
 80008de:	4283      	cmp	r3, r0
 80008e0:	bf0c      	ite	eq
 80008e2:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 80008e6:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 80008ea:	e192      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 80008ec:	2208      	movs	r2, #8
 80008ee:	e7da      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008f0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80008f4:	e7d7      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008f6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80008fa:	e7d4      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 80008fc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000900:	e7d1      	b.n	80008a6 <HAL_DMA_IRQHandler+0x196>
 8000902:	4a4d      	ldr	r2, [pc, #308]	; (8000a38 <HAL_DMA_IRQHandler+0x328>)
 8000904:	6810      	ldr	r0, [r2, #0]
 8000906:	f421 6280 	bic.w	r2, r1, #1024	; 0x400
 800090a:	4d47      	ldr	r5, [pc, #284]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 800090c:	42aa      	cmp	r2, r5
 800090e:	d013      	beq.n	8000938 <HAL_DMA_IRQHandler+0x228>
 8000910:	3560      	adds	r5, #96	; 0x60
 8000912:	42aa      	cmp	r2, r5
 8000914:	d034      	beq.n	8000980 <HAL_DMA_IRQHandler+0x270>
 8000916:	3d48      	subs	r5, #72	; 0x48
 8000918:	42aa      	cmp	r2, r5
 800091a:	d033      	beq.n	8000984 <HAL_DMA_IRQHandler+0x274>
 800091c:	3560      	adds	r5, #96	; 0x60
 800091e:	42aa      	cmp	r2, r5
 8000920:	d033      	beq.n	800098a <HAL_DMA_IRQHandler+0x27a>
 8000922:	3d48      	subs	r5, #72	; 0x48
 8000924:	42aa      	cmp	r2, r5
 8000926:	d033      	beq.n	8000990 <HAL_DMA_IRQHandler+0x280>
 8000928:	3560      	adds	r5, #96	; 0x60
 800092a:	42aa      	cmp	r2, r5
 800092c:	bf0c      	ite	eq
 800092e:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 8000932:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 8000936:	e000      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 8000938:	2208      	movs	r2, #8
 800093a:	4202      	tst	r2, r0
 800093c:	f041 8092 	bne.w	8001a64 <HAL_DMA_IRQHandler+0x1354>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000940:	4a3d      	ldr	r2, [pc, #244]	; (8000a38 <HAL_DMA_IRQHandler+0x328>)
 8000942:	6812      	ldr	r2, [r2, #0]
 8000944:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000948:	4837      	ldr	r0, [pc, #220]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 800094a:	4283      	cmp	r3, r0
 800094c:	f000 816f 	beq.w	8000c2e <HAL_DMA_IRQHandler+0x51e>
 8000950:	3060      	adds	r0, #96	; 0x60
 8000952:	4283      	cmp	r3, r0
 8000954:	f000 8190 	beq.w	8000c78 <HAL_DMA_IRQHandler+0x568>
 8000958:	3848      	subs	r0, #72	; 0x48
 800095a:	4283      	cmp	r3, r0
 800095c:	f000 818e 	beq.w	8000c7c <HAL_DMA_IRQHandler+0x56c>
 8000960:	3060      	adds	r0, #96	; 0x60
 8000962:	4283      	cmp	r3, r0
 8000964:	f000 818c 	beq.w	8000c80 <HAL_DMA_IRQHandler+0x570>
 8000968:	3848      	subs	r0, #72	; 0x48
 800096a:	4283      	cmp	r3, r0
 800096c:	f000 818a 	beq.w	8000c84 <HAL_DMA_IRQHandler+0x574>
 8000970:	3060      	adds	r0, #96	; 0x60
 8000972:	4283      	cmp	r3, r0
 8000974:	bf0c      	ite	eq
 8000976:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800097a:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 800097e:	e157      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8000980:	2208      	movs	r2, #8
 8000982:	e7da      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 8000984:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000988:	e7d7      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 800098a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800098e:	e7d4      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
 8000990:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8000994:	e7d1      	b.n	800093a <HAL_DMA_IRQHandler+0x22a>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000996:	2308      	movs	r3, #8
 8000998:	4a24      	ldr	r2, [pc, #144]	; (8000a2c <HAL_DMA_IRQHandler+0x31c>)
 800099a:	60d3      	str	r3, [r2, #12]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800099c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800099e:	f043 0301 	orr.w	r3, r3, #1
 80009a2:	64e3      	str	r3, [r4, #76]	; 0x4c
      hdma->State = HAL_DMA_STATE_ERROR;
 80009a4:	2304      	movs	r3, #4
 80009a6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 80009aa:	2300      	movs	r3, #0
 80009ac:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 80009b0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80009b2:	b10b      	cbz	r3, 80009b8 <HAL_DMA_IRQHandler+0x2a8>
        hdma->XferErrorCallback(hdma);
 80009b4:	4620      	mov	r0, r4
 80009b6:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 80009b8:	6821      	ldr	r1, [r4, #0]
 80009ba:	460b      	mov	r3, r1
 80009bc:	4a19      	ldr	r2, [pc, #100]	; (8000a24 <HAL_DMA_IRQHandler+0x314>)
 80009be:	4291      	cmp	r1, r2
 80009c0:	f63f aecc 	bhi.w	800075c <HAL_DMA_IRQHandler+0x4c>
 80009c4:	4a1a      	ldr	r2, [pc, #104]	; (8000a30 <HAL_DMA_IRQHandler+0x320>)
 80009c6:	4291      	cmp	r1, r2
 80009c8:	f240 811d 	bls.w	8000c06 <HAL_DMA_IRQHandler+0x4f6>
 80009cc:	4a17      	ldr	r2, [pc, #92]	; (8000a2c <HAL_DMA_IRQHandler+0x31c>)
 80009ce:	6812      	ldr	r2, [r2, #0]
 80009d0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80009d4:	4814      	ldr	r0, [pc, #80]	; (8000a28 <HAL_DMA_IRQHandler+0x318>)
 80009d6:	4283      	cmp	r3, r0
 80009d8:	f000 80dc 	beq.w	8000b94 <HAL_DMA_IRQHandler+0x484>
 80009dc:	3060      	adds	r0, #96	; 0x60
 80009de:	4283      	cmp	r3, r0
 80009e0:	f000 8108 	beq.w	8000bf4 <HAL_DMA_IRQHandler+0x4e4>
 80009e4:	3848      	subs	r0, #72	; 0x48
 80009e6:	4283      	cmp	r3, r0
 80009e8:	f000 8106 	beq.w	8000bf8 <HAL_DMA_IRQHandler+0x4e8>
 80009ec:	3060      	adds	r0, #96	; 0x60
 80009ee:	4283      	cmp	r3, r0
 80009f0:	f000 8104 	beq.w	8000bfc <HAL_DMA_IRQHandler+0x4ec>
 80009f4:	3848      	subs	r0, #72	; 0x48
 80009f6:	4283      	cmp	r3, r0
 80009f8:	f000 8102 	beq.w	8000c00 <HAL_DMA_IRQHandler+0x4f0>
 80009fc:	3060      	adds	r0, #96	; 0x60
 80009fe:	4283      	cmp	r3, r0
 8000a00:	bf0c      	ite	eq
 8000a02:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000a06:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000a0a:	e0c4      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8000a0c:	2308      	movs	r3, #8
 8000a0e:	e7c3      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a10:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a14:	e7c0      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a16:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a1a:	e7bd      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a1c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000a20:	e7ba      	b.n	8000998 <HAL_DMA_IRQHandler+0x288>
 8000a22:	bf00      	nop
 8000a24:	40026458 	.word	0x40026458
 8000a28:	40026010 	.word	0x40026010
 8000a2c:	40026400 	.word	0x40026400
 8000a30:	400260b8 	.word	0x400260b8
 8000a34:	40026058 	.word	0x40026058
 8000a38:	40026000 	.word	0x40026000
 8000a3c:	4ab5      	ldr	r2, [pc, #724]	; (8000d14 <HAL_DMA_IRQHandler+0x604>)
 8000a3e:	4293      	cmp	r3, r2
 8000a40:	d927      	bls.n	8000a92 <HAL_DMA_IRQHandler+0x382>
 8000a42:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000a46:	3aa8      	subs	r2, #168	; 0xa8
 8000a48:	4293      	cmp	r3, r2
 8000a4a:	d013      	beq.n	8000a74 <HAL_DMA_IRQHandler+0x364>
 8000a4c:	3260      	adds	r2, #96	; 0x60
 8000a4e:	4293      	cmp	r3, r2
 8000a50:	d014      	beq.n	8000a7c <HAL_DMA_IRQHandler+0x36c>
 8000a52:	3a48      	subs	r2, #72	; 0x48
 8000a54:	4293      	cmp	r3, r2
 8000a56:	d013      	beq.n	8000a80 <HAL_DMA_IRQHandler+0x370>
 8000a58:	3260      	adds	r2, #96	; 0x60
 8000a5a:	4293      	cmp	r3, r2
 8000a5c:	d013      	beq.n	8000a86 <HAL_DMA_IRQHandler+0x376>
 8000a5e:	3a48      	subs	r2, #72	; 0x48
 8000a60:	4293      	cmp	r3, r2
 8000a62:	d013      	beq.n	8000a8c <HAL_DMA_IRQHandler+0x37c>
 8000a64:	3260      	adds	r2, #96	; 0x60
 8000a66:	4293      	cmp	r3, r2
 8000a68:	bf0c      	ite	eq
 8000a6a:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 8000a6e:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000a72:	e000      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a74:	2308      	movs	r3, #8
 8000a76:	4aa8      	ldr	r2, [pc, #672]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000a78:	6093      	str	r3, [r2, #8]
 8000a7a:	e78f      	b.n	800099c <HAL_DMA_IRQHandler+0x28c>
 8000a7c:	2308      	movs	r3, #8
 8000a7e:	e7fa      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a80:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a84:	e7f7      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a86:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a8a:	e7f4      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a8c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000a90:	e7f1      	b.n	8000a76 <HAL_DMA_IRQHandler+0x366>
 8000a92:	4aa2      	ldr	r2, [pc, #648]	; (8000d1c <HAL_DMA_IRQHandler+0x60c>)
 8000a94:	4293      	cmp	r3, r2
 8000a96:	d927      	bls.n	8000ae8 <HAL_DMA_IRQHandler+0x3d8>
 8000a98:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000a9c:	3a48      	subs	r2, #72	; 0x48
 8000a9e:	4293      	cmp	r3, r2
 8000aa0:	d013      	beq.n	8000aca <HAL_DMA_IRQHandler+0x3ba>
 8000aa2:	3260      	adds	r2, #96	; 0x60
 8000aa4:	4293      	cmp	r3, r2
 8000aa6:	d014      	beq.n	8000ad2 <HAL_DMA_IRQHandler+0x3c2>
 8000aa8:	3a48      	subs	r2, #72	; 0x48
 8000aaa:	4293      	cmp	r3, r2
 8000aac:	d013      	beq.n	8000ad6 <HAL_DMA_IRQHandler+0x3c6>
 8000aae:	3260      	adds	r2, #96	; 0x60
 8000ab0:	4293      	cmp	r3, r2
 8000ab2:	d013      	beq.n	8000adc <HAL_DMA_IRQHandler+0x3cc>
 8000ab4:	3a48      	subs	r2, #72	; 0x48
 8000ab6:	4293      	cmp	r3, r2
 8000ab8:	d013      	beq.n	8000ae2 <HAL_DMA_IRQHandler+0x3d2>
 8000aba:	3260      	adds	r2, #96	; 0x60
 8000abc:	4293      	cmp	r3, r2
 8000abe:	bf0c      	ite	eq
 8000ac0:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 8000ac4:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000ac8:	e000      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000aca:	2308      	movs	r3, #8
 8000acc:	4a94      	ldr	r2, [pc, #592]	; (8000d20 <HAL_DMA_IRQHandler+0x610>)
 8000ace:	60d3      	str	r3, [r2, #12]
 8000ad0:	e764      	b.n	800099c <HAL_DMA_IRQHandler+0x28c>
 8000ad2:	2308      	movs	r3, #8
 8000ad4:	e7fa      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000ad6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ada:	e7f7      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000adc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000ae0:	e7f4      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000ae2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000ae6:	e7f1      	b.n	8000acc <HAL_DMA_IRQHandler+0x3bc>
 8000ae8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000aec:	4a8d      	ldr	r2, [pc, #564]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000aee:	4293      	cmp	r3, r2
 8000af0:	d013      	beq.n	8000b1a <HAL_DMA_IRQHandler+0x40a>
 8000af2:	3260      	adds	r2, #96	; 0x60
 8000af4:	4293      	cmp	r3, r2
 8000af6:	d014      	beq.n	8000b22 <HAL_DMA_IRQHandler+0x412>
 8000af8:	3a48      	subs	r2, #72	; 0x48
 8000afa:	4293      	cmp	r3, r2
 8000afc:	d013      	beq.n	8000b26 <HAL_DMA_IRQHandler+0x416>
 8000afe:	3260      	adds	r2, #96	; 0x60
 8000b00:	4293      	cmp	r3, r2
 8000b02:	d013      	beq.n	8000b2c <HAL_DMA_IRQHandler+0x41c>
 8000b04:	3a48      	subs	r2, #72	; 0x48
 8000b06:	4293      	cmp	r3, r2
 8000b08:	d013      	beq.n	8000b32 <HAL_DMA_IRQHandler+0x422>
 8000b0a:	3260      	adds	r2, #96	; 0x60
 8000b0c:	4293      	cmp	r3, r2
 8000b0e:	bf0c      	ite	eq
 8000b10:	f44f 2300 	moveq.w	r3, #524288	; 0x80000
 8000b14:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8000b18:	e000      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b1a:	2308      	movs	r3, #8
 8000b1c:	4a80      	ldr	r2, [pc, #512]	; (8000d20 <HAL_DMA_IRQHandler+0x610>)
 8000b1e:	6093      	str	r3, [r2, #8]
 8000b20:	e73c      	b.n	800099c <HAL_DMA_IRQHandler+0x28c>
 8000b22:	2308      	movs	r3, #8
 8000b24:	e7fa      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b26:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000b2a:	e7f7      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b2c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000b30:	e7f4      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
 8000b32:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8000b36:	e7f1      	b.n	8000b1c <HAL_DMA_IRQHandler+0x40c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000b38:	4b7b      	ldr	r3, [pc, #492]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000b3a:	4213      	tst	r3, r2
 8000b3c:	d12e      	bne.n	8000b9c <HAL_DMA_IRQHandler+0x48c>
        hdma->XferErrorCallback(hdma);
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000b3e:	6822      	ldr	r2, [r4, #0]
 8000b40:	4613      	mov	r3, r2
 8000b42:	4975      	ldr	r1, [pc, #468]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000b44:	6849      	ldr	r1, [r1, #4]
 8000b46:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000b4a:	4876      	ldr	r0, [pc, #472]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000b4c:	4283      	cmp	r3, r0
 8000b4e:	f000 8167 	beq.w	8000e20 <HAL_DMA_IRQHandler+0x710>
 8000b52:	3060      	adds	r0, #96	; 0x60
 8000b54:	4283      	cmp	r3, r0
 8000b56:	f000 8188 	beq.w	8000e6a <HAL_DMA_IRQHandler+0x75a>
 8000b5a:	3848      	subs	r0, #72	; 0x48
 8000b5c:	4283      	cmp	r3, r0
 8000b5e:	f000 8186 	beq.w	8000e6e <HAL_DMA_IRQHandler+0x75e>
 8000b62:	3060      	adds	r0, #96	; 0x60
 8000b64:	4283      	cmp	r3, r0
 8000b66:	f000 8185 	beq.w	8000e74 <HAL_DMA_IRQHandler+0x764>
 8000b6a:	3848      	subs	r0, #72	; 0x48
 8000b6c:	4283      	cmp	r3, r0
 8000b6e:	f000 8184 	beq.w	8000e7a <HAL_DMA_IRQHandler+0x76a>
 8000b72:	3060      	adds	r0, #96	; 0x60
 8000b74:	4283      	cmp	r3, r0
 8000b76:	bf0c      	ite	eq
 8000b78:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000b7c:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000b80:	e14f      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000b82:	4b69      	ldr	r3, [pc, #420]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000b84:	e7d9      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b86:	2340      	movs	r3, #64	; 0x40
 8000b88:	e7d7      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b8a:	2340      	movs	r3, #64	; 0x40
 8000b8c:	e7d5      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b8e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000b92:	e7d2      	b.n	8000b3a <HAL_DMA_IRQHandler+0x42a>
 8000b94:	4b64      	ldr	r3, [pc, #400]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000b96:	4213      	tst	r3, r2
 8000b98:	f000 874c 	beq.w	8001a34 <HAL_DMA_IRQHandler+0x1324>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8000b9c:	694b      	ldr	r3, [r1, #20]
 8000b9e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8000ba2:	f000 8083 	beq.w	8000cac <HAL_DMA_IRQHandler+0x59c>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 8000ba6:	694b      	ldr	r3, [r1, #20]
 8000ba8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000bac:	614b      	str	r3, [r1, #20]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000bae:	6823      	ldr	r3, [r4, #0]
 8000bb0:	4a5e      	ldr	r2, [pc, #376]	; (8000d2c <HAL_DMA_IRQHandler+0x61c>)
 8000bb2:	4293      	cmp	r3, r2
 8000bb4:	f240 80bc 	bls.w	8000d30 <HAL_DMA_IRQHandler+0x620>
 8000bb8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000bbc:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 8000bc0:	4293      	cmp	r3, r2
 8000bc2:	d062      	beq.n	8000c8a <HAL_DMA_IRQHandler+0x57a>
 8000bc4:	3260      	adds	r2, #96	; 0x60
 8000bc6:	4293      	cmp	r3, r2
 8000bc8:	f000 809a 	beq.w	8000d00 <HAL_DMA_IRQHandler+0x5f0>
 8000bcc:	3a48      	subs	r2, #72	; 0x48
 8000bce:	4293      	cmp	r3, r2
 8000bd0:	f000 8098 	beq.w	8000d04 <HAL_DMA_IRQHandler+0x5f4>
 8000bd4:	3260      	adds	r2, #96	; 0x60
 8000bd6:	4293      	cmp	r3, r2
 8000bd8:	f000 8096 	beq.w	8000d08 <HAL_DMA_IRQHandler+0x5f8>
 8000bdc:	3a48      	subs	r2, #72	; 0x48
 8000bde:	4293      	cmp	r3, r2
 8000be0:	f000 8094 	beq.w	8000d0c <HAL_DMA_IRQHandler+0x5fc>
 8000be4:	3260      	adds	r2, #96	; 0x60
 8000be6:	4293      	cmp	r3, r2
 8000be8:	bf0c      	ite	eq
 8000bea:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000bee:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000bf2:	e04b      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000bf4:	4b4c      	ldr	r3, [pc, #304]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000bf6:	e7ce      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000bf8:	2340      	movs	r3, #64	; 0x40
 8000bfa:	e7cc      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000bfc:	2340      	movs	r3, #64	; 0x40
 8000bfe:	e7ca      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000c00:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c04:	e7c7      	b.n	8000b96 <HAL_DMA_IRQHandler+0x486>
 8000c06:	4a45      	ldr	r2, [pc, #276]	; (8000d1c <HAL_DMA_IRQHandler+0x60c>)
 8000c08:	4291      	cmp	r1, r2
 8000c0a:	f63f ae4f 	bhi.w	80008ac <HAL_DMA_IRQHandler+0x19c>
 8000c0e:	e697      	b.n	8000940 <HAL_DMA_IRQHandler+0x230>
 8000c10:	4b45      	ldr	r3, [pc, #276]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c12:	4213      	tst	r3, r2
 8000c14:	d1c2      	bne.n	8000b9c <HAL_DMA_IRQHandler+0x48c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000c16:	6822      	ldr	r2, [r4, #0]
 8000c18:	4613      	mov	r3, r2
 8000c1a:	e171      	b.n	8000f00 <HAL_DMA_IRQHandler+0x7f0>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000c1c:	4b42      	ldr	r3, [pc, #264]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c1e:	e7f8      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c20:	2340      	movs	r3, #64	; 0x40
 8000c22:	e7f6      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c24:	2340      	movs	r3, #64	; 0x40
 8000c26:	e7f4      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c28:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c2c:	e7f1      	b.n	8000c12 <HAL_DMA_IRQHandler+0x502>
 8000c2e:	4b3e      	ldr	r3, [pc, #248]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c30:	4213      	tst	r3, r2
 8000c32:	d1b3      	bne.n	8000b9c <HAL_DMA_IRQHandler+0x48c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000c34:	6822      	ldr	r2, [r4, #0]
 8000c36:	4613      	mov	r3, r2
 8000c38:	4939      	ldr	r1, [pc, #228]	; (8000d20 <HAL_DMA_IRQHandler+0x610>)
 8000c3a:	6809      	ldr	r1, [r1, #0]
 8000c3c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000c40:	4838      	ldr	r0, [pc, #224]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000c42:	4283      	cmp	r3, r0
 8000c44:	f000 81a7 	beq.w	8000f96 <HAL_DMA_IRQHandler+0x886>
 8000c48:	3060      	adds	r0, #96	; 0x60
 8000c4a:	4283      	cmp	r3, r0
 8000c4c:	f000 81aa 	beq.w	8000fa4 <HAL_DMA_IRQHandler+0x894>
 8000c50:	3848      	subs	r0, #72	; 0x48
 8000c52:	4283      	cmp	r3, r0
 8000c54:	f000 81a8 	beq.w	8000fa8 <HAL_DMA_IRQHandler+0x898>
 8000c58:	3060      	adds	r0, #96	; 0x60
 8000c5a:	4283      	cmp	r3, r0
 8000c5c:	f000 81a7 	beq.w	8000fae <HAL_DMA_IRQHandler+0x89e>
 8000c60:	3848      	subs	r0, #72	; 0x48
 8000c62:	4283      	cmp	r3, r0
 8000c64:	f000 81a6 	beq.w	8000fb4 <HAL_DMA_IRQHandler+0x8a4>
 8000c68:	3060      	adds	r0, #96	; 0x60
 8000c6a:	4283      	cmp	r3, r0
 8000c6c:	bf0c      	ite	eq
 8000c6e:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000c72:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000c76:	e18f      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8000c78:	4b2b      	ldr	r3, [pc, #172]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c7a:	e7d9      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
 8000c7c:	2340      	movs	r3, #64	; 0x40
 8000c7e:	e7d7      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
 8000c80:	2340      	movs	r3, #64	; 0x40
 8000c82:	e7d5      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
 8000c84:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000c88:	e7d2      	b.n	8000c30 <HAL_DMA_IRQHandler+0x520>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000c8a:	4b27      	ldr	r3, [pc, #156]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000c8c:	4a22      	ldr	r2, [pc, #136]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000c8e:	60d3      	str	r3, [r2, #12]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8000c90:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000c92:	f043 0302 	orr.w	r3, r3, #2
 8000c96:	64e3      	str	r3, [r4, #76]	; 0x4c
      hdma->State = HAL_DMA_STATE_ERROR;
 8000c98:	2304      	movs	r3, #4
 8000c9a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 8000c9e:	2300      	movs	r3, #0
 8000ca0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 8000ca4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000ca6:	b10b      	cbz	r3, 8000cac <HAL_DMA_IRQHandler+0x59c>
        hdma->XferErrorCallback(hdma);
 8000ca8:	4620      	mov	r0, r4
 8000caa:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000cac:	6822      	ldr	r2, [r4, #0]
 8000cae:	4613      	mov	r3, r2
 8000cb0:	491e      	ldr	r1, [pc, #120]	; (8000d2c <HAL_DMA_IRQHandler+0x61c>)
 8000cb2:	428a      	cmp	r2, r1
 8000cb4:	f63f af45 	bhi.w	8000b42 <HAL_DMA_IRQHandler+0x432>
 8000cb8:	4916      	ldr	r1, [pc, #88]	; (8000d14 <HAL_DMA_IRQHandler+0x604>)
 8000cba:	428a      	cmp	r2, r1
 8000cbc:	f240 811c 	bls.w	8000ef8 <HAL_DMA_IRQHandler+0x7e8>
 8000cc0:	4915      	ldr	r1, [pc, #84]	; (8000d18 <HAL_DMA_IRQHandler+0x608>)
 8000cc2:	6809      	ldr	r1, [r1, #0]
 8000cc4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000cc8:	4816      	ldr	r0, [pc, #88]	; (8000d24 <HAL_DMA_IRQHandler+0x614>)
 8000cca:	4283      	cmp	r3, r0
 8000ccc:	f000 80d8 	beq.w	8000e80 <HAL_DMA_IRQHandler+0x770>
 8000cd0:	3060      	adds	r0, #96	; 0x60
 8000cd2:	4283      	cmp	r3, r0
 8000cd4:	f000 8105 	beq.w	8000ee2 <HAL_DMA_IRQHandler+0x7d2>
 8000cd8:	3848      	subs	r0, #72	; 0x48
 8000cda:	4283      	cmp	r3, r0
 8000cdc:	f000 8103 	beq.w	8000ee6 <HAL_DMA_IRQHandler+0x7d6>
 8000ce0:	3060      	adds	r0, #96	; 0x60
 8000ce2:	4283      	cmp	r3, r0
 8000ce4:	f000 8102 	beq.w	8000eec <HAL_DMA_IRQHandler+0x7dc>
 8000ce8:	3848      	subs	r0, #72	; 0x48
 8000cea:	4283      	cmp	r3, r0
 8000cec:	f000 8101 	beq.w	8000ef2 <HAL_DMA_IRQHandler+0x7e2>
 8000cf0:	3060      	adds	r0, #96	; 0x60
 8000cf2:	4283      	cmp	r3, r0
 8000cf4:	bf0c      	ite	eq
 8000cf6:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000cfa:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000cfe:	e0c0      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));
 8000d00:	4b09      	ldr	r3, [pc, #36]	; (8000d28 <HAL_DMA_IRQHandler+0x618>)
 8000d02:	e7c3      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d04:	2340      	movs	r3, #64	; 0x40
 8000d06:	e7c1      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d08:	2340      	movs	r3, #64	; 0x40
 8000d0a:	e7bf      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d0c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000d10:	e7bc      	b.n	8000c8c <HAL_DMA_IRQHandler+0x57c>
 8000d12:	bf00      	nop
 8000d14:	400260b8 	.word	0x400260b8
 8000d18:	40026400 	.word	0x40026400
 8000d1c:	40026058 	.word	0x40026058
 8000d20:	40026000 	.word	0x40026000
 8000d24:	40026010 	.word	0x40026010
 8000d28:	00800001 	.word	0x00800001
 8000d2c:	40026458 	.word	0x40026458
 8000d30:	4aa2      	ldr	r2, [pc, #648]	; (8000fbc <HAL_DMA_IRQHandler+0x8ac>)
 8000d32:	4293      	cmp	r3, r2
 8000d34:	d925      	bls.n	8000d82 <HAL_DMA_IRQHandler+0x672>
 8000d36:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000d3a:	3aa8      	subs	r2, #168	; 0xa8
 8000d3c:	4293      	cmp	r3, r2
 8000d3e:	d013      	beq.n	8000d68 <HAL_DMA_IRQHandler+0x658>
 8000d40:	3260      	adds	r2, #96	; 0x60
 8000d42:	4293      	cmp	r3, r2
 8000d44:	d014      	beq.n	8000d70 <HAL_DMA_IRQHandler+0x660>
 8000d46:	3a48      	subs	r2, #72	; 0x48
 8000d48:	4293      	cmp	r3, r2
 8000d4a:	d013      	beq.n	8000d74 <HAL_DMA_IRQHandler+0x664>
 8000d4c:	3260      	adds	r2, #96	; 0x60
 8000d4e:	4293      	cmp	r3, r2
 8000d50:	d012      	beq.n	8000d78 <HAL_DMA_IRQHandler+0x668>
 8000d52:	3a48      	subs	r2, #72	; 0x48
 8000d54:	4293      	cmp	r3, r2
 8000d56:	d011      	beq.n	8000d7c <HAL_DMA_IRQHandler+0x66c>
 8000d58:	3260      	adds	r2, #96	; 0x60
 8000d5a:	4293      	cmp	r3, r2
 8000d5c:	bf0c      	ite	eq
 8000d5e:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000d62:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000d66:	e000      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d68:	4b95      	ldr	r3, [pc, #596]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000d6a:	4a96      	ldr	r2, [pc, #600]	; (8000fc4 <HAL_DMA_IRQHandler+0x8b4>)
 8000d6c:	6093      	str	r3, [r2, #8]
 8000d6e:	e78f      	b.n	8000c90 <HAL_DMA_IRQHandler+0x580>
 8000d70:	4b93      	ldr	r3, [pc, #588]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000d72:	e7fa      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d74:	2340      	movs	r3, #64	; 0x40
 8000d76:	e7f8      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d78:	2340      	movs	r3, #64	; 0x40
 8000d7a:	e7f6      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d7c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000d80:	e7f3      	b.n	8000d6a <HAL_DMA_IRQHandler+0x65a>
 8000d82:	4a91      	ldr	r2, [pc, #580]	; (8000fc8 <HAL_DMA_IRQHandler+0x8b8>)
 8000d84:	4293      	cmp	r3, r2
 8000d86:	d925      	bls.n	8000dd4 <HAL_DMA_IRQHandler+0x6c4>
 8000d88:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000d8c:	3a48      	subs	r2, #72	; 0x48
 8000d8e:	4293      	cmp	r3, r2
 8000d90:	d013      	beq.n	8000dba <HAL_DMA_IRQHandler+0x6aa>
 8000d92:	3260      	adds	r2, #96	; 0x60
 8000d94:	4293      	cmp	r3, r2
 8000d96:	d014      	beq.n	8000dc2 <HAL_DMA_IRQHandler+0x6b2>
 8000d98:	3a48      	subs	r2, #72	; 0x48
 8000d9a:	4293      	cmp	r3, r2
 8000d9c:	d013      	beq.n	8000dc6 <HAL_DMA_IRQHandler+0x6b6>
 8000d9e:	3260      	adds	r2, #96	; 0x60
 8000da0:	4293      	cmp	r3, r2
 8000da2:	d012      	beq.n	8000dca <HAL_DMA_IRQHandler+0x6ba>
 8000da4:	3a48      	subs	r2, #72	; 0x48
 8000da6:	4293      	cmp	r3, r2
 8000da8:	d011      	beq.n	8000dce <HAL_DMA_IRQHandler+0x6be>
 8000daa:	3260      	adds	r2, #96	; 0x60
 8000dac:	4293      	cmp	r3, r2
 8000dae:	bf0c      	ite	eq
 8000db0:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000db4:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000db8:	e000      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dba:	4b81      	ldr	r3, [pc, #516]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000dbc:	4a83      	ldr	r2, [pc, #524]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000dbe:	60d3      	str	r3, [r2, #12]
 8000dc0:	e766      	b.n	8000c90 <HAL_DMA_IRQHandler+0x580>
 8000dc2:	4b7f      	ldr	r3, [pc, #508]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000dc4:	e7fa      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dc6:	2340      	movs	r3, #64	; 0x40
 8000dc8:	e7f8      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dca:	2340      	movs	r3, #64	; 0x40
 8000dcc:	e7f6      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dce:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000dd2:	e7f3      	b.n	8000dbc <HAL_DMA_IRQHandler+0x6ac>
 8000dd4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000dd8:	4a7d      	ldr	r2, [pc, #500]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000dda:	4293      	cmp	r3, r2
 8000ddc:	d013      	beq.n	8000e06 <HAL_DMA_IRQHandler+0x6f6>
 8000dde:	3260      	adds	r2, #96	; 0x60
 8000de0:	4293      	cmp	r3, r2
 8000de2:	d014      	beq.n	8000e0e <HAL_DMA_IRQHandler+0x6fe>
 8000de4:	3a48      	subs	r2, #72	; 0x48
 8000de6:	4293      	cmp	r3, r2
 8000de8:	d013      	beq.n	8000e12 <HAL_DMA_IRQHandler+0x702>
 8000dea:	3260      	adds	r2, #96	; 0x60
 8000dec:	4293      	cmp	r3, r2
 8000dee:	d012      	beq.n	8000e16 <HAL_DMA_IRQHandler+0x706>
 8000df0:	3a48      	subs	r2, #72	; 0x48
 8000df2:	4293      	cmp	r3, r2
 8000df4:	d011      	beq.n	8000e1a <HAL_DMA_IRQHandler+0x70a>
 8000df6:	3260      	adds	r2, #96	; 0x60
 8000df8:	4293      	cmp	r3, r2
 8000dfa:	bf0c      	ite	eq
 8000dfc:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8000e00:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 8000e04:	e000      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e06:	4b6e      	ldr	r3, [pc, #440]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000e08:	4a70      	ldr	r2, [pc, #448]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000e0a:	6093      	str	r3, [r2, #8]
 8000e0c:	e740      	b.n	8000c90 <HAL_DMA_IRQHandler+0x580>
 8000e0e:	4b6c      	ldr	r3, [pc, #432]	; (8000fc0 <HAL_DMA_IRQHandler+0x8b0>)
 8000e10:	e7fa      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e12:	2340      	movs	r3, #64	; 0x40
 8000e14:	e7f8      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e16:	2340      	movs	r3, #64	; 0x40
 8000e18:	e7f6      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
 8000e1a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000e1e:	e7f3      	b.n	8000e08 <HAL_DMA_IRQHandler+0x6f8>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000e20:	4b6c      	ldr	r3, [pc, #432]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000e22:	420b      	tst	r3, r1
 8000e24:	d130      	bne.n	8000e88 <HAL_DMA_IRQHandler+0x778>
        hdma->XferErrorCallback(hdma);
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000e26:	6822      	ldr	r2, [r4, #0]
 8000e28:	4611      	mov	r1, r2
 8000e2a:	4b66      	ldr	r3, [pc, #408]	; (8000fc4 <HAL_DMA_IRQHandler+0x8b4>)
 8000e2c:	6858      	ldr	r0, [r3, #4]
 8000e2e:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 8000e32:	4d67      	ldr	r5, [pc, #412]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000e34:	42ab      	cmp	r3, r5
 8000e36:	f000 8195 	beq.w	8001164 <HAL_DMA_IRQHandler+0xa54>
 8000e3a:	3560      	adds	r5, #96	; 0x60
 8000e3c:	42ab      	cmp	r3, r5
 8000e3e:	f000 81b6 	beq.w	80011ae <HAL_DMA_IRQHandler+0xa9e>
 8000e42:	3d48      	subs	r5, #72	; 0x48
 8000e44:	42ab      	cmp	r3, r5
 8000e46:	f000 81b4 	beq.w	80011b2 <HAL_DMA_IRQHandler+0xaa2>
 8000e4a:	3560      	adds	r5, #96	; 0x60
 8000e4c:	42ab      	cmp	r3, r5
 8000e4e:	f000 81b3 	beq.w	80011b8 <HAL_DMA_IRQHandler+0xaa8>
 8000e52:	3d48      	subs	r5, #72	; 0x48
 8000e54:	42ab      	cmp	r3, r5
 8000e56:	f000 81b2 	beq.w	80011be <HAL_DMA_IRQHandler+0xaae>
 8000e5a:	3560      	adds	r5, #96	; 0x60
 8000e5c:	42ab      	cmp	r3, r5
 8000e5e:	bf0c      	ite	eq
 8000e60:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000e64:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000e68:	e17d      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000e6a:	4b5a      	ldr	r3, [pc, #360]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000e6c:	e7d9      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e6e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000e72:	e7d6      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e74:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000e78:	e7d3      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e7a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000e7e:	e7d0      	b.n	8000e22 <HAL_DMA_IRQHandler+0x712>
 8000e80:	4b54      	ldr	r3, [pc, #336]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000e82:	420b      	tst	r3, r1
 8000e84:	f000 85da 	beq.w	8001a3c <HAL_DMA_IRQHandler+0x132c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8000e88:	6813      	ldr	r3, [r2, #0]
 8000e8a:	f013 0f02 	tst.w	r3, #2
 8000e8e:	f000 80b6 	beq.w	8000ffe <HAL_DMA_IRQHandler+0x8ee>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 8000e92:	6813      	ldr	r3, [r2, #0]
 8000e94:	f023 0302 	bic.w	r3, r3, #2
 8000e98:	6013      	str	r3, [r2, #0]
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000e9a:	6823      	ldr	r3, [r4, #0]
 8000e9c:	4a4e      	ldr	r2, [pc, #312]	; (8000fd8 <HAL_DMA_IRQHandler+0x8c8>)
 8000e9e:	4293      	cmp	r3, r2
 8000ea0:	f240 80e2 	bls.w	8001068 <HAL_DMA_IRQHandler+0x958>
 8000ea4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000ea8:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 8000eac:	4293      	cmp	r3, r2
 8000eae:	f000 8095 	beq.w	8000fdc <HAL_DMA_IRQHandler+0x8cc>
 8000eb2:	3260      	adds	r2, #96	; 0x60
 8000eb4:	4293      	cmp	r3, r2
 8000eb6:	f000 80cc 	beq.w	8001052 <HAL_DMA_IRQHandler+0x942>
 8000eba:	3a48      	subs	r2, #72	; 0x48
 8000ebc:	4293      	cmp	r3, r2
 8000ebe:	f000 80ca 	beq.w	8001056 <HAL_DMA_IRQHandler+0x946>
 8000ec2:	3260      	adds	r2, #96	; 0x60
 8000ec4:	4293      	cmp	r3, r2
 8000ec6:	f000 80c9 	beq.w	800105c <HAL_DMA_IRQHandler+0x94c>
 8000eca:	3a48      	subs	r2, #72	; 0x48
 8000ecc:	4293      	cmp	r3, r2
 8000ece:	f000 80c8 	beq.w	8001062 <HAL_DMA_IRQHandler+0x952>
 8000ed2:	3260      	adds	r2, #96	; 0x60
 8000ed4:	4293      	cmp	r3, r2
 8000ed6:	bf0c      	ite	eq
 8000ed8:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000edc:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000ee0:	e07d      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000ee2:	4b3c      	ldr	r3, [pc, #240]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000ee4:	e7cd      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000ee6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000eea:	e7ca      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000eec:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000ef0:	e7c7      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000ef2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000ef6:	e7c4      	b.n	8000e82 <HAL_DMA_IRQHandler+0x772>
 8000ef8:	4933      	ldr	r1, [pc, #204]	; (8000fc8 <HAL_DMA_IRQHandler+0x8b8>)
 8000efa:	428a      	cmp	r2, r1
 8000efc:	f67f ae9c 	bls.w	8000c38 <HAL_DMA_IRQHandler+0x528>
 8000f00:	4932      	ldr	r1, [pc, #200]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000f02:	6849      	ldr	r1, [r1, #4]
 8000f04:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000f08:	4831      	ldr	r0, [pc, #196]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000f0a:	4283      	cmp	r3, r0
 8000f0c:	d013      	beq.n	8000f36 <HAL_DMA_IRQHandler+0x826>
 8000f0e:	3060      	adds	r0, #96	; 0x60
 8000f10:	4283      	cmp	r3, r0
 8000f12:	d035      	beq.n	8000f80 <HAL_DMA_IRQHandler+0x870>
 8000f14:	3848      	subs	r0, #72	; 0x48
 8000f16:	4283      	cmp	r3, r0
 8000f18:	d034      	beq.n	8000f84 <HAL_DMA_IRQHandler+0x874>
 8000f1a:	3060      	adds	r0, #96	; 0x60
 8000f1c:	4283      	cmp	r3, r0
 8000f1e:	d034      	beq.n	8000f8a <HAL_DMA_IRQHandler+0x87a>
 8000f20:	3848      	subs	r0, #72	; 0x48
 8000f22:	4283      	cmp	r3, r0
 8000f24:	d034      	beq.n	8000f90 <HAL_DMA_IRQHandler+0x880>
 8000f26:	3060      	adds	r0, #96	; 0x60
 8000f28:	4283      	cmp	r3, r0
 8000f2a:	bf0c      	ite	eq
 8000f2c:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8000f30:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8000f34:	e000      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f36:	4b27      	ldr	r3, [pc, #156]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000f38:	420b      	tst	r3, r1
 8000f3a:	d1a5      	bne.n	8000e88 <HAL_DMA_IRQHandler+0x778>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000f3c:	6822      	ldr	r2, [r4, #0]
 8000f3e:	4611      	mov	r1, r2
 8000f40:	4b22      	ldr	r3, [pc, #136]	; (8000fcc <HAL_DMA_IRQHandler+0x8bc>)
 8000f42:	6858      	ldr	r0, [r3, #4]
 8000f44:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 8000f48:	4d21      	ldr	r5, [pc, #132]	; (8000fd0 <HAL_DMA_IRQHandler+0x8c0>)
 8000f4a:	42ab      	cmp	r3, r5
 8000f4c:	f000 8195 	beq.w	800127a <HAL_DMA_IRQHandler+0xb6a>
 8000f50:	3560      	adds	r5, #96	; 0x60
 8000f52:	42ab      	cmp	r3, r5
 8000f54:	f000 81b6 	beq.w	80012c4 <HAL_DMA_IRQHandler+0xbb4>
 8000f58:	3d48      	subs	r5, #72	; 0x48
 8000f5a:	42ab      	cmp	r3, r5
 8000f5c:	f000 81b4 	beq.w	80012c8 <HAL_DMA_IRQHandler+0xbb8>
 8000f60:	3560      	adds	r5, #96	; 0x60
 8000f62:	42ab      	cmp	r3, r5
 8000f64:	f000 81b3 	beq.w	80012ce <HAL_DMA_IRQHandler+0xbbe>
 8000f68:	3d48      	subs	r5, #72	; 0x48
 8000f6a:	42ab      	cmp	r3, r5
 8000f6c:	f000 81b2 	beq.w	80012d4 <HAL_DMA_IRQHandler+0xbc4>
 8000f70:	3560      	adds	r5, #96	; 0x60
 8000f72:	42ab      	cmp	r3, r5
 8000f74:	bf0c      	ite	eq
 8000f76:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8000f7a:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8000f7e:	e17d      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000f80:	4b14      	ldr	r3, [pc, #80]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000f82:	e7d9      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f84:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000f88:	e7d6      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f8a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000f8e:	e7d3      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f90:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000f94:	e7d0      	b.n	8000f38 <HAL_DMA_IRQHandler+0x828>
 8000f96:	4b0f      	ldr	r3, [pc, #60]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000f98:	420b      	tst	r3, r1
 8000f9a:	f47f af75 	bne.w	8000e88 <HAL_DMA_IRQHandler+0x778>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000f9e:	6822      	ldr	r2, [r4, #0]
 8000fa0:	4611      	mov	r1, r2
 8000fa2:	e14f      	b.n	8001244 <HAL_DMA_IRQHandler+0xb34>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8000fa4:	4b0b      	ldr	r3, [pc, #44]	; (8000fd4 <HAL_DMA_IRQHandler+0x8c4>)
 8000fa6:	e7f7      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fa8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000fac:	e7f4      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fae:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000fb2:	e7f1      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fb4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000fb8:	e7ee      	b.n	8000f98 <HAL_DMA_IRQHandler+0x888>
 8000fba:	bf00      	nop
 8000fbc:	400260b8 	.word	0x400260b8
 8000fc0:	00800001 	.word	0x00800001
 8000fc4:	40026400 	.word	0x40026400
 8000fc8:	40026058 	.word	0x40026058
 8000fcc:	40026000 	.word	0x40026000
 8000fd0:	40026010 	.word	0x40026010
 8000fd4:	00800004 	.word	0x00800004
 8000fd8:	40026458 	.word	0x40026458
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8000fdc:	4bbf      	ldr	r3, [pc, #764]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8000fde:	4ac0      	ldr	r2, [pc, #768]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 8000fe0:	60d3      	str	r3, [r2, #12]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8000fe2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8000fe4:	f043 0304 	orr.w	r3, r3, #4
 8000fe8:	64e3      	str	r3, [r4, #76]	; 0x4c
      hdma->State = HAL_DMA_STATE_ERROR;
 8000fea:	2304      	movs	r3, #4
 8000fec:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 8000ff0:	2300      	movs	r3, #0
 8000ff2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 8000ff6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000ff8:	b10b      	cbz	r3, 8000ffe <HAL_DMA_IRQHandler+0x8ee>
        hdma->XferErrorCallback(hdma);
 8000ffa:	4620      	mov	r0, r4
 8000ffc:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8000ffe:	6822      	ldr	r2, [r4, #0]
 8001000:	4611      	mov	r1, r2
 8001002:	4bb8      	ldr	r3, [pc, #736]	; (80012e4 <HAL_DMA_IRQHandler+0xbd4>)
 8001004:	429a      	cmp	r2, r3
 8001006:	f63f af10 	bhi.w	8000e2a <HAL_DMA_IRQHandler+0x71a>
 800100a:	4bb7      	ldr	r3, [pc, #732]	; (80012e8 <HAL_DMA_IRQHandler+0xbd8>)
 800100c:	429a      	cmp	r2, r3
 800100e:	f240 8115 	bls.w	800123c <HAL_DMA_IRQHandler+0xb2c>
 8001012:	4bb3      	ldr	r3, [pc, #716]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 8001014:	6818      	ldr	r0, [r3, #0]
 8001016:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 800101a:	4db4      	ldr	r5, [pc, #720]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800101c:	42ab      	cmp	r3, r5
 800101e:	f000 80d1 	beq.w	80011c4 <HAL_DMA_IRQHandler+0xab4>
 8001022:	3560      	adds	r5, #96	; 0x60
 8001024:	42ab      	cmp	r3, r5
 8001026:	f000 80fe 	beq.w	8001226 <HAL_DMA_IRQHandler+0xb16>
 800102a:	3d48      	subs	r5, #72	; 0x48
 800102c:	42ab      	cmp	r3, r5
 800102e:	f000 80fc 	beq.w	800122a <HAL_DMA_IRQHandler+0xb1a>
 8001032:	3560      	adds	r5, #96	; 0x60
 8001034:	42ab      	cmp	r3, r5
 8001036:	f000 80fb 	beq.w	8001230 <HAL_DMA_IRQHandler+0xb20>
 800103a:	3d48      	subs	r5, #72	; 0x48
 800103c:	42ab      	cmp	r3, r5
 800103e:	f000 80fa 	beq.w	8001236 <HAL_DMA_IRQHandler+0xb26>
 8001042:	3560      	adds	r5, #96	; 0x60
 8001044:	42ab      	cmp	r3, r5
 8001046:	bf0c      	ite	eq
 8001048:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 800104c:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001050:	e0b9      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));
 8001052:	4ba2      	ldr	r3, [pc, #648]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001054:	e7c3      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 8001056:	f44f 7380 	mov.w	r3, #256	; 0x100
 800105a:	e7c0      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 800105c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001060:	e7bd      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 8001062:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001066:	e7ba      	b.n	8000fde <HAL_DMA_IRQHandler+0x8ce>
 8001068:	4a9f      	ldr	r2, [pc, #636]	; (80012e8 <HAL_DMA_IRQHandler+0xbd8>)
 800106a:	4293      	cmp	r3, r2
 800106c:	d927      	bls.n	80010be <HAL_DMA_IRQHandler+0x9ae>
 800106e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001072:	3aa8      	subs	r2, #168	; 0xa8
 8001074:	4293      	cmp	r3, r2
 8001076:	d013      	beq.n	80010a0 <HAL_DMA_IRQHandler+0x990>
 8001078:	3260      	adds	r2, #96	; 0x60
 800107a:	4293      	cmp	r3, r2
 800107c:	d014      	beq.n	80010a8 <HAL_DMA_IRQHandler+0x998>
 800107e:	3a48      	subs	r2, #72	; 0x48
 8001080:	4293      	cmp	r3, r2
 8001082:	d013      	beq.n	80010ac <HAL_DMA_IRQHandler+0x99c>
 8001084:	3260      	adds	r2, #96	; 0x60
 8001086:	4293      	cmp	r3, r2
 8001088:	d013      	beq.n	80010b2 <HAL_DMA_IRQHandler+0x9a2>
 800108a:	3a48      	subs	r2, #72	; 0x48
 800108c:	4293      	cmp	r3, r2
 800108e:	d013      	beq.n	80010b8 <HAL_DMA_IRQHandler+0x9a8>
 8001090:	3260      	adds	r2, #96	; 0x60
 8001092:	4293      	cmp	r3, r2
 8001094:	bf0c      	ite	eq
 8001096:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 800109a:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 800109e:	e000      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010a0:	4b8e      	ldr	r3, [pc, #568]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 80010a2:	4a8f      	ldr	r2, [pc, #572]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 80010a4:	6093      	str	r3, [r2, #8]
 80010a6:	e79c      	b.n	8000fe2 <HAL_DMA_IRQHandler+0x8d2>
 80010a8:	4b8c      	ldr	r3, [pc, #560]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 80010aa:	e7fa      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010ac:	f44f 7380 	mov.w	r3, #256	; 0x100
 80010b0:	e7f7      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010b2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80010b6:	e7f4      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010b8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80010bc:	e7f1      	b.n	80010a2 <HAL_DMA_IRQHandler+0x992>
 80010be:	4a8c      	ldr	r2, [pc, #560]	; (80012f0 <HAL_DMA_IRQHandler+0xbe0>)
 80010c0:	4293      	cmp	r3, r2
 80010c2:	d927      	bls.n	8001114 <HAL_DMA_IRQHandler+0xa04>
 80010c4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80010c8:	3a48      	subs	r2, #72	; 0x48
 80010ca:	4293      	cmp	r3, r2
 80010cc:	d013      	beq.n	80010f6 <HAL_DMA_IRQHandler+0x9e6>
 80010ce:	3260      	adds	r2, #96	; 0x60
 80010d0:	4293      	cmp	r3, r2
 80010d2:	d014      	beq.n	80010fe <HAL_DMA_IRQHandler+0x9ee>
 80010d4:	3a48      	subs	r2, #72	; 0x48
 80010d6:	4293      	cmp	r3, r2
 80010d8:	d013      	beq.n	8001102 <HAL_DMA_IRQHandler+0x9f2>
 80010da:	3260      	adds	r2, #96	; 0x60
 80010dc:	4293      	cmp	r3, r2
 80010de:	d013      	beq.n	8001108 <HAL_DMA_IRQHandler+0x9f8>
 80010e0:	3a48      	subs	r2, #72	; 0x48
 80010e2:	4293      	cmp	r3, r2
 80010e4:	d013      	beq.n	800110e <HAL_DMA_IRQHandler+0x9fe>
 80010e6:	3260      	adds	r2, #96	; 0x60
 80010e8:	4293      	cmp	r3, r2
 80010ea:	bf0c      	ite	eq
 80010ec:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 80010f0:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 80010f4:	e000      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 80010f6:	4b79      	ldr	r3, [pc, #484]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 80010f8:	4a7e      	ldr	r2, [pc, #504]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 80010fa:	60d3      	str	r3, [r2, #12]
 80010fc:	e771      	b.n	8000fe2 <HAL_DMA_IRQHandler+0x8d2>
 80010fe:	4b77      	ldr	r3, [pc, #476]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001100:	e7fa      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 8001102:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001106:	e7f7      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 8001108:	f44f 7380 	mov.w	r3, #256	; 0x100
 800110c:	e7f4      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 800110e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001112:	e7f1      	b.n	80010f8 <HAL_DMA_IRQHandler+0x9e8>
 8001114:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001118:	4a74      	ldr	r2, [pc, #464]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800111a:	4293      	cmp	r3, r2
 800111c:	d013      	beq.n	8001146 <HAL_DMA_IRQHandler+0xa36>
 800111e:	3260      	adds	r2, #96	; 0x60
 8001120:	4293      	cmp	r3, r2
 8001122:	d014      	beq.n	800114e <HAL_DMA_IRQHandler+0xa3e>
 8001124:	3a48      	subs	r2, #72	; 0x48
 8001126:	4293      	cmp	r3, r2
 8001128:	d013      	beq.n	8001152 <HAL_DMA_IRQHandler+0xa42>
 800112a:	3260      	adds	r2, #96	; 0x60
 800112c:	4293      	cmp	r3, r2
 800112e:	d013      	beq.n	8001158 <HAL_DMA_IRQHandler+0xa48>
 8001130:	3a48      	subs	r2, #72	; 0x48
 8001132:	4293      	cmp	r3, r2
 8001134:	d013      	beq.n	800115e <HAL_DMA_IRQHandler+0xa4e>
 8001136:	3260      	adds	r2, #96	; 0x60
 8001138:	4293      	cmp	r3, r2
 800113a:	bf0c      	ite	eq
 800113c:	f44f 2380 	moveq.w	r3, #262144	; 0x40000
 8001140:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
 8001144:	e000      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 8001146:	4b65      	ldr	r3, [pc, #404]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001148:	4a6a      	ldr	r2, [pc, #424]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 800114a:	6093      	str	r3, [r2, #8]
 800114c:	e749      	b.n	8000fe2 <HAL_DMA_IRQHandler+0x8d2>
 800114e:	4b63      	ldr	r3, [pc, #396]	; (80012dc <HAL_DMA_IRQHandler+0xbcc>)
 8001150:	e7fa      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 8001152:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001156:	e7f7      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 8001158:	f44f 7380 	mov.w	r3, #256	; 0x100
 800115c:	e7f4      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
 800115e:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001162:	e7f1      	b.n	8001148 <HAL_DMA_IRQHandler+0xa38>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001164:	2310      	movs	r3, #16
 8001166:	4203      	tst	r3, r0
 8001168:	d130      	bne.n	80011cc <HAL_DMA_IRQHandler+0xabc>
        hdma->XferHalfCpltCallback(hdma);
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 800116a:	6822      	ldr	r2, [r4, #0]
 800116c:	4611      	mov	r1, r2
 800116e:	4b5c      	ldr	r3, [pc, #368]	; (80012e0 <HAL_DMA_IRQHandler+0xbd0>)
 8001170:	6858      	ldr	r0, [r3, #4]
 8001172:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 8001176:	4d5d      	ldr	r5, [pc, #372]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 8001178:	42ab      	cmp	r3, r5
 800117a:	f000 825c 	beq.w	8001636 <HAL_DMA_IRQHandler+0xf26>
 800117e:	3560      	adds	r5, #96	; 0x60
 8001180:	42ab      	cmp	r3, r5
 8001182:	f000 8288 	beq.w	8001696 <HAL_DMA_IRQHandler+0xf86>
 8001186:	3d48      	subs	r5, #72	; 0x48
 8001188:	42ab      	cmp	r3, r5
 800118a:	f000 8286 	beq.w	800169a <HAL_DMA_IRQHandler+0xf8a>
 800118e:	3560      	adds	r5, #96	; 0x60
 8001190:	42ab      	cmp	r3, r5
 8001192:	f000 8285 	beq.w	80016a0 <HAL_DMA_IRQHandler+0xf90>
 8001196:	3d48      	subs	r5, #72	; 0x48
 8001198:	42ab      	cmp	r3, r5
 800119a:	f000 8284 	beq.w	80016a6 <HAL_DMA_IRQHandler+0xf96>
 800119e:	3560      	adds	r5, #96	; 0x60
 80011a0:	42ab      	cmp	r3, r5
 80011a2:	bf0c      	ite	eq
 80011a4:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80011a8:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80011ac:	e244      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 80011ae:	2310      	movs	r3, #16
 80011b0:	e7d9      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80011b6:	e7d6      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011b8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80011bc:	e7d3      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011be:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80011c2:	e7d0      	b.n	8001166 <HAL_DMA_IRQHandler+0xa56>
 80011c4:	2310      	movs	r3, #16
 80011c6:	4203      	tst	r3, r0
 80011c8:	f000 843c 	beq.w	8001a44 <HAL_DMA_IRQHandler+0x1334>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80011cc:	6813      	ldr	r3, [r2, #0]
 80011ce:	f013 0f08 	tst.w	r3, #8
 80011d2:	f000 8171 	beq.w	80014b8 <HAL_DMA_IRQHandler+0xda8>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 80011d6:	6813      	ldr	r3, [r2, #0]
 80011d8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80011dc:	f000 813c 	beq.w	8001458 <HAL_DMA_IRQHandler+0xd48>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 80011e0:	4b40      	ldr	r3, [pc, #256]	; (80012e4 <HAL_DMA_IRQHandler+0xbd4>)
 80011e2:	4299      	cmp	r1, r3
 80011e4:	f240 80b2 	bls.w	800134c <HAL_DMA_IRQHandler+0xc3c>
 80011e8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80011ec:	f5a3 6389 	sub.w	r3, r3, #1096	; 0x448
 80011f0:	4299      	cmp	r1, r3
 80011f2:	f000 8093 	beq.w	800131c <HAL_DMA_IRQHandler+0xc0c>
 80011f6:	3360      	adds	r3, #96	; 0x60
 80011f8:	4299      	cmp	r1, r3
 80011fa:	f000 809c 	beq.w	8001336 <HAL_DMA_IRQHandler+0xc26>
 80011fe:	3b48      	subs	r3, #72	; 0x48
 8001200:	4299      	cmp	r1, r3
 8001202:	f000 809a 	beq.w	800133a <HAL_DMA_IRQHandler+0xc2a>
 8001206:	3360      	adds	r3, #96	; 0x60
 8001208:	4299      	cmp	r1, r3
 800120a:	f000 8099 	beq.w	8001340 <HAL_DMA_IRQHandler+0xc30>
 800120e:	3b48      	subs	r3, #72	; 0x48
 8001210:	4299      	cmp	r1, r3
 8001212:	f000 8098 	beq.w	8001346 <HAL_DMA_IRQHandler+0xc36>
 8001216:	3360      	adds	r3, #96	; 0x60
 8001218:	4299      	cmp	r1, r3
 800121a:	bf0c      	ite	eq
 800121c:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 8001220:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001224:	e07b      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001226:	2310      	movs	r3, #16
 8001228:	e7cd      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 800122a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800122e:	e7ca      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 8001230:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001234:	e7c7      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 8001236:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800123a:	e7c4      	b.n	80011c6 <HAL_DMA_IRQHandler+0xab6>
 800123c:	4b2c      	ldr	r3, [pc, #176]	; (80012f0 <HAL_DMA_IRQHandler+0xbe0>)
 800123e:	429a      	cmp	r2, r3
 8001240:	f63f ae7e 	bhi.w	8000f40 <HAL_DMA_IRQHandler+0x830>
 8001244:	4b2b      	ldr	r3, [pc, #172]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 8001246:	6818      	ldr	r0, [r3, #0]
 8001248:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 800124c:	4d27      	ldr	r5, [pc, #156]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800124e:	42ab      	cmp	r3, r5
 8001250:	d052      	beq.n	80012f8 <HAL_DMA_IRQHandler+0xbe8>
 8001252:	3560      	adds	r5, #96	; 0x60
 8001254:	42ab      	cmp	r3, r5
 8001256:	d056      	beq.n	8001306 <HAL_DMA_IRQHandler+0xbf6>
 8001258:	3d48      	subs	r5, #72	; 0x48
 800125a:	42ab      	cmp	r3, r5
 800125c:	d055      	beq.n	800130a <HAL_DMA_IRQHandler+0xbfa>
 800125e:	3560      	adds	r5, #96	; 0x60
 8001260:	42ab      	cmp	r3, r5
 8001262:	d055      	beq.n	8001310 <HAL_DMA_IRQHandler+0xc00>
 8001264:	3d48      	subs	r5, #72	; 0x48
 8001266:	42ab      	cmp	r3, r5
 8001268:	d055      	beq.n	8001316 <HAL_DMA_IRQHandler+0xc06>
 800126a:	3560      	adds	r5, #96	; 0x60
 800126c:	42ab      	cmp	r3, r5
 800126e:	bf0c      	ite	eq
 8001270:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8001274:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001278:	e03f      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 800127a:	2310      	movs	r3, #16
 800127c:	4203      	tst	r3, r0
 800127e:	d1a5      	bne.n	80011cc <HAL_DMA_IRQHandler+0xabc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001280:	6822      	ldr	r2, [r4, #0]
 8001282:	4611      	mov	r1, r2
 8001284:	4b1b      	ldr	r3, [pc, #108]	; (80012f4 <HAL_DMA_IRQHandler+0xbe4>)
 8001286:	6858      	ldr	r0, [r3, #4]
 8001288:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 800128c:	4d17      	ldr	r5, [pc, #92]	; (80012ec <HAL_DMA_IRQHandler+0xbdc>)
 800128e:	42ab      	cmp	r3, r5
 8001290:	f000 823c 	beq.w	800170c <HAL_DMA_IRQHandler+0xffc>
 8001294:	3560      	adds	r5, #96	; 0x60
 8001296:	42ab      	cmp	r3, r5
 8001298:	f000 823e 	beq.w	8001718 <HAL_DMA_IRQHandler+0x1008>
 800129c:	3d48      	subs	r5, #72	; 0x48
 800129e:	42ab      	cmp	r3, r5
 80012a0:	f000 823c 	beq.w	800171c <HAL_DMA_IRQHandler+0x100c>
 80012a4:	3560      	adds	r5, #96	; 0x60
 80012a6:	42ab      	cmp	r3, r5
 80012a8:	f000 823b 	beq.w	8001722 <HAL_DMA_IRQHandler+0x1012>
 80012ac:	3d48      	subs	r5, #72	; 0x48
 80012ae:	42ab      	cmp	r3, r5
 80012b0:	f000 823a 	beq.w	8001728 <HAL_DMA_IRQHandler+0x1018>
 80012b4:	3560      	adds	r5, #96	; 0x60
 80012b6:	42ab      	cmp	r3, r5
 80012b8:	bf0c      	ite	eq
 80012ba:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80012be:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80012c2:	e224      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 80012c4:	2310      	movs	r3, #16
 80012c6:	e7d9      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80012cc:	e7d6      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012ce:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80012d2:	e7d3      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012d4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80012d8:	e7d0      	b.n	800127c <HAL_DMA_IRQHandler+0xb6c>
 80012da:	bf00      	nop
 80012dc:	00800004 	.word	0x00800004
 80012e0:	40026400 	.word	0x40026400
 80012e4:	40026458 	.word	0x40026458
 80012e8:	400260b8 	.word	0x400260b8
 80012ec:	40026010 	.word	0x40026010
 80012f0:	40026058 	.word	0x40026058
 80012f4:	40026000 	.word	0x40026000
 80012f8:	2310      	movs	r3, #16
 80012fa:	4203      	tst	r3, r0
 80012fc:	f47f af66 	bne.w	80011cc <HAL_DMA_IRQHandler+0xabc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001300:	6822      	ldr	r2, [r4, #0]
 8001302:	4611      	mov	r1, r2
 8001304:	e1e7      	b.n	80016d6 <HAL_DMA_IRQHandler+0xfc6>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001306:	2310      	movs	r3, #16
 8001308:	e7f7      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 800130a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800130e:	e7f4      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 8001310:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001314:	e7f1      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
 8001316:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800131a:	e7ee      	b.n	80012fa <HAL_DMA_IRQHandler+0xbea>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800131c:	2110      	movs	r1, #16
 800131e:	4bba      	ldr	r3, [pc, #744]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 8001320:	60d9      	str	r1, [r3, #12]
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8001322:	6823      	ldr	r3, [r4, #0]
 8001324:	681a      	ldr	r2, [r3, #0]
 8001326:	f412 2f00 	tst.w	r2, #524288	; 0x80000
 800132a:	f040 808d 	bne.w	8001448 <HAL_DMA_IRQHandler+0xd38>
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 800132e:	2331      	movs	r3, #49	; 0x31
 8001330:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 8001334:	e0bc      	b.n	80014b0 <HAL_DMA_IRQHandler+0xda0>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001336:	2110      	movs	r1, #16
 8001338:	e7f1      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 800133a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800133e:	e7ee      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 8001340:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001344:	e7eb      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 8001346:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 800134a:	e7e8      	b.n	800131e <HAL_DMA_IRQHandler+0xc0e>
 800134c:	4baf      	ldr	r3, [pc, #700]	; (800160c <HAL_DMA_IRQHandler+0xefc>)
 800134e:	4299      	cmp	r1, r3
 8001350:	d927      	bls.n	80013a2 <HAL_DMA_IRQHandler+0xc92>
 8001352:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001356:	3ba8      	subs	r3, #168	; 0xa8
 8001358:	4299      	cmp	r1, r3
 800135a:	d013      	beq.n	8001384 <HAL_DMA_IRQHandler+0xc74>
 800135c:	3360      	adds	r3, #96	; 0x60
 800135e:	4299      	cmp	r1, r3
 8001360:	d014      	beq.n	800138c <HAL_DMA_IRQHandler+0xc7c>
 8001362:	3b48      	subs	r3, #72	; 0x48
 8001364:	4299      	cmp	r1, r3
 8001366:	d013      	beq.n	8001390 <HAL_DMA_IRQHandler+0xc80>
 8001368:	3360      	adds	r3, #96	; 0x60
 800136a:	4299      	cmp	r1, r3
 800136c:	d013      	beq.n	8001396 <HAL_DMA_IRQHandler+0xc86>
 800136e:	3b48      	subs	r3, #72	; 0x48
 8001370:	4299      	cmp	r1, r3
 8001372:	d013      	beq.n	800139c <HAL_DMA_IRQHandler+0xc8c>
 8001374:	3360      	adds	r3, #96	; 0x60
 8001376:	4299      	cmp	r1, r3
 8001378:	bf0c      	ite	eq
 800137a:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 800137e:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001382:	e000      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 8001384:	2110      	movs	r1, #16
 8001386:	4ba0      	ldr	r3, [pc, #640]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 8001388:	6099      	str	r1, [r3, #8]
 800138a:	e7ca      	b.n	8001322 <HAL_DMA_IRQHandler+0xc12>
 800138c:	2110      	movs	r1, #16
 800138e:	e7fa      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 8001390:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001394:	e7f7      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 8001396:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800139a:	e7f4      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 800139c:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 80013a0:	e7f1      	b.n	8001386 <HAL_DMA_IRQHandler+0xc76>
 80013a2:	4b9b      	ldr	r3, [pc, #620]	; (8001610 <HAL_DMA_IRQHandler+0xf00>)
 80013a4:	4299      	cmp	r1, r3
 80013a6:	d927      	bls.n	80013f8 <HAL_DMA_IRQHandler+0xce8>
 80013a8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80013ac:	3b48      	subs	r3, #72	; 0x48
 80013ae:	4299      	cmp	r1, r3
 80013b0:	d013      	beq.n	80013da <HAL_DMA_IRQHandler+0xcca>
 80013b2:	3360      	adds	r3, #96	; 0x60
 80013b4:	4299      	cmp	r1, r3
 80013b6:	d014      	beq.n	80013e2 <HAL_DMA_IRQHandler+0xcd2>
 80013b8:	3b48      	subs	r3, #72	; 0x48
 80013ba:	4299      	cmp	r1, r3
 80013bc:	d013      	beq.n	80013e6 <HAL_DMA_IRQHandler+0xcd6>
 80013be:	3360      	adds	r3, #96	; 0x60
 80013c0:	4299      	cmp	r1, r3
 80013c2:	d013      	beq.n	80013ec <HAL_DMA_IRQHandler+0xcdc>
 80013c4:	3b48      	subs	r3, #72	; 0x48
 80013c6:	4299      	cmp	r1, r3
 80013c8:	d013      	beq.n	80013f2 <HAL_DMA_IRQHandler+0xce2>
 80013ca:	3360      	adds	r3, #96	; 0x60
 80013cc:	4299      	cmp	r1, r3
 80013ce:	bf0c      	ite	eq
 80013d0:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 80013d4:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 80013d8:	e000      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013da:	2110      	movs	r1, #16
 80013dc:	4b8d      	ldr	r3, [pc, #564]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 80013de:	60d9      	str	r1, [r3, #12]
 80013e0:	e79f      	b.n	8001322 <HAL_DMA_IRQHandler+0xc12>
 80013e2:	2110      	movs	r1, #16
 80013e4:	e7fa      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013e6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013ea:	e7f7      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013ec:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80013f0:	e7f4      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013f2:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 80013f6:	e7f1      	b.n	80013dc <HAL_DMA_IRQHandler+0xccc>
 80013f8:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80013fc:	4b86      	ldr	r3, [pc, #536]	; (8001618 <HAL_DMA_IRQHandler+0xf08>)
 80013fe:	4299      	cmp	r1, r3
 8001400:	d013      	beq.n	800142a <HAL_DMA_IRQHandler+0xd1a>
 8001402:	3360      	adds	r3, #96	; 0x60
 8001404:	4299      	cmp	r1, r3
 8001406:	d014      	beq.n	8001432 <HAL_DMA_IRQHandler+0xd22>
 8001408:	3b48      	subs	r3, #72	; 0x48
 800140a:	4299      	cmp	r1, r3
 800140c:	d013      	beq.n	8001436 <HAL_DMA_IRQHandler+0xd26>
 800140e:	3360      	adds	r3, #96	; 0x60
 8001410:	4299      	cmp	r1, r3
 8001412:	d013      	beq.n	800143c <HAL_DMA_IRQHandler+0xd2c>
 8001414:	3b48      	subs	r3, #72	; 0x48
 8001416:	4299      	cmp	r1, r3
 8001418:	d013      	beq.n	8001442 <HAL_DMA_IRQHandler+0xd32>
 800141a:	3360      	adds	r3, #96	; 0x60
 800141c:	4299      	cmp	r1, r3
 800141e:	bf0c      	ite	eq
 8001420:	f44f 1180 	moveq.w	r1, #1048576	; 0x100000
 8001424:	f04f 6180 	movne.w	r1, #67108864	; 0x4000000
 8001428:	e000      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 800142a:	2110      	movs	r1, #16
 800142c:	4b79      	ldr	r3, [pc, #484]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 800142e:	6099      	str	r1, [r3, #8]
 8001430:	e777      	b.n	8001322 <HAL_DMA_IRQHandler+0xc12>
 8001432:	2110      	movs	r1, #16
 8001434:	e7fa      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 8001436:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800143a:	e7f7      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 800143c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001440:	e7f4      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
 8001442:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 8001446:	e7f1      	b.n	800142c <HAL_DMA_IRQHandler+0xd1c>
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 800144e:	d02f      	beq.n	80014b0 <HAL_DMA_IRQHandler+0xda0>
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 8001450:	2341      	movs	r3, #65	; 0x41
 8001452:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 8001456:	e02b      	b.n	80014b0 <HAL_DMA_IRQHandler+0xda0>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001458:	6813      	ldr	r3, [r2, #0]
 800145a:	f413 7f80 	tst.w	r3, #256	; 0x100
 800145e:	d103      	bne.n	8001468 <HAL_DMA_IRQHandler+0xd58>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8001460:	6813      	ldr	r3, [r2, #0]
 8001462:	f023 0308 	bic.w	r3, r3, #8
 8001466:	6013      	str	r3, [r2, #0]
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001468:	6823      	ldr	r3, [r4, #0]
 800146a:	4a6c      	ldr	r2, [pc, #432]	; (800161c <HAL_DMA_IRQHandler+0xf0c>)
 800146c:	4293      	cmp	r3, r2
 800146e:	d958      	bls.n	8001522 <HAL_DMA_IRQHandler+0xe12>
 8001470:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001474:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 8001478:	4293      	cmp	r3, r2
 800147a:	d013      	beq.n	80014a4 <HAL_DMA_IRQHandler+0xd94>
 800147c:	3260      	adds	r2, #96	; 0x60
 800147e:	4293      	cmp	r3, r2
 8001480:	d044      	beq.n	800150c <HAL_DMA_IRQHandler+0xdfc>
 8001482:	3a48      	subs	r2, #72	; 0x48
 8001484:	4293      	cmp	r3, r2
 8001486:	d043      	beq.n	8001510 <HAL_DMA_IRQHandler+0xe00>
 8001488:	3260      	adds	r2, #96	; 0x60
 800148a:	4293      	cmp	r3, r2
 800148c:	d043      	beq.n	8001516 <HAL_DMA_IRQHandler+0xe06>
 800148e:	3a48      	subs	r2, #72	; 0x48
 8001490:	4293      	cmp	r3, r2
 8001492:	d043      	beq.n	800151c <HAL_DMA_IRQHandler+0xe0c>
 8001494:	3260      	adds	r2, #96	; 0x60
 8001496:	4293      	cmp	r3, r2
 8001498:	bf0c      	ite	eq
 800149a:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 800149e:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80014a2:	e000      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 80014a4:	2310      	movs	r3, #16
 80014a6:	4a58      	ldr	r2, [pc, #352]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 80014a8:	60d3      	str	r3, [r2, #12]
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 80014aa:	2331      	movs	r3, #49	; 0x31
 80014ac:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      if(hdma->XferHalfCpltCallback != NULL)
 80014b0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80014b2:	b10b      	cbz	r3, 80014b8 <HAL_DMA_IRQHandler+0xda8>
        hdma->XferHalfCpltCallback(hdma);
 80014b4:	4620      	mov	r0, r4
 80014b6:	4798      	blx	r3
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 80014b8:	6822      	ldr	r2, [r4, #0]
 80014ba:	4611      	mov	r1, r2
 80014bc:	4b57      	ldr	r3, [pc, #348]	; (800161c <HAL_DMA_IRQHandler+0xf0c>)
 80014be:	429a      	cmp	r2, r3
 80014c0:	f63f ae55 	bhi.w	800116e <HAL_DMA_IRQHandler+0xa5e>
 80014c4:	4b51      	ldr	r3, [pc, #324]	; (800160c <HAL_DMA_IRQHandler+0xefc>)
 80014c6:	429a      	cmp	r2, r3
 80014c8:	f240 8101 	bls.w	80016ce <HAL_DMA_IRQHandler+0xfbe>
 80014cc:	4b4e      	ldr	r3, [pc, #312]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 80014ce:	6818      	ldr	r0, [r3, #0]
 80014d0:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 80014d4:	4d50      	ldr	r5, [pc, #320]	; (8001618 <HAL_DMA_IRQHandler+0xf08>)
 80014d6:	42ab      	cmp	r3, r5
 80014d8:	f000 80e8 	beq.w	80016ac <HAL_DMA_IRQHandler+0xf9c>
 80014dc:	3560      	adds	r5, #96	; 0x60
 80014de:	42ab      	cmp	r3, r5
 80014e0:	f000 80ea 	beq.w	80016b8 <HAL_DMA_IRQHandler+0xfa8>
 80014e4:	3d48      	subs	r5, #72	; 0x48
 80014e6:	42ab      	cmp	r3, r5
 80014e8:	f000 80e8 	beq.w	80016bc <HAL_DMA_IRQHandler+0xfac>
 80014ec:	3560      	adds	r5, #96	; 0x60
 80014ee:	42ab      	cmp	r3, r5
 80014f0:	f000 80e7 	beq.w	80016c2 <HAL_DMA_IRQHandler+0xfb2>
 80014f4:	3d48      	subs	r5, #72	; 0x48
 80014f6:	42ab      	cmp	r3, r5
 80014f8:	f000 80e6 	beq.w	80016c8 <HAL_DMA_IRQHandler+0xfb8>
 80014fc:	3560      	adds	r5, #96	; 0x60
 80014fe:	42ab      	cmp	r3, r5
 8001500:	bf0c      	ite	eq
 8001502:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001506:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800150a:	e0d0      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800150c:	2310      	movs	r3, #16
 800150e:	e7ca      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 8001510:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001514:	e7c7      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 8001516:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800151a:	e7c4      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 800151c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001520:	e7c1      	b.n	80014a6 <HAL_DMA_IRQHandler+0xd96>
 8001522:	4a3a      	ldr	r2, [pc, #232]	; (800160c <HAL_DMA_IRQHandler+0xefc>)
 8001524:	4293      	cmp	r3, r2
 8001526:	d927      	bls.n	8001578 <HAL_DMA_IRQHandler+0xe68>
 8001528:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800152c:	3aa8      	subs	r2, #168	; 0xa8
 800152e:	4293      	cmp	r3, r2
 8001530:	d013      	beq.n	800155a <HAL_DMA_IRQHandler+0xe4a>
 8001532:	3260      	adds	r2, #96	; 0x60
 8001534:	4293      	cmp	r3, r2
 8001536:	d014      	beq.n	8001562 <HAL_DMA_IRQHandler+0xe52>
 8001538:	3a48      	subs	r2, #72	; 0x48
 800153a:	4293      	cmp	r3, r2
 800153c:	d013      	beq.n	8001566 <HAL_DMA_IRQHandler+0xe56>
 800153e:	3260      	adds	r2, #96	; 0x60
 8001540:	4293      	cmp	r3, r2
 8001542:	d013      	beq.n	800156c <HAL_DMA_IRQHandler+0xe5c>
 8001544:	3a48      	subs	r2, #72	; 0x48
 8001546:	4293      	cmp	r3, r2
 8001548:	d013      	beq.n	8001572 <HAL_DMA_IRQHandler+0xe62>
 800154a:	3260      	adds	r2, #96	; 0x60
 800154c:	4293      	cmp	r3, r2
 800154e:	bf0c      	ite	eq
 8001550:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8001554:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001558:	e000      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 800155a:	2310      	movs	r3, #16
 800155c:	4a2a      	ldr	r2, [pc, #168]	; (8001608 <HAL_DMA_IRQHandler+0xef8>)
 800155e:	6093      	str	r3, [r2, #8]
 8001560:	e7a3      	b.n	80014aa <HAL_DMA_IRQHandler+0xd9a>
 8001562:	2310      	movs	r3, #16
 8001564:	e7fa      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 8001566:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800156a:	e7f7      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 800156c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001570:	e7f4      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 8001572:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001576:	e7f1      	b.n	800155c <HAL_DMA_IRQHandler+0xe4c>
 8001578:	4a25      	ldr	r2, [pc, #148]	; (8001610 <HAL_DMA_IRQHandler+0xf00>)
 800157a:	4293      	cmp	r3, r2
 800157c:	d927      	bls.n	80015ce <HAL_DMA_IRQHandler+0xebe>
 800157e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001582:	3a48      	subs	r2, #72	; 0x48
 8001584:	4293      	cmp	r3, r2
 8001586:	d013      	beq.n	80015b0 <HAL_DMA_IRQHandler+0xea0>
 8001588:	3260      	adds	r2, #96	; 0x60
 800158a:	4293      	cmp	r3, r2
 800158c:	d014      	beq.n	80015b8 <HAL_DMA_IRQHandler+0xea8>
 800158e:	3a48      	subs	r2, #72	; 0x48
 8001590:	4293      	cmp	r3, r2
 8001592:	d013      	beq.n	80015bc <HAL_DMA_IRQHandler+0xeac>
 8001594:	3260      	adds	r2, #96	; 0x60
 8001596:	4293      	cmp	r3, r2
 8001598:	d013      	beq.n	80015c2 <HAL_DMA_IRQHandler+0xeb2>
 800159a:	3a48      	subs	r2, #72	; 0x48
 800159c:	4293      	cmp	r3, r2
 800159e:	d013      	beq.n	80015c8 <HAL_DMA_IRQHandler+0xeb8>
 80015a0:	3260      	adds	r2, #96	; 0x60
 80015a2:	4293      	cmp	r3, r2
 80015a4:	bf0c      	ite	eq
 80015a6:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 80015aa:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80015ae:	e000      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015b0:	2310      	movs	r3, #16
 80015b2:	4a18      	ldr	r2, [pc, #96]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 80015b4:	60d3      	str	r3, [r2, #12]
 80015b6:	e778      	b.n	80014aa <HAL_DMA_IRQHandler+0xd9a>
 80015b8:	2310      	movs	r3, #16
 80015ba:	e7fa      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80015c0:	e7f7      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015c2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80015c6:	e7f4      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80015cc:	e7f1      	b.n	80015b2 <HAL_DMA_IRQHandler+0xea2>
 80015ce:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80015d2:	4a11      	ldr	r2, [pc, #68]	; (8001618 <HAL_DMA_IRQHandler+0xf08>)
 80015d4:	4293      	cmp	r3, r2
 80015d6:	d013      	beq.n	8001600 <HAL_DMA_IRQHandler+0xef0>
 80015d8:	3260      	adds	r2, #96	; 0x60
 80015da:	4293      	cmp	r3, r2
 80015dc:	d020      	beq.n	8001620 <HAL_DMA_IRQHandler+0xf10>
 80015de:	3a48      	subs	r2, #72	; 0x48
 80015e0:	4293      	cmp	r3, r2
 80015e2:	d01f      	beq.n	8001624 <HAL_DMA_IRQHandler+0xf14>
 80015e4:	3260      	adds	r2, #96	; 0x60
 80015e6:	4293      	cmp	r3, r2
 80015e8:	d01f      	beq.n	800162a <HAL_DMA_IRQHandler+0xf1a>
 80015ea:	3a48      	subs	r2, #72	; 0x48
 80015ec:	4293      	cmp	r3, r2
 80015ee:	d01f      	beq.n	8001630 <HAL_DMA_IRQHandler+0xf20>
 80015f0:	3260      	adds	r2, #96	; 0x60
 80015f2:	4293      	cmp	r3, r2
 80015f4:	bf0c      	ite	eq
 80015f6:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 80015fa:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 80015fe:	e000      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 8001600:	2310      	movs	r3, #16
 8001602:	4a04      	ldr	r2, [pc, #16]	; (8001614 <HAL_DMA_IRQHandler+0xf04>)
 8001604:	6093      	str	r3, [r2, #8]
 8001606:	e750      	b.n	80014aa <HAL_DMA_IRQHandler+0xd9a>
 8001608:	40026400 	.word	0x40026400
 800160c:	400260b8 	.word	0x400260b8
 8001610:	40026058 	.word	0x40026058
 8001614:	40026000 	.word	0x40026000
 8001618:	40026010 	.word	0x40026010
 800161c:	40026458 	.word	0x40026458
 8001620:	2310      	movs	r3, #16
 8001622:	e7ee      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 8001624:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001628:	e7eb      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 800162a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800162e:	e7e8      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
 8001630:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8001634:	e7e5      	b.n	8001602 <HAL_DMA_IRQHandler+0xef2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001636:	2320      	movs	r3, #32
 8001638:	4203      	tst	r3, r0
 800163a:	bf14      	ite	ne
 800163c:	2301      	movne	r3, #1
 800163e:	2300      	moveq	r3, #0
 8001640:	2b00      	cmp	r3, #0
 8001642:	f000 8221 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8001646:	6813      	ldr	r3, [r2, #0]
 8001648:	f013 0f10 	tst.w	r3, #16
 800164c:	f000 821c 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0)
 8001650:	6813      	ldr	r3, [r2, #0]
 8001652:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8001656:	f000 8120 	beq.w	800189a <HAL_DMA_IRQHandler+0x118a>
      {
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800165a:	4bb1      	ldr	r3, [pc, #708]	; (8001920 <HAL_DMA_IRQHandler+0x1210>)
 800165c:	4299      	cmp	r1, r3
 800165e:	f240 8092 	bls.w	8001786 <HAL_DMA_IRQHandler+0x1076>
 8001662:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001666:	f5a3 6389 	sub.w	r3, r3, #1096	; 0x448
 800166a:	4299      	cmp	r1, r3
 800166c:	d070      	beq.n	8001750 <HAL_DMA_IRQHandler+0x1040>
 800166e:	3360      	adds	r3, #96	; 0x60
 8001670:	4299      	cmp	r1, r3
 8001672:	d07d      	beq.n	8001770 <HAL_DMA_IRQHandler+0x1060>
 8001674:	3b48      	subs	r3, #72	; 0x48
 8001676:	4299      	cmp	r1, r3
 8001678:	d07c      	beq.n	8001774 <HAL_DMA_IRQHandler+0x1064>
 800167a:	3360      	adds	r3, #96	; 0x60
 800167c:	4299      	cmp	r1, r3
 800167e:	d07c      	beq.n	800177a <HAL_DMA_IRQHandler+0x106a>
 8001680:	3b48      	subs	r3, #72	; 0x48
 8001682:	4299      	cmp	r1, r3
 8001684:	d07c      	beq.n	8001780 <HAL_DMA_IRQHandler+0x1070>
 8001686:	3360      	adds	r3, #96	; 0x60
 8001688:	4299      	cmp	r1, r3
 800168a:	bf0c      	ite	eq
 800168c:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8001690:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8001694:	e05d      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001696:	2320      	movs	r3, #32
 8001698:	e7ce      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 800169a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800169e:	e7cb      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 80016a0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016a4:	e7c8      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 80016a6:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80016aa:	e7c5      	b.n	8001638 <HAL_DMA_IRQHandler+0xf28>
 80016ac:	2320      	movs	r3, #32
 80016ae:	4203      	tst	r3, r0
 80016b0:	bf14      	ite	ne
 80016b2:	2301      	movne	r3, #1
 80016b4:	2300      	moveq	r3, #0
 80016b6:	e7c3      	b.n	8001640 <HAL_DMA_IRQHandler+0xf30>
 80016b8:	2320      	movs	r3, #32
 80016ba:	e7f8      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016c0:	e7f5      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016c2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80016c6:	e7f2      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016c8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80016cc:	e7ef      	b.n	80016ae <HAL_DMA_IRQHandler+0xf9e>
 80016ce:	4b95      	ldr	r3, [pc, #596]	; (8001924 <HAL_DMA_IRQHandler+0x1214>)
 80016d0:	429a      	cmp	r2, r3
 80016d2:	f63f add7 	bhi.w	8001284 <HAL_DMA_IRQHandler+0xb74>
 80016d6:	4b94      	ldr	r3, [pc, #592]	; (8001928 <HAL_DMA_IRQHandler+0x1218>)
 80016d8:	6818      	ldr	r0, [r3, #0]
 80016da:	f421 6380 	bic.w	r3, r1, #1024	; 0x400
 80016de:	4d93      	ldr	r5, [pc, #588]	; (800192c <HAL_DMA_IRQHandler+0x121c>)
 80016e0:	42ab      	cmp	r3, r5
 80016e2:	d024      	beq.n	800172e <HAL_DMA_IRQHandler+0x101e>
 80016e4:	3560      	adds	r5, #96	; 0x60
 80016e6:	42ab      	cmp	r3, r5
 80016e8:	d027      	beq.n	800173a <HAL_DMA_IRQHandler+0x102a>
 80016ea:	3d48      	subs	r5, #72	; 0x48
 80016ec:	42ab      	cmp	r3, r5
 80016ee:	d026      	beq.n	800173e <HAL_DMA_IRQHandler+0x102e>
 80016f0:	3560      	adds	r5, #96	; 0x60
 80016f2:	42ab      	cmp	r3, r5
 80016f4:	d026      	beq.n	8001744 <HAL_DMA_IRQHandler+0x1034>
 80016f6:	3d48      	subs	r5, #72	; 0x48
 80016f8:	42ab      	cmp	r3, r5
 80016fa:	d026      	beq.n	800174a <HAL_DMA_IRQHandler+0x103a>
 80016fc:	3560      	adds	r5, #96	; 0x60
 80016fe:	42ab      	cmp	r3, r5
 8001700:	bf0c      	ite	eq
 8001702:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001706:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800170a:	e011      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 800170c:	2320      	movs	r3, #32
 800170e:	4203      	tst	r3, r0
 8001710:	bf14      	ite	ne
 8001712:	2301      	movne	r3, #1
 8001714:	2300      	moveq	r3, #0
 8001716:	e793      	b.n	8001640 <HAL_DMA_IRQHandler+0xf30>
 8001718:	2320      	movs	r3, #32
 800171a:	e7f8      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 800171c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001720:	e7f5      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 8001722:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001726:	e7f2      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 8001728:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800172c:	e7ef      	b.n	800170e <HAL_DMA_IRQHandler+0xffe>
 800172e:	2320      	movs	r3, #32
 8001730:	4203      	tst	r3, r0
 8001732:	bf14      	ite	ne
 8001734:	2301      	movne	r3, #1
 8001736:	2300      	moveq	r3, #0
 8001738:	e782      	b.n	8001640 <HAL_DMA_IRQHandler+0xf30>
 800173a:	2320      	movs	r3, #32
 800173c:	e7f8      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 800173e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001742:	e7f5      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 8001744:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001748:	e7f2      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
 800174a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800174e:	e7ef      	b.n	8001730 <HAL_DMA_IRQHandler+0x1020>
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001750:	2120      	movs	r1, #32
 8001752:	4b77      	ldr	r3, [pc, #476]	; (8001930 <HAL_DMA_IRQHandler+0x1220>)
 8001754:	60d9      	str	r1, [r3, #12]

        /* Current memory buffer used is Memory 1 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0)
 8001756:	6823      	ldr	r3, [r4, #0]
 8001758:	681a      	ldr	r2, [r3, #0]
 800175a:	f412 2f00 	tst.w	r2, #524288	; 0x80000
 800175e:	f040 8090 	bne.w	8001882 <HAL_DMA_IRQHandler+0x1172>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8001762:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001764:	2b00      	cmp	r3, #0
 8001766:	f000 818f 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 800176a:	4620      	mov	r0, r4
 800176c:	4798      	blx	r3
 800176e:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001770:	2120      	movs	r1, #32
 8001772:	e7ee      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 8001774:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001778:	e7eb      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 800177a:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800177e:	e7e8      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 8001780:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001784:	e7e5      	b.n	8001752 <HAL_DMA_IRQHandler+0x1042>
 8001786:	4b6b      	ldr	r3, [pc, #428]	; (8001934 <HAL_DMA_IRQHandler+0x1224>)
 8001788:	4299      	cmp	r1, r3
 800178a:	d927      	bls.n	80017dc <HAL_DMA_IRQHandler+0x10cc>
 800178c:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001790:	3ba8      	subs	r3, #168	; 0xa8
 8001792:	4299      	cmp	r1, r3
 8001794:	d013      	beq.n	80017be <HAL_DMA_IRQHandler+0x10ae>
 8001796:	3360      	adds	r3, #96	; 0x60
 8001798:	4299      	cmp	r1, r3
 800179a:	d014      	beq.n	80017c6 <HAL_DMA_IRQHandler+0x10b6>
 800179c:	3b48      	subs	r3, #72	; 0x48
 800179e:	4299      	cmp	r1, r3
 80017a0:	d013      	beq.n	80017ca <HAL_DMA_IRQHandler+0x10ba>
 80017a2:	3360      	adds	r3, #96	; 0x60
 80017a4:	4299      	cmp	r1, r3
 80017a6:	d013      	beq.n	80017d0 <HAL_DMA_IRQHandler+0x10c0>
 80017a8:	3b48      	subs	r3, #72	; 0x48
 80017aa:	4299      	cmp	r1, r3
 80017ac:	d013      	beq.n	80017d6 <HAL_DMA_IRQHandler+0x10c6>
 80017ae:	3360      	adds	r3, #96	; 0x60
 80017b0:	4299      	cmp	r1, r3
 80017b2:	bf0c      	ite	eq
 80017b4:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 80017b8:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 80017bc:	e000      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017be:	2120      	movs	r1, #32
 80017c0:	4b5b      	ldr	r3, [pc, #364]	; (8001930 <HAL_DMA_IRQHandler+0x1220>)
 80017c2:	6099      	str	r1, [r3, #8]
 80017c4:	e7c7      	b.n	8001756 <HAL_DMA_IRQHandler+0x1046>
 80017c6:	2120      	movs	r1, #32
 80017c8:	e7fa      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017ca:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017ce:	e7f7      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017d0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80017d4:	e7f4      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017d6:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80017da:	e7f1      	b.n	80017c0 <HAL_DMA_IRQHandler+0x10b0>
 80017dc:	4b51      	ldr	r3, [pc, #324]	; (8001924 <HAL_DMA_IRQHandler+0x1214>)
 80017de:	4299      	cmp	r1, r3
 80017e0:	d927      	bls.n	8001832 <HAL_DMA_IRQHandler+0x1122>
 80017e2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80017e6:	3b48      	subs	r3, #72	; 0x48
 80017e8:	4299      	cmp	r1, r3
 80017ea:	d013      	beq.n	8001814 <HAL_DMA_IRQHandler+0x1104>
 80017ec:	3360      	adds	r3, #96	; 0x60
 80017ee:	4299      	cmp	r1, r3
 80017f0:	d014      	beq.n	800181c <HAL_DMA_IRQHandler+0x110c>
 80017f2:	3b48      	subs	r3, #72	; 0x48
 80017f4:	4299      	cmp	r1, r3
 80017f6:	d013      	beq.n	8001820 <HAL_DMA_IRQHandler+0x1110>
 80017f8:	3360      	adds	r3, #96	; 0x60
 80017fa:	4299      	cmp	r1, r3
 80017fc:	d013      	beq.n	8001826 <HAL_DMA_IRQHandler+0x1116>
 80017fe:	3b48      	subs	r3, #72	; 0x48
 8001800:	4299      	cmp	r1, r3
 8001802:	d013      	beq.n	800182c <HAL_DMA_IRQHandler+0x111c>
 8001804:	3360      	adds	r3, #96	; 0x60
 8001806:	4299      	cmp	r1, r3
 8001808:	bf0c      	ite	eq
 800180a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 800180e:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8001812:	e000      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001814:	2120      	movs	r1, #32
 8001816:	4b44      	ldr	r3, [pc, #272]	; (8001928 <HAL_DMA_IRQHandler+0x1218>)
 8001818:	60d9      	str	r1, [r3, #12]
 800181a:	e79c      	b.n	8001756 <HAL_DMA_IRQHandler+0x1046>
 800181c:	2120      	movs	r1, #32
 800181e:	e7fa      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001820:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001824:	e7f7      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001826:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800182a:	e7f4      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 800182c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001830:	e7f1      	b.n	8001816 <HAL_DMA_IRQHandler+0x1106>
 8001832:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001836:	4b3d      	ldr	r3, [pc, #244]	; (800192c <HAL_DMA_IRQHandler+0x121c>)
 8001838:	4299      	cmp	r1, r3
 800183a:	d013      	beq.n	8001864 <HAL_DMA_IRQHandler+0x1154>
 800183c:	3360      	adds	r3, #96	; 0x60
 800183e:	4299      	cmp	r1, r3
 8001840:	d014      	beq.n	800186c <HAL_DMA_IRQHandler+0x115c>
 8001842:	3b48      	subs	r3, #72	; 0x48
 8001844:	4299      	cmp	r1, r3
 8001846:	d013      	beq.n	8001870 <HAL_DMA_IRQHandler+0x1160>
 8001848:	3360      	adds	r3, #96	; 0x60
 800184a:	4299      	cmp	r1, r3
 800184c:	d013      	beq.n	8001876 <HAL_DMA_IRQHandler+0x1166>
 800184e:	3b48      	subs	r3, #72	; 0x48
 8001850:	4299      	cmp	r1, r3
 8001852:	d013      	beq.n	800187c <HAL_DMA_IRQHandler+0x116c>
 8001854:	3360      	adds	r3, #96	; 0x60
 8001856:	4299      	cmp	r1, r3
 8001858:	bf0c      	ite	eq
 800185a:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 800185e:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 8001862:	e000      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 8001864:	2120      	movs	r1, #32
 8001866:	4b30      	ldr	r3, [pc, #192]	; (8001928 <HAL_DMA_IRQHandler+0x1218>)
 8001868:	6099      	str	r1, [r3, #8]
 800186a:	e774      	b.n	8001756 <HAL_DMA_IRQHandler+0x1046>
 800186c:	2120      	movs	r1, #32
 800186e:	e7fa      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 8001870:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001874:	e7f7      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 8001876:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800187a:	e7f4      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
 800187c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8001880:	e7f1      	b.n	8001866 <HAL_DMA_IRQHandler+0x1156>
          }
        }
        /* Current memory buffer used is Memory 0 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0)
 8001882:	681b      	ldr	r3, [r3, #0]
 8001884:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8001888:	f000 80fe 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
        {
          if(hdma->XferCpltCallback != NULL)
 800188c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800188e:	2b00      	cmp	r3, #0
 8001890:	f000 80fa 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8001894:	4620      	mov	r0, r4
 8001896:	4798      	blx	r3
 8001898:	bd38      	pop	{r3, r4, r5, pc}
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 800189a:	6813      	ldr	r3, [r2, #0]
 800189c:	f413 7f80 	tst.w	r3, #256	; 0x100
 80018a0:	d103      	bne.n	80018aa <HAL_DMA_IRQHandler+0x119a>
        {
          /* Disable the transfer complete interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 80018a2:	6813      	ldr	r3, [r2, #0]
 80018a4:	f023 0310 	bic.w	r3, r3, #16
 80018a8:	6013      	str	r3, [r2, #0]
        }
        /* Clear the transfer complete flag */
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80018aa:	6823      	ldr	r3, [r4, #0]
 80018ac:	4a1c      	ldr	r2, [pc, #112]	; (8001920 <HAL_DMA_IRQHandler+0x1210>)
 80018ae:	4293      	cmp	r3, r2
 80018b0:	d942      	bls.n	8001938 <HAL_DMA_IRQHandler+0x1228>
 80018b2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80018b6:	f5a2 6289 	sub.w	r2, r2, #1096	; 0x448
 80018ba:	4293      	cmp	r3, r2
 80018bc:	d013      	beq.n	80018e6 <HAL_DMA_IRQHandler+0x11d6>
 80018be:	3260      	adds	r2, #96	; 0x60
 80018c0:	4293      	cmp	r3, r2
 80018c2:	d022      	beq.n	800190a <HAL_DMA_IRQHandler+0x11fa>
 80018c4:	3a48      	subs	r2, #72	; 0x48
 80018c6:	4293      	cmp	r3, r2
 80018c8:	d021      	beq.n	800190e <HAL_DMA_IRQHandler+0x11fe>
 80018ca:	3260      	adds	r2, #96	; 0x60
 80018cc:	4293      	cmp	r3, r2
 80018ce:	d021      	beq.n	8001914 <HAL_DMA_IRQHandler+0x1204>
 80018d0:	3a48      	subs	r2, #72	; 0x48
 80018d2:	4293      	cmp	r3, r2
 80018d4:	d021      	beq.n	800191a <HAL_DMA_IRQHandler+0x120a>
 80018d6:	3260      	adds	r2, #96	; 0x60
 80018d8:	4293      	cmp	r3, r2
 80018da:	bf0c      	ite	eq
 80018dc:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80018e0:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80018e4:	e000      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 80018e6:	2320      	movs	r3, #32
 80018e8:	4a11      	ldr	r2, [pc, #68]	; (8001930 <HAL_DMA_IRQHandler+0x1220>)
 80018ea:	60d3      	str	r3, [r2, #12]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 80018ec:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80018ee:	64e3      	str	r3, [r4, #76]	; 0x4c

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 80018f0:	2311      	movs	r3, #17
 80018f2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80018f6:	2300      	movs	r3, #0
 80018f8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

        if(hdma->XferCpltCallback != NULL)
 80018fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80018fe:	2b00      	cmp	r3, #0
 8001900:	f000 80c2 	beq.w	8001a88 <HAL_DMA_IRQHandler+0x1378>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8001904:	4620      	mov	r0, r4
 8001906:	4798      	blx	r3
        }
      }
    }
  }
}
 8001908:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 800190a:	2320      	movs	r3, #32
 800190c:	e7ec      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 800190e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001912:	e7e9      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 8001914:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001918:	e7e6      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 800191a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800191e:	e7e3      	b.n	80018e8 <HAL_DMA_IRQHandler+0x11d8>
 8001920:	40026458 	.word	0x40026458
 8001924:	40026058 	.word	0x40026058
 8001928:	40026000 	.word	0x40026000
 800192c:	40026010 	.word	0x40026010
 8001930:	40026400 	.word	0x40026400
 8001934:	400260b8 	.word	0x400260b8
 8001938:	4a54      	ldr	r2, [pc, #336]	; (8001a8c <HAL_DMA_IRQHandler+0x137c>)
 800193a:	4293      	cmp	r3, r2
 800193c:	d927      	bls.n	800198e <HAL_DMA_IRQHandler+0x127e>
 800193e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001942:	3aa8      	subs	r2, #168	; 0xa8
 8001944:	4293      	cmp	r3, r2
 8001946:	d013      	beq.n	8001970 <HAL_DMA_IRQHandler+0x1260>
 8001948:	3260      	adds	r2, #96	; 0x60
 800194a:	4293      	cmp	r3, r2
 800194c:	d014      	beq.n	8001978 <HAL_DMA_IRQHandler+0x1268>
 800194e:	3a48      	subs	r2, #72	; 0x48
 8001950:	4293      	cmp	r3, r2
 8001952:	d013      	beq.n	800197c <HAL_DMA_IRQHandler+0x126c>
 8001954:	3260      	adds	r2, #96	; 0x60
 8001956:	4293      	cmp	r3, r2
 8001958:	d013      	beq.n	8001982 <HAL_DMA_IRQHandler+0x1272>
 800195a:	3a48      	subs	r2, #72	; 0x48
 800195c:	4293      	cmp	r3, r2
 800195e:	d013      	beq.n	8001988 <HAL_DMA_IRQHandler+0x1278>
 8001960:	3260      	adds	r2, #96	; 0x60
 8001962:	4293      	cmp	r3, r2
 8001964:	bf0c      	ite	eq
 8001966:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 800196a:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 800196e:	e000      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 8001970:	2320      	movs	r3, #32
 8001972:	4a47      	ldr	r2, [pc, #284]	; (8001a90 <HAL_DMA_IRQHandler+0x1380>)
 8001974:	6093      	str	r3, [r2, #8]
 8001976:	e7b9      	b.n	80018ec <HAL_DMA_IRQHandler+0x11dc>
 8001978:	2320      	movs	r3, #32
 800197a:	e7fa      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 800197c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001980:	e7f7      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 8001982:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001986:	e7f4      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 8001988:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800198c:	e7f1      	b.n	8001972 <HAL_DMA_IRQHandler+0x1262>
 800198e:	4a41      	ldr	r2, [pc, #260]	; (8001a94 <HAL_DMA_IRQHandler+0x1384>)
 8001990:	4293      	cmp	r3, r2
 8001992:	d927      	bls.n	80019e4 <HAL_DMA_IRQHandler+0x12d4>
 8001994:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001998:	3a48      	subs	r2, #72	; 0x48
 800199a:	4293      	cmp	r3, r2
 800199c:	d013      	beq.n	80019c6 <HAL_DMA_IRQHandler+0x12b6>
 800199e:	3260      	adds	r2, #96	; 0x60
 80019a0:	4293      	cmp	r3, r2
 80019a2:	d014      	beq.n	80019ce <HAL_DMA_IRQHandler+0x12be>
 80019a4:	3a48      	subs	r2, #72	; 0x48
 80019a6:	4293      	cmp	r3, r2
 80019a8:	d013      	beq.n	80019d2 <HAL_DMA_IRQHandler+0x12c2>
 80019aa:	3260      	adds	r2, #96	; 0x60
 80019ac:	4293      	cmp	r3, r2
 80019ae:	d013      	beq.n	80019d8 <HAL_DMA_IRQHandler+0x12c8>
 80019b0:	3a48      	subs	r2, #72	; 0x48
 80019b2:	4293      	cmp	r3, r2
 80019b4:	d013      	beq.n	80019de <HAL_DMA_IRQHandler+0x12ce>
 80019b6:	3260      	adds	r2, #96	; 0x60
 80019b8:	4293      	cmp	r3, r2
 80019ba:	bf0c      	ite	eq
 80019bc:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 80019c0:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 80019c4:	e000      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019c6:	2320      	movs	r3, #32
 80019c8:	4a33      	ldr	r2, [pc, #204]	; (8001a98 <HAL_DMA_IRQHandler+0x1388>)
 80019ca:	60d3      	str	r3, [r2, #12]
 80019cc:	e78e      	b.n	80018ec <HAL_DMA_IRQHandler+0x11dc>
 80019ce:	2320      	movs	r3, #32
 80019d0:	e7fa      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019d2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80019d6:	e7f7      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019d8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80019dc:	e7f4      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019de:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80019e2:	e7f1      	b.n	80019c8 <HAL_DMA_IRQHandler+0x12b8>
 80019e4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80019e8:	4a2c      	ldr	r2, [pc, #176]	; (8001a9c <HAL_DMA_IRQHandler+0x138c>)
 80019ea:	4293      	cmp	r3, r2
 80019ec:	d013      	beq.n	8001a16 <HAL_DMA_IRQHandler+0x1306>
 80019ee:	3260      	adds	r2, #96	; 0x60
 80019f0:	4293      	cmp	r3, r2
 80019f2:	d014      	beq.n	8001a1e <HAL_DMA_IRQHandler+0x130e>
 80019f4:	3a48      	subs	r2, #72	; 0x48
 80019f6:	4293      	cmp	r3, r2
 80019f8:	d013      	beq.n	8001a22 <HAL_DMA_IRQHandler+0x1312>
 80019fa:	3260      	adds	r2, #96	; 0x60
 80019fc:	4293      	cmp	r3, r2
 80019fe:	d013      	beq.n	8001a28 <HAL_DMA_IRQHandler+0x1318>
 8001a00:	3a48      	subs	r2, #72	; 0x48
 8001a02:	4293      	cmp	r3, r2
 8001a04:	d013      	beq.n	8001a2e <HAL_DMA_IRQHandler+0x131e>
 8001a06:	3260      	adds	r2, #96	; 0x60
 8001a08:	4293      	cmp	r3, r2
 8001a0a:	bf0c      	ite	eq
 8001a0c:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001a10:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001a14:	e000      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a16:	2320      	movs	r3, #32
 8001a18:	4a1f      	ldr	r2, [pc, #124]	; (8001a98 <HAL_DMA_IRQHandler+0x1388>)
 8001a1a:	6093      	str	r3, [r2, #8]
 8001a1c:	e766      	b.n	80018ec <HAL_DMA_IRQHandler+0x11dc>
 8001a1e:	2320      	movs	r3, #32
 8001a20:	e7fa      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a22:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001a26:	e7f7      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a28:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001a2c:	e7f4      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
 8001a2e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8001a32:	e7f1      	b.n	8001a18 <HAL_DMA_IRQHandler+0x1308>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma)) != RESET)
 8001a34:	6822      	ldr	r2, [r4, #0]
 8001a36:	4613      	mov	r3, r2
 8001a38:	f7ff b942 	b.w	8000cc0 <HAL_DMA_IRQHandler+0x5b0>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8001a3c:	6822      	ldr	r2, [r4, #0]
 8001a3e:	4611      	mov	r1, r2
 8001a40:	f7ff bae7 	b.w	8001012 <HAL_DMA_IRQHandler+0x902>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8001a44:	6822      	ldr	r2, [r4, #0]
 8001a46:	4611      	mov	r1, r2
 8001a48:	e540      	b.n	80014cc <HAL_DMA_IRQHandler+0xdbc>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a4a:	6821      	ldr	r1, [r4, #0]
 8001a4c:	460b      	mov	r3, r1
 8001a4e:	f7fe bfbd 	b.w	80009cc <HAL_DMA_IRQHandler+0x2bc>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001a52:	680b      	ldr	r3, [r1, #0]
 8001a54:	f013 0f04 	tst.w	r3, #4
 8001a58:	f47e aed3 	bne.w	8000802 <HAL_DMA_IRQHandler+0xf2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a5c:	6821      	ldr	r1, [r4, #0]
 8001a5e:	460b      	mov	r3, r1
 8001a60:	f7fe bf24 	b.w	80008ac <HAL_DMA_IRQHandler+0x19c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001a64:	680b      	ldr	r3, [r1, #0]
 8001a66:	f013 0f04 	tst.w	r3, #4
 8001a6a:	f47e aeca 	bne.w	8000802 <HAL_DMA_IRQHandler+0xf2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a6e:	6821      	ldr	r1, [r4, #0]
 8001a70:	460b      	mov	r3, r1
 8001a72:	f7fe bf65 	b.w	8000940 <HAL_DMA_IRQHandler+0x230>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8001a76:	680b      	ldr	r3, [r1, #0]
 8001a78:	f013 0f04 	tst.w	r3, #4
 8001a7c:	f47e aec1 	bne.w	8000802 <HAL_DMA_IRQHandler+0xf2>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma)) != RESET)
 8001a80:	6821      	ldr	r1, [r4, #0]
 8001a82:	460b      	mov	r3, r1
 8001a84:	f7fe be6a 	b.w	800075c <HAL_DMA_IRQHandler+0x4c>
 8001a88:	bd38      	pop	{r3, r4, r5, pc}
 8001a8a:	bf00      	nop
 8001a8c:	400260b8 	.word	0x400260b8
 8001a90:	40026400 	.word	0x40026400
 8001a94:	40026058 	.word	0x40026058
 8001a98:	40026000 	.word	0x40026000
 8001a9c:	40026010 	.word	0x40026010

08001aa0 <prvWriteMACCR>:

	heth->Instance->DMAOMR = ulValue;
}

static void prvWriteMACCR( ETH_HandleTypeDef *heth, uint32_t ulValue)
{
 8001aa0:	b538      	push	{r3, r4, r5, lr}
 8001aa2:	4604      	mov	r4, r0
 8001aa4:	460d      	mov	r5, r1
	/* Enable the MAC transmission */
	heth->Instance->MACCR = ulValue;
 8001aa6:	6803      	ldr	r3, [r0, #0]
 8001aa8:	6019      	str	r1, [r3, #0]

	/* Wait until the write operation will be taken into account:
	at least four TX_CLK/RX_CLK clock cycles.
	Read it back, wait a ms and */
	( void ) heth->Instance->MACCR;
 8001aaa:	6803      	ldr	r3, [r0, #0]
 8001aac:	681b      	ldr	r3, [r3, #0]

	HAL_Delay( ETH_REG_WRITE_DELAY );
 8001aae:	2001      	movs	r0, #1
 8001ab0:	f7fe fdbc 	bl	800062c <HAL_Delay>

	heth->Instance->MACCR = ulValue;
 8001ab4:	6823      	ldr	r3, [r4, #0]
 8001ab6:	601d      	str	r5, [r3, #0]
 8001ab8:	bd38      	pop	{r3, r4, r5, pc}

08001aba <prvWriteDMAOMR>:
{
 8001aba:	b570      	push	{r4, r5, r6, lr}
 8001abc:	4605      	mov	r5, r0
 8001abe:	460e      	mov	r6, r1
	heth->Instance->DMAOMR = ulValue;
 8001ac0:	6803      	ldr	r3, [r0, #0]
 8001ac2:	f241 0418 	movw	r4, #4120	; 0x1018
 8001ac6:	5119      	str	r1, [r3, r4]
	( void ) heth->Instance->DMAOMR;
 8001ac8:	6803      	ldr	r3, [r0, #0]
 8001aca:	591b      	ldr	r3, [r3, r4]
	HAL_Delay( ETH_REG_WRITE_DELAY );
 8001acc:	2001      	movs	r0, #1
 8001ace:	f7fe fdad 	bl	800062c <HAL_Delay>
	heth->Instance->DMAOMR = ulValue;
 8001ad2:	682b      	ldr	r3, [r5, #0]
 8001ad4:	511e      	str	r6, [r3, r4]
 8001ad6:	bd70      	pop	{r4, r5, r6, pc}

08001ad8 <ETH_FlushTransmitFIFO>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_FlushTransmitFIFO(ETH_HandleTypeDef *heth)
{
 8001ad8:	b500      	push	{lr}
 8001ada:	b083      	sub	sp, #12
	/* Set the Flush Transmit FIFO bit */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_FTF;
 8001adc:	6802      	ldr	r2, [r0, #0]
 8001ade:	f241 0318 	movw	r3, #4120	; 0x1018
 8001ae2:	58d3      	ldr	r3, [r2, r3]
 8001ae4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001ae8:	9301      	str	r3, [sp, #4]

	prvWriteDMAOMR( heth, tmpreg );
 8001aea:	9901      	ldr	r1, [sp, #4]
 8001aec:	f7ff ffe5 	bl	8001aba <prvWriteDMAOMR>
}
 8001af0:	b003      	add	sp, #12
 8001af2:	f85d fb04 	ldr.w	pc, [sp], #4

08001af6 <HAL_ETH_DMATxDescListInit>:
{
 8001af6:	468c      	mov	ip, r1
	__HAL_LOCK( heth );
 8001af8:	f890 1045 	ldrb.w	r1, [r0, #69]	; 0x45
 8001afc:	2901      	cmp	r1, #1
 8001afe:	d03b      	beq.n	8001b78 <HAL_ETH_DMATxDescListInit+0x82>
{
 8001b00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	__HAL_LOCK( heth );
 8001b04:	2101      	movs	r1, #1
 8001b06:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001b0a:	2102      	movs	r1, #2
 8001b0c:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	heth->TxDesc = pxDMATable;
 8001b10:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
	for( i=0; i < ulBufferCount; i++ )
 8001b14:	b313      	cbz	r3, 8001b5c <HAL_ETH_DMATxDescListInit+0x66>
 8001b16:	46e1      	mov	r9, ip
 8001b18:	4664      	mov	r4, ip
 8001b1a:	2500      	movs	r5, #0
		pxDMADescriptor->Status = ETH_DMATXDESC_TCH;
 8001b1c:	f44f 1880 	mov.w	r8, #1048576	; 0x100000
		pxDMADescriptor->ControlBufferSize = 0;
 8001b20:	4629      	mov	r1, r5
		if(i < ( ulBufferCount - 1 ) )
 8001b22:	f103 3eff 	add.w	lr, r3, #4294967295	; 0xffffffff
 8001b26:	e00c      	b.n	8001b42 <HAL_ETH_DMATxDescListInit+0x4c>
 8001b28:	45ae      	cmp	lr, r5
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) ( pxDMATable + i + 1 );
 8001b2a:	bf86      	itte	hi
 8001b2c:	f104 0720 	addhi.w	r7, r4, #32
 8001b30:	60f7      	strhi	r7, [r6, #12]
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) pxDMATable;
 8001b32:	f8c6 900c 	strls.w	r9, [r6, #12]
	for( i=0; i < ulBufferCount; i++ )
 8001b36:	3501      	adds	r5, #1
 8001b38:	3420      	adds	r4, #32
 8001b3a:	f202 52f4 	addw	r2, r2, #1524	; 0x5f4
 8001b3e:	42ab      	cmp	r3, r5
 8001b40:	d00c      	beq.n	8001b5c <HAL_ETH_DMATxDescListInit+0x66>
		pxDMADescriptor = pxDMATable + i;
 8001b42:	4626      	mov	r6, r4
		pxDMADescriptor->Status = ETH_DMATXDESC_TCH;
 8001b44:	f8c4 8000 	str.w	r8, [r4]
		pxDMADescriptor->ControlBufferSize = 0;
 8001b48:	6061      	str	r1, [r4, #4]
		pxDMADescriptor->Buffer1Addr = ( uint32_t )( &ucDataBuffer[ i * ETH_TX_BUF_SIZE ] );
 8001b4a:	60a2      	str	r2, [r4, #8]
		if (heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8001b4c:	69c7      	ldr	r7, [r0, #28]
 8001b4e:	2f00      	cmp	r7, #0
 8001b50:	d1ea      	bne.n	8001b28 <HAL_ETH_DMATxDescListInit+0x32>
			pxDMADescriptor->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8001b52:	6827      	ldr	r7, [r4, #0]
 8001b54:	f447 0740 	orr.w	r7, r7, #12582912	; 0xc00000
 8001b58:	6027      	str	r7, [r4, #0]
 8001b5a:	e7e5      	b.n	8001b28 <HAL_ETH_DMATxDescListInit+0x32>
	heth->Instance->DMATDLAR = ( uint32_t ) pxDMATable;
 8001b5c:	6802      	ldr	r2, [r0, #0]
 8001b5e:	f241 0310 	movw	r3, #4112	; 0x1010
 8001b62:	f842 c003 	str.w	ip, [r2, r3]
	heth->State= HAL_ETH_STATE_READY;
 8001b66:	2301      	movs	r3, #1
 8001b68:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001b6c:	2300      	movs	r3, #0
 8001b6e:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	return HAL_OK;
 8001b72:	4618      	mov	r0, r3
 8001b74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	__HAL_LOCK( heth );
 8001b78:	2002      	movs	r0, #2
 8001b7a:	4770      	bx	lr

08001b7c <HAL_ETH_DMARxDescListInit>:
{
 8001b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b80:	4688      	mov	r8, r1
	__HAL_LOCK( heth );
 8001b82:	f890 1045 	ldrb.w	r1, [r0, #69]	; 0x45
 8001b86:	2901      	cmp	r1, #1
 8001b88:	d02f      	beq.n	8001bea <HAL_ETH_DMARxDescListInit+0x6e>
 8001b8a:	4686      	mov	lr, r0
 8001b8c:	2101      	movs	r1, #1
 8001b8e:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001b92:	2102      	movs	r1, #2
 8001b94:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	heth->RxDesc = pxDMATable;
 8001b98:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
	for(i=0; i < ulBufferCount; i++)
 8001b9c:	b1bb      	cbz	r3, 8001bce <HAL_ETH_DMARxDescListInit+0x52>
 8001b9e:	46c4      	mov	ip, r8
 8001ba0:	4644      	mov	r4, r8
 8001ba2:	2500      	movs	r5, #0
		pxDMADescriptor->Status = ETH_DMARXDESC_OWN;
 8001ba4:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		pxDMADescriptor->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;
 8001ba8:	f244 57f4 	movw	r7, #17908	; 0x45f4
		if(i < (ulBufferCount-1))
 8001bac:	1e5e      	subs	r6, r3, #1
		pxDMADescriptor->Status = ETH_DMARXDESC_OWN;
 8001bae:	6021      	str	r1, [r4, #0]
		pxDMADescriptor->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;
 8001bb0:	6067      	str	r7, [r4, #4]
		pxDMADescriptor->Buffer1Addr = ( uint32_t )( &ucDataBuffer[ i * ETH_RX_BUF_SIZE ] );
 8001bb2:	60a2      	str	r2, [r4, #8]
		if(i < (ulBufferCount-1))
 8001bb4:	42ae      	cmp	r6, r5
			pxDMADescriptor->Buffer2NextDescAddr = (uint32_t)(pxDMATable+i+1);
 8001bb6:	bf86      	itte	hi
 8001bb8:	f104 0020 	addhi.w	r0, r4, #32
 8001bbc:	60e0      	strhi	r0, [r4, #12]
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) pxDMATable;
 8001bbe:	f8c4 c00c 	strls.w	ip, [r4, #12]
	for(i=0; i < ulBufferCount; i++)
 8001bc2:	3501      	adds	r5, #1
 8001bc4:	3420      	adds	r4, #32
 8001bc6:	f202 52f4 	addw	r2, r2, #1524	; 0x5f4
 8001bca:	42ab      	cmp	r3, r5
 8001bcc:	d1ef      	bne.n	8001bae <HAL_ETH_DMARxDescListInit+0x32>
	heth->Instance->DMARDLAR = ( uint32_t ) pxDMATable;
 8001bce:	f8de 2000 	ldr.w	r2, [lr]
 8001bd2:	f241 030c 	movw	r3, #4108	; 0x100c
 8001bd6:	f842 8003 	str.w	r8, [r2, r3]
	heth->State= HAL_ETH_STATE_READY;
 8001bda:	2301      	movs	r3, #1
 8001bdc:	f88e 3044 	strb.w	r3, [lr, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001be0:	2000      	movs	r0, #0
 8001be2:	f88e 0045 	strb.w	r0, [lr, #69]	; 0x45
	return HAL_OK;
 8001be6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__HAL_LOCK( heth );
 8001bea:	2002      	movs	r0, #2
}
 8001bec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001bf0 <HAL_ETH_Init>:
	if( heth == NULL )
 8001bf0:	2800      	cmp	r0, #0
 8001bf2:	f000 80cd 	beq.w	8001d90 <HAL_ETH_Init+0x1a0>
{
 8001bf6:	b570      	push	{r4, r5, r6, lr}
 8001bf8:	4605      	mov	r5, r0
	if( heth->State == HAL_ETH_STATE_RESET )
 8001bfa:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001bfe:	2b00      	cmp	r3, #0
 8001c00:	f000 80a1 	beq.w	8001d46 <HAL_ETH_Init+0x156>
	__HAL_RCC_SYSCFG_CLK_ENABLE();
 8001c04:	4a63      	ldr	r2, [pc, #396]	; (8001d94 <HAL_ETH_Init+0x1a4>)
 8001c06:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8001c08:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001c0c:	6453      	str	r3, [r2, #68]	; 0x44
	SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8001c0e:	4b62      	ldr	r3, [pc, #392]	; (8001d98 <HAL_ETH_Init+0x1a8>)
 8001c10:	685a      	ldr	r2, [r3, #4]
 8001c12:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8001c16:	605a      	str	r2, [r3, #4]
	SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8001c18:	685a      	ldr	r2, [r3, #4]
 8001c1a:	6a29      	ldr	r1, [r5, #32]
 8001c1c:	430a      	orrs	r2, r1
 8001c1e:	605a      	str	r2, [r3, #4]
	heth->Instance->DMABMR |= ETH_DMABMR_SR | ETH_DMABMR_EDE;
 8001c20:	682b      	ldr	r3, [r5, #0]
 8001c22:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001c26:	681a      	ldr	r2, [r3, #0]
 8001c28:	f042 0281 	orr.w	r2, r2, #129	; 0x81
 8001c2c:	601a      	str	r2, [r3, #0]
	while ((heth->Instance->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8001c2e:	6829      	ldr	r1, [r5, #0]
 8001c30:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
 8001c34:	6814      	ldr	r4, [r2, #0]
 8001c36:	f014 0401 	ands.w	r4, r4, #1
 8001c3a:	d1fb      	bne.n	8001c34 <HAL_ETH_Init+0x44>
	tmpreg = heth->Instance->MACMIIAR;
 8001c3c:	690e      	ldr	r6, [r1, #16]
	tmpreg &= ETH_MACMIIAR_CR_MASK;
 8001c3e:	f026 061c 	bic.w	r6, r6, #28
	hclk = HAL_RCC_GetHCLKFreq();
 8001c42:	f000 ffad 	bl	8002ba0 <HAL_RCC_GetHCLKFreq>
	if( ( hclk >= 20000000 ) && ( hclk < 35000000 ) )
 8001c46:	4b55      	ldr	r3, [pc, #340]	; (8001d9c <HAL_ETH_Init+0x1ac>)
 8001c48:	4403      	add	r3, r0
 8001c4a:	4a55      	ldr	r2, [pc, #340]	; (8001da0 <HAL_ETH_Init+0x1b0>)
 8001c4c:	4293      	cmp	r3, r2
 8001c4e:	d87d      	bhi.n	8001d4c <HAL_ETH_Init+0x15c>
		tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div16;
 8001c50:	f046 0608 	orr.w	r6, r6, #8
	heth->Instance->MACMIIAR = (uint32_t)tmpreg;
 8001c54:	682b      	ldr	r3, [r5, #0]
 8001c56:	611e      	str	r6, [r3, #16]
	vMACBProbePhy();
 8001c58:	f006 ff38 	bl	8008acc <vMACBProbePhy>
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8001c5c:	69eb      	ldr	r3, [r5, #28]
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
 8001c5e:	2b00      	cmp	r3, #0
 8001c60:	bf08      	it	eq
 8001c62:	f44f 6480 	moveq.w	r4, #1024	; 0x400
  tmpreg = heth->Instance->MACCR;
 8001c66:	682b      	ldr	r3, [r5, #0]
 8001c68:	681a      	ldr	r2, [r3, #0]
                       macinit.LoopbackMode |
 8001c6a:	68ab      	ldr	r3, [r5, #8]
 8001c6c:	68e9      	ldr	r1, [r5, #12]
 8001c6e:	4319      	orrs	r1, r3
 8001c70:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  tmpreg &= ETH_MACCR_CLEAR_MASK;
 8001c74:	4b4b      	ldr	r3, [pc, #300]	; (8001da4 <HAL_ETH_Init+0x1b4>)
 8001c76:	4013      	ands	r3, r2
 8001c78:	4319      	orrs	r1, r3
  prvWriteMACCR( heth, tmpreg );
 8001c7a:	4321      	orrs	r1, r4
 8001c7c:	4628      	mov	r0, r5
 8001c7e:	f7ff ff0f 	bl	8001aa0 <prvWriteMACCR>
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
 8001c82:	682b      	ldr	r3, [r5, #0]
 8001c84:	2240      	movs	r2, #64	; 0x40
 8001c86:	605a      	str	r2, [r3, #4]
   tmpreg = heth->Instance->MACFFR;
 8001c88:	682b      	ldr	r3, [r5, #0]
 8001c8a:	685c      	ldr	r4, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8001c8c:	2001      	movs	r0, #1
 8001c8e:	f7fe fccd 	bl	800062c <HAL_Delay>
   heth->Instance->MACFFR = tmpreg;
 8001c92:	682b      	ldr	r3, [r5, #0]
 8001c94:	605c      	str	r4, [r3, #4]
   heth->Instance->MACHTHR = (uint32_t)macinit.HashTableHigh;
 8001c96:	682b      	ldr	r3, [r5, #0]
 8001c98:	2600      	movs	r6, #0
 8001c9a:	609e      	str	r6, [r3, #8]
   heth->Instance->MACHTLR = (uint32_t)macinit.HashTableLow;
 8001c9c:	682b      	ldr	r3, [r5, #0]
 8001c9e:	60de      	str	r6, [r3, #12]
   tmpreg = heth->Instance->MACFCR;
 8001ca0:	682b      	ldr	r3, [r5, #0]
 8001ca2:	699c      	ldr	r4, [r3, #24]
   tmpreg &= ETH_MACFCR_CLEAR_MASK;
 8001ca4:	f024 04be 	bic.w	r4, r4, #190	; 0xbe
 8001ca8:	0424      	lsls	r4, r4, #16
 8001caa:	0c24      	lsrs	r4, r4, #16
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
 8001cac:	f044 0480 	orr.w	r4, r4, #128	; 0x80
	heth->Instance->MACFCR = ulValue;
 8001cb0:	619c      	str	r4, [r3, #24]
	( void ) heth->Instance->MACFCR;
 8001cb2:	682b      	ldr	r3, [r5, #0]
 8001cb4:	699b      	ldr	r3, [r3, #24]
	HAL_Delay( ETH_REG_WRITE_DELAY );
 8001cb6:	2001      	movs	r0, #1
 8001cb8:	f7fe fcb8 	bl	800062c <HAL_Delay>
	heth->Instance->MACFCR = ulValue;
 8001cbc:	682b      	ldr	r3, [r5, #0]
 8001cbe:	619c      	str	r4, [r3, #24]
   heth->Instance->MACVLANTR = (uint32_t)(macinit.VLANTagComparison |
 8001cc0:	682b      	ldr	r3, [r5, #0]
 8001cc2:	61de      	str	r6, [r3, #28]
    tmpreg = heth->Instance->MACVLANTR;
 8001cc4:	682b      	ldr	r3, [r5, #0]
 8001cc6:	69dc      	ldr	r4, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8001cc8:	2001      	movs	r0, #1
 8001cca:	f7fe fcaf 	bl	800062c <HAL_Delay>
    heth->Instance->MACVLANTR = tmpreg;
 8001cce:	682b      	ldr	r3, [r5, #0]
 8001cd0:	61dc      	str	r4, [r3, #28]
    tmpreg = heth->Instance->DMAOMR;
 8001cd2:	682a      	ldr	r2, [r5, #0]
 8001cd4:	f241 0318 	movw	r3, #4120	; 0x1018
 8001cd8:	58d3      	ldr	r3, [r2, r3]
    tmpreg &= ETH_DMAOMR_CLEAR_MASK;
 8001cda:	4933      	ldr	r1, [pc, #204]	; (8001da8 <HAL_ETH_Init+0x1b8>)
 8001cdc:	4019      	ands	r1, r3
    prvWriteDMAOMR( heth, tmpreg );
 8001cde:	f041 7108 	orr.w	r1, r1, #35651584	; 0x2200000
 8001ce2:	f041 0104 	orr.w	r1, r1, #4
 8001ce6:	4628      	mov	r0, r5
 8001ce8:	f7ff fee7 	bl	8001aba <prvWriteDMAOMR>
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
 8001cec:	682b      	ldr	r3, [r5, #0]
 8001cee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001cf2:	4a2e      	ldr	r2, [pc, #184]	; (8001dac <HAL_ETH_Init+0x1bc>)
 8001cf4:	601a      	str	r2, [r3, #0]
     tmpreg = heth->Instance->DMABMR;
 8001cf6:	682b      	ldr	r3, [r5, #0]
 8001cf8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001cfc:	681c      	ldr	r4, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 8001cfe:	2001      	movs	r0, #1
 8001d00:	f7fe fc94 	bl	800062c <HAL_Delay>
     heth->Instance->DMABMR = tmpreg;
 8001d04:	682b      	ldr	r3, [r5, #0]
 8001d06:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8001d0a:	601c      	str	r4, [r3, #0]
     if(heth->Init.RxMode == ETH_RXINTERRUPT_MODE)
 8001d0c:	69ab      	ldr	r3, [r5, #24]
 8001d0e:	2b01      	cmp	r3, #1
 8001d10:	d034      	beq.n	8001d7c <HAL_ETH_Init+0x18c>
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8001d12:	696a      	ldr	r2, [r5, #20]
	tmpreg = 0x80000000ul | ( ( uint32_t )Addr[ 5 ] << 8) | (uint32_t)Addr[ 4 ];
 8001d14:	7951      	ldrb	r1, [r2, #5]
 8001d16:	7913      	ldrb	r3, [r2, #4]
 8001d18:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001d1c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	( * ( __IO uint32_t * ) ( ( uint32_t ) ( ETH_MAC_ADDR_HBASE + MacAddr ) ) ) = tmpreg;
 8001d20:	4923      	ldr	r1, [pc, #140]	; (8001db0 <HAL_ETH_Init+0x1c0>)
 8001d22:	600b      	str	r3, [r1, #0]
	tmpreg = ( ( uint32_t )Addr[ 3 ] << 24 ) | ( ( uint32_t )Addr[ 2 ] << 16 ) | ( ( uint32_t )Addr[ 1 ] << 8 ) | Addr[ 0 ];
 8001d24:	78d1      	ldrb	r1, [r2, #3]
 8001d26:	7893      	ldrb	r3, [r2, #2]
 8001d28:	041b      	lsls	r3, r3, #16
 8001d2a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8001d2e:	7811      	ldrb	r1, [r2, #0]
 8001d30:	430b      	orrs	r3, r1
 8001d32:	7852      	ldrb	r2, [r2, #1]
 8001d34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	( * ( __IO uint32_t * ) ( ( uint32_t ) ( ETH_MAC_ADDR_LBASE + MacAddr ) ) ) = tmpreg;
 8001d38:	4a1e      	ldr	r2, [pc, #120]	; (8001db4 <HAL_ETH_Init+0x1c4>)
 8001d3a:	6013      	str	r3, [r2, #0]
	heth->State= HAL_ETH_STATE_READY;
 8001d3c:	2301      	movs	r3, #1
 8001d3e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	return HAL_OK;
 8001d42:	2000      	movs	r0, #0
 8001d44:	bd70      	pop	{r4, r5, r6, pc}
		HAL_ETH_MspInit( heth );
 8001d46:	f00a fc1d 	bl	800c584 <HAL_ETH_MspInit>
 8001d4a:	e75b      	b.n	8001c04 <HAL_ETH_Init+0x14>
	else if( ( hclk >= 35000000 ) && ( hclk < 60000000 ) )
 8001d4c:	4b1a      	ldr	r3, [pc, #104]	; (8001db8 <HAL_ETH_Init+0x1c8>)
 8001d4e:	4403      	add	r3, r0
 8001d50:	4a1a      	ldr	r2, [pc, #104]	; (8001dbc <HAL_ETH_Init+0x1cc>)
 8001d52:	4293      	cmp	r3, r2
 8001d54:	d802      	bhi.n	8001d5c <HAL_ETH_Init+0x16c>
	tmpreg |= ( uint32_t ) ETH_MACMIIAR_CR_Div26;
 8001d56:	f046 060c 	orr.w	r6, r6, #12
 8001d5a:	e77b      	b.n	8001c54 <HAL_ETH_Init+0x64>
	else if((hclk >= 60000000 ) && ( hclk < 100000000 ) )
 8001d5c:	4b18      	ldr	r3, [pc, #96]	; (8001dc0 <HAL_ETH_Init+0x1d0>)
 8001d5e:	4403      	add	r3, r0
 8001d60:	4a18      	ldr	r2, [pc, #96]	; (8001dc4 <HAL_ETH_Init+0x1d4>)
 8001d62:	4293      	cmp	r3, r2
 8001d64:	f67f af76 	bls.w	8001c54 <HAL_ETH_Init+0x64>
	else if((hclk >= 100000000 ) && ( hclk < 150000000))
 8001d68:	4b17      	ldr	r3, [pc, #92]	; (8001dc8 <HAL_ETH_Init+0x1d8>)
 8001d6a:	4403      	add	r3, r0
 8001d6c:	4a17      	ldr	r2, [pc, #92]	; (8001dcc <HAL_ETH_Init+0x1dc>)
 8001d6e:	4293      	cmp	r3, r2
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8001d70:	bf94      	ite	ls
 8001d72:	f046 0604 	orrls.w	r6, r6, #4
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;
 8001d76:	f046 0610 	orrhi.w	r6, r6, #16
 8001d7a:	e76b      	b.n	8001c54 <HAL_ETH_Init+0x64>
       __HAL_ETH_DMA_ENABLE_IT(( heth ), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8001d7c:	6829      	ldr	r1, [r5, #0]
 8001d7e:	f241 021c 	movw	r2, #4124	; 0x101c
 8001d82:	588b      	ldr	r3, [r1, r2]
 8001d84:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001d88:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001d8c:	508b      	str	r3, [r1, r2]
 8001d8e:	e7c0      	b.n	8001d12 <HAL_ETH_Init+0x122>
		return HAL_ERROR;
 8001d90:	2001      	movs	r0, #1
 8001d92:	4770      	bx	lr
 8001d94:	40023800 	.word	0x40023800
 8001d98:	40013800 	.word	0x40013800
 8001d9c:	feced300 	.word	0xfeced300
 8001da0:	00e4e1bf 	.word	0x00e4e1bf
 8001da4:	ff20810f 	.word	0xff20810f
 8001da8:	f8de3f23 	.word	0xf8de3f23
 8001dac:	02c12080 	.word	0x02c12080
 8001db0:	40028040 	.word	0x40028040
 8001db4:	40028044 	.word	0x40028044
 8001db8:	fde9f140 	.word	0xfde9f140
 8001dbc:	017d783f 	.word	0x017d783f
 8001dc0:	fc6c7900 	.word	0xfc6c7900
 8001dc4:	026259ff 	.word	0x026259ff
 8001dc8:	fa0a1f00 	.word	0xfa0a1f00
 8001dcc:	02faf07f 	.word	0x02faf07f

08001dd0 <HAL_ETH_TransmitFrame>:
	__HAL_LOCK( heth );
 8001dd0:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001dd4:	2b01      	cmp	r3, #1
 8001dd6:	d07c      	beq.n	8001ed2 <HAL_ETH_TransmitFrame+0x102>
{
 8001dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
	__IO ETH_DMADescTypeDef *pxDmaTxDesc = heth->TxDesc;
 8001dda:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
	__HAL_LOCK( heth );
 8001ddc:	2301      	movs	r3, #1
 8001dde:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001de2:	2302      	movs	r3, #2
 8001de4:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	if( FrameLength == 0 )
 8001de8:	b1b9      	cbz	r1, 8001e1a <HAL_ETH_TransmitFrame+0x4a>
	if( ( pxDmaTxDesc->Status & ETH_DMATXDESC_OWN ) != ( uint32_t ) RESET )
 8001dea:	683b      	ldr	r3, [r7, #0]
 8001dec:	2b00      	cmp	r3, #0
 8001dee:	db1c      	blt.n	8001e2a <HAL_ETH_TransmitFrame+0x5a>
	bufcount = ( FrameLength + ETH_TX_BUF_SIZE - 1 ) / ETH_TX_BUF_SIZE;
 8001df0:	f201 54f3 	addw	r4, r1, #1523	; 0x5f3
 8001df4:	4b38      	ldr	r3, [pc, #224]	; (8001ed8 <HAL_ETH_TransmitFrame+0x108>)
 8001df6:	fba3 3404 	umull	r3, r4, r3, r4
 8001dfa:	0aa4      	lsrs	r4, r4, #10
	if (bufcount == 1)
 8001dfc:	2c01      	cmp	r4, #1
 8001dfe:	d01c      	beq.n	8001e3a <HAL_ETH_TransmitFrame+0x6a>
		for( i = 0; i < bufcount; i++ )
 8001e00:	b34c      	cbz	r4, 8001e56 <HAL_ETH_TransmitFrame+0x86>
				size = FrameLength - (bufcount-1)*ETH_TX_BUF_SIZE;
 8001e02:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 8001e06:	4e35      	ldr	r6, [pc, #212]	; (8001edc <HAL_ETH_TransmitFrame+0x10c>)
 8001e08:	fb06 1104 	mla	r1, r6, r4, r1
				heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8001e0c:	f3c1 060c 	ubfx	r6, r1, #0, #13
 8001e10:	2300      	movs	r3, #0
			if (i < (bufcount-1))
 8001e12:	1e65      	subs	r5, r4, #1
				heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8001e14:	f240 5ef4 	movw	lr, #1524	; 0x5f4
 8001e18:	e04f      	b.n	8001eba <HAL_ETH_TransmitFrame+0xea>
		heth->State = HAL_ETH_STATE_READY;
 8001e1a:	2301      	movs	r3, #1
 8001e1c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		__HAL_UNLOCK( heth );
 8001e20:	2200      	movs	r2, #0
 8001e22:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
		return  HAL_ERROR;
 8001e26:	4618      	mov	r0, r3
 8001e28:	bdf0      	pop	{r4, r5, r6, r7, pc}
		heth->State = HAL_ETH_STATE_BUSY_TX;
 8001e2a:	2312      	movs	r3, #18
 8001e2c:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		__HAL_UNLOCK( heth );
 8001e30:	2300      	movs	r3, #0
 8001e32:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
		return HAL_ERROR;
 8001e36:	2001      	movs	r0, #1
 8001e38:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pxDmaTxDesc->Status |= ETH_DMATXDESC_FS | ETH_DMATXDESC_LS;
 8001e3a:	683b      	ldr	r3, [r7, #0]
 8001e3c:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
 8001e40:	603b      	str	r3, [r7, #0]
		pxDmaTxDesc->ControlBufferSize = ( FrameLength & ETH_DMATXDESC_TBS1 );
 8001e42:	f3c1 010c 	ubfx	r1, r1, #0, #13
 8001e46:	6079      	str	r1, [r7, #4]
		pxDmaTxDesc->Status |= ETH_DMATXDESC_OWN;
 8001e48:	683b      	ldr	r3, [r7, #0]
 8001e4a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001e4e:	603b      	str	r3, [r7, #0]
		heth->TxDesc = ( ETH_DMADescTypeDef * ) ( heth->TxDesc->Buffer2NextDescAddr );
 8001e50:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001e52:	68db      	ldr	r3, [r3, #12]
 8001e54:	62c3      	str	r3, [r0, #44]	; 0x2c
	if( ( heth->Instance->DMASR & ETH_DMASR_TBUS ) != ( uint32_t )RESET )
 8001e56:	6803      	ldr	r3, [r0, #0]
 8001e58:	f241 0214 	movw	r2, #4116	; 0x1014
 8001e5c:	589a      	ldr	r2, [r3, r2]
 8001e5e:	f012 0f04 	tst.w	r2, #4
 8001e62:	d00c      	beq.n	8001e7e <HAL_ETH_TransmitFrame+0xae>
		heth->Instance->DMACHTDR = ( uint32_t )pxDmaTxDesc;
 8001e64:	f241 0248 	movw	r2, #4168	; 0x1048
 8001e68:	509f      	str	r7, [r3, r2]
		heth->Instance->DMASR = ETH_DMASR_TBUS;
 8001e6a:	6802      	ldr	r2, [r0, #0]
 8001e6c:	2104      	movs	r1, #4
 8001e6e:	f241 0314 	movw	r3, #4116	; 0x1014
 8001e72:	50d1      	str	r1, [r2, r3]
		heth->Instance->DMATPDR = 0;
 8001e74:	6802      	ldr	r2, [r0, #0]
 8001e76:	2100      	movs	r1, #0
 8001e78:	f241 0304 	movw	r3, #4100	; 0x1004
 8001e7c:	50d1      	str	r1, [r2, r3]
	heth->State = HAL_ETH_STATE_READY;
 8001e7e:	2301      	movs	r3, #1
 8001e80:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001e84:	2300      	movs	r3, #0
 8001e86:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	return HAL_OK;
 8001e8a:	4618      	mov	r0, r3
 8001e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				heth->TxDesc->Status = ulStatus | ETH_DMATXDESC_FS;
 8001e8e:	f042 5c80 	orr.w	ip, r2, #268435456	; 0x10000000
 8001e92:	f8c1 c000 	str.w	ip, [r1]
 8001e96:	e016      	b.n	8001ec6 <HAL_ETH_TransmitFrame+0xf6>
				heth->TxDesc->Status = ulStatus | ETH_DMATXDESC_LS;
 8001e98:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001e9a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8001e9e:	600a      	str	r2, [r1, #0]
				heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 8001ea0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001ea2:	6056      	str	r6, [r2, #4]
			heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 8001ea4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001ea6:	680a      	ldr	r2, [r1, #0]
 8001ea8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8001eac:	600a      	str	r2, [r1, #0]
			heth->TxDesc = (ETH_DMADescTypeDef *)( heth->TxDesc->Buffer2NextDescAddr );
 8001eae:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001eb0:	68d2      	ldr	r2, [r2, #12]
 8001eb2:	62c2      	str	r2, [r0, #44]	; 0x2c
		for( i = 0; i < bufcount; i++ )
 8001eb4:	3301      	adds	r3, #1
 8001eb6:	429c      	cmp	r4, r3
 8001eb8:	d0cd      	beq.n	8001e56 <HAL_ETH_TransmitFrame+0x86>
		uint32_t ulStatus = heth->TxDesc->Status & ~( ETH_DMATXDESC_FS | ETH_DMATXDESC_LS );
 8001eba:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001ebc:	680a      	ldr	r2, [r1, #0]
 8001ebe:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
			if( i == 0 )
 8001ec2:	2b00      	cmp	r3, #0
 8001ec4:	d0e3      	beq.n	8001e8e <HAL_ETH_TransmitFrame+0xbe>
			if (i < (bufcount-1))
 8001ec6:	429d      	cmp	r5, r3
 8001ec8:	d9e6      	bls.n	8001e98 <HAL_ETH_TransmitFrame+0xc8>
				heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8001eca:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001ecc:	f8c2 e004 	str.w	lr, [r2, #4]
 8001ed0:	e7e8      	b.n	8001ea4 <HAL_ETH_TransmitFrame+0xd4>
	__HAL_LOCK( heth );
 8001ed2:	2002      	movs	r0, #2
 8001ed4:	4770      	bx	lr
 8001ed6:	bf00      	nop
 8001ed8:	ac02b00b 	.word	0xac02b00b
 8001edc:	fffffa0c 	.word	0xfffffa0c

08001ee0 <HAL_ETH_GetReceivedFrame>:
	__HAL_LOCK( heth );
 8001ee0:	f890 2045 	ldrb.w	r2, [r0, #69]	; 0x45
 8001ee4:	2a01      	cmp	r2, #1
 8001ee6:	d040      	beq.n	8001f6a <HAL_ETH_GetReceivedFrame+0x8a>
{
 8001ee8:	b470      	push	{r4, r5, r6}
 8001eea:	4603      	mov	r3, r0
ETH_DMADescTypeDef *pxDescriptor = heth->RxDesc;
 8001eec:	6a82      	ldr	r2, [r0, #40]	; 0x28
	__HAL_LOCK( heth );
 8001eee:	2101      	movs	r1, #1
 8001ef0:	f880 1045 	strb.w	r1, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8001ef4:	2102      	movs	r1, #2
 8001ef6:	f880 1044 	strb.w	r1, [r0, #68]	; 0x44
	while( ( ( pxDescriptor->Status & ETH_DMARXDESC_OWN ) == 0ul ) && ( ulCounter < ETH_RXBUFNB ) )
 8001efa:	2105      	movs	r1, #5
			heth->RxFrameInfos.LSRxDesc = ( ETH_DMADescTypeDef *)NULL;
 8001efc:	2600      	movs	r6, #0
			heth->RxFrameInfos.SegCount = 1;
 8001efe:	2501      	movs	r5, #1
	while( ( ( pxDescriptor->Status & ETH_DMARXDESC_OWN ) == 0ul ) && ( ulCounter < ETH_RXBUFNB ) )
 8001f00:	e00a      	b.n	8001f18 <HAL_ETH_GetReceivedFrame+0x38>
			heth->RxFrameInfos.FSRxDesc = pxDescriptor;
 8001f02:	631a      	str	r2, [r3, #48]	; 0x30
			heth->RxFrameInfos.LSRxDesc = ( ETH_DMADescTypeDef *)NULL;
 8001f04:	635e      	str	r6, [r3, #52]	; 0x34
			heth->RxFrameInfos.SegCount = 1;
 8001f06:	639d      	str	r5, [r3, #56]	; 0x38
			pxDescriptor = (ETH_DMADescTypeDef*) (pxDescriptor->Buffer2NextDescAddr);
 8001f08:	68d2      	ldr	r2, [r2, #12]
			heth->RxDesc = pxDescriptor;
 8001f0a:	629a      	str	r2, [r3, #40]	; 0x28
 8001f0c:	e004      	b.n	8001f18 <HAL_ETH_GetReceivedFrame+0x38>
			heth->RxFrameInfos.SegCount++;
 8001f0e:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8001f10:	3001      	adds	r0, #1
 8001f12:	6398      	str	r0, [r3, #56]	; 0x38
			pxDescriptor = ( ETH_DMADescTypeDef * ) ( pxDescriptor->Buffer2NextDescAddr );
 8001f14:	68d2      	ldr	r2, [r2, #12]
			heth->RxDesc = pxDescriptor;
 8001f16:	629a      	str	r2, [r3, #40]	; 0x28
	while( ( ( pxDescriptor->Status & ETH_DMARXDESC_OWN ) == 0ul ) && ( ulCounter < ETH_RXBUFNB ) )
 8001f18:	6810      	ldr	r0, [r2, #0]
 8001f1a:	2800      	cmp	r0, #0
 8001f1c:	db23      	blt.n	8001f66 <HAL_ETH_GetReceivedFrame+0x86>
 8001f1e:	3901      	subs	r1, #1
 8001f20:	d018      	beq.n	8001f54 <HAL_ETH_GetReceivedFrame+0x74>
	uint32_t ulStatus = pxDescriptor->Status;
 8001f22:	6814      	ldr	r4, [r2, #0]
		if( ( ulStatus & ( ETH_DMARXDESC_FS | ETH_DMARXDESC_LS ) ) == ( uint32_t )ETH_DMARXDESC_FS )
 8001f24:	f404 7040 	and.w	r0, r4, #768	; 0x300
 8001f28:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8001f2c:	d0e9      	beq.n	8001f02 <HAL_ETH_GetReceivedFrame+0x22>
		else if( ( ulStatus & ( ETH_DMARXDESC_LS | ETH_DMARXDESC_FS ) ) == 0ul )
 8001f2e:	2800      	cmp	r0, #0
 8001f30:	d0ed      	beq.n	8001f0e <HAL_ETH_GetReceivedFrame+0x2e>
			if( heth->RxFrameInfos.SegCount == 0 )
 8001f32:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8001f34:	b901      	cbnz	r1, 8001f38 <HAL_ETH_GetReceivedFrame+0x58>
				heth->RxFrameInfos.FSRxDesc = pxDescriptor;
 8001f36:	631a      	str	r2, [r3, #48]	; 0x30
			heth->RxFrameInfos.SegCount++;
 8001f38:	3101      	adds	r1, #1
 8001f3a:	6399      	str	r1, [r3, #56]	; 0x38
			heth->RxFrameInfos.LSRxDesc = pxDescriptor;
 8001f3c:	635a      	str	r2, [r3, #52]	; 0x34
				( ( ulStatus & ETH_DMARXDESC_FL ) >> ETH_DMARXDESC_FRAMELENGTHSHIFT ) - 4;
 8001f3e:	f3c4 440d 	ubfx	r4, r4, #16, #14
 8001f42:	3c04      	subs	r4, #4
			heth->RxFrameInfos.length =
 8001f44:	63dc      	str	r4, [r3, #60]	; 0x3c
			heth->RxFrameInfos.buffer = heth->RxFrameInfos.FSRxDesc->Buffer1Addr;
 8001f46:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001f48:	6889      	ldr	r1, [r1, #8]
 8001f4a:	6419      	str	r1, [r3, #64]	; 0x40
			heth->RxDesc = ( ETH_DMADescTypeDef * ) pxDescriptor->Buffer2NextDescAddr;
 8001f4c:	68d2      	ldr	r2, [r2, #12]
 8001f4e:	629a      	str	r2, [r3, #40]	; 0x28
			xResult = HAL_OK;
 8001f50:	2000      	movs	r0, #0
			break;
 8001f52:	e000      	b.n	8001f56 <HAL_ETH_GetReceivedFrame+0x76>
HAL_StatusTypeDef xResult = HAL_ERROR;
 8001f54:	2001      	movs	r0, #1
	heth->State = HAL_ETH_STATE_READY;
 8001f56:	2201      	movs	r2, #1
 8001f58:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8001f5c:	2200      	movs	r2, #0
 8001f5e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
}
 8001f62:	bc70      	pop	{r4, r5, r6}
 8001f64:	4770      	bx	lr
HAL_StatusTypeDef xResult = HAL_ERROR;
 8001f66:	2001      	movs	r0, #1
 8001f68:	e7f5      	b.n	8001f56 <HAL_ETH_GetReceivedFrame+0x76>
	__HAL_LOCK( heth );
 8001f6a:	2002      	movs	r0, #2
 8001f6c:	4770      	bx	lr

08001f6e <HAL_ETH_ErrorCallback>:
{
 8001f6e:	4770      	bx	lr

08001f70 <HAL_ETH_IRQHandler>:
{
 8001f70:	b538      	push	{r3, r4, r5, lr}
 8001f72:	4605      	mov	r5, r0
	dmasr = heth->Instance->DMASR & ETH_DMA_ALL_INTS;
 8001f74:	6801      	ldr	r1, [r0, #0]
 8001f76:	f241 0214 	movw	r2, #4116	; 0x1014
 8001f7a:	588c      	ldr	r4, [r1, r2]
 8001f7c:	4b0b      	ldr	r3, [pc, #44]	; (8001fac <HAL_ETH_IRQHandler+0x3c>)
 8001f7e:	4023      	ands	r3, r4
	heth->Instance->DMASR = dmasr;
 8001f80:	508b      	str	r3, [r1, r2]
	if( ( dmasr & ( ETH_DMA_FLAG_R | ETH_DMA_IT_RBU ) ) != 0 )
 8001f82:	f014 0fc0 	tst.w	r4, #192	; 0xc0
 8001f86:	d106      	bne.n	8001f96 <HAL_ETH_IRQHandler+0x26>
	if( ( dmasr & ( ETH_DMA_FLAG_T ) ) != 0 )
 8001f88:	f014 0f01 	tst.w	r4, #1
 8001f8c:	d106      	bne.n	8001f9c <HAL_ETH_IRQHandler+0x2c>
	if( ( dmasr & ( ETH_DMA_FLAG_AIS ) ) != 0 )
 8001f8e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8001f92:	d107      	bne.n	8001fa4 <HAL_ETH_IRQHandler+0x34>
 8001f94:	bd38      	pop	{r3, r4, r5, pc}
		HAL_ETH_RxCpltCallback( heth );
 8001f96:	f006 fccf 	bl	8008938 <HAL_ETH_RxCpltCallback>
 8001f9a:	e7f5      	b.n	8001f88 <HAL_ETH_IRQHandler+0x18>
		HAL_ETH_TxCpltCallback( heth );
 8001f9c:	4628      	mov	r0, r5
 8001f9e:	f006 fced 	bl	800897c <HAL_ETH_TxCpltCallback>
 8001fa2:	e7f4      	b.n	8001f8e <HAL_ETH_IRQHandler+0x1e>
		HAL_ETH_ErrorCallback( heth );
 8001fa4:	4628      	mov	r0, r5
 8001fa6:	f7ff ffe2 	bl	8001f6e <HAL_ETH_ErrorCallback>
}
 8001faa:	e7f3      	b.n	8001f94 <HAL_ETH_IRQHandler+0x24>
 8001fac:	3801e7fb 	.word	0x3801e7fb

08001fb0 <HAL_ETH_ReadPHYRegister>:
{
 8001fb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( heth->State == HAL_ETH_STATE_BUSY_RD )
 8001fb2:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001fb6:	b2db      	uxtb	r3, r3
 8001fb8:	2b82      	cmp	r3, #130	; 0x82
 8001fba:	d03d      	beq.n	8002038 <HAL_ETH_ReadPHYRegister+0x88>
 8001fbc:	4604      	mov	r4, r0
 8001fbe:	4616      	mov	r6, r2
		__HAL_LOCK( heth );
 8001fc0:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001fc4:	2b01      	cmp	r3, #1
 8001fc6:	d102      	bne.n	8001fce <HAL_ETH_ReadPHYRegister+0x1e>
 8001fc8:	2402      	movs	r4, #2
}
 8001fca:	4620      	mov	r0, r4
 8001fcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		__HAL_LOCK( heth );
 8001fce:	2301      	movs	r3, #1
 8001fd0:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
		heth->State = HAL_ETH_STATE_BUSY_RD;
 8001fd4:	2382      	movs	r3, #130	; 0x82
 8001fd6:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		tmpreg = heth->Instance->MACMIIAR;
 8001fda:	6802      	ldr	r2, [r0, #0]
 8001fdc:	6913      	ldr	r3, [r2, #16]
		tmpreg |= ( ( ( uint32_t )PHYReg << 6 ) & ETH_MACMIIAR_MR );                   /* Set the PHY register address */
 8001fde:	0189      	lsls	r1, r1, #6
 8001fe0:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
		tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8001fe4:	f003 031c 	and.w	r3, r3, #28
 8001fe8:	4319      	orrs	r1, r3
		tmpreg |= ( ( ( uint32_t )heth->Init.PhyAddress << 11) & ETH_MACMIIAR_PA );    /* Set the PHY device address   */
 8001fea:	8a03      	ldrh	r3, [r0, #16]
 8001fec:	02db      	lsls	r3, r3, #11
 8001fee:	b29b      	uxth	r3, r3
		tmpreg &= ~ETH_MACMIIAR_MW;                                           /* Set the read mode            */
 8001ff0:	4319      	orrs	r1, r3
		tmpreg |= ETH_MACMIIAR_MB;                                            /* Set the MII Busy bit         */
 8001ff2:	f041 0101 	orr.w	r1, r1, #1
		heth->Instance->MACMIIAR = tmpreg;
 8001ff6:	6111      	str	r1, [r2, #16]
		tickstart = HAL_GetTick();
 8001ff8:	f7fe fb12 	bl	8000620 <HAL_GetTick>
 8001ffc:	4607      	mov	r7, r0
			if( ( HAL_GetTick( ) - tickstart ) > PHY_READ_TO )
 8001ffe:	4d11      	ldr	r5, [pc, #68]	; (8002044 <HAL_ETH_ReadPHYRegister+0x94>)
			tmpreg = heth->Instance->MACMIIAR;
 8002000:	6823      	ldr	r3, [r4, #0]
 8002002:	691a      	ldr	r2, [r3, #16]
			if( ( tmpreg & ETH_MACMIIAR_MB ) == 0ul )
 8002004:	f012 0f01 	tst.w	r2, #1
 8002008:	d00c      	beq.n	8002024 <HAL_ETH_ReadPHYRegister+0x74>
			if( ( HAL_GetTick( ) - tickstart ) > PHY_READ_TO )
 800200a:	f7fe fb09 	bl	8000620 <HAL_GetTick>
 800200e:	1bc0      	subs	r0, r0, r7
 8002010:	42a8      	cmp	r0, r5
 8002012:	d9f5      	bls.n	8002000 <HAL_ETH_ReadPHYRegister+0x50>
		heth->State = HAL_ETH_STATE_READY;
 8002014:	2301      	movs	r3, #1
 8002016:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 800201a:	2300      	movs	r3, #0
 800201c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
				xResult = HAL_TIMEOUT;
 8002020:	2403      	movs	r4, #3
 8002022:	e00a      	b.n	800203a <HAL_ETH_ReadPHYRegister+0x8a>
				*RegValue = ( uint32_t ) heth->Instance->MACMIIDR;
 8002024:	695b      	ldr	r3, [r3, #20]
 8002026:	6033      	str	r3, [r6, #0]
		heth->State = HAL_ETH_STATE_READY;
 8002028:	2301      	movs	r3, #1
 800202a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 800202e:	2300      	movs	r3, #0
 8002030:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	return xResult;
 8002034:	461c      	mov	r4, r3
 8002036:	e7c8      	b.n	8001fca <HAL_ETH_ReadPHYRegister+0x1a>
		xResult = HAL_BUSY;
 8002038:	2402      	movs	r4, #2
		lUDPLoggingPrintf( "ReadPHY: %d\n", xResult );
 800203a:	4621      	mov	r1, r4
 800203c:	4802      	ldr	r0, [pc, #8]	; (8002048 <HAL_ETH_ReadPHYRegister+0x98>)
 800203e:	f009 fd03 	bl	800ba48 <lUDPLoggingPrintf>
 8002042:	e7c2      	b.n	8001fca <HAL_ETH_ReadPHYRegister+0x1a>
 8002044:	0004ffff 	.word	0x0004ffff
 8002048:	0800c940 	.word	0x0800c940

0800204c <HAL_ETH_WritePHYRegister>:
{
 800204c:	b570      	push	{r4, r5, r6, lr}
	if( heth->State == HAL_ETH_STATE_BUSY_WR )
 800204e:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8002052:	b2db      	uxtb	r3, r3
 8002054:	2b42      	cmp	r3, #66	; 0x42
 8002056:	d035      	beq.n	80020c4 <HAL_ETH_WritePHYRegister+0x78>
 8002058:	4604      	mov	r4, r0
		__HAL_LOCK( heth );
 800205a:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 800205e:	2b01      	cmp	r3, #1
 8002060:	d102      	bne.n	8002068 <HAL_ETH_WritePHYRegister+0x1c>
 8002062:	2402      	movs	r4, #2
}
 8002064:	4620      	mov	r0, r4
 8002066:	bd70      	pop	{r4, r5, r6, pc}
		__HAL_LOCK( heth );
 8002068:	2301      	movs	r3, #1
 800206a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
		heth->State = HAL_ETH_STATE_BUSY_WR;
 800206e:	2342      	movs	r3, #66	; 0x42
 8002070:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		tmpreg = heth->Instance->MACMIIAR;
 8002074:	6800      	ldr	r0, [r0, #0]
 8002076:	6905      	ldr	r5, [r0, #16]
		tmpreg |= ( ( ( uint32_t ) PHYReg << 6 ) & ETH_MACMIIAR_MR );                 /* Set the PHY register address */
 8002078:	018b      	lsls	r3, r1, #6
 800207a:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 800207e:	f043 0303 	orr.w	r3, r3, #3
		tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8002082:	f005 011c 	and.w	r1, r5, #28
 8002086:	430b      	orrs	r3, r1
		tmpreg |= ( ( ( uint32_t ) heth->Init.PhyAddress << 11 ) & ETH_MACMIIAR_PA ); /* Set the PHY device address */
 8002088:	8a21      	ldrh	r1, [r4, #16]
 800208a:	02c9      	lsls	r1, r1, #11
 800208c:	b289      	uxth	r1, r1
		tmpreg |= ETH_MACMIIAR_MB;                                          /* Set the MII Busy bit */
 800208e:	430b      	orrs	r3, r1
 8002090:	b292      	uxth	r2, r2
		heth->Instance->MACMIIDR = ( uint16_t ) RegValue;
 8002092:	6142      	str	r2, [r0, #20]
		heth->Instance->MACMIIAR = tmpreg;
 8002094:	6822      	ldr	r2, [r4, #0]
 8002096:	6113      	str	r3, [r2, #16]
		tickstart = HAL_GetTick();
 8002098:	f7fe fac2 	bl	8000620 <HAL_GetTick>
 800209c:	4606      	mov	r6, r0
			if( ( HAL_GetTick( ) - tickstart ) > PHY_WRITE_TO )
 800209e:	4d10      	ldr	r5, [pc, #64]	; (80020e0 <HAL_ETH_WritePHYRegister+0x94>)
			tmpreg = heth->Instance->MACMIIAR;
 80020a0:	6823      	ldr	r3, [r4, #0]
 80020a2:	691b      	ldr	r3, [r3, #16]
			if( ( tmpreg & ETH_MACMIIAR_MB ) == 0ul )
 80020a4:	f013 0f01 	tst.w	r3, #1
 80020a8:	d012      	beq.n	80020d0 <HAL_ETH_WritePHYRegister+0x84>
			if( ( HAL_GetTick( ) - tickstart ) > PHY_WRITE_TO )
 80020aa:	f7fe fab9 	bl	8000620 <HAL_GetTick>
 80020ae:	1b80      	subs	r0, r0, r6
 80020b0:	42a8      	cmp	r0, r5
 80020b2:	d9f5      	bls.n	80020a0 <HAL_ETH_WritePHYRegister+0x54>
		heth->State = HAL_ETH_STATE_READY;
 80020b4:	2301      	movs	r3, #1
 80020b6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 80020ba:	2300      	movs	r3, #0
 80020bc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
				xResult = HAL_TIMEOUT;
 80020c0:	2403      	movs	r4, #3
 80020c2:	e000      	b.n	80020c6 <HAL_ETH_WritePHYRegister+0x7a>
		xResult = HAL_BUSY;
 80020c4:	2402      	movs	r4, #2
		lUDPLoggingPrintf( "WritePHY: %d\n", xResult );
 80020c6:	4621      	mov	r1, r4
 80020c8:	4806      	ldr	r0, [pc, #24]	; (80020e4 <HAL_ETH_WritePHYRegister+0x98>)
 80020ca:	f009 fcbd 	bl	800ba48 <lUDPLoggingPrintf>
 80020ce:	e7c9      	b.n	8002064 <HAL_ETH_WritePHYRegister+0x18>
		heth->State = HAL_ETH_STATE_READY;
 80020d0:	2301      	movs	r3, #1
 80020d2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		__HAL_UNLOCK( heth );
 80020d6:	2300      	movs	r3, #0
 80020d8:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	return xResult;
 80020dc:	461c      	mov	r4, r3
 80020de:	e7c1      	b.n	8002064 <HAL_ETH_WritePHYRegister+0x18>
 80020e0:	0004ffff 	.word	0x0004ffff
 80020e4:	0800c950 	.word	0x0800c950

080020e8 <HAL_ETH_Start>:
	__HAL_LOCK( heth );
 80020e8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80020ec:	2b01      	cmp	r3, #1
 80020ee:	d101      	bne.n	80020f4 <HAL_ETH_Start+0xc>
 80020f0:	2002      	movs	r0, #2
 80020f2:	4770      	bx	lr
{
 80020f4:	b570      	push	{r4, r5, r6, lr}
 80020f6:	b084      	sub	sp, #16
 80020f8:	4604      	mov	r4, r0
	__HAL_LOCK( heth );
 80020fa:	2501      	movs	r5, #1
 80020fc:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
	heth->State = HAL_ETH_STATE_BUSY;
 8002100:	2302      	movs	r3, #2
 8002102:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	uint32_t tmpreg = heth->Instance->MACCR | ETH_MACCR_TE;
 8002106:	6803      	ldr	r3, [r0, #0]
 8002108:	6819      	ldr	r1, [r3, #0]
	prvWriteMACCR( heth, tmpreg );
 800210a:	f041 0108 	orr.w	r1, r1, #8
 800210e:	f7ff fcc7 	bl	8001aa0 <prvWriteMACCR>
	__IO uint32_t tmpreg = heth->Instance->MACCR | ETH_MACCR_RE;
 8002112:	6823      	ldr	r3, [r4, #0]
 8002114:	681b      	ldr	r3, [r3, #0]
 8002116:	f043 0304 	orr.w	r3, r3, #4
 800211a:	9303      	str	r3, [sp, #12]
	prvWriteMACCR( heth, tmpreg );
 800211c:	9903      	ldr	r1, [sp, #12]
 800211e:	4620      	mov	r0, r4
 8002120:	f7ff fcbe 	bl	8001aa0 <prvWriteMACCR>
	ETH_FlushTransmitFIFO( heth );
 8002124:	4620      	mov	r0, r4
 8002126:	f7ff fcd7 	bl	8001ad8 <ETH_FlushTransmitFIFO>
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_ST;
 800212a:	6823      	ldr	r3, [r4, #0]
 800212c:	f241 0618 	movw	r6, #4120	; 0x1018
 8002130:	599b      	ldr	r3, [r3, r6]
 8002132:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002136:	9302      	str	r3, [sp, #8]
	prvWriteDMAOMR( heth, tmpreg );
 8002138:	9902      	ldr	r1, [sp, #8]
 800213a:	4620      	mov	r0, r4
 800213c:	f7ff fcbd 	bl	8001aba <prvWriteDMAOMR>
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_SR;
 8002140:	6823      	ldr	r3, [r4, #0]
 8002142:	599b      	ldr	r3, [r3, r6]
 8002144:	f043 0302 	orr.w	r3, r3, #2
 8002148:	9301      	str	r3, [sp, #4]
	prvWriteDMAOMR( heth, tmpreg );
 800214a:	9901      	ldr	r1, [sp, #4]
 800214c:	4620      	mov	r0, r4
 800214e:	f7ff fcb4 	bl	8001aba <prvWriteDMAOMR>
	heth->State= HAL_ETH_STATE_READY;
 8002152:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
	__HAL_UNLOCK( heth );
 8002156:	2000      	movs	r0, #0
 8002158:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 800215c:	b004      	add	sp, #16
 800215e:	bd70      	pop	{r4, r5, r6, pc}

08002160 <HAL_ETH_Stop>:
  __HAL_LOCK( heth );
 8002160:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8002164:	2b01      	cmp	r3, #1
 8002166:	d101      	bne.n	800216c <HAL_ETH_Stop+0xc>
 8002168:	2002      	movs	r0, #2
 800216a:	4770      	bx	lr
{
 800216c:	b570      	push	{r4, r5, r6, lr}
 800216e:	b084      	sub	sp, #16
 8002170:	4604      	mov	r4, r0
  __HAL_LOCK( heth );
 8002172:	2501      	movs	r5, #1
 8002174:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8002178:	2302      	movs	r3, #2
 800217a:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	__IO uint32_t tmpreg = heth->Instance->DMAOMR & ~( ETH_DMAOMR_ST );
 800217e:	6803      	ldr	r3, [r0, #0]
 8002180:	f241 0618 	movw	r6, #4120	; 0x1018
 8002184:	599b      	ldr	r3, [r3, r6]
 8002186:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800218a:	9303      	str	r3, [sp, #12]
	prvWriteDMAOMR( heth, tmpreg );
 800218c:	9903      	ldr	r1, [sp, #12]
 800218e:	f7ff fc94 	bl	8001aba <prvWriteDMAOMR>
	__IO uint32_t tmpreg = heth->Instance->DMAOMR & ~( ETH_DMAOMR_SR );
 8002192:	6823      	ldr	r3, [r4, #0]
 8002194:	599b      	ldr	r3, [r3, r6]
 8002196:	f023 0302 	bic.w	r3, r3, #2
 800219a:	9302      	str	r3, [sp, #8]
	prvWriteDMAOMR( heth, tmpreg );
 800219c:	9902      	ldr	r1, [sp, #8]
 800219e:	4620      	mov	r0, r4
 80021a0:	f7ff fc8b 	bl	8001aba <prvWriteDMAOMR>
	__IO uint32_t tmpreg = heth->Instance->MACCR & ~( ETH_MACCR_RE );
 80021a4:	6823      	ldr	r3, [r4, #0]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	f023 0304 	bic.w	r3, r3, #4
 80021ac:	9301      	str	r3, [sp, #4]
	prvWriteMACCR( heth, tmpreg );
 80021ae:	9901      	ldr	r1, [sp, #4]
 80021b0:	4620      	mov	r0, r4
 80021b2:	f7ff fc75 	bl	8001aa0 <prvWriteMACCR>
  ETH_FlushTransmitFIFO( heth );
 80021b6:	4620      	mov	r0, r4
 80021b8:	f7ff fc8e 	bl	8001ad8 <ETH_FlushTransmitFIFO>
	uint32_t tmpreg = heth->Instance->MACCR & ~( ETH_MACCR_TE );
 80021bc:	6823      	ldr	r3, [r4, #0]
 80021be:	6819      	ldr	r1, [r3, #0]
	prvWriteMACCR( heth, tmpreg );
 80021c0:	f021 0108 	bic.w	r1, r1, #8
 80021c4:	4620      	mov	r0, r4
 80021c6:	f7ff fc6b 	bl	8001aa0 <prvWriteMACCR>
  heth->State = HAL_ETH_STATE_READY;
 80021ca:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
  __HAL_UNLOCK( heth );
 80021ce:	2000      	movs	r0, #0
 80021d0:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 80021d4:	b004      	add	sp, #16
 80021d6:	bd70      	pop	{r4, r5, r6, pc}

080021d8 <HAL_ETH_ConfigMAC>:
	__HAL_LOCK( heth );
 80021d8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80021dc:	2b01      	cmp	r3, #1
 80021de:	f000 8082 	beq.w	80022e6 <HAL_ETH_ConfigMAC+0x10e>
{
 80021e2:	b570      	push	{r4, r5, r6, lr}
 80021e4:	460c      	mov	r4, r1
 80021e6:	4605      	mov	r5, r0
	__HAL_LOCK( heth );
 80021e8:	2301      	movs	r3, #1
 80021ea:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	heth->State= HAL_ETH_STATE_BUSY;
 80021ee:	2302      	movs	r3, #2
 80021f0:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
	if (macconf != NULL)
 80021f4:	2900      	cmp	r1, #0
 80021f6:	d06b      	beq.n	80022d0 <HAL_ETH_ConfigMAC+0xf8>
		tmpreg = heth->Instance->MACCR;
 80021f8:	6803      	ldr	r3, [r0, #0]
 80021fa:	681b      	ldr	r3, [r3, #0]
		tmpreg &= ETH_MACCR_CLEAR_MASK;
 80021fc:	493b      	ldr	r1, [pc, #236]	; (80022ec <HAL_ETH_ConfigMAC+0x114>)
 80021fe:	4019      	ands	r1, r3
			macconf->BackOffLimit |
 8002200:	6823      	ldr	r3, [r4, #0]
 8002202:	6862      	ldr	r2, [r4, #4]
 8002204:	4313      	orrs	r3, r2
 8002206:	68a2      	ldr	r2, [r4, #8]
 8002208:	4313      	orrs	r3, r2
 800220a:	68e2      	ldr	r2, [r4, #12]
 800220c:	4313      	orrs	r3, r2
 800220e:	6922      	ldr	r2, [r4, #16]
 8002210:	4313      	orrs	r3, r2
 8002212:	6962      	ldr	r2, [r4, #20]
 8002214:	4313      	orrs	r3, r2
 8002216:	69a2      	ldr	r2, [r4, #24]
 8002218:	4313      	orrs	r3, r2
 800221a:	69e2      	ldr	r2, [r4, #28]
 800221c:	4313      	orrs	r3, r2
 800221e:	6a22      	ldr	r2, [r4, #32]
 8002220:	4313      	orrs	r3, r2
 8002222:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002224:	4313      	orrs	r3, r2
 8002226:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002228:	4313      	orrs	r3, r2
 800222a:	6882      	ldr	r2, [r0, #8]
 800222c:	4313      	orrs	r3, r2
 800222e:	68c2      	ldr	r2, [r0, #12]
 8002230:	4313      	orrs	r3, r2
		prvWriteMACCR( heth, tmpreg );
 8002232:	4319      	orrs	r1, r3
 8002234:	f7ff fc34 	bl	8001aa0 <prvWriteMACCR>
		heth->Instance->MACFFR = (uint32_t)(
 8002238:	682a      	ldr	r2, [r5, #0]
			macconf->ReceiveAll |
 800223a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800223c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800223e:	430b      	orrs	r3, r1
			macconf->SourceAddrFilter |
 8002240:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8002242:	430b      	orrs	r3, r1
			macconf->PassControlFrames |
 8002244:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8002246:	430b      	orrs	r3, r1
			macconf->BroadcastFramesReception |
 8002248:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800224a:	430b      	orrs	r3, r1
			macconf->DestinationAddrFilter |
 800224c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800224e:	430b      	orrs	r3, r1
			macconf->PromiscuousMode |
 8002250:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8002252:	430b      	orrs	r3, r1
			macconf->MulticastFramesFilter |
 8002254:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8002256:	430b      	orrs	r3, r1
		heth->Instance->MACFFR = (uint32_t)(
 8002258:	6053      	str	r3, [r2, #4]
		tmpreg = heth->Instance->MACFFR;
 800225a:	682b      	ldr	r3, [r5, #0]
 800225c:	685e      	ldr	r6, [r3, #4]
		HAL_Delay(ETH_REG_WRITE_DELAY);
 800225e:	2001      	movs	r0, #1
 8002260:	f7fe f9e4 	bl	800062c <HAL_Delay>
		heth->Instance->MACFFR = tmpreg;
 8002264:	682b      	ldr	r3, [r5, #0]
 8002266:	605e      	str	r6, [r3, #4]
		heth->Instance->MACHTHR = (uint32_t)macconf->HashTableHigh;
 8002268:	682b      	ldr	r3, [r5, #0]
 800226a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800226c:	609a      	str	r2, [r3, #8]
		heth->Instance->MACHTLR = (uint32_t)macconf->HashTableLow;
 800226e:	682b      	ldr	r3, [r5, #0]
 8002270:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8002272:	60da      	str	r2, [r3, #12]
		tmpreg = heth->Instance->MACFCR;
 8002274:	6829      	ldr	r1, [r5, #0]
 8002276:	698a      	ldr	r2, [r1, #24]
		tmpreg &= ETH_MACFCR_CLEAR_MASK;
 8002278:	f022 02be 	bic.w	r2, r2, #190	; 0xbe
 800227c:	0412      	lsls	r2, r2, #16
 800227e:	0c12      	lsrs	r2, r2, #16
			macconf->ReceiveFlowControl |
 8002280:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002282:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 8002284:	431e      	orrs	r6, r3
 8002286:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002288:	431e      	orrs	r6, r3
 800228a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800228c:	431e      	orrs	r6, r3
 800228e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8002290:	431e      	orrs	r6, r3
			macconf->PauseTime << 16) |
 8002292:	6d63      	ldr	r3, [r4, #84]	; 0x54
			macconf->ReceiveFlowControl |
 8002294:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
		tmpreg |= (uint32_t)((
 8002298:	4316      	orrs	r6, r2
	heth->Instance->MACFCR = ulValue;
 800229a:	618e      	str	r6, [r1, #24]
	( void ) heth->Instance->MACFCR;
 800229c:	682b      	ldr	r3, [r5, #0]
 800229e:	699b      	ldr	r3, [r3, #24]
	HAL_Delay( ETH_REG_WRITE_DELAY );
 80022a0:	2001      	movs	r0, #1
 80022a2:	f7fe f9c3 	bl	800062c <HAL_Delay>
	heth->Instance->MACFCR = ulValue;
 80022a6:	682b      	ldr	r3, [r5, #0]
 80022a8:	619e      	str	r6, [r3, #24]
		heth->Instance->MACVLANTR = (uint32_t)(macconf->VLANTagComparison |
 80022aa:	682a      	ldr	r2, [r5, #0]
 80022ac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80022ae:	6f21      	ldr	r1, [r4, #112]	; 0x70
 80022b0:	430b      	orrs	r3, r1
 80022b2:	61d3      	str	r3, [r2, #28]
		tmpreg = heth->Instance->MACVLANTR;
 80022b4:	682b      	ldr	r3, [r5, #0]
 80022b6:	69dc      	ldr	r4, [r3, #28]
		HAL_Delay(ETH_REG_WRITE_DELAY);
 80022b8:	2001      	movs	r0, #1
 80022ba:	f7fe f9b7 	bl	800062c <HAL_Delay>
		heth->Instance->MACVLANTR = tmpreg;
 80022be:	682b      	ldr	r3, [r5, #0]
 80022c0:	61dc      	str	r4, [r3, #28]
	heth->State= HAL_ETH_STATE_READY;
 80022c2:	2301      	movs	r3, #1
 80022c4:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	__HAL_UNLOCK( heth );
 80022c8:	2000      	movs	r0, #0
 80022ca:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
	return HAL_OK;
 80022ce:	bd70      	pop	{r4, r5, r6, pc}
		tmpreg = heth->Instance->MACCR;
 80022d0:	6803      	ldr	r3, [r0, #0]
 80022d2:	681b      	ldr	r3, [r3, #0]
		tmpreg &= ~((uint32_t)0x00004800);
 80022d4:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
		tmpreg |= (uint32_t)(heth->Init.Speed | heth->Init.DuplexMode);
 80022d8:	6881      	ldr	r1, [r0, #8]
 80022da:	68c2      	ldr	r2, [r0, #12]
 80022dc:	4311      	orrs	r1, r2
		prvWriteMACCR( heth, tmpreg );
 80022de:	4319      	orrs	r1, r3
 80022e0:	f7ff fbde 	bl	8001aa0 <prvWriteMACCR>
 80022e4:	e7ed      	b.n	80022c2 <HAL_ETH_ConfigMAC+0xea>
	__HAL_LOCK( heth );
 80022e6:	2002      	movs	r0, #2
 80022e8:	4770      	bx	lr
 80022ea:	bf00      	nop
 80022ec:	ff20810f 	.word	0xff20810f

080022f0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80022f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 80022f4:	2500      	movs	r5, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80022f6:	4f69      	ldr	r7, [pc, #420]	; (800249c <HAL_GPIO_Init+0x1ac>)

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80022f8:	f8df e1ac 	ldr.w	lr, [pc, #428]	; 80024a8 <HAL_GPIO_Init+0x1b8>
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80022fc:	4e68      	ldr	r6, [pc, #416]	; (80024a0 <HAL_GPIO_Init+0x1b0>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80022fe:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 80024ac <HAL_GPIO_Init+0x1bc>
 8002302:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 80024b0 <HAL_GPIO_Init+0x1c0>
 8002306:	e057      	b.n	80023b8 <HAL_GPIO_Init+0xc8>
        temp = GPIOx->AFR[position >> 3];
 8002308:	08ec      	lsrs	r4, r5, #3
 800230a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800230e:	f8d4 c020 	ldr.w	ip, [r4, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8002312:	f005 0207 	and.w	r2, r5, #7
 8002316:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 800231a:	220f      	movs	r2, #15
 800231c:	fa02 f20b 	lsl.w	r2, r2, fp
 8002320:	ea2c 0c02 	bic.w	ip, ip, r2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8002324:	690a      	ldr	r2, [r1, #16]
 8002326:	fa02 f20b 	lsl.w	r2, r2, fp
 800232a:	ea42 020c 	orr.w	r2, r2, ip
        GPIOx->AFR[position >> 3] = temp;
 800232e:	6222      	str	r2, [r4, #32]
 8002330:	e04e      	b.n	80023d0 <HAL_GPIO_Init+0xe0>
        temp = GPIOx->OSPEEDR;
 8002332:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8002334:	ea02 0b04 	and.w	fp, r2, r4
        temp |= (GPIO_Init->Speed << (position * 2));
 8002338:	68cc      	ldr	r4, [r1, #12]
 800233a:	fa04 f40c 	lsl.w	r4, r4, ip
 800233e:	ea44 040b 	orr.w	r4, r4, fp
        GPIOx->OSPEEDR = temp;
 8002342:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 8002344:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002346:	ea24 0b03 	bic.w	fp, r4, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800234a:	684c      	ldr	r4, [r1, #4]
 800234c:	f3c4 1300 	ubfx	r3, r4, #4, #1
 8002350:	40ab      	lsls	r3, r5
 8002352:	ea43 030b 	orr.w	r3, r3, fp
        GPIOx->OTYPER = temp;
 8002356:	6043      	str	r3, [r0, #4]
 8002358:	e051      	b.n	80023fe <HAL_GPIO_Init+0x10e>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800235a:	2200      	movs	r2, #0
 800235c:	fa02 f20b 	lsl.w	r2, r2, fp
 8002360:	ea42 020c 	orr.w	r2, r2, ip
        SYSCFG->EXTICR[position >> 2] = temp;
 8002364:	609a      	str	r2, [r3, #8]
        temp = EXTI->IMR;
 8002366:	6833      	ldr	r3, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 8002368:	ea6f 0408 	mvn.w	r4, r8
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800236c:	684a      	ldr	r2, [r1, #4]
 800236e:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8002372:	bf0c      	ite	eq
 8002374:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 8002376:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->IMR = temp;
 800237a:	6033      	str	r3, [r6, #0]

        temp = EXTI->EMR;
 800237c:	6873      	ldr	r3, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800237e:	684a      	ldr	r2, [r1, #4]
 8002380:	f412 3f00 	tst.w	r2, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8002384:	bf0c      	ite	eq
 8002386:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 8002388:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->EMR = temp;
 800238c:	6073      	str	r3, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800238e:	68b2      	ldr	r2, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002390:	684b      	ldr	r3, [r1, #4]
 8002392:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8002396:	bf0c      	ite	eq
 8002398:	4022      	andeq	r2, r4
        {
          temp |= iocurrent;
 800239a:	ea48 0202 	orrne.w	r2, r8, r2
        }
        EXTI->RTSR = temp;
 800239e:	60b2      	str	r2, [r6, #8]

        temp = EXTI->FTSR;
 80023a0:	68f3      	ldr	r3, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80023a2:	684a      	ldr	r2, [r1, #4]
 80023a4:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
        temp &= ~((uint32_t)iocurrent);
 80023a8:	bf0c      	ite	eq
 80023aa:	4023      	andeq	r3, r4
        {
          temp |= iocurrent;
 80023ac:	ea48 0303 	orrne.w	r3, r8, r3
        }
        EXTI->FTSR = temp;
 80023b0:	60f3      	str	r3, [r6, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 80023b2:	3501      	adds	r5, #1
 80023b4:	2d10      	cmp	r5, #16
 80023b6:	d06f      	beq.n	8002498 <HAL_GPIO_Init+0x1a8>
    ioposition = ((uint32_t)0x01) << position;
 80023b8:	2301      	movs	r3, #1
 80023ba:	40ab      	lsls	r3, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80023bc:	680a      	ldr	r2, [r1, #0]
 80023be:	ea03 0802 	and.w	r8, r3, r2
    if(iocurrent == ioposition)
 80023c2:	4543      	cmp	r3, r8
 80023c4:	d1f5      	bne.n	80023b2 <HAL_GPIO_Init+0xc2>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80023c6:	684a      	ldr	r2, [r1, #4]
 80023c8:	f022 0210 	bic.w	r2, r2, #16
 80023cc:	2a02      	cmp	r2, #2
 80023ce:	d09b      	beq.n	8002308 <HAL_GPIO_Init+0x18>
      temp = GPIOx->MODER;
 80023d0:	6804      	ldr	r4, [r0, #0]
 80023d2:	ea4f 0c45 	mov.w	ip, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80023d6:	2203      	movs	r2, #3
 80023d8:	fa02 f20c 	lsl.w	r2, r2, ip
 80023dc:	43d2      	mvns	r2, r2
 80023de:	ea04 0b02 	and.w	fp, r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80023e2:	684c      	ldr	r4, [r1, #4]
 80023e4:	f004 0403 	and.w	r4, r4, #3
 80023e8:	fa04 f40c 	lsl.w	r4, r4, ip
 80023ec:	ea44 040b 	orr.w	r4, r4, fp
      GPIOx->MODER = temp;
 80023f0:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80023f2:	684c      	ldr	r4, [r1, #4]
 80023f4:	f024 0410 	bic.w	r4, r4, #16
 80023f8:	3c01      	subs	r4, #1
 80023fa:	2c01      	cmp	r4, #1
 80023fc:	d999      	bls.n	8002332 <HAL_GPIO_Init+0x42>
      temp = GPIOx->PUPDR;
 80023fe:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8002400:	401a      	ands	r2, r3
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8002402:	688b      	ldr	r3, [r1, #8]
 8002404:	fa03 f30c 	lsl.w	r3, r3, ip
 8002408:	4313      	orrs	r3, r2
      GPIOx->PUPDR = temp;
 800240a:	60c3      	str	r3, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800240c:	684b      	ldr	r3, [r1, #4]
 800240e:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8002412:	d0ce      	beq.n	80023b2 <HAL_GPIO_Init+0xc2>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002414:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002416:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800241a:	647b      	str	r3, [r7, #68]	; 0x44
 800241c:	f025 0303 	bic.w	r3, r5, #3
 8002420:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002424:	f503 339c 	add.w	r3, r3, #79872	; 0x13800
        temp = SYSCFG->EXTICR[position >> 2];
 8002428:	689c      	ldr	r4, [r3, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800242a:	f005 0203 	and.w	r2, r5, #3
 800242e:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 8002432:	220f      	movs	r2, #15
 8002434:	fa02 f20b 	lsl.w	r2, r2, fp
 8002438:	ea24 0c02 	bic.w	ip, r4, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800243c:	4570      	cmp	r0, lr
 800243e:	d08c      	beq.n	800235a <HAL_GPIO_Init+0x6a>
 8002440:	4548      	cmp	r0, r9
 8002442:	d01b      	beq.n	800247c <HAL_GPIO_Init+0x18c>
 8002444:	4550      	cmp	r0, sl
 8002446:	d01b      	beq.n	8002480 <HAL_GPIO_Init+0x190>
 8002448:	4a16      	ldr	r2, [pc, #88]	; (80024a4 <HAL_GPIO_Init+0x1b4>)
 800244a:	4290      	cmp	r0, r2
 800244c:	d01a      	beq.n	8002484 <HAL_GPIO_Init+0x194>
 800244e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002452:	4290      	cmp	r0, r2
 8002454:	d018      	beq.n	8002488 <HAL_GPIO_Init+0x198>
 8002456:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800245a:	4290      	cmp	r0, r2
 800245c:	d016      	beq.n	800248c <HAL_GPIO_Init+0x19c>
 800245e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002462:	4290      	cmp	r0, r2
 8002464:	d014      	beq.n	8002490 <HAL_GPIO_Init+0x1a0>
 8002466:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800246a:	4290      	cmp	r0, r2
 800246c:	d012      	beq.n	8002494 <HAL_GPIO_Init+0x1a4>
 800246e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002472:	4290      	cmp	r0, r2
 8002474:	bf0c      	ite	eq
 8002476:	2208      	moveq	r2, #8
 8002478:	2209      	movne	r2, #9
 800247a:	e76f      	b.n	800235c <HAL_GPIO_Init+0x6c>
 800247c:	2201      	movs	r2, #1
 800247e:	e76d      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002480:	2202      	movs	r2, #2
 8002482:	e76b      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002484:	2203      	movs	r2, #3
 8002486:	e769      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002488:	2204      	movs	r2, #4
 800248a:	e767      	b.n	800235c <HAL_GPIO_Init+0x6c>
 800248c:	2205      	movs	r2, #5
 800248e:	e765      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002490:	2206      	movs	r2, #6
 8002492:	e763      	b.n	800235c <HAL_GPIO_Init+0x6c>
 8002494:	2207      	movs	r2, #7
 8002496:	e761      	b.n	800235c <HAL_GPIO_Init+0x6c>
      }
    }
  }
}
 8002498:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800249c:	40023800 	.word	0x40023800
 80024a0:	40013c00 	.word	0x40013c00
 80024a4:	40020c00 	.word	0x40020c00
 80024a8:	40020000 	.word	0x40020000
 80024ac:	40020400 	.word	0x40020400
 80024b0:	40020800 	.word	0x40020800

080024b4 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80024b4:	6943      	ldr	r3, [r0, #20]
 80024b6:	4059      	eors	r1, r3
 80024b8:	6141      	str	r1, [r0, #20]
 80024ba:	4770      	bx	lr

080024bc <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80024bc:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 80024be:	4b05      	ldr	r3, [pc, #20]	; (80024d4 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 80024c0:	695b      	ldr	r3, [r3, #20]
 80024c2:	4203      	tst	r3, r0
 80024c4:	d100      	bne.n	80024c8 <HAL_GPIO_EXTI_IRQHandler+0xc>
 80024c6:	bd08      	pop	{r3, pc}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80024c8:	4b02      	ldr	r3, [pc, #8]	; (80024d4 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 80024ca:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80024cc:	f000 fe72 	bl	80031b4 <HAL_GPIO_EXTI_Callback>
  }
}
 80024d0:	e7f9      	b.n	80024c6 <HAL_GPIO_EXTI_IRQHandler+0xa>
 80024d2:	bf00      	nop
 80024d4:	40013c00 	.word	0x40013c00

080024d8 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80024d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80024da:	4604      	mov	r4, r0
  uint32_t tickstart = 0;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80024dc:	6803      	ldr	r3, [r0, #0]
 80024de:	f013 0f01 	tst.w	r3, #1
 80024e2:	d02d      	beq.n	8002540 <HAL_RCC_OscConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80024e4:	4bae      	ldr	r3, [pc, #696]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80024e6:	689b      	ldr	r3, [r3, #8]
 80024e8:	f003 030c 	and.w	r3, r3, #12
 80024ec:	2b04      	cmp	r3, #4
 80024ee:	d01e      	beq.n	800252e <HAL_RCC_OscConfig+0x56>
 80024f0:	4bab      	ldr	r3, [pc, #684]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80024f2:	689b      	ldr	r3, [r3, #8]
 80024f4:	f003 030c 	and.w	r3, r3, #12
 80024f8:	2b08      	cmp	r3, #8
 80024fa:	d013      	beq.n	8002524 <HAL_RCC_OscConfig+0x4c>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 80024fc:	2200      	movs	r2, #0
 80024fe:	4ba9      	ldr	r3, [pc, #676]	; (80027a4 <HAL_RCC_OscConfig+0x2cc>)
 8002500:	701a      	strb	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002502:	f7fe f88d 	bl	8000620 <HAL_GetTick>
 8002506:	4607      	mov	r7, r0

      /* Wait till HSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002508:	4da5      	ldr	r5, [pc, #660]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800250a:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800250e:	682b      	ldr	r3, [r5, #0]
 8002510:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002514:	d038      	beq.n	8002588 <HAL_RCC_OscConfig+0xb0>
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002516:	f7fe f883 	bl	8000620 <HAL_GetTick>
 800251a:	1bc0      	subs	r0, r0, r7
 800251c:	42b0      	cmp	r0, r6
 800251e:	d9f6      	bls.n	800250e <HAL_RCC_OscConfig+0x36>
        {
          return HAL_TIMEOUT;
 8002520:	2003      	movs	r0, #3
 8002522:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002524:	4b9e      	ldr	r3, [pc, #632]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002526:	685b      	ldr	r3, [r3, #4]
 8002528:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 800252c:	d0e6      	beq.n	80024fc <HAL_RCC_OscConfig+0x24>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800252e:	4b9c      	ldr	r3, [pc, #624]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002530:	681b      	ldr	r3, [r3, #0]
 8002532:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002536:	d003      	beq.n	8002540 <HAL_RCC_OscConfig+0x68>
 8002538:	6863      	ldr	r3, [r4, #4]
 800253a:	2b00      	cmp	r3, #0
 800253c:	f000 818e 	beq.w	800285c <HAL_RCC_OscConfig+0x384>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002540:	6823      	ldr	r3, [r4, #0]
 8002542:	f013 0f02 	tst.w	r3, #2
 8002546:	d064      	beq.n	8002612 <HAL_RCC_OscConfig+0x13a>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002548:	4b95      	ldr	r3, [pc, #596]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 800254a:	689b      	ldr	r3, [r3, #8]
 800254c:	f013 0f0c 	tst.w	r3, #12
 8002550:	d046      	beq.n	80025e0 <HAL_RCC_OscConfig+0x108>
 8002552:	4b93      	ldr	r3, [pc, #588]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002554:	689b      	ldr	r3, [r3, #8]
 8002556:	f003 030c 	and.w	r3, r3, #12
 800255a:	2b08      	cmp	r3, #8
 800255c:	d03b      	beq.n	80025d6 <HAL_RCC_OscConfig+0xfe>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800255e:	68e3      	ldr	r3, [r4, #12]
 8002560:	2b00      	cmp	r3, #0
 8002562:	d07f      	beq.n	8002664 <HAL_RCC_OscConfig+0x18c>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8002564:	2201      	movs	r2, #1
 8002566:	4b90      	ldr	r3, [pc, #576]	; (80027a8 <HAL_RCC_OscConfig+0x2d0>)
 8002568:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800256a:	f7fe f859 	bl	8000620 <HAL_GetTick>
 800256e:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002570:	4d8b      	ldr	r5, [pc, #556]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002572:	682b      	ldr	r3, [r5, #0]
 8002574:	f013 0f02 	tst.w	r3, #2
 8002578:	d164      	bne.n	8002644 <HAL_RCC_OscConfig+0x16c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800257a:	f7fe f851 	bl	8000620 <HAL_GetTick>
 800257e:	1b80      	subs	r0, r0, r6
 8002580:	2864      	cmp	r0, #100	; 0x64
 8002582:	d9f6      	bls.n	8002572 <HAL_RCC_OscConfig+0x9a>
          {
            return HAL_TIMEOUT;
 8002584:	2003      	movs	r0, #3
 8002586:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002588:	7922      	ldrb	r2, [r4, #4]
 800258a:	4b86      	ldr	r3, [pc, #536]	; (80027a4 <HAL_RCC_OscConfig+0x2cc>)
 800258c:	701a      	strb	r2, [r3, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800258e:	6863      	ldr	r3, [r4, #4]
 8002590:	b183      	cbz	r3, 80025b4 <HAL_RCC_OscConfig+0xdc>
        tickstart = HAL_GetTick();
 8002592:	f7fe f845 	bl	8000620 <HAL_GetTick>
 8002596:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002598:	4d81      	ldr	r5, [pc, #516]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800259a:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800259e:	682b      	ldr	r3, [r5, #0]
 80025a0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80025a4:	d1cc      	bne.n	8002540 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025a6:	f7fe f83b 	bl	8000620 <HAL_GetTick>
 80025aa:	1bc0      	subs	r0, r0, r7
 80025ac:	42b0      	cmp	r0, r6
 80025ae:	d9f6      	bls.n	800259e <HAL_RCC_OscConfig+0xc6>
            return HAL_TIMEOUT;
 80025b0:	2003      	movs	r0, #3
 80025b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tickstart = HAL_GetTick();
 80025b4:	f7fe f834 	bl	8000620 <HAL_GetTick>
 80025b8:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80025ba:	4d79      	ldr	r5, [pc, #484]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025bc:	f241 3688 	movw	r6, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80025c0:	682b      	ldr	r3, [r5, #0]
 80025c2:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80025c6:	d0bb      	beq.n	8002540 <HAL_RCC_OscConfig+0x68>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025c8:	f7fe f82a 	bl	8000620 <HAL_GetTick>
 80025cc:	1bc0      	subs	r0, r0, r7
 80025ce:	42b0      	cmp	r0, r6
 80025d0:	d9f6      	bls.n	80025c0 <HAL_RCC_OscConfig+0xe8>
            return HAL_TIMEOUT;
 80025d2:	2003      	movs	r0, #3
 80025d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80025d6:	4b72      	ldr	r3, [pc, #456]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80025d8:	685b      	ldr	r3, [r3, #4]
 80025da:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80025de:	d1be      	bne.n	800255e <HAL_RCC_OscConfig+0x86>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80025e0:	4b6f      	ldr	r3, [pc, #444]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80025e2:	681b      	ldr	r3, [r3, #0]
 80025e4:	f013 0f02 	tst.w	r3, #2
 80025e8:	d004      	beq.n	80025f4 <HAL_RCC_OscConfig+0x11c>
 80025ea:	68e3      	ldr	r3, [r4, #12]
 80025ec:	2b01      	cmp	r3, #1
 80025ee:	d001      	beq.n	80025f4 <HAL_RCC_OscConfig+0x11c>
        return HAL_ERROR;
 80025f0:	2001      	movs	r0, #1
 80025f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80025f4:	486a      	ldr	r0, [pc, #424]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80025f6:	6802      	ldr	r2, [r0, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80025f8:	23f8      	movs	r3, #248	; 0xf8
 80025fa:	fa93 f3a3 	rbit	r3, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
{
  uint32_t result;

  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80025fe:	fab3 f383 	clz	r3, r3
 8002602:	b2db      	uxtb	r3, r3
 8002604:	6921      	ldr	r1, [r4, #16]
 8002606:	fa01 f303 	lsl.w	r3, r1, r3
 800260a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800260e:	4313      	orrs	r3, r2
 8002610:	6003      	str	r3, [r0, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002612:	6823      	ldr	r3, [r4, #0]
 8002614:	f013 0f08 	tst.w	r3, #8
 8002618:	d048      	beq.n	80026ac <HAL_RCC_OscConfig+0x1d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800261a:	6963      	ldr	r3, [r4, #20]
 800261c:	2b00      	cmp	r3, #0
 800261e:	d033      	beq.n	8002688 <HAL_RCC_OscConfig+0x1b0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002620:	2201      	movs	r2, #1
 8002622:	4b62      	ldr	r3, [pc, #392]	; (80027ac <HAL_RCC_OscConfig+0x2d4>)
 8002624:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002626:	f7fd fffb 	bl	8000620 <HAL_GetTick>
 800262a:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800262c:	4d5c      	ldr	r5, [pc, #368]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 800262e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002630:	f013 0f02 	tst.w	r3, #2
 8002634:	d13a      	bne.n	80026ac <HAL_RCC_OscConfig+0x1d4>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002636:	f7fd fff3 	bl	8000620 <HAL_GetTick>
 800263a:	1b80      	subs	r0, r0, r6
 800263c:	2864      	cmp	r0, #100	; 0x64
 800263e:	d9f6      	bls.n	800262e <HAL_RCC_OscConfig+0x156>
        {
          return HAL_TIMEOUT;
 8002640:	2003      	movs	r0, #3
 8002642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002644:	4856      	ldr	r0, [pc, #344]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002646:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002648:	23f8      	movs	r3, #248	; 0xf8
 800264a:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 800264e:	fab3 f383 	clz	r3, r3
 8002652:	b2db      	uxtb	r3, r3
 8002654:	6921      	ldr	r1, [r4, #16]
 8002656:	fa01 f303 	lsl.w	r3, r1, r3
 800265a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800265e:	4313      	orrs	r3, r2
 8002660:	6003      	str	r3, [r0, #0]
 8002662:	e7d6      	b.n	8002612 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_DISABLE();
 8002664:	2200      	movs	r2, #0
 8002666:	4b50      	ldr	r3, [pc, #320]	; (80027a8 <HAL_RCC_OscConfig+0x2d0>)
 8002668:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800266a:	f7fd ffd9 	bl	8000620 <HAL_GetTick>
 800266e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002670:	4d4b      	ldr	r5, [pc, #300]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002672:	682b      	ldr	r3, [r5, #0]
 8002674:	f013 0f02 	tst.w	r3, #2
 8002678:	d0cb      	beq.n	8002612 <HAL_RCC_OscConfig+0x13a>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800267a:	f7fd ffd1 	bl	8000620 <HAL_GetTick>
 800267e:	1b80      	subs	r0, r0, r6
 8002680:	2864      	cmp	r0, #100	; 0x64
 8002682:	d9f6      	bls.n	8002672 <HAL_RCC_OscConfig+0x19a>
            return HAL_TIMEOUT;
 8002684:	2003      	movs	r0, #3
 8002686:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002688:	2200      	movs	r2, #0
 800268a:	4b48      	ldr	r3, [pc, #288]	; (80027ac <HAL_RCC_OscConfig+0x2d4>)
 800268c:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800268e:	f7fd ffc7 	bl	8000620 <HAL_GetTick>
 8002692:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002694:	4d42      	ldr	r5, [pc, #264]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 8002696:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002698:	f013 0f02 	tst.w	r3, #2
 800269c:	d006      	beq.n	80026ac <HAL_RCC_OscConfig+0x1d4>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800269e:	f7fd ffbf 	bl	8000620 <HAL_GetTick>
 80026a2:	1b80      	subs	r0, r0, r6
 80026a4:	2864      	cmp	r0, #100	; 0x64
 80026a6:	d9f6      	bls.n	8002696 <HAL_RCC_OscConfig+0x1be>
        {
          return HAL_TIMEOUT;
 80026a8:	2003      	movs	r0, #3
 80026aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80026ac:	6823      	ldr	r3, [r4, #0]
 80026ae:	f013 0f04 	tst.w	r3, #4
 80026b2:	d11f      	bne.n	80026f4 <HAL_RCC_OscConfig+0x21c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80026b4:	69a3      	ldr	r3, [r4, #24]
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	f000 80d2 	beq.w	8002860 <HAL_RCC_OscConfig+0x388>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80026bc:	4a38      	ldr	r2, [pc, #224]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80026be:	6892      	ldr	r2, [r2, #8]
 80026c0:	f002 020c 	and.w	r2, r2, #12
 80026c4:	2a08      	cmp	r2, #8
 80026c6:	f000 80cd 	beq.w	8002864 <HAL_RCC_OscConfig+0x38c>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80026ca:	2b02      	cmp	r3, #2
 80026cc:	d076      	beq.n	80027bc <HAL_RCC_OscConfig+0x2e4>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80026ce:	2200      	movs	r2, #0
 80026d0:	4b37      	ldr	r3, [pc, #220]	; (80027b0 <HAL_RCC_OscConfig+0x2d8>)
 80026d2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80026d4:	f7fd ffa4 	bl	8000620 <HAL_GetTick>
 80026d8:	4605      	mov	r5, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80026da:	4c31      	ldr	r4, [pc, #196]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80026dc:	6823      	ldr	r3, [r4, #0]
 80026de:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80026e2:	f000 80b9 	beq.w	8002858 <HAL_RCC_OscConfig+0x380>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80026e6:	f7fd ff9b 	bl	8000620 <HAL_GetTick>
 80026ea:	1b40      	subs	r0, r0, r5
 80026ec:	2864      	cmp	r0, #100	; 0x64
 80026ee:	d9f5      	bls.n	80026dc <HAL_RCC_OscConfig+0x204>
          {
            return HAL_TIMEOUT;
 80026f0:	2003      	movs	r0, #3
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80026f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 80026f4:	4a2a      	ldr	r2, [pc, #168]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
 80026f6:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80026f8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80026fc:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_DBP;
 80026fe:	f5a2 32e4 	sub.w	r2, r2, #116736	; 0x1c800
 8002702:	6813      	ldr	r3, [r2, #0]
 8002704:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002708:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800270a:	f7fd ff89 	bl	8000620 <HAL_GetTick>
 800270e:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8002710:	4d28      	ldr	r5, [pc, #160]	; (80027b4 <HAL_RCC_OscConfig+0x2dc>)
 8002712:	682b      	ldr	r3, [r5, #0]
 8002714:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002718:	d106      	bne.n	8002728 <HAL_RCC_OscConfig+0x250>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800271a:	f7fd ff81 	bl	8000620 <HAL_GetTick>
 800271e:	1b80      	subs	r0, r0, r6
 8002720:	2864      	cmp	r0, #100	; 0x64
 8002722:	d9f6      	bls.n	8002712 <HAL_RCC_OscConfig+0x23a>
        return HAL_TIMEOUT;
 8002724:	2003      	movs	r0, #3
 8002726:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8002728:	2200      	movs	r2, #0
 800272a:	4b23      	ldr	r3, [pc, #140]	; (80027b8 <HAL_RCC_OscConfig+0x2e0>)
 800272c:	701a      	strb	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800272e:	f7fd ff77 	bl	8000620 <HAL_GetTick>
 8002732:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002734:	4d1a      	ldr	r5, [pc, #104]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002736:	f241 3688 	movw	r6, #5000	; 0x1388
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800273a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800273c:	f013 0f02 	tst.w	r3, #2
 8002740:	d006      	beq.n	8002750 <HAL_RCC_OscConfig+0x278>
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002742:	f7fd ff6d 	bl	8000620 <HAL_GetTick>
 8002746:	1bc0      	subs	r0, r0, r7
 8002748:	42b0      	cmp	r0, r6
 800274a:	d9f6      	bls.n	800273a <HAL_RCC_OscConfig+0x262>
        return HAL_TIMEOUT;
 800274c:	2003      	movs	r0, #3
 800274e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002750:	7a22      	ldrb	r2, [r4, #8]
 8002752:	4b19      	ldr	r3, [pc, #100]	; (80027b8 <HAL_RCC_OscConfig+0x2e0>)
 8002754:	701a      	strb	r2, [r3, #0]
    if((RCC_OscInitStruct->LSEState) == RCC_LSE_ON)
 8002756:	68a3      	ldr	r3, [r4, #8]
 8002758:	2b01      	cmp	r3, #1
 800275a:	d010      	beq.n	800277e <HAL_RCC_OscConfig+0x2a6>
      tickstart = HAL_GetTick();
 800275c:	f7fd ff60 	bl	8000620 <HAL_GetTick>
 8002760:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002762:	4d0f      	ldr	r5, [pc, #60]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002764:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002768:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800276a:	f013 0f02 	tst.w	r3, #2
 800276e:	d0a1      	beq.n	80026b4 <HAL_RCC_OscConfig+0x1dc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002770:	f7fd ff56 	bl	8000620 <HAL_GetTick>
 8002774:	1bc0      	subs	r0, r0, r7
 8002776:	42b0      	cmp	r0, r6
 8002778:	d9f6      	bls.n	8002768 <HAL_RCC_OscConfig+0x290>
          return HAL_TIMEOUT;
 800277a:	2003      	movs	r0, #3
 800277c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tickstart = HAL_GetTick();
 800277e:	f7fd ff4f 	bl	8000620 <HAL_GetTick>
 8002782:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002784:	4d06      	ldr	r5, [pc, #24]	; (80027a0 <HAL_RCC_OscConfig+0x2c8>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002786:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800278a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800278c:	f013 0f02 	tst.w	r3, #2
 8002790:	d190      	bne.n	80026b4 <HAL_RCC_OscConfig+0x1dc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002792:	f7fd ff45 	bl	8000620 <HAL_GetTick>
 8002796:	1bc0      	subs	r0, r0, r7
 8002798:	42b0      	cmp	r0, r6
 800279a:	d9f6      	bls.n	800278a <HAL_RCC_OscConfig+0x2b2>
          return HAL_TIMEOUT;
 800279c:	2003      	movs	r0, #3
 800279e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80027a0:	40023800 	.word	0x40023800
 80027a4:	40023802 	.word	0x40023802
 80027a8:	42470000 	.word	0x42470000
 80027ac:	42470e80 	.word	0x42470e80
 80027b0:	42470060 	.word	0x42470060
 80027b4:	40007000 	.word	0x40007000
 80027b8:	40023870 	.word	0x40023870
        __HAL_RCC_PLL_DISABLE();
 80027bc:	2200      	movs	r2, #0
 80027be:	4b2a      	ldr	r3, [pc, #168]	; (8002868 <HAL_RCC_OscConfig+0x390>)
 80027c0:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80027c2:	f7fd ff2d 	bl	8000620 <HAL_GetTick>
 80027c6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80027c8:	4d28      	ldr	r5, [pc, #160]	; (800286c <HAL_RCC_OscConfig+0x394>)
 80027ca:	682b      	ldr	r3, [r5, #0]
 80027cc:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80027d0:	d006      	beq.n	80027e0 <HAL_RCC_OscConfig+0x308>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80027d2:	f7fd ff25 	bl	8000620 <HAL_GetTick>
 80027d6:	1b80      	subs	r0, r0, r6
 80027d8:	2864      	cmp	r0, #100	; 0x64
 80027da:	d9f6      	bls.n	80027ca <HAL_RCC_OscConfig+0x2f2>
            return HAL_TIMEOUT;
 80027dc:	2003      	movs	r0, #3
 80027de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80027e0:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80027e4:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80027e8:	fab2 f282 	clz	r2, r2
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80027ec:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 80027f0:	fa90 f0a0 	rbit	r0, r0
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 80027f4:	fab0 f080 	clz	r0, r0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80027f8:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 80027fc:	fa91 f1a1 	rbit	r1, r1
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002800:	fab1 f181 	clz	r1, r1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002804:	6a23      	ldr	r3, [r4, #32]
 8002806:	69e5      	ldr	r5, [r4, #28]
 8002808:	432b      	orrs	r3, r5
 800280a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800280e:	b2d2      	uxtb	r2, r2
 8002810:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8002812:	fa05 f202 	lsl.w	r2, r5, r2
 8002816:	4313      	orrs	r3, r2
 8002818:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800281a:	0852      	lsrs	r2, r2, #1
 800281c:	3a01      	subs	r2, #1
 800281e:	b2c0      	uxtb	r0, r0
 8002820:	4082      	lsls	r2, r0
 8002822:	4313      	orrs	r3, r2
 8002824:	b2c9      	uxtb	r1, r1
 8002826:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002828:	408a      	lsls	r2, r1
 800282a:	4313      	orrs	r3, r2
 800282c:	4a0f      	ldr	r2, [pc, #60]	; (800286c <HAL_RCC_OscConfig+0x394>)
 800282e:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 8002830:	2201      	movs	r2, #1
 8002832:	4b0d      	ldr	r3, [pc, #52]	; (8002868 <HAL_RCC_OscConfig+0x390>)
 8002834:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002836:	f7fd fef3 	bl	8000620 <HAL_GetTick>
 800283a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800283c:	4c0b      	ldr	r4, [pc, #44]	; (800286c <HAL_RCC_OscConfig+0x394>)
 800283e:	6823      	ldr	r3, [r4, #0]
 8002840:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002844:	d106      	bne.n	8002854 <HAL_RCC_OscConfig+0x37c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002846:	f7fd feeb 	bl	8000620 <HAL_GetTick>
 800284a:	1b40      	subs	r0, r0, r5
 800284c:	2864      	cmp	r0, #100	; 0x64
 800284e:	d9f6      	bls.n	800283e <HAL_RCC_OscConfig+0x366>
            return HAL_TIMEOUT;
 8002850:	2003      	movs	r0, #3
 8002852:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8002854:	2000      	movs	r0, #0
 8002856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002858:	2000      	movs	r0, #0
 800285a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_ERROR;
 800285c:	2001      	movs	r0, #1
 800285e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 8002860:	2000      	movs	r0, #0
 8002862:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_ERROR;
 8002864:	2001      	movs	r0, #1
 8002866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002868:	42470060 	.word	0x42470060
 800286c:	40023800 	.word	0x40023800

08002870 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8002870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002874:	4604      	mov	r4, r0
 8002876:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002878:	4b87      	ldr	r3, [pc, #540]	; (8002a98 <HAL_RCC_ClockConfig+0x228>)
 800287a:	681b      	ldr	r3, [r3, #0]
 800287c:	f003 030f 	and.w	r3, r3, #15
 8002880:	428b      	cmp	r3, r1
 8002882:	d274      	bcs.n	800296e <HAL_RCC_ClockConfig+0xfe>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002884:	b2ca      	uxtb	r2, r1
 8002886:	4b84      	ldr	r3, [pc, #528]	; (8002a98 <HAL_RCC_ClockConfig+0x228>)
 8002888:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800288a:	681b      	ldr	r3, [r3, #0]
 800288c:	f003 030f 	and.w	r3, r3, #15
 8002890:	4299      	cmp	r1, r3
 8002892:	d002      	beq.n	800289a <HAL_RCC_ClockConfig+0x2a>
    {
      return HAL_ERROR;
 8002894:	2001      	movs	r0, #1
 8002896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800289a:	6803      	ldr	r3, [r0, #0]
 800289c:	f013 0f02 	tst.w	r3, #2
 80028a0:	d006      	beq.n	80028b0 <HAL_RCC_ClockConfig+0x40>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80028a2:	4a7e      	ldr	r2, [pc, #504]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80028a4:	6893      	ldr	r3, [r2, #8]
 80028a6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80028aa:	6881      	ldr	r1, [r0, #8]
 80028ac:	430b      	orrs	r3, r1
 80028ae:	6093      	str	r3, [r2, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80028b0:	6823      	ldr	r3, [r4, #0]
 80028b2:	f013 0f01 	tst.w	r3, #1
 80028b6:	f000 80cb 	beq.w	8002a50 <HAL_RCC_ClockConfig+0x1e0>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80028ba:	6862      	ldr	r2, [r4, #4]
 80028bc:	2a01      	cmp	r2, #1
 80028be:	d025      	beq.n	800290c <HAL_RCC_ClockConfig+0x9c>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80028c0:	2a02      	cmp	r2, #2
 80028c2:	d02b      	beq.n	800291c <HAL_RCC_ClockConfig+0xac>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80028c4:	4b75      	ldr	r3, [pc, #468]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80028c6:	681b      	ldr	r3, [r3, #0]
 80028c8:	f013 0f02 	tst.w	r3, #2
 80028cc:	f000 80dd 	beq.w	8002a8a <HAL_RCC_ClockConfig+0x21a>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80028d0:	4972      	ldr	r1, [pc, #456]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80028d2:	688b      	ldr	r3, [r1, #8]
 80028d4:	f023 0303 	bic.w	r3, r3, #3
 80028d8:	4313      	orrs	r3, r2
 80028da:	608b      	str	r3, [r1, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80028dc:	f7fd fea0 	bl	8000620 <HAL_GetTick>
 80028e0:	4605      	mov	r5, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80028e2:	6863      	ldr	r3, [r4, #4]
 80028e4:	2b01      	cmp	r3, #1
 80028e6:	d021      	beq.n	800292c <HAL_RCC_ClockConfig+0xbc>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80028e8:	2b02      	cmp	r3, #2
 80028ea:	d030      	beq.n	800294e <HAL_RCC_ClockConfig+0xde>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80028ec:	4e6b      	ldr	r6, [pc, #428]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80028ee:	f241 3788 	movw	r7, #5000	; 0x1388
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80028f2:	68b3      	ldr	r3, [r6, #8]
 80028f4:	f013 0f0c 	tst.w	r3, #12
 80028f8:	f000 80aa 	beq.w	8002a50 <HAL_RCC_ClockConfig+0x1e0>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80028fc:	f7fd fe90 	bl	8000620 <HAL_GetTick>
 8002900:	1b40      	subs	r0, r0, r5
 8002902:	42b8      	cmp	r0, r7
 8002904:	d9f5      	bls.n	80028f2 <HAL_RCC_ClockConfig+0x82>
          {
            return HAL_TIMEOUT;
 8002906:	2003      	movs	r0, #3
 8002908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800290c:	4b63      	ldr	r3, [pc, #396]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 800290e:	681b      	ldr	r3, [r3, #0]
 8002910:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002914:	d1dc      	bne.n	80028d0 <HAL_RCC_ClockConfig+0x60>
          return HAL_ERROR;
 8002916:	2001      	movs	r0, #1
 8002918:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800291c:	4b5f      	ldr	r3, [pc, #380]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8002924:	d1d4      	bne.n	80028d0 <HAL_RCC_ClockConfig+0x60>
          return HAL_ERROR;
 8002926:	2001      	movs	r0, #1
 8002928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 800292c:	4e5b      	ldr	r6, [pc, #364]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800292e:	f241 3788 	movw	r7, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8002932:	68b3      	ldr	r3, [r6, #8]
 8002934:	f003 030c 	and.w	r3, r3, #12
 8002938:	2b04      	cmp	r3, #4
 800293a:	f000 8089 	beq.w	8002a50 <HAL_RCC_ClockConfig+0x1e0>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800293e:	f7fd fe6f 	bl	8000620 <HAL_GetTick>
 8002942:	1b40      	subs	r0, r0, r5
 8002944:	42b8      	cmp	r0, r7
 8002946:	d9f4      	bls.n	8002932 <HAL_RCC_ClockConfig+0xc2>
            return HAL_TIMEOUT;
 8002948:	2003      	movs	r0, #3
 800294a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800294e:	4e53      	ldr	r6, [pc, #332]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002950:	f241 3788 	movw	r7, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002954:	68b3      	ldr	r3, [r6, #8]
 8002956:	f003 030c 	and.w	r3, r3, #12
 800295a:	2b08      	cmp	r3, #8
 800295c:	d078      	beq.n	8002a50 <HAL_RCC_ClockConfig+0x1e0>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800295e:	f7fd fe5f 	bl	8000620 <HAL_GetTick>
 8002962:	1b40      	subs	r0, r0, r5
 8002964:	42b8      	cmp	r0, r7
 8002966:	d9f5      	bls.n	8002954 <HAL_RCC_ClockConfig+0xe4>
            return HAL_TIMEOUT;
 8002968:	2003      	movs	r0, #3
 800296a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800296e:	6803      	ldr	r3, [r0, #0]
 8002970:	f013 0f02 	tst.w	r3, #2
 8002974:	d006      	beq.n	8002984 <HAL_RCC_ClockConfig+0x114>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002976:	4a49      	ldr	r2, [pc, #292]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002978:	6893      	ldr	r3, [r2, #8]
 800297a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800297e:	6881      	ldr	r1, [r0, #8]
 8002980:	430b      	orrs	r3, r1
 8002982:	6093      	str	r3, [r2, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002984:	6823      	ldr	r3, [r4, #0]
 8002986:	f013 0f01 	tst.w	r3, #1
 800298a:	d056      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
    {
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800298c:	6862      	ldr	r2, [r4, #4]
 800298e:	2a01      	cmp	r2, #1
 8002990:	d023      	beq.n	80029da <HAL_RCC_ClockConfig+0x16a>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002992:	2a02      	cmp	r2, #2
 8002994:	d029      	beq.n	80029ea <HAL_RCC_ClockConfig+0x17a>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002996:	4b41      	ldr	r3, [pc, #260]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002998:	681b      	ldr	r3, [r3, #0]
 800299a:	f013 0f02 	tst.w	r3, #2
 800299e:	d077      	beq.n	8002a90 <HAL_RCC_ClockConfig+0x220>
        {
          return HAL_ERROR;
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80029a0:	493e      	ldr	r1, [pc, #248]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80029a2:	688b      	ldr	r3, [r1, #8]
 80029a4:	f023 0303 	bic.w	r3, r3, #3
 80029a8:	4313      	orrs	r3, r2
 80029aa:	608b      	str	r3, [r1, #8]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80029ac:	f7fd fe38 	bl	8000620 <HAL_GetTick>
 80029b0:	4606      	mov	r6, r0

      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80029b2:	6863      	ldr	r3, [r4, #4]
 80029b4:	2b01      	cmp	r3, #1
 80029b6:	d020      	beq.n	80029fa <HAL_RCC_ClockConfig+0x18a>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80029b8:	2b02      	cmp	r3, #2
 80029ba:	d02e      	beq.n	8002a1a <HAL_RCC_ClockConfig+0x1aa>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80029bc:	4f37      	ldr	r7, [pc, #220]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029be:	f241 3888 	movw	r8, #5000	; 0x1388
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80029c2:	68bb      	ldr	r3, [r7, #8]
 80029c4:	f013 0f0c 	tst.w	r3, #12
 80029c8:	d037      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029ca:	f7fd fe29 	bl	8000620 <HAL_GetTick>
 80029ce:	1b80      	subs	r0, r0, r6
 80029d0:	4540      	cmp	r0, r8
 80029d2:	d9f6      	bls.n	80029c2 <HAL_RCC_ClockConfig+0x152>
          {
            return HAL_TIMEOUT;
 80029d4:	2003      	movs	r0, #3
 80029d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80029da:	4b30      	ldr	r3, [pc, #192]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80029dc:	681b      	ldr	r3, [r3, #0]
 80029de:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80029e2:	d1dd      	bne.n	80029a0 <HAL_RCC_ClockConfig+0x130>
          return HAL_ERROR;
 80029e4:	2001      	movs	r0, #1
 80029e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80029ea:	4b2c      	ldr	r3, [pc, #176]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 80029ec:	681b      	ldr	r3, [r3, #0]
 80029ee:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80029f2:	d1d5      	bne.n	80029a0 <HAL_RCC_ClockConfig+0x130>
          return HAL_ERROR;
 80029f4:	2001      	movs	r0, #1
 80029f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 80029fa:	4f28      	ldr	r7, [pc, #160]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029fc:	f241 3888 	movw	r8, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 8002a00:	68bb      	ldr	r3, [r7, #8]
 8002a02:	f003 030c 	and.w	r3, r3, #12
 8002a06:	2b04      	cmp	r3, #4
 8002a08:	d017      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a0a:	f7fd fe09 	bl	8000620 <HAL_GetTick>
 8002a0e:	1b80      	subs	r0, r0, r6
 8002a10:	4540      	cmp	r0, r8
 8002a12:	d9f5      	bls.n	8002a00 <HAL_RCC_ClockConfig+0x190>
            return HAL_TIMEOUT;
 8002a14:	2003      	movs	r0, #3
 8002a16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002a1a:	4f20      	ldr	r7, [pc, #128]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a1c:	f241 3888 	movw	r8, #5000	; 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002a20:	68bb      	ldr	r3, [r7, #8]
 8002a22:	f003 030c 	and.w	r3, r3, #12
 8002a26:	2b08      	cmp	r3, #8
 8002a28:	d007      	beq.n	8002a3a <HAL_RCC_ClockConfig+0x1ca>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a2a:	f7fd fdf9 	bl	8000620 <HAL_GetTick>
 8002a2e:	1b80      	subs	r0, r0, r6
 8002a30:	4540      	cmp	r0, r8
 8002a32:	d9f5      	bls.n	8002a20 <HAL_RCC_ClockConfig+0x1b0>
            return HAL_TIMEOUT;
 8002a34:	2003      	movs	r0, #3
 8002a36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }

    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002a3a:	b2ea      	uxtb	r2, r5
 8002a3c:	4b16      	ldr	r3, [pc, #88]	; (8002a98 <HAL_RCC_ClockConfig+0x228>)
 8002a3e:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	f003 030f 	and.w	r3, r3, #15
 8002a46:	429d      	cmp	r5, r3
 8002a48:	d002      	beq.n	8002a50 <HAL_RCC_ClockConfig+0x1e0>
    {
      return HAL_ERROR;
 8002a4a:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 8002a4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002a50:	6823      	ldr	r3, [r4, #0]
 8002a52:	f013 0f04 	tst.w	r3, #4
 8002a56:	d006      	beq.n	8002a66 <HAL_RCC_ClockConfig+0x1f6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002a58:	4a10      	ldr	r2, [pc, #64]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002a5a:	6893      	ldr	r3, [r2, #8]
 8002a5c:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8002a60:	68e1      	ldr	r1, [r4, #12]
 8002a62:	430b      	orrs	r3, r1
 8002a64:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002a66:	6823      	ldr	r3, [r4, #0]
 8002a68:	f013 0f08 	tst.w	r3, #8
 8002a6c:	d007      	beq.n	8002a7e <HAL_RCC_ClockConfig+0x20e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002a6e:	4a0b      	ldr	r2, [pc, #44]	; (8002a9c <HAL_RCC_ClockConfig+0x22c>)
 8002a70:	6893      	ldr	r3, [r2, #8]
 8002a72:	6921      	ldr	r1, [r4, #16]
 8002a74:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8002a78:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002a7c:	6093      	str	r3, [r2, #8]
  HAL_InitTick (TICK_INT_PRIORITY);
 8002a7e:	2000      	movs	r0, #0
 8002a80:	f7fd fd98 	bl	80005b4 <HAL_InitTick>
  return HAL_OK;
 8002a84:	2000      	movs	r0, #0
 8002a86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          return HAL_ERROR;
 8002a8a:	2001      	movs	r0, #1
 8002a8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          return HAL_ERROR;
 8002a90:	2001      	movs	r0, #1
 8002a92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002a96:	bf00      	nop
 8002a98:	40023c00 	.word	0x40023c00
 8002a9c:	40023800 	.word	0x40023800

08002aa0 <HAL_RCC_MCOConfig>:
  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8002aa0:	b570      	push	{r4, r5, r6, lr}
 8002aa2:	b086      	sub	sp, #24
 8002aa4:	460c      	mov	r4, r1
 8002aa6:	4616      	mov	r6, r2
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 8002aa8:	b1d8      	cbz	r0, 8002ae2 <HAL_RCC_MCOConfig+0x42>
  else
  {
    assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));

    /* MCO2 Clock Enable */
    __MCO2_CLK_ENABLE();
 8002aaa:	4d1b      	ldr	r5, [pc, #108]	; (8002b18 <HAL_RCC_MCOConfig+0x78>)
 8002aac:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002aae:	f043 0304 	orr.w	r3, r3, #4
 8002ab2:	632b      	str	r3, [r5, #48]	; 0x30

    /* Configure the MCO2 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO2_PIN;
 8002ab4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002ab8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002aba:	2302      	movs	r3, #2
 8002abc:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002abe:	2303      	movs	r3, #3
 8002ac0:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002ac2:	2300      	movs	r3, #0
 8002ac4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8002ac6:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 8002ac8:	a901      	add	r1, sp, #4
 8002aca:	4814      	ldr	r0, [pc, #80]	; (8002b1c <HAL_RCC_MCOConfig+0x7c>)
 8002acc:	f7ff fc10 	bl	80022f0 <HAL_GPIO_Init>

    /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
 8002ad0:	68ab      	ldr	r3, [r5, #8]
 8002ad2:	ea44 04c6 	orr.w	r4, r4, r6, lsl #3
 8002ad6:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8002ada:	431c      	orrs	r4, r3
 8002adc:	60ac      	str	r4, [r5, #8]
  }
}
 8002ade:	b006      	add	sp, #24
 8002ae0:	bd70      	pop	{r4, r5, r6, pc}
    __MCO1_CLK_ENABLE();
 8002ae2:	4d0d      	ldr	r5, [pc, #52]	; (8002b18 <HAL_RCC_MCOConfig+0x78>)
 8002ae4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002ae6:	f043 0301 	orr.w	r3, r3, #1
 8002aea:	632b      	str	r3, [r5, #48]	; 0x30
    GPIO_InitStruct.Pin = MCO1_PIN;
 8002aec:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002af0:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002af2:	2302      	movs	r3, #2
 8002af4:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8002af6:	2303      	movs	r3, #3
 8002af8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002afa:	2300      	movs	r3, #0
 8002afc:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8002afe:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8002b00:	a901      	add	r1, sp, #4
 8002b02:	4807      	ldr	r0, [pc, #28]	; (8002b20 <HAL_RCC_MCOConfig+0x80>)
 8002b04:	f7ff fbf4 	bl	80022f0 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 8002b08:	68aa      	ldr	r2, [r5, #8]
 8002b0a:	f022 62ec 	bic.w	r2, r2, #123731968	; 0x7600000
 8002b0e:	4332      	orrs	r2, r6
 8002b10:	4314      	orrs	r4, r2
 8002b12:	60ac      	str	r4, [r5, #8]
 8002b14:	e7e3      	b.n	8002ade <HAL_RCC_MCOConfig+0x3e>
 8002b16:	bf00      	nop
 8002b18:	40023800 	.word	0x40023800
 8002b1c:	40020800 	.word	0x40020800
 8002b20:	40020000 	.word	0x40020000

08002b24 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002b24:	4b1b      	ldr	r3, [pc, #108]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b26:	689b      	ldr	r3, [r3, #8]
 8002b28:	f003 030c 	and.w	r3, r3, #12
 8002b2c:	2b04      	cmp	r3, #4
 8002b2e:	d003      	beq.n	8002b38 <HAL_RCC_GetSysClockFreq+0x14>
 8002b30:	2b08      	cmp	r3, #8
 8002b32:	d003      	beq.n	8002b3c <HAL_RCC_GetSysClockFreq+0x18>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8002b34:	4818      	ldr	r0, [pc, #96]	; (8002b98 <HAL_RCC_GetSysClockFreq+0x74>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002b36:	4770      	bx	lr
      sysclockfreq = HSE_VALUE;
 8002b38:	4818      	ldr	r0, [pc, #96]	; (8002b9c <HAL_RCC_GetSysClockFreq+0x78>)
 8002b3a:	4770      	bx	lr
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002b3c:	4a15      	ldr	r2, [pc, #84]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b3e:	6853      	ldr	r3, [r2, #4]
 8002b40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002b44:	6852      	ldr	r2, [r2, #4]
 8002b46:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8002b4a:	4a12      	ldr	r2, [pc, #72]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b4c:	6850      	ldr	r0, [r2, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002b4e:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8002b52:	fa91 f2a1 	rbit	r2, r1
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002b56:	fab2 f282 	clz	r2, r2
 8002b5a:	ea00 0001 	and.w	r0, r0, r1
 8002b5e:	b2d2      	uxtb	r2, r2
 8002b60:	fa20 f202 	lsr.w	r2, r0, r2
 8002b64:	bf14      	ite	ne
 8002b66:	480d      	ldrne	r0, [pc, #52]	; (8002b9c <HAL_RCC_GetSysClockFreq+0x78>)
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8002b68:	480b      	ldreq	r0, [pc, #44]	; (8002b98 <HAL_RCC_GetSysClockFreq+0x74>)
 8002b6a:	fbb0 f0f3 	udiv	r0, r0, r3
 8002b6e:	fb00 f002 	mul.w	r0, r0, r2
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8002b72:	4b08      	ldr	r3, [pc, #32]	; (8002b94 <HAL_RCC_GetSysClockFreq+0x70>)
 8002b74:	685b      	ldr	r3, [r3, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002b76:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8002b7a:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002b7e:	fab2 f282 	clz	r2, r2
 8002b82:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002b86:	b2d2      	uxtb	r2, r2
 8002b88:	40d3      	lsrs	r3, r2
 8002b8a:	3301      	adds	r3, #1
 8002b8c:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8002b8e:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 8002b92:	4770      	bx	lr
 8002b94:	40023800 	.word	0x40023800
 8002b98:	00f42400 	.word	0x00f42400
 8002b9c:	017d7840 	.word	0x017d7840

08002ba0 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002ba0:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8002ba2:	f7ff ffbf 	bl	8002b24 <HAL_RCC_GetSysClockFreq>
 8002ba6:	4b09      	ldr	r3, [pc, #36]	; (8002bcc <HAL_RCC_GetHCLKFreq+0x2c>)
 8002ba8:	689a      	ldr	r2, [r3, #8]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002baa:	23f0      	movs	r3, #240	; 0xf0
 8002bac:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002bb0:	fab3 f383 	clz	r3, r3
 8002bb4:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8002bb8:	b2db      	uxtb	r3, r3
 8002bba:	fa22 f303 	lsr.w	r3, r2, r3
 8002bbe:	4a04      	ldr	r2, [pc, #16]	; (8002bd0 <HAL_RCC_GetHCLKFreq+0x30>)
 8002bc0:	5cd3      	ldrb	r3, [r2, r3]
 8002bc2:	40d8      	lsrs	r0, r3
 8002bc4:	4b03      	ldr	r3, [pc, #12]	; (8002bd4 <HAL_RCC_GetHCLKFreq+0x34>)
 8002bc6:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8002bc8:	bd08      	pop	{r3, pc}
 8002bca:	bf00      	nop
 8002bcc:	40023800 	.word	0x40023800
 8002bd0:	0800c960 	.word	0x0800c960
 8002bd4:	20000000 	.word	0x20000000

08002bd8 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002bd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002bda:	4605      	mov	r5, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8002bdc:	6803      	ldr	r3, [r0, #0]
 8002bde:	f013 0f01 	tst.w	r3, #1
 8002be2:	d105      	bne.n	8002bf0 <HAL_RCCEx_PeriphCLKConfig+0x18>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8002be4:	682b      	ldr	r3, [r5, #0]
 8002be6:	f013 0f02 	tst.w	r3, #2
 8002bea:	d13d      	bne.n	8002c68 <HAL_RCCEx_PeriphCLKConfig+0x90>
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  return HAL_OK;
 8002bec:	2000      	movs	r0, #0
 8002bee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 8002bf0:	2200      	movs	r2, #0
 8002bf2:	4b4d      	ldr	r3, [pc, #308]	; (8002d28 <HAL_RCCEx_PeriphCLKConfig+0x150>)
 8002bf4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002bf6:	f7fd fd13 	bl	8000620 <HAL_GetTick>
 8002bfa:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002bfc:	4c4b      	ldr	r4, [pc, #300]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002bfe:	6823      	ldr	r3, [r4, #0]
 8002c00:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002c04:	d006      	beq.n	8002c14 <HAL_RCCEx_PeriphCLKConfig+0x3c>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8002c06:	f7fd fd0b 	bl	8000620 <HAL_GetTick>
 8002c0a:	1b80      	subs	r0, r0, r6
 8002c0c:	2864      	cmp	r0, #100	; 0x64
 8002c0e:	d9f6      	bls.n	8002bfe <HAL_RCCEx_PeriphCLKConfig+0x26>
        return HAL_TIMEOUT;
 8002c10:	2003      	movs	r0, #3
 8002c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002c14:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8002c18:	fa92 f2a2 	rbit	r2, r2
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002c1c:	fab2 f282 	clz	r2, r2
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002c20:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8002c24:	fa93 f3a3 	rbit	r3, r3
  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
 8002c28:	fab3 f383 	clz	r3, r3
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8002c2c:	b2d2      	uxtb	r2, r2
 8002c2e:	6869      	ldr	r1, [r5, #4]
 8002c30:	fa01 f202 	lsl.w	r2, r1, r2
 8002c34:	b2db      	uxtb	r3, r3
 8002c36:	68a9      	ldr	r1, [r5, #8]
 8002c38:	fa01 f303 	lsl.w	r3, r1, r3
 8002c3c:	4313      	orrs	r3, r2
 8002c3e:	4a3b      	ldr	r2, [pc, #236]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c40:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8002c44:	2201      	movs	r2, #1
 8002c46:	4b38      	ldr	r3, [pc, #224]	; (8002d28 <HAL_RCCEx_PeriphCLKConfig+0x150>)
 8002c48:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002c4a:	f7fd fce9 	bl	8000620 <HAL_GetTick>
 8002c4e:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002c50:	4c36      	ldr	r4, [pc, #216]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c52:	6823      	ldr	r3, [r4, #0]
 8002c54:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8002c58:	d1c4      	bne.n	8002be4 <HAL_RCCEx_PeriphCLKConfig+0xc>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8002c5a:	f7fd fce1 	bl	8000620 <HAL_GetTick>
 8002c5e:	1b80      	subs	r0, r0, r6
 8002c60:	2864      	cmp	r0, #100	; 0x64
 8002c62:	d9f6      	bls.n	8002c52 <HAL_RCCEx_PeriphCLKConfig+0x7a>
        return HAL_TIMEOUT;
 8002c64:	2003      	movs	r0, #3
 8002c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8002c68:	4a30      	ldr	r2, [pc, #192]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c6a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8002c6c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002c70:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_DBP;
 8002c72:	f5a2 32e4 	sub.w	r2, r2, #116736	; 0x1c800
 8002c76:	6813      	ldr	r3, [r2, #0]
 8002c78:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c7c:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8002c7e:	f7fd fccf 	bl	8000620 <HAL_GetTick>
 8002c82:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8002c84:	4c2a      	ldr	r4, [pc, #168]	; (8002d30 <HAL_RCCEx_PeriphCLKConfig+0x158>)
 8002c86:	6823      	ldr	r3, [r4, #0]
 8002c88:	f413 7f80 	tst.w	r3, #256	; 0x100
 8002c8c:	d106      	bne.n	8002c9c <HAL_RCCEx_PeriphCLKConfig+0xc4>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002c8e:	f7fd fcc7 	bl	8000620 <HAL_GetTick>
 8002c92:	1b80      	subs	r0, r0, r6
 8002c94:	2864      	cmp	r0, #100	; 0x64
 8002c96:	d9f6      	bls.n	8002c86 <HAL_RCCEx_PeriphCLKConfig+0xae>
        return HAL_TIMEOUT;
 8002c98:	2003      	movs	r0, #3
 8002c9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8002c9c:	4b23      	ldr	r3, [pc, #140]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002c9e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002ca0:	68ea      	ldr	r2, [r5, #12]
 8002ca2:	4053      	eors	r3, r2
 8002ca4:	f413 7f40 	tst.w	r3, #768	; 0x300
 8002ca8:	d009      	beq.n	8002cbe <HAL_RCCEx_PeriphCLKConfig+0xe6>
      tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002caa:	4a20      	ldr	r2, [pc, #128]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002cac:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8002cae:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002cb2:	4920      	ldr	r1, [pc, #128]	; (8002d34 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 8002cb4:	2001      	movs	r0, #1
 8002cb6:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002cb8:	2000      	movs	r0, #0
 8002cba:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg;
 8002cbc:	6713      	str	r3, [r2, #112]	; 0x70
    if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 8002cbe:	68eb      	ldr	r3, [r5, #12]
 8002cc0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002cc4:	d013      	beq.n	8002cee <HAL_RCCEx_PeriphCLKConfig+0x116>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002cc6:	68eb      	ldr	r3, [r5, #12]
 8002cc8:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8002ccc:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8002cd0:	d01e      	beq.n	8002d10 <HAL_RCCEx_PeriphCLKConfig+0x138>
 8002cd2:	4a16      	ldr	r2, [pc, #88]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002cd4:	6893      	ldr	r3, [r2, #8]
 8002cd6:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8002cda:	6093      	str	r3, [r2, #8]
 8002cdc:	4a13      	ldr	r2, [pc, #76]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002cde:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002ce0:	68eb      	ldr	r3, [r5, #12]
 8002ce2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002ce6:	430b      	orrs	r3, r1
 8002ce8:	6713      	str	r3, [r2, #112]	; 0x70
  return HAL_OK;
 8002cea:	2000      	movs	r0, #0
 8002cec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tickstart = HAL_GetTick();
 8002cee:	f7fd fc97 	bl	8000620 <HAL_GetTick>
 8002cf2:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002cf4:	4c0d      	ldr	r4, [pc, #52]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002cf6:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002cfa:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8002cfc:	f013 0f02 	tst.w	r3, #2
 8002d00:	d1e1      	bne.n	8002cc6 <HAL_RCCEx_PeriphCLKConfig+0xee>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002d02:	f7fd fc8d 	bl	8000620 <HAL_GetTick>
 8002d06:	1bc0      	subs	r0, r0, r7
 8002d08:	42b0      	cmp	r0, r6
 8002d0a:	d9f6      	bls.n	8002cfa <HAL_RCCEx_PeriphCLKConfig+0x122>
          return HAL_TIMEOUT;
 8002d0c:	2003      	movs	r0, #3
}
 8002d0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002d10:	4906      	ldr	r1, [pc, #24]	; (8002d2c <HAL_RCCEx_PeriphCLKConfig+0x154>)
 8002d12:	688a      	ldr	r2, [r1, #8]
 8002d14:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8002d18:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8002d1c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002d20:	4313      	orrs	r3, r2
 8002d22:	608b      	str	r3, [r1, #8]
 8002d24:	e7da      	b.n	8002cdc <HAL_RCCEx_PeriphCLKConfig+0x104>
 8002d26:	bf00      	nop
 8002d28:	42470068 	.word	0x42470068
 8002d2c:	40023800 	.word	0x40023800
 8002d30:	40007000 	.word	0x40007000
 8002d34:	42470e40 	.word	0x42470e40

08002d38 <HAL_RNG_MspInit>:
  * @param  hrng: pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval None
  */
__weak void HAL_RNG_MspInit(RNG_HandleTypeDef *hrng)
{
 8002d38:	4770      	bx	lr

08002d3a <HAL_RNG_Init>:
  if(hrng == NULL)
 8002d3a:	b1b8      	cbz	r0, 8002d6c <HAL_RNG_Init+0x32>
{
 8002d3c:	b510      	push	{r4, lr}
 8002d3e:	4604      	mov	r4, r0
  __HAL_LOCK(hrng);
 8002d40:	7903      	ldrb	r3, [r0, #4]
 8002d42:	2b01      	cmp	r3, #1
 8002d44:	d014      	beq.n	8002d70 <HAL_RNG_Init+0x36>
 8002d46:	2301      	movs	r3, #1
 8002d48:	7103      	strb	r3, [r0, #4]
  if(hrng->State == HAL_RNG_STATE_RESET)
 8002d4a:	7943      	ldrb	r3, [r0, #5]
 8002d4c:	b15b      	cbz	r3, 8002d66 <HAL_RNG_Init+0x2c>
  hrng->State = HAL_RNG_STATE_BUSY;
 8002d4e:	2302      	movs	r3, #2
 8002d50:	7163      	strb	r3, [r4, #5]
  __HAL_RNG_ENABLE(hrng);
 8002d52:	6822      	ldr	r2, [r4, #0]
 8002d54:	6813      	ldr	r3, [r2, #0]
 8002d56:	f043 0304 	orr.w	r3, r3, #4
 8002d5a:	6013      	str	r3, [r2, #0]
  hrng->State = HAL_RNG_STATE_READY;
 8002d5c:	2301      	movs	r3, #1
 8002d5e:	7163      	strb	r3, [r4, #5]
  __HAL_UNLOCK(hrng);
 8002d60:	2000      	movs	r0, #0
 8002d62:	7120      	strb	r0, [r4, #4]
  return HAL_OK;
 8002d64:	bd10      	pop	{r4, pc}
    HAL_RNG_MspInit(hrng);
 8002d66:	f7ff ffe7 	bl	8002d38 <HAL_RNG_MspInit>
 8002d6a:	e7f0      	b.n	8002d4e <HAL_RNG_Init+0x14>
    return HAL_ERROR;
 8002d6c:	2001      	movs	r0, #1
 8002d6e:	4770      	bx	lr
  __HAL_LOCK(hrng);
 8002d70:	2002      	movs	r0, #2
}
 8002d72:	bd10      	pop	{r4, pc}

08002d74 <HAL_RNG_GenerateRandomNumber>:
{
  uint32_t tickstart = 0;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 8002d74:	7903      	ldrb	r3, [r0, #4]
 8002d76:	2b01      	cmp	r3, #1
 8002d78:	d028      	beq.n	8002dcc <HAL_RNG_GenerateRandomNumber+0x58>
{
 8002d7a:	b570      	push	{r4, r5, r6, lr}
 8002d7c:	460d      	mov	r5, r1
 8002d7e:	4604      	mov	r4, r0
  __HAL_LOCK(hrng);
 8002d80:	2301      	movs	r3, #1
 8002d82:	7103      	strb	r3, [r0, #4]

  /* Check RNG peripheral state */
  if(hrng->State == HAL_RNG_STATE_READY)
 8002d84:	7943      	ldrb	r3, [r0, #5]
 8002d86:	b2db      	uxtb	r3, r3
 8002d88:	2b01      	cmp	r3, #1
 8002d8a:	d003      	beq.n	8002d94 <HAL_RNG_GenerateRandomNumber+0x20>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    status = HAL_ERROR;
 8002d8c:	2001      	movs	r0, #1
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8002d8e:	2300      	movs	r3, #0
 8002d90:	7123      	strb	r3, [r4, #4]

  return status;
 8002d92:	bd70      	pop	{r4, r5, r6, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
 8002d94:	2302      	movs	r3, #2
 8002d96:	7143      	strb	r3, [r0, #5]
    tickstart = HAL_GetTick();
 8002d98:	f7fd fc42 	bl	8000620 <HAL_GetTick>
 8002d9c:	4606      	mov	r6, r0
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8002d9e:	6823      	ldr	r3, [r4, #0]
 8002da0:	685a      	ldr	r2, [r3, #4]
 8002da2:	f012 0f01 	tst.w	r2, #1
 8002da6:	d10a      	bne.n	8002dbe <HAL_RNG_GenerateRandomNumber+0x4a>
      if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 8002da8:	f7fd fc3a 	bl	8000620 <HAL_GetTick>
 8002dac:	1b80      	subs	r0, r0, r6
 8002dae:	2802      	cmp	r0, #2
 8002db0:	d9f5      	bls.n	8002d9e <HAL_RNG_GenerateRandomNumber+0x2a>
        hrng->State = HAL_RNG_STATE_ERROR;
 8002db2:	2304      	movs	r3, #4
 8002db4:	7163      	strb	r3, [r4, #5]
        __HAL_UNLOCK(hrng);
 8002db6:	2300      	movs	r3, #0
 8002db8:	7123      	strb	r3, [r4, #4]
        return HAL_TIMEOUT;
 8002dba:	2003      	movs	r0, #3
 8002dbc:	bd70      	pop	{r4, r5, r6, pc}
    hrng->RandomNumber = hrng->Instance->DR;
 8002dbe:	689b      	ldr	r3, [r3, #8]
 8002dc0:	60a3      	str	r3, [r4, #8]
    *random32bit = hrng->RandomNumber;
 8002dc2:	602b      	str	r3, [r5, #0]
    hrng->State = HAL_RNG_STATE_READY;
 8002dc4:	2301      	movs	r3, #1
 8002dc6:	7163      	strb	r3, [r4, #5]
  HAL_StatusTypeDef status = HAL_OK;
 8002dc8:	2000      	movs	r0, #0
 8002dca:	e7e0      	b.n	8002d8e <HAL_RNG_GenerateRandomNumber+0x1a>
  __HAL_LOCK(hrng);
 8002dcc:	2002      	movs	r0, #2
 8002dce:	4770      	bx	lr

08002dd0 <HAL_TIM_Base_MspInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 8002dd0:	4770      	bx	lr

08002dd2 <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002dd2:	6802      	ldr	r2, [r0, #0]
 8002dd4:	68d3      	ldr	r3, [r2, #12]
 8002dd6:	f043 0301 	orr.w	r3, r3, #1
 8002dda:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8002ddc:	6802      	ldr	r2, [r0, #0]
 8002dde:	6813      	ldr	r3, [r2, #0]
 8002de0:	f043 0301 	orr.w	r3, r3, #1
 8002de4:	6013      	str	r3, [r2, #0]

  /* Return function status */
  return HAL_OK;
}
 8002de6:	2000      	movs	r0, #0
 8002de8:	4770      	bx	lr
	...

08002dec <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 8002dec:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)
 8002dee:	4a31      	ldr	r2, [pc, #196]	; (8002eb4 <TIM_Base_SetConfig+0xc8>)
 8002df0:	4290      	cmp	r0, r2
 8002df2:	d02f      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002df4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002df8:	d02c      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002dfa:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8002dfe:	4290      	cmp	r0, r2
 8002e00:	d028      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002e02:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e06:	4290      	cmp	r0, r2
 8002e08:	d024      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002e0a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e0e:	4290      	cmp	r0, r2
 8002e10:	d020      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
 8002e12:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002e16:	4290      	cmp	r0, r2
 8002e18:	d01c      	beq.n	8002e54 <TIM_Base_SetConfig+0x68>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)
 8002e1a:	4a27      	ldr	r2, [pc, #156]	; (8002eb8 <TIM_Base_SetConfig+0xcc>)
 8002e1c:	4290      	cmp	r0, r2
 8002e1e:	d02f      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e20:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e24:	4290      	cmp	r0, r2
 8002e26:	d02b      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e28:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e2c:	4290      	cmp	r0, r2
 8002e2e:	d027      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e30:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8002e34:	4290      	cmp	r0, r2
 8002e36:	d023      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e38:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e3c:	4290      	cmp	r0, r2
 8002e3e:	d01f      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e40:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e44:	4290      	cmp	r0, r2
 8002e46:	d01b      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 8002e48:	6003      	str	r3, [r0, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002e4a:	688b      	ldr	r3, [r1, #8]
 8002e4c:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002e4e:	680b      	ldr	r3, [r1, #0]
 8002e50:	6283      	str	r3, [r0, #40]	; 0x28
 8002e52:	e021      	b.n	8002e98 <TIM_Base_SetConfig+0xac>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002e54:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002e58:	684a      	ldr	r2, [r1, #4]
 8002e5a:	4313      	orrs	r3, r2
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)
 8002e5c:	4a15      	ldr	r2, [pc, #84]	; (8002eb4 <TIM_Base_SetConfig+0xc8>)
 8002e5e:	4290      	cmp	r0, r2
 8002e60:	d00e      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e62:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002e66:	d00b      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e68:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8002e6c:	4290      	cmp	r0, r2
 8002e6e:	d007      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e70:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e74:	4290      	cmp	r0, r2
 8002e76:	d003      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002e78:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002e7c:	4290      	cmp	r0, r2
 8002e7e:	d113      	bne.n	8002ea8 <TIM_Base_SetConfig+0xbc>
    tmpcr1 &= ~TIM_CR1_CKD;
 8002e80:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002e84:	68ca      	ldr	r2, [r1, #12]
 8002e86:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8002e88:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002e8a:	688b      	ldr	r3, [r1, #8]
 8002e8c:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002e8e:	680b      	ldr	r3, [r1, #0]
 8002e90:	6283      	str	r3, [r0, #40]	; 0x28

  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8002e92:	4b08      	ldr	r3, [pc, #32]	; (8002eb4 <TIM_Base_SetConfig+0xc8>)
 8002e94:	4298      	cmp	r0, r3
 8002e96:	d002      	beq.n	8002e9e <TIM_Base_SetConfig+0xb2>
 8002e98:	4b08      	ldr	r3, [pc, #32]	; (8002ebc <TIM_Base_SetConfig+0xd0>)
 8002e9a:	4298      	cmp	r0, r3
 8002e9c:	d101      	bne.n	8002ea2 <TIM_Base_SetConfig+0xb6>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8002e9e:	690b      	ldr	r3, [r1, #16]
 8002ea0:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002ea2:	2301      	movs	r3, #1
 8002ea4:	6143      	str	r3, [r0, #20]
}
 8002ea6:	4770      	bx	lr
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)
 8002ea8:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8002eac:	4290      	cmp	r0, r2
 8002eae:	d0e7      	beq.n	8002e80 <TIM_Base_SetConfig+0x94>
 8002eb0:	e7b3      	b.n	8002e1a <TIM_Base_SetConfig+0x2e>
 8002eb2:	bf00      	nop
 8002eb4:	40010000 	.word	0x40010000
 8002eb8:	40014000 	.word	0x40014000
 8002ebc:	40010400 	.word	0x40010400

08002ec0 <HAL_TIM_Base_Init>:
  if(htim == NULL)
 8002ec0:	b198      	cbz	r0, 8002eea <HAL_TIM_Base_Init+0x2a>
{
 8002ec2:	b510      	push	{r4, lr}
 8002ec4:	4604      	mov	r4, r0
  if(htim->State == HAL_TIM_STATE_RESET)
 8002ec6:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002eca:	b15b      	cbz	r3, 8002ee4 <HAL_TIM_Base_Init+0x24>
  htim->State= HAL_TIM_STATE_BUSY;
 8002ecc:	2302      	movs	r3, #2
 8002ece:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002ed2:	1d21      	adds	r1, r4, #4
 8002ed4:	6820      	ldr	r0, [r4, #0]
 8002ed6:	f7ff ff89 	bl	8002dec <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8002eda:	2301      	movs	r3, #1
 8002edc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  return HAL_OK;
 8002ee0:	2000      	movs	r0, #0
 8002ee2:	bd10      	pop	{r4, pc}
    HAL_TIM_Base_MspInit(htim);
 8002ee4:	f7ff ff74 	bl	8002dd0 <HAL_TIM_Base_MspInit>
 8002ee8:	e7f0      	b.n	8002ecc <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8002eea:	2001      	movs	r0, #1
 8002eec:	4770      	bx	lr
	...

08002ef0 <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvHelpCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 8002ef0:	b538      	push	{r3, r4, r5, lr}
 8002ef2:	460a      	mov	r2, r1
static const CLI_Definition_List_Item_t * pxCommand = NULL;
BaseType_t xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
 8002ef4:	4b09      	ldr	r3, [pc, #36]	; (8002f1c <prvHelpCommand+0x2c>)
 8002ef6:	681b      	ldr	r3, [r3, #0]
 8002ef8:	b15b      	cbz	r3, 8002f12 <prvHelpCommand+0x22>
		pxCommand = &xRegisteredCommands;
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( pcWriteBuffer, pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
 8002efa:	4c08      	ldr	r4, [pc, #32]	; (8002f1c <prvHelpCommand+0x2c>)
 8002efc:	6825      	ldr	r5, [r4, #0]
 8002efe:	682b      	ldr	r3, [r5, #0]
 8002f00:	6859      	ldr	r1, [r3, #4]
 8002f02:	f009 fc43 	bl	800c78c <strncpy>
	pxCommand = pxCommand->pxNext;
 8002f06:	6868      	ldr	r0, [r5, #4]
 8002f08:	6020      	str	r0, [r4, #0]
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
 8002f0a:	3000      	adds	r0, #0
 8002f0c:	bf18      	it	ne
 8002f0e:	2001      	movne	r0, #1
 8002f10:	bd38      	pop	{r3, r4, r5, pc}
		pxCommand = &xRegisteredCommands;
 8002f12:	4903      	ldr	r1, [pc, #12]	; (8002f20 <prvHelpCommand+0x30>)
 8002f14:	4b01      	ldr	r3, [pc, #4]	; (8002f1c <prvHelpCommand+0x2c>)
 8002f16:	6019      	str	r1, [r3, #0]
 8002f18:	e7ef      	b.n	8002efa <prvHelpCommand+0xa>
 8002f1a:	bf00      	nop
 8002f1c:	2000036c 	.word	0x2000036c
 8002f20:	20000008 	.word	0x20000008

08002f24 <FreeRTOS_CLIRegisterCommand>:
{
 8002f24:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxCommandToRegister );
 8002f26:	4605      	mov	r5, r0
 8002f28:	b188      	cbz	r0, 8002f4e <FreeRTOS_CLIRegisterCommand+0x2a>
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
 8002f2a:	2008      	movs	r0, #8
 8002f2c:	f006 f9a4 	bl	8009278 <pvPortMalloc>
	configASSERT( pxNewListItem );
 8002f30:	4604      	mov	r4, r0
 8002f32:	b188      	cbz	r0, 8002f58 <FreeRTOS_CLIRegisterCommand+0x34>
		taskENTER_CRITICAL();
 8002f34:	f006 f816 	bl	8008f64 <vPortEnterCritical>
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
 8002f38:	6025      	str	r5, [r4, #0]
			pxNewListItem->pxNext = NULL;
 8002f3a:	2300      	movs	r3, #0
 8002f3c:	6063      	str	r3, [r4, #4]
			pxLastCommandInList->pxNext = pxNewListItem;
 8002f3e:	4b09      	ldr	r3, [pc, #36]	; (8002f64 <FreeRTOS_CLIRegisterCommand+0x40>)
 8002f40:	681a      	ldr	r2, [r3, #0]
 8002f42:	6054      	str	r4, [r2, #4]
			pxLastCommandInList = pxNewListItem;
 8002f44:	601c      	str	r4, [r3, #0]
		taskEXIT_CRITICAL();
 8002f46:	f006 f82f 	bl	8008fa8 <vPortExitCritical>
		xReturn = pdPASS;
 8002f4a:	2001      	movs	r0, #1
}
 8002f4c:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxCommandToRegister );
 8002f4e:	216c      	movs	r1, #108	; 0x6c
 8002f50:	4805      	ldr	r0, [pc, #20]	; (8002f68 <FreeRTOS_CLIRegisterCommand+0x44>)
 8002f52:	f009 fa05 	bl	800c360 <vAssertCalled>
 8002f56:	e7e8      	b.n	8002f2a <FreeRTOS_CLIRegisterCommand+0x6>
	configASSERT( pxNewListItem );
 8002f58:	2170      	movs	r1, #112	; 0x70
 8002f5a:	4803      	ldr	r0, [pc, #12]	; (8002f68 <FreeRTOS_CLIRegisterCommand+0x44>)
 8002f5c:	f009 fa00 	bl	800c360 <vAssertCalled>
BaseType_t xReturn = pdFAIL;
 8002f60:	2000      	movs	r0, #0
	return xReturn;
 8002f62:	bd38      	pop	{r3, r4, r5, pc}
 8002f64:	20000004 	.word	0x20000004
 8002f68:	0800ca18 	.word	0x0800ca18

08002f6c <FreeRTOS_CLIProcessCommand>:
{
 8002f6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002f70:	4606      	mov	r6, r0
 8002f72:	4688      	mov	r8, r1
 8002f74:	4691      	mov	r9, r2
	if( pxCommand == NULL )
 8002f76:	4b31      	ldr	r3, [pc, #196]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8002f78:	681b      	ldr	r3, [r3, #0]
 8002f7a:	b16b      	cbz	r3, 8002f98 <FreeRTOS_CLIProcessCommand+0x2c>
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
 8002f7c:	681b      	ldr	r3, [r3, #0]
 8002f7e:	689b      	ldr	r3, [r3, #8]
 8002f80:	4632      	mov	r2, r6
 8002f82:	4649      	mov	r1, r9
 8002f84:	4640      	mov	r0, r8
 8002f86:	4798      	blx	r3
		if( xReturn == pdFALSE )
 8002f88:	4603      	mov	r3, r0
 8002f8a:	b910      	cbnz	r0, 8002f92 <FreeRTOS_CLIProcessCommand+0x26>
			pxCommand = NULL;
 8002f8c:	2100      	movs	r1, #0
 8002f8e:	4a2b      	ldr	r2, [pc, #172]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8002f90:	6011      	str	r1, [r2, #0]
}
 8002f92:	4618      	mov	r0, r3
 8002f94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 8002f98:	4c29      	ldr	r4, [pc, #164]	; (8003040 <FreeRTOS_CLIProcessCommand+0xd4>)
 8002f9a:	4a28      	ldr	r2, [pc, #160]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8002f9c:	6014      	str	r4, [r2, #0]
 8002f9e:	4617      	mov	r7, r2
 8002fa0:	e009      	b.n	8002fb6 <FreeRTOS_CLIProcessCommand+0x4a>
				if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
 8002fa2:	4602      	mov	r2, r0
 8002fa4:	4629      	mov	r1, r5
 8002fa6:	4630      	mov	r0, r6
 8002fa8:	f009 fbde 	bl	800c768 <strncmp>
 8002fac:	b178      	cbz	r0, 8002fce <FreeRTOS_CLIProcessCommand+0x62>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
 8002fae:	6864      	ldr	r4, [r4, #4]
 8002fb0:	603c      	str	r4, [r7, #0]
 8002fb2:	2c00      	cmp	r4, #0
 8002fb4:	d03b      	beq.n	800302e <FreeRTOS_CLIProcessCommand+0xc2>
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
 8002fb6:	f8d4 a000 	ldr.w	sl, [r4]
 8002fba:	f8da 5000 	ldr.w	r5, [sl]
			xCommandStringLength = strlen( pcRegisteredCommandString );
 8002fbe:	4628      	mov	r0, r5
 8002fc0:	f7fd f906 	bl	80001d0 <strlen>
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
 8002fc4:	5c33      	ldrb	r3, [r6, r0]
 8002fc6:	f013 0fdf 	tst.w	r3, #223	; 0xdf
 8002fca:	d1f0      	bne.n	8002fae <FreeRTOS_CLIProcessCommand+0x42>
 8002fcc:	e7e9      	b.n	8002fa2 <FreeRTOS_CLIProcessCommand+0x36>
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
 8002fce:	f99a 500c 	ldrsb.w	r5, [sl, #12]
 8002fd2:	2d00      	cmp	r5, #0
 8002fd4:	db27      	blt.n	8003026 <FreeRTOS_CLIProcessCommand+0xba>
{
int8_t cParameters = 0;
BaseType_t xLastCharacterWasSpace = pdFALSE;

	/* Count the number of space delimited words in pcCommandString. */
	while( *pcCommandString != 0x00 )
 8002fd6:	7833      	ldrb	r3, [r6, #0]
 8002fd8:	b31b      	cbz	r3, 8003022 <FreeRTOS_CLIProcessCommand+0xb6>
 8002fda:	4632      	mov	r2, r6
 8002fdc:	4601      	mov	r1, r0
				xLastCharacterWasSpace = pdTRUE;
			}
		}
		else
		{
			xLastCharacterWasSpace = pdFALSE;
 8002fde:	4604      	mov	r4, r0
			if( xLastCharacterWasSpace != pdTRUE )
 8002fe0:	2701      	movs	r7, #1
 8002fe2:	e006      	b.n	8002ff2 <FreeRTOS_CLIProcessCommand+0x86>
 8002fe4:	b949      	cbnz	r1, 8002ffa <FreeRTOS_CLIProcessCommand+0x8e>
				cParameters++;
 8002fe6:	3001      	adds	r0, #1
 8002fe8:	b240      	sxtb	r0, r0
				xLastCharacterWasSpace = pdTRUE;
 8002fea:	4639      	mov	r1, r7
	while( *pcCommandString != 0x00 )
 8002fec:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8002ff0:	b12b      	cbz	r3, 8002ffe <FreeRTOS_CLIProcessCommand+0x92>
		if( ( *pcCommandString ) == ' ' )
 8002ff2:	2b20      	cmp	r3, #32
 8002ff4:	d0f6      	beq.n	8002fe4 <FreeRTOS_CLIProcessCommand+0x78>
			xLastCharacterWasSpace = pdFALSE;
 8002ff6:	4621      	mov	r1, r4
 8002ff8:	e7f8      	b.n	8002fec <FreeRTOS_CLIProcessCommand+0x80>
			if( xLastCharacterWasSpace != pdTRUE )
 8002ffa:	4639      	mov	r1, r7
 8002ffc:	e7f6      	b.n	8002fec <FreeRTOS_CLIProcessCommand+0x80>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
 8002ffe:	b969      	cbnz	r1, 800301c <FreeRTOS_CLIProcessCommand+0xb0>
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 8003000:	4b0e      	ldr	r3, [pc, #56]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8003002:	681b      	ldr	r3, [r3, #0]
 8003004:	b19b      	cbz	r3, 800302e <FreeRTOS_CLIProcessCommand+0xc2>
 8003006:	4285      	cmp	r5, r0
 8003008:	d0b8      	beq.n	8002f7c <FreeRTOS_CLIProcessCommand+0x10>
		strncpy( pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 800300a:	464a      	mov	r2, r9
 800300c:	490d      	ldr	r1, [pc, #52]	; (8003044 <FreeRTOS_CLIProcessCommand+0xd8>)
 800300e:	4640      	mov	r0, r8
 8003010:	f009 fbbc 	bl	800c78c <strncpy>
		pxCommand = NULL;
 8003014:	2300      	movs	r3, #0
 8003016:	4a09      	ldr	r2, [pc, #36]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8003018:	6013      	str	r3, [r2, #0]
 800301a:	e7ba      	b.n	8002f92 <FreeRTOS_CLIProcessCommand+0x26>
	{
		cParameters--;
 800301c:	3801      	subs	r0, #1
 800301e:	b240      	sxtb	r0, r0
 8003020:	e7ee      	b.n	8003000 <FreeRTOS_CLIProcessCommand+0x94>
	while( *pcCommandString != 0x00 )
 8003022:	2000      	movs	r0, #0
 8003024:	e7ec      	b.n	8003000 <FreeRTOS_CLIProcessCommand+0x94>
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
 8003026:	4b05      	ldr	r3, [pc, #20]	; (800303c <FreeRTOS_CLIProcessCommand+0xd0>)
 8003028:	681b      	ldr	r3, [r3, #0]
 800302a:	2b00      	cmp	r3, #0
 800302c:	d1a6      	bne.n	8002f7c <FreeRTOS_CLIProcessCommand+0x10>
		strncpy( pcWriteBuffer, "Command not recognised.  Enter 'help' to view a list of available commands.\r\n\r\n", xWriteBufferLen );
 800302e:	464a      	mov	r2, r9
 8003030:	4905      	ldr	r1, [pc, #20]	; (8003048 <FreeRTOS_CLIProcessCommand+0xdc>)
 8003032:	4640      	mov	r0, r8
 8003034:	f009 fbaa 	bl	800c78c <strncpy>
		xReturn = pdFALSE;
 8003038:	2300      	movs	r3, #0
	return xReturn;
 800303a:	e7aa      	b.n	8002f92 <FreeRTOS_CLIProcessCommand+0x26>
 800303c:	20000368 	.word	0x20000368
 8003040:	20000008 	.word	0x20000008
 8003044:	0800c970 	.word	0x0800c970
 8003048:	0800c9c8 	.word	0x0800c9c8

0800304c <FreeRTOS_CLIGetParameter>:
	*pxParameterStringLength = 0;
 800304c:	2300      	movs	r3, #0
 800304e:	6013      	str	r3, [r2, #0]
	while( uxParametersFound < uxWantedParameter )
 8003050:	b119      	cbz	r1, 800305a <FreeRTOS_CLIGetParameter+0xe>
{
 8003052:	b410      	push	{r4}
 8003054:	460c      	mov	r4, r1
	while( uxParametersFound < uxWantedParameter )
 8003056:	2100      	movs	r1, #0
 8003058:	e009      	b.n	800306e <FreeRTOS_CLIGetParameter+0x22>
const char *pcReturn = NULL;
 800305a:	4618      	mov	r0, r3
 800305c:	4770      	bx	lr
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
 800305e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8003062:	2b20      	cmp	r3, #32
 8003064:	d0fb      	beq.n	800305e <FreeRTOS_CLIGetParameter+0x12>
		if( *pcCommandString != 0x00 )
 8003066:	b1eb      	cbz	r3, 80030a4 <FreeRTOS_CLIGetParameter+0x58>
			uxParametersFound++;
 8003068:	3101      	adds	r1, #1
			if( uxParametersFound == uxWantedParameter )
 800306a:	428c      	cmp	r4, r1
 800306c:	d009      	beq.n	8003082 <FreeRTOS_CLIGetParameter+0x36>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 800306e:	7803      	ldrb	r3, [r0, #0]
 8003070:	b1f3      	cbz	r3, 80030b0 <FreeRTOS_CLIGetParameter+0x64>
 8003072:	2b20      	cmp	r3, #32
 8003074:	d0f3      	beq.n	800305e <FreeRTOS_CLIGetParameter+0x12>
 8003076:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800307a:	b1cb      	cbz	r3, 80030b0 <FreeRTOS_CLIGetParameter+0x64>
 800307c:	2b20      	cmp	r3, #32
 800307e:	d1fa      	bne.n	8003076 <FreeRTOS_CLIGetParameter+0x2a>
 8003080:	e7ed      	b.n	800305e <FreeRTOS_CLIGetParameter+0x12>
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 8003082:	7803      	ldrb	r3, [r0, #0]
 8003084:	f013 0fdf 	tst.w	r3, #223	; 0xdf
 8003088:	d010      	beq.n	80030ac <FreeRTOS_CLIGetParameter+0x60>
 800308a:	4601      	mov	r1, r0
					( *pxParameterStringLength )++;
 800308c:	6813      	ldr	r3, [r2, #0]
 800308e:	3301      	adds	r3, #1
 8003090:	6013      	str	r3, [r2, #0]
				while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) != ' ' ) )
 8003092:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8003096:	f014 0fdf 	tst.w	r4, #223	; 0xdf
 800309a:	d1f7      	bne.n	800308c <FreeRTOS_CLIGetParameter+0x40>
					pcReturn = NULL;
 800309c:	2b00      	cmp	r3, #0
 800309e:	bf08      	it	eq
 80030a0:	2000      	moveq	r0, #0
 80030a2:	e000      	b.n	80030a6 <FreeRTOS_CLIGetParameter+0x5a>
const char *pcReturn = NULL;
 80030a4:	2000      	movs	r0, #0
}
 80030a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80030aa:	4770      	bx	lr
					pcReturn = NULL;
 80030ac:	2000      	movs	r0, #0
 80030ae:	e7fa      	b.n	80030a6 <FreeRTOS_CLIGetParameter+0x5a>
		while( ( ( *pcCommandString ) != 0x00 ) && ( ( *pcCommandString ) == ' ' ) )
 80030b0:	7803      	ldrb	r3, [r0, #0]
 80030b2:	e7d8      	b.n	8003066 <FreeRTOS_CLIGetParameter+0x1a>

080030b4 <strcasecmp>:

		return cReturnChar;
	}

	int strcasecmp( const char *pcString1, const char *pcString2 )
	{
 80030b4:	b410      	push	{r4}
		unsigned char c1,c2;
		do
		{
			c1 = *pcString1++;
 80030b6:	f810 3b01 	ldrb.w	r3, [r0], #1
			c2 = *pcString2++;
 80030ba:	f811 2b01 	ldrb.w	r2, [r1], #1
		if( c >= 'A' && c <= 'Z' )
 80030be:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 80030c2:	b2e4      	uxtb	r4, r4
 80030c4:	2c19      	cmp	r4, #25
			cReturnChar = c + 0x20;
 80030c6:	bf9c      	itt	ls
 80030c8:	3320      	addls	r3, #32
 80030ca:	b2db      	uxtbls	r3, r3
		if( c >= 'A' && c <= 'Z' )
 80030cc:	f1a2 0441 	sub.w	r4, r2, #65	; 0x41
 80030d0:	b2e4      	uxtb	r4, r4
 80030d2:	2c19      	cmp	r4, #25
			cReturnChar = c + 0x20;
 80030d4:	bf9c      	itt	ls
 80030d6:	3220      	addls	r2, #32
 80030d8:	b2d2      	uxtbls	r2, r2
			c1 = ( unsigned char ) prvToLower( ( unsigned char ) c1 );
			c2 = ( unsigned char ) prvToLower( ( unsigned char ) c2 );
		}
		while( ( c1 == c2 ) && ( c1 != '\0' ) );
 80030da:	429a      	cmp	r2, r3
 80030dc:	d102      	bne.n	80030e4 <strcasecmp+0x30>
 80030de:	2b00      	cmp	r3, #0
 80030e0:	d1e9      	bne.n	80030b6 <strcasecmp+0x2>
 80030e2:	461a      	mov	r2, r3

		return ( int ) c1 - c2;
	}	/* strcasecmp() */
 80030e4:	1a98      	subs	r0, r3, r2
 80030e6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80030ea:	4770      	bx	lr

080030ec <SDIO_IRQHandler>:
#endif	/* SDIO_USES_DMA */
/*-----------------------------------------------------------*/

#if( SDIO_USES_DMA != 0 )
	void SDIO_IRQHandler(void)
	{
 80030ec:	b500      	push	{lr}
 80030ee:	b083      	sub	sp, #12
	BaseType_t xHigherPriorityTaskWoken = 0;
 80030f0:	2300      	movs	r3, #0
 80030f2:	9301      	str	r3, [sp, #4]

		HAL_SD_IRQHandler( &xSDHandle );
 80030f4:	480a      	ldr	r0, [pc, #40]	; (8003120 <SDIO_IRQHandler+0x34>)
 80030f6:	f000 f881 	bl	80031fc <HAL_SD_IRQHandler>
		if( xSDCardSemaphore != NULL )
 80030fa:	4b0a      	ldr	r3, [pc, #40]	; (8003124 <SDIO_IRQHandler+0x38>)
 80030fc:	6818      	ldr	r0, [r3, #0]
 80030fe:	b110      	cbz	r0, 8003106 <SDIO_IRQHandler+0x1a>
		{
			xSemaphoreGiveFromISR( xSDCardSemaphore, &xHigherPriorityTaskWoken );
 8003100:	a901      	add	r1, sp, #4
 8003102:	f006 fbc1 	bl	8009888 <xQueueGiveFromISR>
		}
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8003106:	9b01      	ldr	r3, [sp, #4]
 8003108:	b13b      	cbz	r3, 800311a <SDIO_IRQHandler+0x2e>
 800310a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800310e:	4b06      	ldr	r3, [pc, #24]	; (8003128 <SDIO_IRQHandler+0x3c>)
 8003110:	601a      	str	r2, [r3, #0]
 8003112:	f3bf 8f4f 	dsb	sy
 8003116:	f3bf 8f6f 	isb	sy
	}
 800311a:	b003      	add	sp, #12
 800311c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003120:	20000374 	.word	0x20000374
 8003124:	20000370 	.word	0x20000370
 8003128:	e000ed04 	.word	0xe000ed04

0800312c <DMA2_Stream6_IRQHandler>:
/*-----------------------------------------------------------*/

#if( SDIO_USES_DMA != 0 )

	void DMA2_Stream6_IRQHandler(void)
	{
 800312c:	b500      	push	{lr}
 800312e:	b083      	sub	sp, #12
	BaseType_t xHigherPriorityTaskWoken = 0;
 8003130:	2300      	movs	r3, #0
 8003132:	9301      	str	r3, [sp, #4]

		/* DMA SDIO-TX interrupt handler. */
		HAL_DMA_IRQHandler (xSDHandle.hdmatx);
 8003134:	4b0b      	ldr	r3, [pc, #44]	; (8003164 <DMA2_Stream6_IRQHandler+0x38>)
 8003136:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8003138:	f7fd faea 	bl	8000710 <HAL_DMA_IRQHandler>
		if( xSDCardSemaphore != NULL )
 800313c:	4b0a      	ldr	r3, [pc, #40]	; (8003168 <DMA2_Stream6_IRQHandler+0x3c>)
 800313e:	6818      	ldr	r0, [r3, #0]
 8003140:	b110      	cbz	r0, 8003148 <DMA2_Stream6_IRQHandler+0x1c>
		{
			xSemaphoreGiveFromISR( xSDCardSemaphore, &xHigherPriorityTaskWoken );
 8003142:	a901      	add	r1, sp, #4
 8003144:	f006 fba0 	bl	8009888 <xQueueGiveFromISR>
		}
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8003148:	9b01      	ldr	r3, [sp, #4]
 800314a:	b13b      	cbz	r3, 800315c <DMA2_Stream6_IRQHandler+0x30>
 800314c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003150:	4b06      	ldr	r3, [pc, #24]	; (800316c <DMA2_Stream6_IRQHandler+0x40>)
 8003152:	601a      	str	r2, [r3, #0]
 8003154:	f3bf 8f4f 	dsb	sy
 8003158:	f3bf 8f6f 	isb	sy
	}
 800315c:	b003      	add	sp, #12
 800315e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003162:	bf00      	nop
 8003164:	20000374 	.word	0x20000374
 8003168:	20000370 	.word	0x20000370
 800316c:	e000ed04 	.word	0xe000ed04

08003170 <DMA2_Stream3_IRQHandler>:
/*-----------------------------------------------------------*/

#if( SDIO_USES_DMA != 0 )

	void DMA2_Stream3_IRQHandler(void)
	{
 8003170:	b500      	push	{lr}
 8003172:	b083      	sub	sp, #12
	BaseType_t xHigherPriorityTaskWoken = 0;
 8003174:	2300      	movs	r3, #0
 8003176:	9301      	str	r3, [sp, #4]

		/* DMA SDIO-RX interrupt handler. */
		HAL_DMA_IRQHandler (xSDHandle.hdmarx);
 8003178:	4b0b      	ldr	r3, [pc, #44]	; (80031a8 <DMA2_Stream3_IRQHandler+0x38>)
 800317a:	6d98      	ldr	r0, [r3, #88]	; 0x58
 800317c:	f7fd fac8 	bl	8000710 <HAL_DMA_IRQHandler>
		if( xSDCardSemaphore != NULL )
 8003180:	4b0a      	ldr	r3, [pc, #40]	; (80031ac <DMA2_Stream3_IRQHandler+0x3c>)
 8003182:	6818      	ldr	r0, [r3, #0]
 8003184:	b110      	cbz	r0, 800318c <DMA2_Stream3_IRQHandler+0x1c>
		{
			xSemaphoreGiveFromISR( xSDCardSemaphore, &xHigherPriorityTaskWoken );
 8003186:	a901      	add	r1, sp, #4
 8003188:	f006 fb7e 	bl	8009888 <xQueueGiveFromISR>
		}
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 800318c:	9b01      	ldr	r3, [sp, #4]
 800318e:	b13b      	cbz	r3, 80031a0 <DMA2_Stream3_IRQHandler+0x30>
 8003190:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003194:	4b06      	ldr	r3, [pc, #24]	; (80031b0 <DMA2_Stream3_IRQHandler+0x40>)
 8003196:	601a      	str	r2, [r3, #0]
 8003198:	f3bf 8f4f 	dsb	sy
 800319c:	f3bf 8f6f 	isb	sy
	}
 80031a0:	b003      	add	sp, #12
 80031a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80031a6:	bf00      	nop
 80031a8:	20000374 	.word	0x20000374
 80031ac:	20000370 	.word	0x20000370
 80031b0:	e000ed04 	.word	0xe000ed04

080031b4 <HAL_GPIO_EXTI_Callback>:

#endif	/* SDIO_USES_DMA != 0 */
/*-----------------------------------------------------------*/

void HAL_GPIO_EXTI_Callback( uint16_t GPIO_Pin )
{
 80031b4:	b500      	push	{lr}
 80031b6:	b083      	sub	sp, #12
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 80031b8:	2300      	movs	r3, #0
 80031ba:	9301      	str	r3, [sp, #4]

	if( GPIO_Pin == configSD_DETECT_PIN )
 80031bc:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 80031c0:	d002      	beq.n	80031c8 <HAL_GPIO_EXTI_Callback+0x14>
	{
		vApplicationCardDetectChangeHookFromISR( &xHigherPriorityTaskWoken );
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}
}
 80031c2:	b003      	add	sp, #12
 80031c4:	f85d fb04 	ldr.w	pc, [sp], #4
		vApplicationCardDetectChangeHookFromISR( &xHigherPriorityTaskWoken );
 80031c8:	a801      	add	r0, sp, #4
 80031ca:	f009 f8f7 	bl	800c3bc <vApplicationCardDetectChangeHookFromISR>
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	2b00      	cmp	r3, #0
 80031d2:	d0f6      	beq.n	80031c2 <HAL_GPIO_EXTI_Callback+0xe>
 80031d4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80031d8:	4b03      	ldr	r3, [pc, #12]	; (80031e8 <HAL_GPIO_EXTI_Callback+0x34>)
 80031da:	601a      	str	r2, [r3, #0]
 80031dc:	f3bf 8f4f 	dsb	sy
 80031e0:	f3bf 8f6f 	isb	sy
}
 80031e4:	e7ed      	b.n	80031c2 <HAL_GPIO_EXTI_Callback+0xe>
 80031e6:	bf00      	nop
 80031e8:	e000ed04 	.word	0xe000ed04

080031ec <EXTI15_10_IRQHandler>:
/*-----------------------------------------------------------*/

void EXTI15_10_IRQHandler( void )
{
 80031ec:	b508      	push	{r3, lr}
	HAL_GPIO_EXTI_IRQHandler( configSD_DETECT_PIN );	/* GPIO PIN H.13 */
 80031ee:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80031f2:	f7ff f963 	bl	80024bc <HAL_GPIO_EXTI_IRQHandler>
 80031f6:	bd08      	pop	{r3, pc}

080031f8 <HAL_SD_XferCpltCallback>:
  * @brief  SD end of transfer callback.
  * @param  hsd: SD handle
  * @retval None
  */
__weak void HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd)
{
 80031f8:	4770      	bx	lr

080031fa <HAL_SD_XferErrorCallback>:
  * @brief  SD Transfer Error callback.
  * @param  hsd: SD handle
  * @retval None
  */
__weak void HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd)
{
 80031fa:	4770      	bx	lr

080031fc <HAL_SD_IRQHandler>:
{
 80031fc:	b510      	push	{r4, lr}
 80031fe:	4604      	mov	r4, r0
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
 8003200:	6803      	ldr	r3, [r0, #0]
 8003202:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003204:	f412 7f80 	tst.w	r2, #256	; 0x100
 8003208:	d11b      	bne.n	8003242 <HAL_SD_IRQHandler+0x46>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DCRCFAIL))
 800320a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800320c:	f012 0f02 	tst.w	r2, #2
 8003210:	d128      	bne.n	8003264 <HAL_SD_IRQHandler+0x68>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DTIMEOUT))
 8003212:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003214:	f012 0f08 	tst.w	r2, #8
 8003218:	d12a      	bne.n	8003270 <HAL_SD_IRQHandler+0x74>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_RXOVERR))
 800321a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800321c:	f012 0f20 	tst.w	r2, #32
 8003220:	d12d      	bne.n	800327e <HAL_SD_IRQHandler+0x82>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_TXUNDERR))
 8003222:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003224:	f012 0f10 	tst.w	r2, #16
 8003228:	d130      	bne.n	800328c <HAL_SD_IRQHandler+0x90>
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_STBITERR))
 800322a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800322c:	f412 7f00 	tst.w	r2, #512	; 0x200
 8003230:	d010      	beq.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8003232:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003236:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_START_BIT_ERR;
 8003238:	2307      	movs	r3, #7
 800323a:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 800323c:	f7ff ffdd 	bl	80031fa <HAL_SD_XferErrorCallback>
 8003240:	e008      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_IT_DATAEND);
 8003242:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003246:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferCplt = 1;
 8003248:	2301      	movs	r3, #1
 800324a:	6483      	str	r3, [r0, #72]	; 0x48
    hsd->SdTransferErr  = SD_OK;
 800324c:	2300      	movs	r3, #0
 800324e:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferCpltCallback(hsd);
 8003250:	f7ff ffd2 	bl	80031f8 <HAL_SD_XferCpltCallback>
  __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
 8003254:	6822      	ldr	r2, [r4, #0]
 8003256:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8003258:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 800325c:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
 8003260:	63d3      	str	r3, [r2, #60]	; 0x3c
 8003262:	bd10      	pop	{r4, pc}
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8003264:	2202      	movs	r2, #2
 8003266:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_DATA_CRC_FAIL;
 8003268:	64c2      	str	r2, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 800326a:	f7ff ffc6 	bl	80031fa <HAL_SD_XferErrorCallback>
 800326e:	e7f1      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8003270:	2208      	movs	r2, #8
 8003272:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_DATA_TIMEOUT;
 8003274:	2304      	movs	r3, #4
 8003276:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 8003278:	f7ff ffbf 	bl	80031fa <HAL_SD_XferErrorCallback>
 800327c:	e7ea      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 800327e:	2220      	movs	r2, #32
 8003280:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_RX_OVERRUN;
 8003282:	2306      	movs	r3, #6
 8003284:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 8003286:	f7ff ffb8 	bl	80031fa <HAL_SD_XferErrorCallback>
 800328a:	e7e3      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 800328c:	2210      	movs	r2, #16
 800328e:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->SdTransferErr = SD_TX_UNDERRUN;
 8003290:	2305      	movs	r3, #5
 8003292:	64c3      	str	r3, [r0, #76]	; 0x4c
    HAL_SD_XferErrorCallback(hsd);
 8003294:	f7ff ffb1 	bl	80031fa <HAL_SD_XferErrorCallback>
 8003298:	e7dc      	b.n	8003254 <HAL_SD_IRQHandler+0x58>
	...

0800329c <vARPRefreshCacheEntry>:

#endif	/* ipconfigUSE_ARP_REMOVE_ENTRY != 0 */
/*-----------------------------------------------------------*/

void vARPRefreshCacheEntry( const MACAddress_t * pxMACAddress, const uint32_t ulIPAddress )
{
 800329c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032a0:	b083      	sub	sp, #12

	#if( ipconfigARP_STORES_REMOTE_ADDRESSES == 0 )
		/* Only process the IP address if it is on the local network.
		Unless: when '*ipLOCAL_IP_ADDRESS_POINTER' equals zero, the IP-address
		and netmask are still unknown. */
		if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
 80032a2:	4b46      	ldr	r3, [pc, #280]	; (80033bc <vARPRefreshCacheEntry+0x120>)
 80032a4:	695b      	ldr	r3, [r3, #20]
 80032a6:	ea83 0401 	eor.w	r4, r3, r1
 80032aa:	4a45      	ldr	r2, [pc, #276]	; (80033c0 <vARPRefreshCacheEntry+0x124>)
 80032ac:	6852      	ldr	r2, [r2, #4]
 80032ae:	4214      	tst	r4, r2
 80032b0:	d001      	beq.n	80032b6 <vARPRefreshCacheEntry+0x1a>
 80032b2:	2b00      	cmp	r3, #0
 80032b4:	d164      	bne.n	8003380 <vARPRefreshCacheEntry+0xe4>
 80032b6:	4688      	mov	r8, r1
 80032b8:	4606      	mov	r6, r0
 80032ba:	4c42      	ldr	r4, [pc, #264]	; (80033c4 <vARPRefreshCacheEntry+0x128>)
{
 80032bc:	f04f 0bff 	mov.w	fp, #255	; 0xff
 80032c0:	2300      	movs	r3, #0
 80032c2:	9301      	str	r3, [sp, #4]
 80032c4:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 80032c8:	46ca      	mov	sl, r9
 80032ca:	461d      	mov	r5, r3
 80032cc:	e017      	b.n	80032fe <vARPRefreshCacheEntry+0x62>
		{
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
			{
				if( pxMACAddress == NULL )
 80032ce:	b34e      	cbz	r6, 8003324 <vARPRefreshCacheEntry+0x88>
					xIpEntry = x;
					break;
				}

				/* See if the MAC-address also matches. */
				if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 80032d0:	2206      	movs	r2, #6
 80032d2:	4631      	mov	r1, r6
 80032d4:	4620      	mov	r0, r4
 80032d6:	f009 f9ef 	bl	800c6b8 <memcmp>
 80032da:	b108      	cbz	r0, 80032e0 <vARPRefreshCacheEntry+0x44>
 80032dc:	46aa      	mov	sl, r5
 80032de:	e00a      	b.n	80032f6 <vARPRefreshCacheEntry+0x5a>
				{
					/* This function will be called for each received packet
					As this is by far the most common path the coding standard
					is relaxed in this case and a return is permitted as an
					optimisation. */
					xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 80032e0:	4b39      	ldr	r3, [pc, #228]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 80032e2:	006a      	lsls	r2, r5, #1
 80032e4:	1951      	adds	r1, r2, r5
 80032e6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80032ea:	2096      	movs	r0, #150	; 0x96
 80032ec:	7288      	strb	r0, [r1, #10]
					xARPCache[ x ].ucValid = ( uint8_t ) pdTRUE;
 80032ee:	2201      	movs	r2, #1
 80032f0:	72ca      	strb	r2, [r1, #11]
					return;
 80032f2:	e045      	b.n	8003380 <vARPRefreshCacheEntry+0xe4>
 80032f4:	46a9      	mov	r9, r5
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80032f6:	3501      	adds	r5, #1
 80032f8:	340c      	adds	r4, #12
 80032fa:	2d06      	cmp	r5, #6
 80032fc:	d013      	beq.n	8003326 <vARPRefreshCacheEntry+0x8a>
 80032fe:	4627      	mov	r7, r4
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 8003300:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8003304:	4598      	cmp	r8, r3
 8003306:	d0e2      	beq.n	80032ce <vARPRefreshCacheEntry+0x32>
				for an ARP reply.  Still want to see if there is match with the
				given MAC address.ucBytes.  If found, either of the two entries
				must be cleared. */
				xIpEntry = x;
			}
			else if( ( pxMACAddress != NULL ) && ( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 ) )
 8003308:	b136      	cbz	r6, 8003318 <vARPRefreshCacheEntry+0x7c>
 800330a:	2206      	movs	r2, #6
 800330c:	4631      	mov	r1, r6
 800330e:	4620      	mov	r0, r4
 8003310:	f009 f9d2 	bl	800c6b8 <memcmp>
 8003314:	2800      	cmp	r0, #0
 8003316:	d0ed      	beq.n	80032f4 <vARPRefreshCacheEntry+0x58>
				xMacEntry = x;
	#endif
			}
			/* _HT_
			Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8003318:	79bb      	ldrb	r3, [r7, #6]
 800331a:	455b      	cmp	r3, fp
 800331c:	d2eb      	bcs.n	80032f6 <vARPRefreshCacheEntry+0x5a>
			{
				/* As the table is traversed, remember the table row that
				contains the oldest entry (the lowest age count, as ages are
				decremented to zero) so the row can be re-used if this function
				needs to add an entry that does not already exist. */
				ucMinAgeFound = xARPCache[ x ].ucAge;
 800331e:	469b      	mov	fp, r3
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8003320:	9501      	str	r5, [sp, #4]
 8003322:	e7e8      	b.n	80032f6 <vARPRefreshCacheEntry+0x5a>
 8003324:	46aa      	mov	sl, r5
				xUseEntry = x;
			}
		}

		if( xMacEntry >= 0 )
 8003326:	f1b9 0f00 	cmp.w	r9, #0
 800332a:	db2c      	blt.n	8003386 <vARPRefreshCacheEntry+0xea>
		{
			xUseEntry = xMacEntry;

			if( xIpEntry >= 0 )
 800332c:	f1ba 0f00 	cmp.w	sl, #0
 8003330:	db30      	blt.n	8003394 <vARPRefreshCacheEntry+0xf8>
			{
				/* Both the MAC address as well as the IP address were found in
				different locations: clear the entry which matches the
				IP-address */
				memset( &xARPCache[ xIpEntry ], '\0', sizeof( xARPCache[ xIpEntry ] ) );
 8003332:	4925      	ldr	r1, [pc, #148]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 8003334:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
 8003338:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800333c:	eb01 020a 	add.w	r2, r1, sl
 8003340:	2300      	movs	r3, #0
 8003342:	f841 300a 	str.w	r3, [r1, sl]
 8003346:	6053      	str	r3, [r2, #4]
 8003348:	6093      	str	r3, [r2, #8]
			/* An entry containing the IP-address was found, but it had a different MAC address */
			xUseEntry = xIpEntry;
		}

		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 800334a:	eb09 0349 	add.w	r3, r9, r9, lsl #1
 800334e:	4a1e      	ldr	r2, [pc, #120]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 8003350:	f842 8023 	str.w	r8, [r2, r3, lsl #2]

		if( pxMACAddress != NULL )
 8003354:	b1a6      	cbz	r6, 8003380 <vARPRefreshCacheEntry+0xe4>
		{
			memcpy( xARPCache[ xUseEntry ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) );
 8003356:	4b1c      	ldr	r3, [pc, #112]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 8003358:	ea4f 0149 	mov.w	r1, r9, lsl #1
 800335c:	eb01 0209 	add.w	r2, r1, r9
 8003360:	0092      	lsls	r2, r2, #2
 8003362:	3204      	adds	r2, #4
 8003364:	189c      	adds	r4, r3, r2
 8003366:	6830      	ldr	r0, [r6, #0]
 8003368:	5098      	str	r0, [r3, r2]
 800336a:	88b2      	ldrh	r2, [r6, #4]
 800336c:	80a2      	strh	r2, [r4, #4]

			iptraceARP_TABLE_ENTRY_CREATED( ulIPAddress, (*pxMACAddress) );
			/* And this entry does not need immediate attention */
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 800336e:	eb01 0209 	add.w	r2, r1, r9
 8003372:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8003376:	2096      	movs	r0, #150	; 0x96
 8003378:	7290      	strb	r0, [r2, #10]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdTRUE;
 800337a:	4613      	mov	r3, r2
 800337c:	2201      	movs	r2, #1
 800337e:	72da      	strb	r2, [r3, #11]
		{
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
		}
	}
}
 8003380:	b003      	add	sp, #12
 8003382:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		else if( xIpEntry >= 0 )
 8003386:	f1ba 0f00 	cmp.w	sl, #0
 800338a:	db01      	blt.n	8003390 <vARPRefreshCacheEntry+0xf4>
			xUseEntry = xIpEntry;
 800338c:	46d1      	mov	r9, sl
 800338e:	e7dc      	b.n	800334a <vARPRefreshCacheEntry+0xae>
 8003390:	f8dd 9004 	ldr.w	r9, [sp, #4]
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 8003394:	eb09 0349 	add.w	r3, r9, r9, lsl #1
 8003398:	4a0b      	ldr	r2, [pc, #44]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 800339a:	f842 8023 	str.w	r8, [r2, r3, lsl #2]
		if( pxMACAddress != NULL )
 800339e:	2e00      	cmp	r6, #0
 80033a0:	d1d9      	bne.n	8003356 <vARPRefreshCacheEntry+0xba>
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
 80033a2:	4b09      	ldr	r3, [pc, #36]	; (80033c8 <vARPRefreshCacheEntry+0x12c>)
 80033a4:	ea4f 0249 	mov.w	r2, r9, lsl #1
 80033a8:	eb02 0109 	add.w	r1, r2, r9
 80033ac:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80033b0:	2005      	movs	r0, #5
 80033b2:	7288      	strb	r0, [r1, #10]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
 80033b4:	2200      	movs	r2, #0
 80033b6:	72ca      	strb	r2, [r1, #11]
 80033b8:	e7e2      	b.n	8003380 <vARPRefreshCacheEntry+0xe4>
 80033ba:	bf00      	nop
 80033bc:	20000010 	.word	0x20000010
 80033c0:	20000530 	.word	0x20000530
 80033c4:	200003e0 	.word	0x200003e0
 80033c8:	200003dc 	.word	0x200003dc

080033cc <eARPProcessPacket>:
{
 80033cc:	b538      	push	{r3, r4, r5, lr}
	if( *ipLOCAL_IP_ADDRESS_POINTER != 0UL )
 80033ce:	4b26      	ldr	r3, [pc, #152]	; (8003468 <eARPProcessPacket+0x9c>)
 80033d0:	695b      	ldr	r3, [r3, #20]
 80033d2:	2b00      	cmp	r3, #0
 80033d4:	d046      	beq.n	8003464 <eARPProcessPacket+0x98>
 80033d6:	4604      	mov	r4, r0
		switch( pxARPHeader->usOperation )
 80033d8:	8a82      	ldrh	r2, [r0, #20]
 80033da:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80033de:	d004      	beq.n	80033ea <eARPProcessPacket+0x1e>
 80033e0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80033e4:	d038      	beq.n	8003458 <eARPProcessPacket+0x8c>
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 80033e6:	2000      	movs	r0, #0
 80033e8:	bd38      	pop	{r3, r4, r5, pc}
				if( pxARPHeader->ulTargetProtocolAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 80033ea:	f8d0 2026 	ldr.w	r2, [r0, #38]	; 0x26
 80033ee:	4293      	cmp	r3, r2
 80033f0:	d001      	beq.n	80033f6 <eARPProcessPacket+0x2a>
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 80033f2:	2000      	movs	r0, #0
}
 80033f4:	bd38      	pop	{r3, r4, r5, pc}
					vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), pxARPHeader->ulSenderProtocolAddress );
 80033f6:	f100 0516 	add.w	r5, r0, #22
 80033fa:	69c1      	ldr	r1, [r0, #28]
 80033fc:	4628      	mov	r0, r5
 80033fe:	f7ff ff4d 	bl	800329c <vARPRefreshCacheEntry>
					pxARPHeader->usOperation = ( uint16_t ) ipARP_REPLY;
 8003402:	2300      	movs	r3, #0
 8003404:	7523      	strb	r3, [r4, #20]
 8003406:	2302      	movs	r3, #2
 8003408:	7563      	strb	r3, [r4, #21]
					if( pxARPHeader->ulTargetProtocolAddress == pxARPHeader->ulSenderProtocolAddress )
 800340a:	69e3      	ldr	r3, [r4, #28]
 800340c:	f8d4 2026 	ldr.w	r2, [r4, #38]	; 0x26
 8003410:	429a      	cmp	r2, r3
 8003412:	d00f      	beq.n	8003434 <eARPProcessPacket+0x68>
						memcpy( pxARPHeader->xTargetHardwareAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( MACAddress_t ) );
 8003414:	682a      	ldr	r2, [r5, #0]
 8003416:	6222      	str	r2, [r4, #32]
 8003418:	88aa      	ldrh	r2, [r5, #4]
 800341a:	84a2      	strh	r2, [r4, #36]	; 0x24
						pxARPHeader->ulTargetProtocolAddress = pxARPHeader->ulSenderProtocolAddress;
 800341c:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
					memcpy( pxARPHeader->xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) );
 8003420:	4b11      	ldr	r3, [pc, #68]	; (8003468 <eARPProcessPacket+0x9c>)
 8003422:	6818      	ldr	r0, [r3, #0]
 8003424:	f8c4 0016 	str.w	r0, [r4, #22]
 8003428:	889a      	ldrh	r2, [r3, #4]
 800342a:	80aa      	strh	r2, [r5, #4]
					pxARPHeader->ulSenderProtocolAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800342c:	695b      	ldr	r3, [r3, #20]
 800342e:	61e3      	str	r3, [r4, #28]
					eReturn = eReturnEthernetFrame;
 8003430:	2002      	movs	r0, #2
 8003432:	bd38      	pop	{r3, r4, r5, pc}
						memcpy( pxARPFrame->xEthernetHeader.xSourceAddress.ucBytes, xBroadcastMACAddress.ucBytes, sizeof( xBroadcastMACAddress ) );
 8003434:	4b0d      	ldr	r3, [pc, #52]	; (800346c <eARPProcessPacket+0xa0>)
 8003436:	681a      	ldr	r2, [r3, #0]
 8003438:	f8c4 2006 	str.w	r2, [r4, #6]
 800343c:	889b      	ldrh	r3, [r3, #4]
 800343e:	8163      	strh	r3, [r4, #10]
						memset( pxARPHeader->xTargetHardwareAddress.ucBytes, '\0', sizeof( MACAddress_t ) );
 8003440:	2300      	movs	r3, #0
 8003442:	6223      	str	r3, [r4, #32]
 8003444:	84a3      	strh	r3, [r4, #36]	; 0x24
						pxARPHeader->ulTargetProtocolAddress = 0UL;
 8003446:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
 800344a:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
 800344e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
 8003452:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
 8003456:	e7e3      	b.n	8003420 <eARPProcessPacket+0x54>
				vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), pxARPHeader->ulSenderProtocolAddress );
 8003458:	69c1      	ldr	r1, [r0, #28]
 800345a:	3016      	adds	r0, #22
 800345c:	f7ff ff1e 	bl	800329c <vARPRefreshCacheEntry>
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8003460:	2000      	movs	r0, #0
				break;
 8003462:	bd38      	pop	{r3, r4, r5, pc}
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8003464:	2000      	movs	r0, #0
 8003466:	bd38      	pop	{r3, r4, r5, pc}
 8003468:	20000010 	.word	0x20000010
 800346c:	0800cb58 	.word	0x0800cb58

08003470 <eARPGetCacheEntry>:
{
eARPLookupResult_t eReturn;
uint32_t ulAddressToLookup;

#if( ipconfigUSE_LLMNR == 1 )
	if( *pulIPAddress == ipLLMNR_IP_ADDR )	/* Is in network byte order */
 8003470:	6803      	ldr	r3, [r0, #0]
 8003472:	4a27      	ldr	r2, [pc, #156]	; (8003510 <eARPGetCacheEntry+0xa0>)
 8003474:	4293      	cmp	r3, r2
 8003476:	d00b      	beq.n	8003490 <eARPGetCacheEntry+0x20>
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else
#endif
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 8003478:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800347c:	d00f      	beq.n	800349e <eARPGetCacheEntry+0x2e>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
 800347e:	4a25      	ldr	r2, [pc, #148]	; (8003514 <eARPGetCacheEntry+0xa4>)
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 8003480:	6912      	ldr	r2, [r2, #16]
 8003482:	4293      	cmp	r3, r2
 8003484:	d00b      	beq.n	800349e <eARPGetCacheEntry+0x2e>
	{
		/* This is a broadcast so uses the broadcast MAC address. */
		memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else if( *ipLOCAL_IP_ADDRESS_POINTER == 0UL )
 8003486:	4a24      	ldr	r2, [pc, #144]	; (8003518 <eARPGetCacheEntry+0xa8>)
 8003488:	6952      	ldr	r2, [r2, #20]
 800348a:	b97a      	cbnz	r2, 80034ac <eARPGetCacheEntry+0x3c>
	{
		/* The IP address has not yet been assigned, so there is nothing that
		can be done. */
		eReturn = eCantSendPacket;
 800348c:	2002      	movs	r0, #2
 800348e:	4770      	bx	lr
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
 8003490:	4b22      	ldr	r3, [pc, #136]	; (800351c <eARPGetCacheEntry+0xac>)
 8003492:	681a      	ldr	r2, [r3, #0]
 8003494:	600a      	str	r2, [r1, #0]
 8003496:	889b      	ldrh	r3, [r3, #4]
 8003498:	808b      	strh	r3, [r1, #4]
		eReturn = eARPCacheHit;
 800349a:	2001      	movs	r0, #1
 800349c:	4770      	bx	lr
		memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
 800349e:	4b20      	ldr	r3, [pc, #128]	; (8003520 <eARPGetCacheEntry+0xb0>)
 80034a0:	681a      	ldr	r2, [r3, #0]
 80034a2:	600a      	str	r2, [r1, #0]
 80034a4:	889b      	ldrh	r3, [r3, #4]
 80034a6:	808b      	strh	r3, [r1, #4]
		eReturn = eARPCacheHit;
 80034a8:	2001      	movs	r0, #1
 80034aa:	4770      	bx	lr
{
 80034ac:	b430      	push	{r4, r5}
	}
	else
	{
		eReturn = eARPCacheMiss;

		if( ( *pulIPAddress & xNetworkAddressing.ulNetMask ) != ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) )
 80034ae:	405a      	eors	r2, r3
 80034b0:	4c18      	ldr	r4, [pc, #96]	; (8003514 <eARPGetCacheEntry+0xa4>)
 80034b2:	6864      	ldr	r4, [r4, #4]
 80034b4:	4222      	tst	r2, r4
			else
#endif
			{
				/* The IP address is off the local network, so look up the
				hardware address of the router, if any. */
				ulAddressToLookup = xNetworkAddressing.ulGatewayAddress;
 80034b6:	bf1c      	itt	ne
 80034b8:	4b16      	ldrne	r3, [pc, #88]	; (8003514 <eARPGetCacheEntry+0xa4>)
 80034ba:	689b      	ldrne	r3, [r3, #8]
			ulAddressToLookup = *pulIPAddress;
		}

		if( eReturn == eARPCacheMiss )
		{
			if( ulAddressToLookup == 0UL )
 80034bc:	b913      	cbnz	r3, 80034c4 <eARPGetCacheEntry+0x54>
			{
				/* The address is not on the local network, and there is not a
				router. */
				eReturn = eCantSendPacket;
 80034be:	2002      	movs	r0, #2
			}
		}
	}

	return eReturn;
}
 80034c0:	bc30      	pop	{r4, r5}
 80034c2:	4770      	bx	lr
	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
	{
		/* Does this row in the ARP cache table hold an entry for the IP address
		being queried? */
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80034c4:	4a17      	ldr	r2, [pc, #92]	; (8003524 <eARPGetCacheEntry+0xb4>)
 80034c6:	6812      	ldr	r2, [r2, #0]
 80034c8:	4293      	cmp	r3, r2
 80034ca:	d00b      	beq.n	80034e4 <eARPGetCacheEntry+0x74>
 80034cc:	4c15      	ldr	r4, [pc, #84]	; (8003524 <eARPGetCacheEntry+0xb4>)
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80034ce:	2201      	movs	r2, #1
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80034d0:	68e5      	ldr	r5, [r4, #12]
 80034d2:	42ab      	cmp	r3, r5
 80034d4:	d007      	beq.n	80034e6 <eARPGetCacheEntry+0x76>
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80034d6:	3201      	adds	r2, #1
 80034d8:	340c      	adds	r4, #12
 80034da:	2a06      	cmp	r2, #6
 80034dc:	d1f8      	bne.n	80034d0 <eARPGetCacheEntry+0x60>
					*pulIPAddress = ulAddressToLookup;
 80034de:	6003      	str	r3, [r0, #0]
				eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress );
 80034e0:	2000      	movs	r0, #0
 80034e2:	e7ed      	b.n	80034c0 <eARPGetCacheEntry+0x50>
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 80034e4:	2200      	movs	r2, #0
		{
			/* A matching valid entry was found. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 80034e6:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80034ea:	480e      	ldr	r0, [pc, #56]	; (8003524 <eARPGetCacheEntry+0xb4>)
 80034ec:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80034f0:	7adb      	ldrb	r3, [r3, #11]
 80034f2:	b90b      	cbnz	r3, 80034f8 <eARPGetCacheEntry+0x88>
			{
				/* This entry is waiting an ARP reply, so is not valid. */
				eReturn = eCantSendPacket;
 80034f4:	2002      	movs	r0, #2
	return eReturn;
 80034f6:	e7e3      	b.n	80034c0 <eARPGetCacheEntry+0x50>
			}
			else
			{
				/* A valid entry was found. */
				memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 80034f8:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80034fc:	009b      	lsls	r3, r3, #2
 80034fe:	3304      	adds	r3, #4
 8003500:	18c2      	adds	r2, r0, r3
 8003502:	58c0      	ldr	r0, [r0, r3]
 8003504:	6008      	str	r0, [r1, #0]
 8003506:	8893      	ldrh	r3, [r2, #4]
 8003508:	808b      	strh	r3, [r1, #4]
				eReturn = eARPCacheHit;
 800350a:	2001      	movs	r0, #1
 800350c:	e7d8      	b.n	80034c0 <eARPGetCacheEntry+0x50>
 800350e:	bf00      	nop
 8003510:	fc0000e0 	.word	0xfc0000e0
 8003514:	20000530 	.word	0x20000530
 8003518:	20000010 	.word	0x20000010
 800351c:	0800cb10 	.word	0x0800cb10
 8003520:	0800cb58 	.word	0x0800cb58
 8003524:	200003dc 	.word	0x200003dc

08003528 <vARPSendGratuitous>:
	}
}
/*-----------------------------------------------------------*/

void vARPSendGratuitous( void )
{
 8003528:	b508      	push	{r3, lr}
	/* Setting xLastGratuitousARPTime to 0 will force a gratuitous ARP the next
	time vARPAgeCache() is called. */
	xLastGratuitousARPTime = ( TickType_t ) 0;
 800352a:	2200      	movs	r2, #0
 800352c:	4b02      	ldr	r3, [pc, #8]	; (8003538 <vARPSendGratuitous+0x10>)
 800352e:	601a      	str	r2, [r3, #0]

	/* Let the IP-task call vARPAgeCache(). */
	xSendEventToIPTask( eARPTimerEvent );
 8003530:	2002      	movs	r0, #2
 8003532:	f001 f8ef 	bl	8004714 <xSendEventToIPTask>
 8003536:	bd08      	pop	{r3, pc}
 8003538:	20000424 	.word	0x20000424

0800353c <vARPGenerateRequestPacket>:
		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
	}
}

void vARPGenerateRequestPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 800353c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800353e:	4686      	mov	lr, r0
ARPPacket_t *pxARPPacket;

	pxARPPacket = ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
 8003540:	6987      	ldr	r7, [r0, #24]
		xARPHeader.ucHardwareAddressLength;
		xARPHeader.ucProtocolAddressLength;
		xARPHeader.usOperation;
		xARPHeader.xTargetHardwareAddress;
	*/
	memcpy( ( void * ) &( pxARPPacket->xEthernetHeader ), ( void * ) xDefaultPartARPPacketHeader, sizeof( xDefaultPartARPPacketHeader ) );
 8003542:	4e12      	ldr	r6, [pc, #72]	; (800358c <vARPGenerateRequestPacket+0x50>)
 8003544:	463c      	mov	r4, r7
 8003546:	f106 0c20 	add.w	ip, r6, #32
 800354a:	4635      	mov	r5, r6
 800354c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800354e:	6020      	str	r0, [r4, #0]
 8003550:	6061      	str	r1, [r4, #4]
 8003552:	60a2      	str	r2, [r4, #8]
 8003554:	60e3      	str	r3, [r4, #12]
 8003556:	462e      	mov	r6, r5
 8003558:	3410      	adds	r4, #16
 800355a:	4565      	cmp	r5, ip
 800355c:	d1f5      	bne.n	800354a <vARPGenerateRequestPacket+0xe>
 800355e:	6828      	ldr	r0, [r5, #0]
 8003560:	6020      	str	r0, [r4, #0]
 8003562:	88ab      	ldrh	r3, [r5, #4]
 8003564:	80a3      	strh	r3, [r4, #4]
	memcpy( ( void * ) pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8003566:	4b0a      	ldr	r3, [pc, #40]	; (8003590 <vARPGenerateRequestPacket+0x54>)
 8003568:	6818      	ldr	r0, [r3, #0]
 800356a:	f8c7 0006 	str.w	r0, [r7, #6]
 800356e:	889a      	ldrh	r2, [r3, #4]
 8003570:	817a      	strh	r2, [r7, #10]
	memcpy( ( void * ) pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8003572:	f8c7 0016 	str.w	r0, [r7, #22]
 8003576:	837a      	strh	r2, [r7, #26]
	/* HT:endian: network to network */
	pxARPPacket->xARPHeader.ulSenderProtocolAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8003578:	695b      	ldr	r3, [r3, #20]
 800357a:	61fb      	str	r3, [r7, #28]
	pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->ulIPAddress;
 800357c:	f8de 3014 	ldr.w	r3, [lr, #20]
 8003580:	f8c7 3026 	str.w	r3, [r7, #38]	; 0x26

	pxNetworkBuffer->xDataLength = sizeof( ARPPacket_t );
 8003584:	232a      	movs	r3, #42	; 0x2a
 8003586:	f8ce 301c 	str.w	r3, [lr, #28]
 800358a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800358c:	0800ca94 	.word	0x0800ca94
 8003590:	20000010 	.word	0x20000010

08003594 <FreeRTOS_OutputARPRequest>:
{
 8003594:	b538      	push	{r3, r4, r5, lr}
 8003596:	4605      	mov	r5, r0
	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( ARPPacket_t ), ( TickType_t ) 0 );
 8003598:	2100      	movs	r1, #0
 800359a:	202a      	movs	r0, #42	; 0x2a
 800359c:	f004 ffc0 	bl	8008520 <pxGetNetworkBufferWithDescriptor>
	if( pxNetworkBuffer != NULL )
 80035a0:	b138      	cbz	r0, 80035b2 <FreeRTOS_OutputARPRequest+0x1e>
 80035a2:	4604      	mov	r4, r0
		pxNetworkBuffer->ulIPAddress = ulIPAddress;
 80035a4:	6145      	str	r5, [r0, #20]
		vARPGenerateRequestPacket( pxNetworkBuffer );
 80035a6:	f7ff ffc9 	bl	800353c <vARPGenerateRequestPacket>
		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 80035aa:	2101      	movs	r1, #1
 80035ac:	4620      	mov	r0, r4
 80035ae:	f005 fa53 	bl	8008a58 <xNetworkInterfaceOutput>
 80035b2:	bd38      	pop	{r3, r4, r5, pc}

080035b4 <vARPAgeCache>:
{
 80035b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80035b8:	4c1b      	ldr	r4, [pc, #108]	; (8003628 <vARPAgeCache+0x74>)
 80035ba:	f104 0648 	add.w	r6, r4, #72	; 0x48
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
 80035be:	2700      	movs	r7, #0
 80035c0:	f04f 0807 	mov.w	r8, #7
 80035c4:	e007      	b.n	80035d6 <vARPAgeCache+0x22>
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 80035c6:	6820      	ldr	r0, [r4, #0]
 80035c8:	f7ff ffe4 	bl	8003594 <FreeRTOS_OutputARPRequest>
			if( xARPCache[ x ].ucAge == 0u )
 80035cc:	7aab      	ldrb	r3, [r5, #10]
 80035ce:	b193      	cbz	r3, 80035f6 <vARPAgeCache+0x42>
 80035d0:	340c      	adds	r4, #12
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80035d2:	42b4      	cmp	r4, r6
 80035d4:	d015      	beq.n	8003602 <vARPAgeCache+0x4e>
 80035d6:	4625      	mov	r5, r4
		if( xARPCache[ x ].ucAge > 0U )
 80035d8:	7aa3      	ldrb	r3, [r4, #10]
 80035da:	2b00      	cmp	r3, #0
 80035dc:	d0f8      	beq.n	80035d0 <vARPAgeCache+0x1c>
			( xARPCache[ x ].ucAge )--;
 80035de:	3b01      	subs	r3, #1
 80035e0:	b2db      	uxtb	r3, r3
 80035e2:	72a3      	strb	r3, [r4, #10]
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 80035e4:	7ae2      	ldrb	r2, [r4, #11]
 80035e6:	2a00      	cmp	r2, #0
 80035e8:	d0ed      	beq.n	80035c6 <vARPAgeCache+0x12>
			else if( xARPCache[ x ].ucAge <= ( uint8_t ) arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST )
 80035ea:	2b03      	cmp	r3, #3
 80035ec:	d8ee      	bhi.n	80035cc <vARPAgeCache+0x18>
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 80035ee:	6820      	ldr	r0, [r4, #0]
 80035f0:	f7ff ffd0 	bl	8003594 <FreeRTOS_OutputARPRequest>
 80035f4:	e7ea      	b.n	80035cc <vARPAgeCache+0x18>
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
 80035f6:	4639      	mov	r1, r7
 80035f8:	4640      	mov	r0, r8
 80035fa:	f008 f929 	bl	800b850 <vExampleDebugStatUpdate>
				xARPCache[ x ].ulIPAddress = 0UL;
 80035fe:	602f      	str	r7, [r5, #0]
 8003600:	e7e6      	b.n	80035d0 <vARPAgeCache+0x1c>
	xTimeNow = xTaskGetTickCount ();
 8003602:	f006 fd15 	bl	800a030 <xTaskGetTickCount>
 8003606:	4604      	mov	r4, r0
	if( ( xLastGratuitousARPTime == ( TickType_t ) 0 ) || ( ( xTimeNow - xLastGratuitousARPTime ) > ( TickType_t ) arpGRATUITOUS_ARP_PERIOD ) )
 8003608:	4b08      	ldr	r3, [pc, #32]	; (800362c <vARPAgeCache+0x78>)
 800360a:	681b      	ldr	r3, [r3, #0]
 800360c:	b123      	cbz	r3, 8003618 <vARPAgeCache+0x64>
 800360e:	1ac3      	subs	r3, r0, r3
 8003610:	f644 6220 	movw	r2, #20000	; 0x4e20
 8003614:	4293      	cmp	r3, r2
 8003616:	d905      	bls.n	8003624 <vARPAgeCache+0x70>
		FreeRTOS_OutputARPRequest( *ipLOCAL_IP_ADDRESS_POINTER );
 8003618:	4b05      	ldr	r3, [pc, #20]	; (8003630 <vARPAgeCache+0x7c>)
 800361a:	6958      	ldr	r0, [r3, #20]
 800361c:	f7ff ffba 	bl	8003594 <FreeRTOS_OutputARPRequest>
		xLastGratuitousARPTime = xTimeNow;
 8003620:	4b02      	ldr	r3, [pc, #8]	; (800362c <vARPAgeCache+0x78>)
 8003622:	601c      	str	r4, [r3, #0]
 8003624:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003628:	200003dc 	.word	0x200003dc
 800362c:	20000424 	.word	0x20000424
 8003630:	20000010 	.word	0x20000010

08003634 <prvCreatePartDHCPMessage>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static uint8_t *prvCreatePartDHCPMessage( struct freertos_sockaddr *pxAddress, BaseType_t xOpcode, const uint8_t * const pucOptionsArray, size_t *pxOptionsArraySize )
{
 8003634:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003638:	b083      	sub	sp, #12
 800363a:	4681      	mov	r9, r0
 800363c:	468b      	mov	fp, r1
 800363e:	4692      	mov	sl, r2
 8003640:	461f      	mov	r7, r3
DHCPMessage_t *pxDHCPMessage;
size_t xRequiredBufferSize = sizeof( DHCPMessage_t ) + *pxOptionsArraySize;
 8003642:	681d      	ldr	r5, [r3, #0]
uint8_t *pucUDPPayloadBuffer;

#if( ipconfigDHCP_REGISTER_HOSTNAME == 1 )
	const char *pucHostName = pcApplicationHostnameHook ();
 8003644:	f008 ff7e 	bl	800c544 <pcApplicationHostnameHook>
 8003648:	9001      	str	r0, [sp, #4]
	size_t xNameLength = strlen( pucHostName );
 800364a:	f7fc fdc1 	bl	80001d0 <strlen>
 800364e:	4680      	mov	r8, r0
	uint8_t *pucPtr;

	xRequiredBufferSize += ( 2 + xNameLength );
 8003650:	35f3      	adds	r5, #243	; 0xf3
 8003652:	4405      	add	r5, r0
	/* Get a buffer.  This uses a maximum delay, but the delay will be capped
	to ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS so the return value still needs to
	be test. */
	do
	{
	} while( ( pucUDPPayloadBuffer = ( uint8_t * ) FreeRTOS_GetUDPPayloadBuffer( xRequiredBufferSize, portMAX_DELAY ) ) == NULL );
 8003654:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8003658:	4631      	mov	r1, r6
 800365a:	4628      	mov	r0, r5
 800365c:	f000 fec6 	bl	80043ec <FreeRTOS_GetUDPPayloadBuffer>
 8003660:	4604      	mov	r4, r0
 8003662:	2800      	cmp	r0, #0
 8003664:	d0f8      	beq.n	8003658 <prvCreatePartDHCPMessage+0x24>

	pxDHCPMessage = ( DHCPMessage_t * ) pucUDPPayloadBuffer;

	/* Most fields need to be zero. */
	memset( ( void * ) pxDHCPMessage, 0x00, sizeof( DHCPMessage_t ) );
 8003666:	22f1      	movs	r2, #241	; 0xf1
 8003668:	2100      	movs	r1, #0
 800366a:	f009 f859 	bl	800c720 <memset>

	/* Create the message. */
	pxDHCPMessage->ucOpcode = ( uint8_t ) xOpcode;
 800366e:	f884 b000 	strb.w	fp, [r4]
	pxDHCPMessage->ucAddressType = ( uint8_t ) dhcpADDRESS_TYPE_ETHERNET;
 8003672:	2301      	movs	r3, #1
 8003674:	7063      	strb	r3, [r4, #1]
	pxDHCPMessage->ucAddressLength = ( uint8_t ) dhcpETHERNET_ADDRESS_LENGTH;
 8003676:	2306      	movs	r3, #6
 8003678:	70a3      	strb	r3, [r4, #2]

	/* ulTransactionID doesn't really need a htonl() translation, but when DHCP
	times out, it is nicer to see an increasing number in this ID field */
	pxDHCPMessage->ulTransactionID = FreeRTOS_htonl( xDHCPData.ulTransactionId );
 800367a:	492a      	ldr	r1, [pc, #168]	; (8003724 <prvCreatePartDHCPMessage+0xf0>)
 800367c:	680b      	ldr	r3, [r1, #0]
 800367e:	0e1a      	lsrs	r2, r3, #24
 8003680:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8003684:	0218      	lsls	r0, r3, #8
 8003686:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 800368a:	4302      	orrs	r2, r0
 800368c:	0a1b      	lsrs	r3, r3, #8
 800368e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8003692:	4313      	orrs	r3, r2
 8003694:	6063      	str	r3, [r4, #4]
	pxDHCPMessage->ulDHCPCookie = ( uint32_t ) dhcpCOOKIE;
 8003696:	2363      	movs	r3, #99	; 0x63
 8003698:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
 800369c:	f06f 027d 	mvn.w	r2, #125	; 0x7d
 80036a0:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
 80036a4:	2253      	movs	r2, #83	; 0x53
 80036a6:	f884 20ee 	strb.w	r2, [r4, #238]	; 0xee
 80036aa:	f884 30ef 	strb.w	r3, [r4, #239]	; 0xef
	if( xDHCPData.xUseBroadcast != pdFALSE )
 80036ae:	698b      	ldr	r3, [r1, #24]
 80036b0:	bb93      	cbnz	r3, 8003718 <prvCreatePartDHCPMessage+0xe4>
	{
		pxDHCPMessage->usFlags = ( uint16_t ) dhcpBROADCAST;
	}
	else
	{
		pxDHCPMessage->usFlags = 0u;
 80036b2:	2300      	movs	r3, #0
 80036b4:	72a3      	strb	r3, [r4, #10]
 80036b6:	72e3      	strb	r3, [r4, #11]
	}

	memcpy( ( void * ) &( pxDHCPMessage->ucClientHardwareAddress[ 0 ] ), ( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) );
 80036b8:	4d1b      	ldr	r5, [pc, #108]	; (8003728 <prvCreatePartDHCPMessage+0xf4>)
 80036ba:	6828      	ldr	r0, [r5, #0]
 80036bc:	61e0      	str	r0, [r4, #28]
 80036be:	88ab      	ldrh	r3, [r5, #4]
 80036c0:	8423      	strh	r3, [r4, #32]

	/* Copy in the const part of the options options. */
	memcpy( ( void * ) &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET ] ), ( void * ) pucOptionsArray, *pxOptionsArraySize );
 80036c2:	683a      	ldr	r2, [r7, #0]
 80036c4:	4651      	mov	r1, sl
 80036c6:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
 80036ca:	f009 f804 	bl	800c6d6 <memcpy>
	{
		/* With this option, the hostname can be registered as well which makes
		it easier to lookup a device in a router's list of DHCP clients. */

		/* Point to where the OPTION_END was stored to add data. */
		pucPtr = &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET + ( *pxOptionsArraySize - 1 ) ] );
 80036ce:	683b      	ldr	r3, [r7, #0]
 80036d0:	33ef      	adds	r3, #239	; 0xef
 80036d2:	18e6      	adds	r6, r4, r3
		pucPtr[ 0 ] = dhcpDNS_HOSTNAME_OPTIONS_CODE;
 80036d4:	220c      	movs	r2, #12
 80036d6:	54e2      	strb	r2, [r4, r3]
		pucPtr[ 1 ] = ( uint8_t ) xNameLength;
 80036d8:	f886 8001 	strb.w	r8, [r6, #1]
		memcpy( ( void *) ( pucPtr + 2 ), pucHostName, xNameLength );
 80036dc:	4642      	mov	r2, r8
 80036de:	9901      	ldr	r1, [sp, #4]
 80036e0:	1cb0      	adds	r0, r6, #2
 80036e2:	f008 fff8 	bl	800c6d6 <memcpy>
		pucPtr[ 2 + xNameLength ] = dhcpOPTION_END_BYTE;
 80036e6:	4446      	add	r6, r8
 80036e8:	23ff      	movs	r3, #255	; 0xff
 80036ea:	70b3      	strb	r3, [r6, #2]
		*pxOptionsArraySize += ( 2 + xNameLength );
 80036ec:	683b      	ldr	r3, [r7, #0]
 80036ee:	3302      	adds	r3, #2
 80036f0:	4443      	add	r3, r8
 80036f2:	603b      	str	r3, [r7, #0]
	}
	#endif

	/* Map in the client identifier. */
	memcpy( ( void * ) &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET + dhcpCLIENT_IDENTIFIER_OFFSET ] ),
 80036f4:	6828      	ldr	r0, [r5, #0]
 80036f6:	f8c4 00f5 	str.w	r0, [r4, #245]	; 0xf5
 80036fa:	88ab      	ldrh	r3, [r5, #4]
 80036fc:	f8a4 30f9 	strh.w	r3, [r4, #249]	; 0xf9
		( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) );

	/* Set the addressing. */
	pxAddress->sin_addr = ipBROADCAST_IP_ADDRESS;
 8003700:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003704:	f8c9 3004 	str.w	r3, [r9, #4]
	pxAddress->sin_port = ( uint16_t ) dhcpSERVER_PORT;
 8003708:	f44f 4386 	mov.w	r3, #17152	; 0x4300
 800370c:	f8a9 3002 	strh.w	r3, [r9, #2]

	return pucUDPPayloadBuffer;
}
 8003710:	4620      	mov	r0, r4
 8003712:	b003      	add	sp, #12
 8003714:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		pxDHCPMessage->usFlags = ( uint16_t ) dhcpBROADCAST;
 8003718:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 800371c:	72a3      	strb	r3, [r4, #10]
 800371e:	2300      	movs	r3, #0
 8003720:	72e3      	strb	r3, [r4, #11]
 8003722:	e7c9      	b.n	80036b8 <prvCreatePartDHCPMessage+0x84>
 8003724:	20000428 	.word	0x20000428
 8003728:	20000010 	.word	0x20000010

0800372c <prvSendDHCPDiscover>:
	}
}
/*-----------------------------------------------------------*/

static void prvSendDHCPDiscover( void )
{
 800372c:	b530      	push	{r4, r5, lr}
 800372e:	b087      	sub	sp, #28
	dhcpMESSAGE_TYPE_OPTION_CODE, 1, dhcpMESSAGE_TYPE_DISCOVER,					/* Message type option. */
	dhcpCLIENT_IDENTIFIER_OPTION_CODE, 6, 0, 0, 0, 0, 0, 0,						/* Client identifier. */
	dhcpPARAMETER_REQUEST_OPTION_CODE, 3, dhcpSUBNET_MASK_OPTION_CODE, dhcpGATEWAY_OPTION_CODE, dhcpDNS_SERVER_OPTIONS_CODE,	/* Parameter request option. */
	dhcpOPTION_END_BYTE
};
size_t xOptionsLength = sizeof( ucDHCPDiscoverOptions );
 8003730:	ab06      	add	r3, sp, #24
 8003732:	2211      	movs	r2, #17
 8003734:	f843 2d0c 	str.w	r2, [r3, #-12]!

	pucUDPPayloadBuffer = prvCreatePartDHCPMessage( &xAddress, dhcpREQUEST_OPCODE, ucDHCPDiscoverOptions, &xOptionsLength );
 8003738:	ac04      	add	r4, sp, #16
 800373a:	4a0c      	ldr	r2, [pc, #48]	; (800376c <prvSendDHCPDiscover+0x40>)
 800373c:	2101      	movs	r1, #1
 800373e:	4620      	mov	r0, r4
 8003740:	f7ff ff78 	bl	8003634 <prvCreatePartDHCPMessage>
 8003744:	4605      	mov	r5, r0

	FreeRTOS_debug_printf( ( "vDHCPProcess: discover\n" ) );
	iptraceSENDING_DHCP_DISCOVER();

	if( FreeRTOS_sendto( xDHCPData.xDHCPSocket, pucUDPPayloadBuffer, ( sizeof( DHCPMessage_t ) + xOptionsLength ), FREERTOS_ZERO_COPY, &xAddress, sizeof( xAddress ) ) == 0 )
 8003746:	4b0a      	ldr	r3, [pc, #40]	; (8003770 <prvSendDHCPDiscover+0x44>)
 8003748:	6a18      	ldr	r0, [r3, #32]
 800374a:	2308      	movs	r3, #8
 800374c:	9301      	str	r3, [sp, #4]
 800374e:	9400      	str	r4, [sp, #0]
 8003750:	2301      	movs	r3, #1
 8003752:	9a03      	ldr	r2, [sp, #12]
 8003754:	32f1      	adds	r2, #241	; 0xf1
 8003756:	4629      	mov	r1, r5
 8003758:	f001 fc5e 	bl	8005018 <FreeRTOS_sendto>
 800375c:	b108      	cbz	r0, 8003762 <prvSendDHCPDiscover+0x36>
	{
		/* The packet was not successfully queued for sending and must be
		returned to the stack. */
		FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayloadBuffer );
	}
}
 800375e:	b007      	add	sp, #28
 8003760:	bd30      	pop	{r4, r5, pc}
		FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayloadBuffer );
 8003762:	4628      	mov	r0, r5
 8003764:	f000 fe71 	bl	800444a <FreeRTOS_ReleaseUDPPayloadBuffer>
}
 8003768:	e7f9      	b.n	800375e <prvSendDHCPDiscover+0x32>
 800376a:	bf00      	nop
 800376c:	0800cad8 	.word	0x0800cad8
 8003770:	20000428 	.word	0x20000428

08003774 <prvSendDHCPRequest>:
{
 8003774:	b530      	push	{r4, r5, lr}
 8003776:	b087      	sub	sp, #28
size_t xOptionsLength = sizeof( ucDHCPRequestOptions );
 8003778:	ab06      	add	r3, sp, #24
 800377a:	2218      	movs	r2, #24
 800377c:	f843 2d0c 	str.w	r2, [r3, #-12]!
	pucUDPPayloadBuffer = prvCreatePartDHCPMessage( &xAddress, dhcpREQUEST_OPCODE, ucDHCPRequestOptions, &xOptionsLength );
 8003780:	ad04      	add	r5, sp, #16
 8003782:	4a0f      	ldr	r2, [pc, #60]	; (80037c0 <prvSendDHCPRequest+0x4c>)
 8003784:	2101      	movs	r1, #1
 8003786:	4628      	mov	r0, r5
 8003788:	f7ff ff54 	bl	8003634 <prvCreatePartDHCPMessage>
 800378c:	4604      	mov	r4, r0
	memcpy( ( void * ) &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET + dhcpREQUESTED_IP_ADDRESS_OFFSET ] ),
 800378e:	4b0d      	ldr	r3, [pc, #52]	; (80037c4 <prvSendDHCPRequest+0x50>)
 8003790:	685a      	ldr	r2, [r3, #4]
 8003792:	f8c0 20fd 	str.w	r2, [r0, #253]	; 0xfd
	memcpy( ( void * ) &( pucUDPPayloadBuffer[ dhcpFIRST_OPTION_BYTE_OFFSET + dhcpDHCP_SERVER_IP_ADDRESS_OFFSET ] ),
 8003796:	689a      	ldr	r2, [r3, #8]
 8003798:	f8c0 2103 	str.w	r2, [r0, #259]	; 0x103
	if( FreeRTOS_sendto( xDHCPData.xDHCPSocket, pucUDPPayloadBuffer, ( sizeof( DHCPMessage_t ) + xOptionsLength ), FREERTOS_ZERO_COPY, &xAddress, sizeof( xAddress ) ) == 0 )
 800379c:	6a18      	ldr	r0, [r3, #32]
 800379e:	2308      	movs	r3, #8
 80037a0:	9301      	str	r3, [sp, #4]
 80037a2:	9500      	str	r5, [sp, #0]
 80037a4:	2301      	movs	r3, #1
 80037a6:	9a03      	ldr	r2, [sp, #12]
 80037a8:	32f1      	adds	r2, #241	; 0xf1
 80037aa:	4621      	mov	r1, r4
 80037ac:	f001 fc34 	bl	8005018 <FreeRTOS_sendto>
 80037b0:	b108      	cbz	r0, 80037b6 <prvSendDHCPRequest+0x42>
}
 80037b2:	b007      	add	sp, #28
 80037b4:	bd30      	pop	{r4, r5, pc}
		FreeRTOS_ReleaseUDPPayloadBuffer( pucUDPPayloadBuffer );
 80037b6:	4620      	mov	r0, r4
 80037b8:	f000 fe47 	bl	800444a <FreeRTOS_ReleaseUDPPayloadBuffer>
}
 80037bc:	e7f9      	b.n	80037b2 <prvSendDHCPRequest+0x3e>
 80037be:	bf00      	nop
 80037c0:	0800caec 	.word	0x0800caec
 80037c4:	20000428 	.word	0x20000428

080037c8 <prvProcessDHCPReplies>:
{
 80037c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80037cc:	b08b      	sub	sp, #44	; 0x2c
 80037ce:	4605      	mov	r5, r0
uint32_t xClientLength = sizeof( xClient );
 80037d0:	2308      	movs	r3, #8
 80037d2:	9306      	str	r3, [sp, #24]
	lBytes = FreeRTOS_recvfrom( xDHCPData.xDHCPSocket, ( void * ) &pucUDPPayload, 0ul, FREERTOS_ZERO_COPY, &xClient, &xClientLength );
 80037d4:	4b90      	ldr	r3, [pc, #576]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80037d6:	6a18      	ldr	r0, [r3, #32]
 80037d8:	ab06      	add	r3, sp, #24
 80037da:	9301      	str	r3, [sp, #4]
 80037dc:	ab07      	add	r3, sp, #28
 80037de:	9300      	str	r3, [sp, #0]
 80037e0:	2301      	movs	r3, #1
 80037e2:	2200      	movs	r2, #0
 80037e4:	a909      	add	r1, sp, #36	; 0x24
 80037e6:	f001 fb51 	bl	8004e8c <FreeRTOS_recvfrom>
	if( lBytes > 0 )
 80037ea:	1e06      	subs	r6, r0, #0
 80037ec:	f340 8112 	ble.w	8003a14 <prvProcessDHCPReplies+0x24c>
		pxDHCPMessage = ( DHCPMessage_t * ) ( pucUDPPayload );
 80037f0:	9c09      	ldr	r4, [sp, #36]	; 0x24
		if( ( pxDHCPMessage->ulDHCPCookie == ( uint32_t ) dhcpCOOKIE ) &&
 80037f2:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 80037f6:	4b89      	ldr	r3, [pc, #548]	; (8003a1c <prvProcessDHCPReplies+0x254>)
 80037f8:	429a      	cmp	r2, r3
 80037fa:	d007      	beq.n	800380c <prvProcessDHCPReplies+0x44>
BaseType_t xReturn = pdFALSE;
 80037fc:	2400      	movs	r4, #0
		FreeRTOS_ReleaseUDPPayloadBuffer( ( void * ) pucUDPPayload );
 80037fe:	9809      	ldr	r0, [sp, #36]	; 0x24
 8003800:	f000 fe23 	bl	800444a <FreeRTOS_ReleaseUDPPayloadBuffer>
}
 8003804:	4620      	mov	r0, r4
 8003806:	b00b      	add	sp, #44	; 0x2c
 8003808:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if( ( pxDHCPMessage->ulDHCPCookie == ( uint32_t ) dhcpCOOKIE ) &&
 800380c:	7823      	ldrb	r3, [r4, #0]
 800380e:	2b02      	cmp	r3, #2
 8003810:	d001      	beq.n	8003816 <prvProcessDHCPReplies+0x4e>
BaseType_t xReturn = pdFALSE;
 8003812:	2400      	movs	r4, #0
 8003814:	e7f3      	b.n	80037fe <prvProcessDHCPReplies+0x36>
			( pxDHCPMessage->ulTransactionID == FreeRTOS_htonl( xDHCPData.ulTransactionId ) ) )
 8003816:	4b80      	ldr	r3, [pc, #512]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 8003818:	681b      	ldr	r3, [r3, #0]
 800381a:	6860      	ldr	r0, [r4, #4]
 800381c:	0e1a      	lsrs	r2, r3, #24
 800381e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8003822:	0219      	lsls	r1, r3, #8
 8003824:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8003828:	430a      	orrs	r2, r1
 800382a:	0a1b      	lsrs	r3, r3, #8
 800382c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8003830:	4313      	orrs	r3, r2
			( pxDHCPMessage->ucOpcode == ( uint8_t ) dhcpREPLY_OPCODE ) &&
 8003832:	4298      	cmp	r0, r3
 8003834:	d001      	beq.n	800383a <prvProcessDHCPReplies+0x72>
BaseType_t xReturn = pdFALSE;
 8003836:	2400      	movs	r4, #0
 8003838:	e7e1      	b.n	80037fe <prvProcessDHCPReplies+0x36>
			if( memcmp( ( void * ) &( pxDHCPMessage->ucClientHardwareAddress ), ( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) ) == 0 )
 800383a:	2206      	movs	r2, #6
 800383c:	4978      	ldr	r1, [pc, #480]	; (8003a20 <prvProcessDHCPReplies+0x258>)
 800383e:	f104 001c 	add.w	r0, r4, #28
 8003842:	f008 ff39 	bl	800c6b8 <memcmp>
 8003846:	2800      	cmp	r0, #0
 8003848:	f040 80dc 	bne.w	8003a04 <prvProcessDHCPReplies+0x23c>
				pucByte = &( pxDHCPMessage->ucFirstOptionByte );
 800384c:	f104 02f0 	add.w	r2, r4, #240	; 0xf0
				pucLastByte = &( pucUDPPayload[ lBytes - dhcpMAX_OPTION_LENGTH_OF_INTEREST ] );
 8003850:	1eb3      	subs	r3, r6, #2
 8003852:	4423      	add	r3, r4
				while( pucByte < pucLastByte )
 8003854:	429a      	cmp	r2, r3
 8003856:	f080 80d7 	bcs.w	8003a08 <prvProcessDHCPReplies+0x240>
					ucOptionCode = pucByte[ 0 ];
 800385a:	f894 10f0 	ldrb.w	r1, [r4, #240]	; 0xf0
					if( ucOptionCode == dhcpOPTION_END_BYTE )
 800385e:	29ff      	cmp	r1, #255	; 0xff
 8003860:	f000 80d4 	beq.w	8003a0c <prvProcessDHCPReplies+0x244>
 8003864:	486c      	ldr	r0, [pc, #432]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 8003866:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800386a:	f890 b01c 	ldrb.w	fp, [r0, #28]
 800386e:	68c7      	ldr	r7, [r0, #12]
 8003870:	f04f 0800 	mov.w	r8, #0
 8003874:	f8cd 8010 	str.w	r8, [sp, #16]
 8003878:	f8cd 800c 	str.w	r8, [sp, #12]
 800387c:	46c6      	mov	lr, r8
							xNetworkAddressing.ulDNSServerAddress = ulParameter;
 800387e:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 8003a28 <prvProcessDHCPReplies+0x260>
							if( *pucByte == ( uint8_t ) xExpectedMessageType )
 8003882:	fa5f f985 	uxtb.w	r9, r5
 8003886:	9505      	str	r5, [sp, #20]
 8003888:	e06f      	b.n	800396a <prvProcessDHCPReplies+0x1a2>
 800388a:	9b03      	ldr	r3, [sp, #12]
 800388c:	bb03      	cbnz	r3, 80038d0 <prvProcessDHCPReplies+0x108>
 800388e:	9b04      	ldr	r3, [sp, #16]
 8003890:	b113      	cbz	r3, 8003898 <prvProcessDHCPReplies+0xd0>
 8003892:	4b61      	ldr	r3, [pc, #388]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 8003894:	f8c3 a008 	str.w	sl, [r3, #8]
 8003898:	f1b8 0f00 	cmp.w	r8, #0
 800389c:	d001      	beq.n	80038a2 <prvProcessDHCPReplies+0xda>
 800389e:	4b5e      	ldr	r3, [pc, #376]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80038a0:	60df      	str	r7, [r3, #12]
				if( ulProcessed >= ulMandatoryOptions )
 80038a2:	f1be 0f01 	cmp.w	lr, #1
 80038a6:	f240 80b3 	bls.w	8003a10 <prvProcessDHCPReplies+0x248>
					xDHCPData.ulOfferedIPAddress = pxDHCPMessage->ulYourIPAddress_yiaddr;
 80038aa:	6923      	ldr	r3, [r4, #16]
 80038ac:	4a5a      	ldr	r2, [pc, #360]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80038ae:	6053      	str	r3, [r2, #4]
					FreeRTOS_printf( ( "vDHCPProcess: offer %lxip\n", FreeRTOS_ntohl( xDHCPData.ulOfferedIPAddress ) ) );
 80038b0:	0e19      	lsrs	r1, r3, #24
 80038b2:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 80038b6:	021a      	lsls	r2, r3, #8
 80038b8:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 80038bc:	4311      	orrs	r1, r2
 80038be:	0a1b      	lsrs	r3, r3, #8
 80038c0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80038c4:	4319      	orrs	r1, r3
 80038c6:	4857      	ldr	r0, [pc, #348]	; (8003a24 <prvProcessDHCPReplies+0x25c>)
 80038c8:	f008 f8be 	bl	800ba48 <lUDPLoggingPrintf>
					xReturn = pdPASS;
 80038cc:	2401      	movs	r4, #1
 80038ce:	e796      	b.n	80037fe <prvProcessDHCPReplies+0x36>
 80038d0:	4b51      	ldr	r3, [pc, #324]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80038d2:	f883 b01c 	strb.w	fp, [r3, #28]
 80038d6:	e7da      	b.n	800388e <prvProcessDHCPReplies+0xc6>
					ucLength = pucByte[ 1 ];
 80038d8:	7850      	ldrb	r0, [r2, #1]
					memcpy( ( void * ) &( ulParameter ), ( void * ) pucByte, ( size_t ) sizeof( ulParameter ) );
 80038da:	f8d2 6002 	ldr.w	r6, [r2, #2]
					switch( ucOptionCode )
 80038de:	3901      	subs	r1, #1
 80038e0:	2935      	cmp	r1, #53	; 0x35
 80038e2:	d83a      	bhi.n	800395a <prvProcessDHCPReplies+0x192>
 80038e4:	e8df f001 	tbb	[pc, r1]
 80038e8:	3932392d 	.word	0x3932392d
 80038ec:	39393739 	.word	0x39393739
 80038f0:	39393939 	.word	0x39393939
 80038f4:	39393939 	.word	0x39393939
 80038f8:	39393939 	.word	0x39393939
 80038fc:	39393939 	.word	0x39393939
 8003900:	39393939 	.word	0x39393939
 8003904:	39393939 	.word	0x39393939
 8003908:	39393939 	.word	0x39393939
 800390c:	39393939 	.word	0x39393939
 8003910:	39393939 	.word	0x39393939
 8003914:	39393939 	.word	0x39393939
 8003918:	39553939 	.word	0x39553939
 800391c:	451b      	.short	0x451b
							if( *pucByte == ( uint8_t ) xExpectedMessageType )
 800391e:	7891      	ldrb	r1, [r2, #2]
 8003920:	4549      	cmp	r1, r9
 8003922:	d00b      	beq.n	800393c <prvProcessDHCPReplies+0x174>
							else if( *pucByte == ( uint8_t ) dhcpMESSAGE_TYPE_NACK )
 8003924:	2906      	cmp	r1, #6
 8003926:	d118      	bne.n	800395a <prvProcessDHCPReplies+0x192>
								if( xExpectedMessageType == ( BaseType_t ) dhcpMESSAGE_TYPE_ACK )
 8003928:	9d05      	ldr	r5, [sp, #20]
 800392a:	2d05      	cmp	r5, #5
 800392c:	9903      	ldr	r1, [sp, #12]
 800392e:	bf08      	it	eq
 8003930:	2101      	moveq	r1, #1
 8003932:	9103      	str	r1, [sp, #12]
 8003934:	bf08      	it	eq
 8003936:	f04f 0b00 	moveq.w	fp, #0
 800393a:	e00e      	b.n	800395a <prvProcessDHCPReplies+0x192>
								ulProcessed++;
 800393c:	f10e 0e01 	add.w	lr, lr, #1
 8003940:	e00b      	b.n	800395a <prvProcessDHCPReplies+0x192>
							if( ucLength == sizeof( uint32_t ) )
 8003942:	2804      	cmp	r0, #4
 8003944:	d109      	bne.n	800395a <prvProcessDHCPReplies+0x192>
								xNetworkAddressing.ulNetMask = ulParameter;
 8003946:	f8cc 6004 	str.w	r6, [ip, #4]
 800394a:	e007      	b.n	800395c <prvProcessDHCPReplies+0x194>
							if( ucLength == sizeof( uint32_t ) )
 800394c:	2804      	cmp	r0, #4
 800394e:	d104      	bne.n	800395a <prvProcessDHCPReplies+0x192>
								xNetworkAddressing.ulGatewayAddress = ulParameter;
 8003950:	f8cc 6008 	str.w	r6, [ip, #8]
 8003954:	e002      	b.n	800395c <prvProcessDHCPReplies+0x194>
							xNetworkAddressing.ulDNSServerAddress = ulParameter;
 8003956:	f8cc 600c 	str.w	r6, [ip, #12]
					if( ucLength == 0u )
 800395a:	b378      	cbz	r0, 80039bc <prvProcessDHCPReplies+0x1f4>
						pucByte += ucLength;
 800395c:	3002      	adds	r0, #2
 800395e:	4402      	add	r2, r0
				while( pucByte < pucLastByte )
 8003960:	4293      	cmp	r3, r2
 8003962:	d93d      	bls.n	80039e0 <prvProcessDHCPReplies+0x218>
					ucOptionCode = pucByte[ 0 ];
 8003964:	7811      	ldrb	r1, [r2, #0]
					if( ucOptionCode == dhcpOPTION_END_BYTE )
 8003966:	29ff      	cmp	r1, #255	; 0xff
 8003968:	d08f      	beq.n	800388a <prvProcessDHCPReplies+0xc2>
					if( ucOptionCode == dhcpZERO_PAD_OPTION_CODE )
 800396a:	2900      	cmp	r1, #0
 800396c:	d1b4      	bne.n	80038d8 <prvProcessDHCPReplies+0x110>
						pucByte += 1;
 800396e:	3201      	adds	r2, #1
						continue;
 8003970:	e7f6      	b.n	8003960 <prvProcessDHCPReplies+0x198>
							if( ucLength == sizeof( uint32_t ) )
 8003972:	2804      	cmp	r0, #4
 8003974:	d1f1      	bne.n	800395a <prvProcessDHCPReplies+0x192>
								if( xExpectedMessageType == ( BaseType_t ) dhcpMESSAGE_TYPE_OFFER )
 8003976:	9905      	ldr	r1, [sp, #20]
 8003978:	2902      	cmp	r1, #2
 800397a:	d004      	beq.n	8003986 <prvProcessDHCPReplies+0x1be>
									if( xDHCPData.ulDHCPServerAddress == ulParameter )
 800397c:	4556      	cmp	r6, sl
 800397e:	d1ed      	bne.n	800395c <prvProcessDHCPReplies+0x194>
										ulProcessed++;
 8003980:	f10e 0e01 	add.w	lr, lr, #1
 8003984:	e7ea      	b.n	800395c <prvProcessDHCPReplies+0x194>
									ulProcessed++;
 8003986:	f10e 0e01 	add.w	lr, lr, #1
									xDHCPData.ulDHCPServerAddress = ulParameter;
 800398a:	46b2      	mov	sl, r6
 800398c:	2101      	movs	r1, #1
 800398e:	9104      	str	r1, [sp, #16]
 8003990:	e7e4      	b.n	800395c <prvProcessDHCPReplies+0x194>
							if( ucLength == sizeof( &( xDHCPData.ulLeaseTime ) ) )
 8003992:	2804      	cmp	r0, #4
 8003994:	d1e1      	bne.n	800395a <prvProcessDHCPReplies+0x192>
								xDHCPData.ulLeaseTime = FreeRTOS_ntohl( ulParameter );
 8003996:	0e37      	lsrs	r7, r6, #24
 8003998:	ea47 6706 	orr.w	r7, r7, r6, lsl #24
 800399c:	0231      	lsls	r1, r6, #8
 800399e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80039a2:	430f      	orrs	r7, r1
 80039a4:	0a31      	lsrs	r1, r6, #8
 80039a6:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 80039aa:	430f      	orrs	r7, r1
								xDHCPData.ulLeaseTime >>= 1UL;
 80039ac:	087f      	lsrs	r7, r7, #1
								xDHCPData.ulLeaseTime = configTICK_RATE_HZ * xDHCPData.ulLeaseTime;
 80039ae:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80039b2:	fb01 f707 	mul.w	r7, r1, r7
 80039b6:	f04f 0801 	mov.w	r8, #1
 80039ba:	e7cf      	b.n	800395c <prvProcessDHCPReplies+0x194>
 80039bc:	9b03      	ldr	r3, [sp, #12]
 80039be:	b95b      	cbnz	r3, 80039d8 <prvProcessDHCPReplies+0x210>
 80039c0:	9b04      	ldr	r3, [sp, #16]
 80039c2:	b113      	cbz	r3, 80039ca <prvProcessDHCPReplies+0x202>
 80039c4:	4b14      	ldr	r3, [pc, #80]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80039c6:	f8c3 a008 	str.w	sl, [r3, #8]
 80039ca:	f1b8 0f00 	cmp.w	r8, #0
 80039ce:	f43f af68 	beq.w	80038a2 <prvProcessDHCPReplies+0xda>
 80039d2:	4b11      	ldr	r3, [pc, #68]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80039d4:	60df      	str	r7, [r3, #12]
 80039d6:	e764      	b.n	80038a2 <prvProcessDHCPReplies+0xda>
 80039d8:	4b0f      	ldr	r3, [pc, #60]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80039da:	f883 b01c 	strb.w	fp, [r3, #28]
 80039de:	e7ef      	b.n	80039c0 <prvProcessDHCPReplies+0x1f8>
 80039e0:	9b03      	ldr	r3, [sp, #12]
 80039e2:	b95b      	cbnz	r3, 80039fc <prvProcessDHCPReplies+0x234>
 80039e4:	9b04      	ldr	r3, [sp, #16]
 80039e6:	b113      	cbz	r3, 80039ee <prvProcessDHCPReplies+0x226>
 80039e8:	4b0b      	ldr	r3, [pc, #44]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80039ea:	f8c3 a008 	str.w	sl, [r3, #8]
 80039ee:	f1b8 0f00 	cmp.w	r8, #0
 80039f2:	f43f af56 	beq.w	80038a2 <prvProcessDHCPReplies+0xda>
 80039f6:	4b08      	ldr	r3, [pc, #32]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80039f8:	60df      	str	r7, [r3, #12]
 80039fa:	e752      	b.n	80038a2 <prvProcessDHCPReplies+0xda>
 80039fc:	4b06      	ldr	r3, [pc, #24]	; (8003a18 <prvProcessDHCPReplies+0x250>)
 80039fe:	f883 b01c 	strb.w	fp, [r3, #28]
 8003a02:	e7ef      	b.n	80039e4 <prvProcessDHCPReplies+0x21c>
BaseType_t xReturn = pdFALSE;
 8003a04:	2400      	movs	r4, #0
 8003a06:	e6fa      	b.n	80037fe <prvProcessDHCPReplies+0x36>
 8003a08:	2400      	movs	r4, #0
 8003a0a:	e6f8      	b.n	80037fe <prvProcessDHCPReplies+0x36>
 8003a0c:	2400      	movs	r4, #0
 8003a0e:	e6f6      	b.n	80037fe <prvProcessDHCPReplies+0x36>
 8003a10:	2400      	movs	r4, #0
 8003a12:	e6f4      	b.n	80037fe <prvProcessDHCPReplies+0x36>
 8003a14:	2400      	movs	r4, #0
	return xReturn;
 8003a16:	e6f5      	b.n	8003804 <prvProcessDHCPReplies+0x3c>
 8003a18:	20000428 	.word	0x20000428
 8003a1c:	63538263 	.word	0x63538263
 8003a20:	20000010 	.word	0x20000010
 8003a24:	0800cabc 	.word	0x0800cabc
 8003a28:	20000530 	.word	0x20000530

08003a2c <prvCreateDHCPSocket>:
{
 8003a2c:	b530      	push	{r4, r5, lr}
 8003a2e:	b087      	sub	sp, #28
TickType_t xTimeoutTime = ( TickType_t ) 0;
 8003a30:	2300      	movs	r3, #0
 8003a32:	9303      	str	r3, [sp, #12]
	if( xDHCPData.xDHCPSocket == NULL )
 8003a34:	4b19      	ldr	r3, [pc, #100]	; (8003a9c <prvCreateDHCPSocket+0x70>)
 8003a36:	6a1b      	ldr	r3, [r3, #32]
 8003a38:	b10b      	cbz	r3, 8003a3e <prvCreateDHCPSocket+0x12>
}
 8003a3a:	b007      	add	sp, #28
 8003a3c:	bd30      	pop	{r4, r5, pc}
		xDHCPData.xDHCPSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 8003a3e:	2211      	movs	r2, #17
 8003a40:	2102      	movs	r1, #2
 8003a42:	4608      	mov	r0, r1
 8003a44:	f001 f98a 	bl	8004d5c <FreeRTOS_socket>
 8003a48:	4b14      	ldr	r3, [pc, #80]	; (8003a9c <prvCreateDHCPSocket+0x70>)
 8003a4a:	6218      	str	r0, [r3, #32]
		if( xDHCPData.xDHCPSocket != FREERTOS_INVALID_SOCKET )
 8003a4c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8003a50:	d020      	beq.n	8003a94 <prvCreateDHCPSocket+0x68>
			FreeRTOS_setsockopt( xDHCPData.xDHCPSocket, 0, FREERTOS_SO_RCVTIMEO, ( void * ) &xTimeoutTime, sizeof( TickType_t ) );
 8003a52:	2504      	movs	r5, #4
 8003a54:	9500      	str	r5, [sp, #0]
 8003a56:	ab03      	add	r3, sp, #12
 8003a58:	2200      	movs	r2, #0
 8003a5a:	4611      	mov	r1, r2
 8003a5c:	f002 f884 	bl	8005b68 <FreeRTOS_setsockopt>
			FreeRTOS_setsockopt( xDHCPData.xDHCPSocket, 0, FREERTOS_SO_SNDTIMEO, ( void * ) &xTimeoutTime, sizeof( TickType_t ) );
 8003a60:	4c0e      	ldr	r4, [pc, #56]	; (8003a9c <prvCreateDHCPSocket+0x70>)
 8003a62:	9500      	str	r5, [sp, #0]
 8003a64:	ab03      	add	r3, sp, #12
 8003a66:	2201      	movs	r2, #1
 8003a68:	2100      	movs	r1, #0
 8003a6a:	6a20      	ldr	r0, [r4, #32]
 8003a6c:	f002 f87c 	bl	8005b68 <FreeRTOS_setsockopt>
			xAddress.sin_port = ( uint16_t ) dhcpCLIENT_PORT;
 8003a70:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8003a74:	f8ad 3012 	strh.w	r3, [sp, #18]
			xReturn = vSocketBind( xDHCPData.xDHCPSocket, &xAddress, sizeof( xAddress ), pdFALSE );
 8003a78:	2300      	movs	r3, #0
 8003a7a:	2208      	movs	r2, #8
 8003a7c:	a904      	add	r1, sp, #16
 8003a7e:	6a20      	ldr	r0, [r4, #32]
 8003a80:	f001 fb4a 	bl	8005118 <vSocketBind>
			if( xReturn != 0 )
 8003a84:	2800      	cmp	r0, #0
 8003a86:	d0d8      	beq.n	8003a3a <prvCreateDHCPSocket+0xe>
				vSocketClose( xDHCPData.xDHCPSocket );
 8003a88:	6a20      	ldr	r0, [r4, #32]
 8003a8a:	f001 fbe1 	bl	8005250 <vSocketClose>
				xDHCPData.xDHCPSocket = NULL;
 8003a8e:	2300      	movs	r3, #0
 8003a90:	6223      	str	r3, [r4, #32]
 8003a92:	e7d2      	b.n	8003a3a <prvCreateDHCPSocket+0xe>
			xDHCPData.xDHCPSocket = NULL;
 8003a94:	2200      	movs	r2, #0
 8003a96:	4b01      	ldr	r3, [pc, #4]	; (8003a9c <prvCreateDHCPSocket+0x70>)
 8003a98:	621a      	str	r2, [r3, #32]
}
 8003a9a:	e7ce      	b.n	8003a3a <prvCreateDHCPSocket+0xe>
 8003a9c:	20000428 	.word	0x20000428

08003aa0 <xIsDHCPSocket>:
	if( xDHCPData.xDHCPSocket == xSocket )
 8003aa0:	4b03      	ldr	r3, [pc, #12]	; (8003ab0 <xIsDHCPSocket+0x10>)
 8003aa2:	6a1b      	ldr	r3, [r3, #32]
}
 8003aa4:	4283      	cmp	r3, r0
 8003aa6:	bf14      	ite	ne
 8003aa8:	2000      	movne	r0, #0
 8003aaa:	2001      	moveq	r0, #1
 8003aac:	4770      	bx	lr
 8003aae:	bf00      	nop
 8003ab0:	20000428 	.word	0x20000428

08003ab4 <vDHCPProcess>:
{
 8003ab4:	b510      	push	{r4, lr}
	if( xReset != pdFALSE )
 8003ab6:	2800      	cmp	r0, #0
 8003ab8:	f000 80cf 	beq.w	8003c5a <vDHCPProcess+0x1a6>
		xDHCPData.eDHCPState = eWaitingSendFirstDiscover;
 8003abc:	2200      	movs	r2, #0
 8003abe:	4b70      	ldr	r3, [pc, #448]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003ac0:	771a      	strb	r2, [r3, #28]
	if( xDHCPData.ulTransactionId == 0ul )
 8003ac2:	4b6f      	ldr	r3, [pc, #444]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003ac4:	681b      	ldr	r3, [r3, #0]
 8003ac6:	b1e3      	cbz	r3, 8003b02 <vDHCPProcess+0x4e>
		xDHCPData.ulTransactionId++;
 8003ac8:	3301      	adds	r3, #1
 8003aca:	4a6d      	ldr	r2, [pc, #436]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003acc:	6013      	str	r3, [r2, #0]
	xDHCPData.xUseBroadcast = 0;
 8003ace:	4c6c      	ldr	r4, [pc, #432]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003ad0:	2300      	movs	r3, #0
 8003ad2:	61a3      	str	r3, [r4, #24]
	xDHCPData.ulOfferedIPAddress = 0UL;
 8003ad4:	6063      	str	r3, [r4, #4]
	xDHCPData.ulDHCPServerAddress = 0UL;
 8003ad6:	60a3      	str	r3, [r4, #8]
	xDHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8003ad8:	f241 3388 	movw	r3, #5000	; 0x1388
 8003adc:	6163      	str	r3, [r4, #20]
	prvCreateDHCPSocket();
 8003ade:	f7ff ffa5 	bl	8003a2c <prvCreateDHCPSocket>
	vIPReloadDHCPTimer( dhcpINITIAL_TIMER_PERIOD );
 8003ae2:	20fa      	movs	r0, #250	; 0xfa
 8003ae4:	f001 f8ae 	bl	8004c44 <vIPReloadDHCPTimer>
				if( xDHCPData.xDHCPSocket == NULL )
 8003ae8:	6a23      	ldr	r3, [r4, #32]
 8003aea:	b323      	cbz	r3, 8003b36 <vDHCPProcess+0x82>
				*ipLOCAL_IP_ADDRESS_POINTER = 0UL;
 8003aec:	2200      	movs	r2, #0
 8003aee:	4b65      	ldr	r3, [pc, #404]	; (8003c84 <vDHCPProcess+0x1d0>)
 8003af0:	615a      	str	r2, [r3, #20]
					xDHCPData.xDHCPTxTime = xTaskGetTickCount();
 8003af2:	f006 fa9d 	bl	800a030 <xTaskGetTickCount>
 8003af6:	6120      	str	r0, [r4, #16]
					prvSendDHCPDiscover( );
 8003af8:	f7ff fe18 	bl	800372c <prvSendDHCPDiscover>
					xDHCPData.eDHCPState = eWaitingOffer;
 8003afc:	2301      	movs	r3, #1
 8003afe:	7723      	strb	r3, [r4, #28]
 8003b00:	bd10      	pop	{r4, pc}
		xDHCPData.ulTransactionId = ipconfigRAND32();
 8003b02:	f008 fcf3 	bl	800c4ec <uxRand>
 8003b06:	4b5e      	ldr	r3, [pc, #376]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b08:	6018      	str	r0, [r3, #0]
 8003b0a:	e7e0      	b.n	8003ace <vDHCPProcess+0x1a>
			if( prvProcessDHCPReplies( dhcpMESSAGE_TYPE_OFFER ) == pdPASS )
 8003b0c:	2002      	movs	r0, #2
 8003b0e:	f7ff fe5b 	bl	80037c8 <prvProcessDHCPReplies>
 8003b12:	2801      	cmp	r0, #1
 8003b14:	d029      	beq.n	8003b6a <vDHCPProcess+0xb6>
			else if( ( xTaskGetTickCount() - xDHCPData.xDHCPTxTime ) > xDHCPData.xDHCPTxPeriod )
 8003b16:	f006 fa8b 	bl	800a030 <xTaskGetTickCount>
 8003b1a:	4a59      	ldr	r2, [pc, #356]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b1c:	6953      	ldr	r3, [r2, #20]
 8003b1e:	6912      	ldr	r2, [r2, #16]
 8003b20:	1a80      	subs	r0, r0, r2
 8003b22:	4298      	cmp	r0, r3
 8003b24:	f240 80aa 	bls.w	8003c7c <vDHCPProcess+0x1c8>
				xDHCPData.xDHCPTxPeriod <<= 1;
 8003b28:	005b      	lsls	r3, r3, #1
 8003b2a:	4a55      	ldr	r2, [pc, #340]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b2c:	6153      	str	r3, [r2, #20]
				if( xDHCPData.xDHCPTxPeriod <= ipconfigMAXIMUM_DISCOVER_TX_PERIOD )
 8003b2e:	f247 5230 	movw	r2, #30000	; 0x7530
 8003b32:	4293      	cmp	r3, r2
 8003b34:	d925      	bls.n	8003b82 <vDHCPProcess+0xce>
		taskENTER_CRITICAL();
 8003b36:	f005 fa15 	bl	8008f64 <vPortEnterCritical>
			*ipLOCAL_IP_ADDRESS_POINTER = xNetworkAddressing.ulDefaultIPAddress;
 8003b3a:	4b53      	ldr	r3, [pc, #332]	; (8003c88 <vDHCPProcess+0x1d4>)
 8003b3c:	681a      	ldr	r2, [r3, #0]
 8003b3e:	4b51      	ldr	r3, [pc, #324]	; (8003c84 <vDHCPProcess+0x1d0>)
 8003b40:	615a      	str	r2, [r3, #20]
		taskEXIT_CRITICAL();
 8003b42:	f005 fa31 	bl	8008fa8 <vPortExitCritical>
		xDHCPData.eDHCPState = eNotUsingLeasedAddress;
 8003b46:	4c4e      	ldr	r4, [pc, #312]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b48:	2304      	movs	r3, #4
 8003b4a:	7723      	strb	r3, [r4, #28]
		vIPSetDHCPTimerEnableState( pdFALSE );
 8003b4c:	2000      	movs	r0, #0
 8003b4e:	f001 f869 	bl	8004c24 <vIPSetDHCPTimerEnableState>
		vIPNetworkUpCalls( );
 8003b52:	f000 fdeb 	bl	800472c <vIPNetworkUpCalls>
		if( xDHCPData.xDHCPSocket != NULL )
 8003b56:	6a20      	ldr	r0, [r4, #32]
 8003b58:	2800      	cmp	r0, #0
 8003b5a:	f000 808f 	beq.w	8003c7c <vDHCPProcess+0x1c8>
			vSocketClose( xDHCPData.xDHCPSocket );
 8003b5e:	f001 fb77 	bl	8005250 <vSocketClose>
			xDHCPData.xDHCPSocket = NULL;
 8003b62:	2200      	movs	r2, #0
 8003b64:	4b46      	ldr	r3, [pc, #280]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b66:	621a      	str	r2, [r3, #32]
}
 8003b68:	bd10      	pop	{r4, pc}
					xDHCPData.xDHCPTxTime = xTaskGetTickCount();
 8003b6a:	f006 fa61 	bl	800a030 <xTaskGetTickCount>
 8003b6e:	4c44      	ldr	r4, [pc, #272]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b70:	6120      	str	r0, [r4, #16]
					xDHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8003b72:	f241 3388 	movw	r3, #5000	; 0x1388
 8003b76:	6163      	str	r3, [r4, #20]
					prvSendDHCPRequest( );
 8003b78:	f7ff fdfc 	bl	8003774 <prvSendDHCPRequest>
					xDHCPData.eDHCPState = eWaitingAcknowledge;
 8003b7c:	2302      	movs	r3, #2
 8003b7e:	7723      	strb	r3, [r4, #28]
					break;
 8003b80:	bd10      	pop	{r4, pc}
					xDHCPData.ulTransactionId++;
 8003b82:	4c3f      	ldr	r4, [pc, #252]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003b84:	6823      	ldr	r3, [r4, #0]
 8003b86:	3301      	adds	r3, #1
 8003b88:	6023      	str	r3, [r4, #0]
					xDHCPData.xDHCPTxTime = xTaskGetTickCount();
 8003b8a:	f006 fa51 	bl	800a030 <xTaskGetTickCount>
 8003b8e:	6120      	str	r0, [r4, #16]
					xDHCPData.xUseBroadcast = !xDHCPData.xUseBroadcast;
 8003b90:	69a3      	ldr	r3, [r4, #24]
 8003b92:	fab3 f383 	clz	r3, r3
 8003b96:	095b      	lsrs	r3, r3, #5
 8003b98:	61a3      	str	r3, [r4, #24]
					prvSendDHCPDiscover( );
 8003b9a:	f7ff fdc7 	bl	800372c <prvSendDHCPDiscover>
 8003b9e:	bd10      	pop	{r4, pc}
			if( prvProcessDHCPReplies( dhcpMESSAGE_TYPE_ACK ) == pdPASS )
 8003ba0:	2005      	movs	r0, #5
 8003ba2:	f7ff fe11 	bl	80037c8 <prvProcessDHCPReplies>
 8003ba6:	2801      	cmp	r0, #1
 8003ba8:	d012      	beq.n	8003bd0 <vDHCPProcess+0x11c>
				if( ( xTaskGetTickCount() - xDHCPData.xDHCPTxTime ) > xDHCPData.xDHCPTxPeriod )
 8003baa:	f006 fa41 	bl	800a030 <xTaskGetTickCount>
 8003bae:	4a34      	ldr	r2, [pc, #208]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003bb0:	6953      	ldr	r3, [r2, #20]
 8003bb2:	6912      	ldr	r2, [r2, #16]
 8003bb4:	1a80      	subs	r0, r0, r2
 8003bb6:	4298      	cmp	r0, r3
 8003bb8:	d960      	bls.n	8003c7c <vDHCPProcess+0x1c8>
					xDHCPData.xDHCPTxPeriod <<= 1;
 8003bba:	005b      	lsls	r3, r3, #1
 8003bbc:	4a30      	ldr	r2, [pc, #192]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003bbe:	6153      	str	r3, [r2, #20]
					if( xDHCPData.xDHCPTxPeriod <= ipconfigMAXIMUM_DISCOVER_TX_PERIOD )
 8003bc0:	f247 5230 	movw	r2, #30000	; 0x7530
 8003bc4:	4293      	cmp	r3, r2
 8003bc6:	d929      	bls.n	8003c1c <vDHCPProcess+0x168>
						xDHCPData.eDHCPState = eWaitingSendFirstDiscover;
 8003bc8:	2200      	movs	r2, #0
 8003bca:	4b2d      	ldr	r3, [pc, #180]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003bcc:	771a      	strb	r2, [r3, #28]
 8003bce:	bd10      	pop	{r4, pc}
				*ipLOCAL_IP_ADDRESS_POINTER = xDHCPData.ulOfferedIPAddress;
 8003bd0:	4c2b      	ldr	r4, [pc, #172]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003bd2:	6863      	ldr	r3, [r4, #4]
 8003bd4:	4a2b      	ldr	r2, [pc, #172]	; (8003c84 <vDHCPProcess+0x1d0>)
 8003bd6:	6153      	str	r3, [r2, #20]
				xNetworkAddressing.ulBroadcastAddress = ( xDHCPData.ulOfferedIPAddress & xNetworkAddressing.ulNetMask ) |  ~xNetworkAddressing.ulNetMask;
 8003bd8:	4a2b      	ldr	r2, [pc, #172]	; (8003c88 <vDHCPProcess+0x1d4>)
 8003bda:	6851      	ldr	r1, [r2, #4]
 8003bdc:	ea63 0301 	orn	r3, r3, r1
 8003be0:	6113      	str	r3, [r2, #16]
				xDHCPData.eDHCPState = eLeasedAddress;
 8003be2:	2303      	movs	r3, #3
 8003be4:	7723      	strb	r3, [r4, #28]
				vIPNetworkUpCalls( );
 8003be6:	f000 fda1 	bl	800472c <vIPNetworkUpCalls>
				vSocketClose( xDHCPData.xDHCPSocket );
 8003bea:	6a20      	ldr	r0, [r4, #32]
 8003bec:	f001 fb30 	bl	8005250 <vSocketClose>
				xDHCPData.xDHCPSocket = NULL;
 8003bf0:	2300      	movs	r3, #0
 8003bf2:	6223      	str	r3, [r4, #32]
				if( xDHCPData.ulLeaseTime == 0UL )
 8003bf4:	68e3      	ldr	r3, [r4, #12]
 8003bf6:	b943      	cbnz	r3, 8003c0a <vDHCPProcess+0x156>
					xDHCPData.ulLeaseTime = dhcpDEFAULT_LEASE_TIME;
 8003bf8:	4a24      	ldr	r2, [pc, #144]	; (8003c8c <vDHCPProcess+0x1d8>)
 8003bfa:	60e2      	str	r2, [r4, #12]
				vARPSendGratuitous();
 8003bfc:	f7ff fc94 	bl	8003528 <vARPSendGratuitous>
				vIPReloadDHCPTimer( xDHCPData.ulLeaseTime );
 8003c00:	4b1f      	ldr	r3, [pc, #124]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003c02:	68d8      	ldr	r0, [r3, #12]
 8003c04:	f001 f81e 	bl	8004c44 <vIPReloadDHCPTimer>
 8003c08:	bd10      	pop	{r4, pc}
				else if( xDHCPData.ulLeaseTime < dhcpMINIMUM_LEASE_TIME )
 8003c0a:	f64e 225f 	movw	r2, #59999	; 0xea5f
 8003c0e:	4293      	cmp	r3, r2
 8003c10:	d8f4      	bhi.n	8003bfc <vDHCPProcess+0x148>
					xDHCPData.ulLeaseTime = dhcpMINIMUM_LEASE_TIME;
 8003c12:	f64e 2260 	movw	r2, #60000	; 0xea60
 8003c16:	4b1a      	ldr	r3, [pc, #104]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003c18:	60da      	str	r2, [r3, #12]
 8003c1a:	e7ef      	b.n	8003bfc <vDHCPProcess+0x148>
						xDHCPData.xDHCPTxTime = xTaskGetTickCount();
 8003c1c:	f006 fa08 	bl	800a030 <xTaskGetTickCount>
 8003c20:	4b17      	ldr	r3, [pc, #92]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003c22:	6118      	str	r0, [r3, #16]
						prvSendDHCPRequest( );
 8003c24:	f7ff fda6 	bl	8003774 <prvSendDHCPRequest>
 8003c28:	bd10      	pop	{r4, pc}
			prvCreateDHCPSocket();
 8003c2a:	f7ff feff 	bl	8003a2c <prvCreateDHCPSocket>
			if( xDHCPData.xDHCPSocket != NULL )
 8003c2e:	4b14      	ldr	r3, [pc, #80]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003c30:	6a1b      	ldr	r3, [r3, #32]
 8003c32:	b31b      	cbz	r3, 8003c7c <vDHCPProcess+0x1c8>
				xDHCPData.xDHCPTxTime = xTaskGetTickCount();
 8003c34:	f006 f9fc 	bl	800a030 <xTaskGetTickCount>
 8003c38:	4c11      	ldr	r4, [pc, #68]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003c3a:	6120      	str	r0, [r4, #16]
				xDHCPData.xDHCPTxPeriod = dhcpINITIAL_DHCP_TX_PERIOD;
 8003c3c:	f241 3388 	movw	r3, #5000	; 0x1388
 8003c40:	6163      	str	r3, [r4, #20]
				prvSendDHCPRequest( );
 8003c42:	f7ff fd97 	bl	8003774 <prvSendDHCPRequest>
				xDHCPData.eDHCPState = eWaitingAcknowledge;
 8003c46:	2302      	movs	r3, #2
 8003c48:	7723      	strb	r3, [r4, #28]
				vIPReloadDHCPTimer( dhcpINITIAL_TIMER_PERIOD );
 8003c4a:	20fa      	movs	r0, #250	; 0xfa
 8003c4c:	f000 fffa 	bl	8004c44 <vIPReloadDHCPTimer>
 8003c50:	bd10      	pop	{r4, pc}
			vIPSetDHCPTimerEnableState( pdFALSE );
 8003c52:	2000      	movs	r0, #0
 8003c54:	f000 ffe6 	bl	8004c24 <vIPSetDHCPTimerEnableState>
			break;
 8003c58:	bd10      	pop	{r4, pc}
	switch( xDHCPData.eDHCPState )
 8003c5a:	4b09      	ldr	r3, [pc, #36]	; (8003c80 <vDHCPProcess+0x1cc>)
 8003c5c:	7f1b      	ldrb	r3, [r3, #28]
 8003c5e:	2b04      	cmp	r3, #4
 8003c60:	d80c      	bhi.n	8003c7c <vDHCPProcess+0x1c8>
 8003c62:	a201      	add	r2, pc, #4	; (adr r2, 8003c68 <vDHCPProcess+0x1b4>)
 8003c64:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003c68:	08003ac3 	.word	0x08003ac3
 8003c6c:	08003b0d 	.word	0x08003b0d
 8003c70:	08003ba1 	.word	0x08003ba1
 8003c74:	08003c2b 	.word	0x08003c2b
 8003c78:	08003c53 	.word	0x08003c53
 8003c7c:	bd10      	pop	{r4, pc}
 8003c7e:	bf00      	nop
 8003c80:	20000428 	.word	0x20000428
 8003c84:	20000010 	.word	0x20000010
 8003c88:	20000530 	.word	0x20000530
 8003c8c:	0a4cb800 	.word	0x0a4cb800

08003c90 <prvSkipNameField>:

static uint8_t *prvSkipNameField( uint8_t *pucByte )
{
	/* Determine if the name is the fully coded name, or an offset to the name
	elsewhere in the message. */
	if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8003c90:	7803      	ldrb	r3, [r0, #0]
 8003c92:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
 8003c96:	2ac0      	cmp	r2, #192	; 0xc0
 8003c98:	d007      	beq.n	8003caa <prvSkipNameField+0x1a>

	}
	else
	{
		/* pucByte points to the full name.  Walk over the string. */
		while( *pucByte != 0x00 )
 8003c9a:	b123      	cbz	r3, 8003ca6 <prvSkipNameField+0x16>
		{
			/* The number of bytes to jump for each name section is stored in the byte
			before the name section. */
			pucByte += ( *pucByte + 1 );
 8003c9c:	3301      	adds	r3, #1
 8003c9e:	4418      	add	r0, r3
		while( *pucByte != 0x00 )
 8003ca0:	7803      	ldrb	r3, [r0, #0]
 8003ca2:	2b00      	cmp	r3, #0
 8003ca4:	d1fa      	bne.n	8003c9c <prvSkipNameField+0xc>
		}

		pucByte++;
 8003ca6:	3001      	adds	r0, #1
	}

	return pucByte;
}
 8003ca8:	4770      	bx	lr
		pucByte += sizeof( uint16_t );
 8003caa:	3002      	adds	r0, #2
 8003cac:	4770      	bx	lr
	...

08003cb0 <prvParseDNSReply>:

#endif /* ipconfigUSE_NBNS */
/*-----------------------------------------------------------*/

static uint32_t prvParseDNSReply( uint8_t *pucUDPPayloadBuffer, TickType_t xIdentifier )
{
 8003cb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003cb4:	b0a0      	sub	sp, #128	; 0x80
 8003cb6:	4607      	mov	r7, r0
 8003cb8:	460c      	mov	r4, r1
uint16_t x, usDataLength, usQuestions;
#if( ipconfigUSE_LLMNR == 1 )
	uint16_t usType = 0, usClass = 0;
#endif
#if( ipconfigUSE_DNS_CACHE == 1 )
	char pcName[128] = ""; /*_RB_ What is the significance of 128?  Probably too big to go on the stack for a small MCU but don't know how else it could be made re-entrant.  Might be necessary. */
 8003cba:	2100      	movs	r1, #0
 8003cbc:	9100      	str	r1, [sp, #0]
 8003cbe:	227c      	movs	r2, #124	; 0x7c
 8003cc0:	a801      	add	r0, sp, #4
 8003cc2:	f008 fd2d 	bl	800c720 <memset>
#endif

	pxDNSMessageHeader = ( DNSMessage_t * ) pucUDPPayloadBuffer;

	if( pxDNSMessageHeader->usIdentifier == ( uint16_t ) xIdentifier )
 8003cc6:	883b      	ldrh	r3, [r7, #0]
 8003cc8:	b2a4      	uxth	r4, r4
 8003cca:	42a3      	cmp	r3, r4
 8003ccc:	d003      	beq.n	8003cd6 <prvParseDNSReply+0x26>
uint32_t ulIPAddress = 0UL;
 8003cce:	2000      	movs	r0, #0
		}
#endif /* ipconfigUSE_LLMNR == 1 */
	}

	return ulIPAddress;
}
 8003cd0:	b020      	add	sp, #128	; 0x80
 8003cd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pucByte = pucUDPPayloadBuffer + sizeof( DNSMessage_t );
 8003cd6:	f107 050c 	add.w	r5, r7, #12
		usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );
 8003cda:	88bb      	ldrh	r3, [r7, #4]
 8003cdc:	0a1e      	lsrs	r6, r3, #8
 8003cde:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
 8003ce2:	b2b6      	uxth	r6, r6
		for( x = 0; x < usQuestions; x++ )
 8003ce4:	2e00      	cmp	r6, #0
 8003ce6:	d05c      	beq.n	8003da2 <prvParseDNSReply+0xf2>
 8003ce8:	2400      	movs	r4, #0
 8003cea:	46a2      	mov	sl, r4
		if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8003cec:	46a1      	mov	r9, r4
					pcName[xNameLen++] = '.';
 8003cee:	f04f 082e 	mov.w	r8, #46	; 0x2e
				if( x == 0 )
 8003cf2:	2c00      	cmp	r4, #0
 8003cf4:	f000 816c 	beq.w	8003fd0 <prvParseDNSReply+0x320>
				pucByte = prvSkipNameField( pucByte );
 8003cf8:	4628      	mov	r0, r5
 8003cfa:	f7ff ffc9 	bl	8003c90 <prvSkipNameField>
			pucByte += sizeof( uint32_t );
 8003cfe:	1d05      	adds	r5, r0, #4
		for( x = 0; x < usQuestions; x++ )
 8003d00:	3401      	adds	r4, #1
 8003d02:	b2a4      	uxth	r4, r4
 8003d04:	42a6      	cmp	r6, r4
 8003d06:	d1f4      	bne.n	8003cf2 <prvParseDNSReply+0x42>

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 8003d08:	7803      	ldrb	r3, [r0, #0]
			  ( ( ( uint32_t )apChr[1] ) ) );
 8003d0a:	7842      	ldrb	r2, [r0, #1]
	return ( uint16_t )
 8003d0c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 8003d10:	7881      	ldrb	r1, [r0, #2]
			  ( ( ( uint32_t )apChr[1] ) ) );
 8003d12:	78c3      	ldrb	r3, [r0, #3]
	return ( uint16_t )
 8003d14:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
		pxDNSMessageHeader->usAnswers = FreeRTOS_ntohs( pxDNSMessageHeader->usAnswers );
 8003d18:	88fb      	ldrh	r3, [r7, #6]
 8003d1a:	0a1c      	lsrs	r4, r3, #8
 8003d1c:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 8003d20:	b2a4      	uxth	r4, r4
 8003d22:	80fc      	strh	r4, [r7, #6]
		if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
 8003d24:	887b      	ldrh	r3, [r7, #2]
 8003d26:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
 8003d2a:	2b80      	cmp	r3, #128	; 0x80
 8003d2c:	d03e      	beq.n	8003dac <prvParseDNSReply+0xfc>
		else if( usQuestions && ( usType == dnsTYPE_A_HOST ) && ( usClass == dnsCLASS_IN ) )
 8003d2e:	2e00      	cmp	r6, #0
 8003d30:	f000 8148 	beq.w	8003fc4 <prvParseDNSReply+0x314>
 8003d34:	2a01      	cmp	r2, #1
 8003d36:	f000 80b8 	beq.w	8003eaa <prvParseDNSReply+0x1fa>
uint32_t ulIPAddress = 0UL;
 8003d3a:	2000      	movs	r0, #0
 8003d3c:	e7c8      	b.n	8003cd0 <prvParseDNSReply+0x20>
			pucByte += sizeof( uint16_t );
 8003d3e:	1ca8      	adds	r0, r5, #2
 8003d40:	46aa      	mov	sl, r5
 8003d42:	e7dc      	b.n	8003cfe <prvParseDNSReply+0x4e>
				for( xCount = *(pucByte++); xCount--; pucByte++ )
 8003d44:	3201      	adds	r2, #1
 8003d46:	4293      	cmp	r3, r2
 8003d48:	d00a      	beq.n	8003d60 <prvParseDNSReply+0xb0>
					if( xNameLen < xLen - 1 )
 8003d4a:	f1ba 0f7e 	cmp.w	sl, #126	; 0x7e
 8003d4e:	dcf9      	bgt.n	8003d44 <prvParseDNSReply+0x94>
						pcName[xNameLen++] = *( ( char * ) pucByte );
 8003d50:	7810      	ldrb	r0, [r2, #0]
 8003d52:	a920      	add	r1, sp, #128	; 0x80
 8003d54:	4451      	add	r1, sl
 8003d56:	f801 0c80 	strb.w	r0, [r1, #-128]
 8003d5a:	f10a 0a01 	add.w	sl, sl, #1
 8003d5e:	e7f1      	b.n	8003d44 <prvParseDNSReply+0x94>
 8003d60:	eb0c 030e 	add.w	r3, ip, lr
			while( *pucByte != 0x00 )
 8003d64:	781a      	ldrb	r2, [r3, #0]
 8003d66:	b1ca      	cbz	r2, 8003d9c <prvParseDNSReply+0xec>
				if( xNameLen && xNameLen < xLen - 1 )
 8003d68:	f1ba 0f00 	cmp.w	sl, #0
 8003d6c:	d008      	beq.n	8003d80 <prvParseDNSReply+0xd0>
 8003d6e:	f1ba 0f7e 	cmp.w	sl, #126	; 0x7e
 8003d72:	dc05      	bgt.n	8003d80 <prvParseDNSReply+0xd0>
					pcName[xNameLen++] = '.';
 8003d74:	aa20      	add	r2, sp, #128	; 0x80
 8003d76:	4452      	add	r2, sl
 8003d78:	f802 8c80 	strb.w	r8, [r2, #-128]
 8003d7c:	f10a 0a01 	add.w	sl, sl, #1
				for( xCount = *(pucByte++); xCount--; pucByte++ )
 8003d80:	f103 0c01 	add.w	ip, r3, #1
 8003d84:	f893 e000 	ldrb.w	lr, [r3]
 8003d88:	f1be 0f00 	cmp.w	lr, #0
 8003d8c:	d004      	beq.n	8003d98 <prvParseDNSReply+0xe8>
 8003d8e:	f10e 0201 	add.w	r2, lr, #1
 8003d92:	4413      	add	r3, r2
 8003d94:	4662      	mov	r2, ip
 8003d96:	e7d8      	b.n	8003d4a <prvParseDNSReply+0x9a>
 8003d98:	4663      	mov	r3, ip
 8003d9a:	e7e3      	b.n	8003d64 <prvParseDNSReply+0xb4>
			pucByte++;
 8003d9c:	1c58      	adds	r0, r3, #1
 8003d9e:	46aa      	mov	sl, r5
 8003da0:	e7ad      	b.n	8003cfe <prvParseDNSReply+0x4e>
	uint16_t usType = 0, usClass = 0;
 8003da2:	4631      	mov	r1, r6
 8003da4:	4632      	mov	r2, r6
	char *pcRequestedName = NULL;
 8003da6:	f04f 0a00 	mov.w	sl, #0
 8003daa:	e7b5      	b.n	8003d18 <prvParseDNSReply+0x68>
			for( x = 0; x < pxDNSMessageHeader->usAnswers; x++ )
 8003dac:	2c00      	cmp	r4, #0
 8003dae:	f000 8107 	beq.w	8003fc0 <prvParseDNSReply+0x310>
 8003db2:	2600      	movs	r6, #0
				pucByte = prvSkipNameField( pucByte );
 8003db4:	4628      	mov	r0, r5
 8003db6:	f7ff ff6b 	bl	8003c90 <prvSkipNameField>
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 8003dba:	7802      	ldrb	r2, [r0, #0]
			  ( ( ( uint32_t )apChr[1] ) ) );
 8003dbc:	7843      	ldrb	r3, [r0, #1]
				if( usChar2u16( pucByte ) == dnsTYPE_A_HOST )
 8003dbe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003dc2:	2b01      	cmp	r3, #1
 8003dc4:	d00c      	beq.n	8003de0 <prvParseDNSReply+0x130>
					memcpy( ( void * ) &usDataLength, ( void * ) pucByte, sizeof( uint16_t ) );
 8003dc6:	8905      	ldrh	r5, [r0, #8]
					usDataLength = FreeRTOS_ntohs( usDataLength );
 8003dc8:	0a2b      	lsrs	r3, r5, #8
 8003dca:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
					pucByte += usDataLength + sizeof( uint16_t );
 8003dce:	b29b      	uxth	r3, r3
 8003dd0:	330a      	adds	r3, #10
 8003dd2:	18c5      	adds	r5, r0, r3
			for( x = 0; x < pxDNSMessageHeader->usAnswers; x++ )
 8003dd4:	3601      	adds	r6, #1
 8003dd6:	b2b6      	uxth	r6, r6
 8003dd8:	42b4      	cmp	r4, r6
 8003dda:	d1eb      	bne.n	8003db4 <prvParseDNSReply+0x104>
uint32_t ulIPAddress = 0UL;
 8003ddc:	2000      	movs	r0, #0
 8003dde:	e777      	b.n	8003cd0 <prvParseDNSReply+0x20>
					if( ( size_t ) *pucByte == sizeof( uint32_t ) )
 8003de0:	7a43      	ldrb	r3, [r0, #9]
 8003de2:	2b04      	cmp	r3, #4
 8003de4:	d001      	beq.n	8003dea <prvParseDNSReply+0x13a>
uint32_t ulIPAddress = 0UL;
 8003de6:	2000      	movs	r0, #0
 8003de8:	e772      	b.n	8003cd0 <prvParseDNSReply+0x20>
						memcpy( ( void * ) &ulIPAddress, ( void * ) pucByte, sizeof( uint32_t ) );
 8003dea:	f8d0 400a 	ldr.w	r4, [r0, #10]
	static BaseType_t xFreeEntry = 0;

		/* For each entry in the DNS cache table. */
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
		{
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 8003dee:	4b7e      	ldr	r3, [pc, #504]	; (8003fe8 <prvParseDNSReply+0x338>)
 8003df0:	791b      	ldrb	r3, [r3, #4]
 8003df2:	b18b      	cbz	r3, 8003e18 <prvParseDNSReply+0x168>
 8003df4:	4e7d      	ldr	r6, [pc, #500]	; (8003fec <prvParseDNSReply+0x33c>)
 8003df6:	2500      	movs	r5, #0
			{
				break;
			}

			if( strncmp( xDNSCache[ x ].pcName, pcName, sizeof( xDNSCache[ x ].pcName ) ) == 0 )
 8003df8:	f04f 0810 	mov.w	r8, #16
 8003dfc:	4642      	mov	r2, r8
 8003dfe:	4669      	mov	r1, sp
 8003e00:	4630      	mov	r0, r6
 8003e02:	f008 fcb1 	bl	800c768 <strncmp>
 8003e06:	2800      	cmp	r0, #0
 8003e08:	d041      	beq.n	8003e8e <prvParseDNSReply+0x1de>
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 8003e0a:	3501      	adds	r5, #1
 8003e0c:	2d04      	cmp	r5, #4
 8003e0e:	d003      	beq.n	8003e18 <prvParseDNSReply+0x168>
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 8003e10:	f816 3f18 	ldrb.w	r3, [r6, #24]!
 8003e14:	2b00      	cmp	r3, #0
 8003e16:	d1f1      	bne.n	8003dfc <prvParseDNSReply+0x14c>
				*pulIP = 0;
			}
			else
			{
				/* Called to add or update an item */
				strncpy( xDNSCache[ xFreeEntry ].pcName, pcName, sizeof( xDNSCache[ xFreeEntry ].pcName ) );
 8003e18:	4b75      	ldr	r3, [pc, #468]	; (8003ff0 <prvParseDNSReply+0x340>)
 8003e1a:	681d      	ldr	r5, [r3, #0]
 8003e1c:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 8003fe8 <prvParseDNSReply+0x338>
 8003e20:	006e      	lsls	r6, r5, #1
 8003e22:	1970      	adds	r0, r6, r5
 8003e24:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
 8003e28:	2210      	movs	r2, #16
 8003e2a:	4669      	mov	r1, sp
 8003e2c:	3004      	adds	r0, #4
 8003e2e:	f008 fcad 	bl	800c78c <strncpy>
				xDNSCache[ xFreeEntry ].ulIPAddress = *pulIP;
 8003e32:	442e      	add	r6, r5
 8003e34:	f848 4036 	str.w	r4, [r8, r6, lsl #3]

				xFreeEntry++;
 8003e38:	3501      	adds	r5, #1
				if( xFreeEntry == ipconfigDNS_CACHE_ENTRIES )
 8003e3a:	2d04      	cmp	r5, #4
 8003e3c:	d02d      	beq.n	8003e9a <prvParseDNSReply+0x1ea>
				xFreeEntry++;
 8003e3e:	4b6c      	ldr	r3, [pc, #432]	; (8003ff0 <prvParseDNSReply+0x340>)
 8003e40:	601d      	str	r5, [r3, #0]
							vDNSDoCallback( ( TickType_t ) pxDNSMessageHeader->usIdentifier, pcName, ulIPAddress );
 8003e42:	883d      	ldrh	r5, [r7, #0]
		vTaskSuspendAll();
 8003e44:	f006 f8ec 	bl	800a020 <vTaskSuspendAll>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8003e48:	4a6a      	ldr	r2, [pc, #424]	; (8003ff4 <prvParseDNSReply+0x344>)
 8003e4a:	68d3      	ldr	r3, [r2, #12]
 8003e4c:	3208      	adds	r2, #8
 8003e4e:	4293      	cmp	r3, r2
 8003e50:	d019      	beq.n	8003e86 <prvParseDNSReply+0x1d6>
				if( listGET_LIST_ITEM_VALUE( pxIterator ) == xIdentifier )
 8003e52:	681a      	ldr	r2, [r3, #0]
 8003e54:	4295      	cmp	r5, r2
 8003e56:	d006      	beq.n	8003e66 <prvParseDNSReply+0x1b6>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8003e58:	4967      	ldr	r1, [pc, #412]	; (8003ff8 <prvParseDNSReply+0x348>)
				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8003e5a:	685b      	ldr	r3, [r3, #4]
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 8003e5c:	428b      	cmp	r3, r1
 8003e5e:	d012      	beq.n	8003e86 <prvParseDNSReply+0x1d6>
				if( listGET_LIST_ITEM_VALUE( pxIterator ) == xIdentifier )
 8003e60:	681a      	ldr	r2, [r3, #0]
 8003e62:	4295      	cmp	r5, r2
 8003e64:	d1f9      	bne.n	8003e5a <prvParseDNSReply+0x1aa>
					DNSCallback_t *pxCallback = ( DNSCallback_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8003e66:	68dd      	ldr	r5, [r3, #12]
					pxCallback->pCallbackFunction( pcName, pxCallback->pvSearchID, ulIPAddress );
 8003e68:	686b      	ldr	r3, [r5, #4]
 8003e6a:	4622      	mov	r2, r4
 8003e6c:	6929      	ldr	r1, [r5, #16]
 8003e6e:	4668      	mov	r0, sp
 8003e70:	4798      	blx	r3
					uxListRemove( &pxCallback->xListItem );
 8003e72:	f105 0014 	add.w	r0, r5, #20
 8003e76:	f005 f81d 	bl	8008eb4 <uxListRemove>
					vPortFree( pxCallback );
 8003e7a:	4628      	mov	r0, r5
 8003e7c:	f005 fa62 	bl	8009344 <vPortFree>
					if( listLIST_IS_EMPTY( &xCallbackList ) )
 8003e80:	4b5c      	ldr	r3, [pc, #368]	; (8003ff4 <prvParseDNSReply+0x344>)
 8003e82:	681b      	ldr	r3, [r3, #0]
 8003e84:	b16b      	cbz	r3, 8003ea2 <prvParseDNSReply+0x1f2>
		xTaskResumeAll();
 8003e86:	f006 f9a5 	bl	800a1d4 <xTaskResumeAll>
						memcpy( ( void * ) &ulIPAddress, ( void * ) pucByte, sizeof( uint32_t ) );
 8003e8a:	4620      	mov	r0, r4
 8003e8c:	e720      	b.n	8003cd0 <prvParseDNSReply+0x20>
					xDNSCache[ x ].ulIPAddress = *pulIP;
 8003e8e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8003e92:	4b55      	ldr	r3, [pc, #340]	; (8003fe8 <prvParseDNSReply+0x338>)
 8003e94:	f843 4035 	str.w	r4, [r3, r5, lsl #3]
 8003e98:	e7d3      	b.n	8003e42 <prvParseDNSReply+0x192>
				{
					xFreeEntry = 0;
 8003e9a:	2200      	movs	r2, #0
 8003e9c:	4b54      	ldr	r3, [pc, #336]	; (8003ff0 <prvParseDNSReply+0x340>)
 8003e9e:	601a      	str	r2, [r3, #0]
 8003ea0:	e7cf      	b.n	8003e42 <prvParseDNSReply+0x192>
						vIPSetDnsTimerEnableState( pdFALSE );
 8003ea2:	2000      	movs	r0, #0
 8003ea4:	f000 fed8 	bl	8004c58 <vIPSetDnsTimerEnableState>
 8003ea8:	e7ed      	b.n	8003e86 <prvParseDNSReply+0x1d6>
		else if( usQuestions && ( usType == dnsTYPE_A_HOST ) && ( usClass == dnsCLASS_IN ) )
 8003eaa:	2901      	cmp	r1, #1
 8003eac:	d001      	beq.n	8003eb2 <prvParseDNSReply+0x202>
uint32_t ulIPAddress = 0UL;
 8003eae:	2000      	movs	r0, #0
 8003eb0:	e70e      	b.n	8003cd0 <prvParseDNSReply+0x20>
			if( xApplicationDNSQueryHook ( ( pcRequestedName + 1 ) ) )
 8003eb2:	f10a 0001 	add.w	r0, sl, #1
 8003eb6:	f008 fb49 	bl	800c54c <xApplicationDNSQueryHook>
 8003eba:	b908      	cbnz	r0, 8003ec0 <prvParseDNSReply+0x210>
uint32_t ulIPAddress = 0UL;
 8003ebc:	2000      	movs	r0, #0
 8003ebe:	e707      	b.n	8003cd0 <prvParseDNSReply+0x20>
			NetworkBufferDescriptor_t *pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pucUDPPayloadBuffer );
 8003ec0:	4638      	mov	r0, r7
 8003ec2:	f000 fab7 	bl	8004434 <pxUDPPayloadBuffer_to_NetworkBuffer>
				if( ( xBufferAllocFixedSize == pdFALSE ) && ( pxNetworkBuffer != NULL ) )
 8003ec6:	4b4d      	ldr	r3, [pc, #308]	; (8003ffc <prvParseDNSReply+0x34c>)
 8003ec8:	681b      	ldr	r3, [r3, #0]
 8003eca:	b9b3      	cbnz	r3, 8003efa <prvParseDNSReply+0x24a>
 8003ecc:	2800      	cmp	r0, #0
 8003ece:	f000 8088 	beq.w	8003fe2 <prvParseDNSReply+0x332>
					sizeof( EthernetHeader_t ) + sizeof( IPHeader_t );
 8003ed2:	69c1      	ldr	r1, [r0, #28]
 8003ed4:	f101 032a 	add.w	r3, r1, #42	; 0x2a
					pxNetworkBuffer->xDataLength = xDataLength;
 8003ed8:	61c3      	str	r3, [r0, #28]
					pxNewBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, xDataLength + 16 );
 8003eda:	313a      	adds	r1, #58	; 0x3a
 8003edc:	f000 fa95 	bl	800440a <pxDuplicateNetworkBufferWithDescriptor>
					if( pxNewBuffer != NULL )
 8003ee0:	4604      	mov	r4, r0
 8003ee2:	2800      	cmp	r0, #0
 8003ee4:	d07d      	beq.n	8003fe2 <prvParseDNSReply+0x332>
						xOffset1 = ( BaseType_t ) ( pucByte - pucUDPPayloadBuffer );
 8003ee6:	463a      	mov	r2, r7
						pucUDPPayloadBuffer = pxNetworkBuffer->pucEthernetBuffer + ipUDP_PAYLOAD_OFFSET_IPv4;
 8003ee8:	6983      	ldr	r3, [r0, #24]
 8003eea:	f103 072a 	add.w	r7, r3, #42	; 0x2a
						xOffset1 = ( BaseType_t ) ( pucByte - pucUDPPayloadBuffer );
 8003eee:	1aad      	subs	r5, r5, r2
						pucByte = pucUDPPayloadBuffer + xOffset1;
 8003ef0:	443d      	add	r5, r7
						xOffset2 = ( BaseType_t ) ( ( ( uint8_t * ) pcRequestedName ) - pucUDPPayloadBuffer );
 8003ef2:	ebaa 0a02 	sub.w	sl, sl, r2
						pcRequestedName = ( char * ) ( pucUDPPayloadBuffer + xOffset2 );
 8003ef6:	44ba      	add	sl, r7
 8003ef8:	e002      	b.n	8003f00 <prvParseDNSReply+0x250>
				if( pxNetworkBuffer != NULL )
 8003efa:	2800      	cmp	r0, #0
 8003efc:	d064      	beq.n	8003fc8 <prvParseDNSReply+0x318>
			NetworkBufferDescriptor_t *pxNewBuffer = NULL;
 8003efe:	2400      	movs	r4, #0
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usFlags, dnsLLMNR_FLAGS_IS_REPONSE );	/* Set the response flag */
 8003f00:	f04f 0e80 	mov.w	lr, #128	; 0x80
 8003f04:	f887 e002 	strb.w	lr, [r7, #2]
 8003f08:	2100      	movs	r1, #0
 8003f0a:	70f9      	strb	r1, [r7, #3]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAnswers, 1 );	/* Provide a single answer */
 8003f0c:	71b9      	strb	r1, [r7, #6]
 8003f0e:	2301      	movs	r3, #1
 8003f10:	71fb      	strb	r3, [r7, #7]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAuthorityRRs, 0 );	/* No authority */
 8003f12:	7239      	strb	r1, [r7, #8]
 8003f14:	7279      	strb	r1, [r7, #9]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAdditionalRRs, 0 );	/* No additional info */
 8003f16:	72b9      	strb	r1, [r7, #10]
 8003f18:	72f9      	strb	r1, [r7, #11]
					pxAnswer->ucNameCode = dnsNAME_IS_OFFSET;
 8003f1a:	22c0      	movs	r2, #192	; 0xc0
 8003f1c:	702a      	strb	r2, [r5, #0]
					pxAnswer->ucNameOffset = ( uint8_t )( pcRequestedName - ( char * ) pucUDPPayloadBuffer );
 8003f1e:	ebaa 0a07 	sub.w	sl, sl, r7
 8003f22:	f885 a001 	strb.w	sl, [r5, #1]
					vSetField16( pxAnswer, LLMNRAnswer_t, usType, dnsTYPE_A_HOST );	/* Type A: host */
 8003f26:	70a9      	strb	r1, [r5, #2]
 8003f28:	70eb      	strb	r3, [r5, #3]
					vSetField16( pxAnswer, LLMNRAnswer_t, usClass, dnsCLASS_IN );	/* 1: Class IN */
 8003f2a:	7129      	strb	r1, [r5, #4]
 8003f2c:	716b      	strb	r3, [r5, #5]
					vSetField32( pxAnswer, LLMNRAnswer_t, ulTTL, dnsLLMNR_TTL_VALUE );
 8003f2e:	71a9      	strb	r1, [r5, #6]
 8003f30:	2304      	movs	r3, #4
 8003f32:	71eb      	strb	r3, [r5, #7]
 8003f34:	2293      	movs	r2, #147	; 0x93
 8003f36:	722a      	strb	r2, [r5, #8]
 8003f38:	22e0      	movs	r2, #224	; 0xe0
 8003f3a:	726a      	strb	r2, [r5, #9]
					vSetField16( pxAnswer, LLMNRAnswer_t, usDataLength, 4 );
 8003f3c:	72a9      	strb	r1, [r5, #10]
 8003f3e:	72eb      	strb	r3, [r5, #11]
					vSetField32( pxAnswer, LLMNRAnswer_t, ulIPAddress, FreeRTOS_ntohl( *ipLOCAL_IP_ADDRESS_POINTER ) );
 8003f40:	4a2f      	ldr	r2, [pc, #188]	; (8004000 <prvParseDNSReply+0x350>)
 8003f42:	7d13      	ldrb	r3, [r2, #20]
 8003f44:	732b      	strb	r3, [r5, #12]
 8003f46:	7d53      	ldrb	r3, [r2, #21]
 8003f48:	736b      	strb	r3, [r5, #13]
 8003f4a:	7d93      	ldrb	r3, [r2, #22]
 8003f4c:	73ab      	strb	r3, [r5, #14]
 8003f4e:	7dd3      	ldrb	r3, [r2, #23]
 8003f50:	73eb      	strb	r3, [r5, #15]
					usLength = ( int16_t ) ( sizeof( *pxAnswer ) + ( size_t ) ( pucByte - pucUDPPayloadBuffer ) );
 8003f52:	1beb      	subs	r3, r5, r7
 8003f54:	b29b      	uxth	r3, r3
		pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
 8003f56:	6985      	ldr	r5, [r0, #24]
					usLength = ( int16_t ) ( sizeof( *pxAnswer ) + ( size_t ) ( pucByte - pucUDPPayloadBuffer ) );
 8003f58:	f103 0610 	add.w	r6, r3, #16
		pxIPHeader->usLength               = FreeRTOS_htons( lNetLength + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER );
 8003f5c:	b236      	sxth	r6, r6
 8003f5e:	f103 0c2c 	add.w	ip, r3, #44	; 0x2c
 8003f62:	f106 071c 	add.w	r7, r6, #28
 8003f66:	0a3f      	lsrs	r7, r7, #8
 8003f68:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
 8003f6c:	822f      	strh	r7, [r5, #16]
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 8003f6e:	f8d5 701a 	ldr.w	r7, [r5, #26]
 8003f72:	f8c5 701e 	str.w	r7, [r5, #30]
		pxIPHeader->ulSourceIPAddress      = *ipLOCAL_IP_ADDRESS_POINTER;
 8003f76:	6952      	ldr	r2, [r2, #20]
 8003f78:	f8c5 201a 	str.w	r2, [r5, #26]
		pxIPHeader->ucTimeToLive           = ipconfigUDP_TIME_TO_LIVE;
 8003f7c:	f885 e016 	strb.w	lr, [r5, #22]
		pxIPHeader->usIdentification       = FreeRTOS_htons( usPacketIdentifier );
 8003f80:	f8df e080 	ldr.w	lr, [pc, #128]	; 8004004 <prvParseDNSReply+0x354>
 8003f84:	f8be 2000 	ldrh.w	r2, [lr]
 8003f88:	0a17      	lsrs	r7, r2, #8
 8003f8a:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
 8003f8e:	826f      	strh	r7, [r5, #18]
		usPacketIdentifier++;
 8003f90:	3201      	adds	r2, #1
 8003f92:	f8ae 2000 	strh.w	r2, [lr]
		pxUDPHeader->usLength              = FreeRTOS_htons( lNetLength + ipSIZE_OF_UDP_HEADER );
 8003f96:	3318      	adds	r3, #24
 8003f98:	f106 0208 	add.w	r2, r6, #8
 8003f9c:	0a12      	lsrs	r2, r2, #8
 8003f9e:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8003fa2:	84ea      	strh	r2, [r5, #38]	; 0x26
		vFlip_16( pxUDPPacket->xUDPHeader.usSourcePort, pxUDPPacket->xUDPHeader.usDestinationPort );
 8003fa4:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
 8003fa6:	8caa      	ldrh	r2, [r5, #36]	; 0x24
 8003fa8:	846a      	strh	r2, [r5, #34]	; 0x22
 8003faa:	84ab      	strh	r3, [r5, #36]	; 0x24
		pxNetworkBuffer->xDataLength = ( size_t ) ( lNetLength + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER + ipSIZE_OF_ETH_HEADER );
 8003fac:	362a      	adds	r6, #42	; 0x2a
 8003fae:	61c6      	str	r6, [r0, #28]
		vReturnEthernetFrame( pxNetworkBuffer, pdFALSE );
 8003fb0:	f000 fbd0 	bl	8004754 <vReturnEthernetFrame>
					if( pxNewBuffer != NULL )
 8003fb4:	b154      	cbz	r4, 8003fcc <prvParseDNSReply+0x31c>
						vReleaseNetworkBufferAndDescriptor( pxNewBuffer );
 8003fb6:	4620      	mov	r0, r4
 8003fb8:	f004 fa8c 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
uint32_t ulIPAddress = 0UL;
 8003fbc:	2000      	movs	r0, #0
 8003fbe:	e687      	b.n	8003cd0 <prvParseDNSReply+0x20>
 8003fc0:	2000      	movs	r0, #0
 8003fc2:	e685      	b.n	8003cd0 <prvParseDNSReply+0x20>
 8003fc4:	2000      	movs	r0, #0
 8003fc6:	e683      	b.n	8003cd0 <prvParseDNSReply+0x20>
 8003fc8:	2000      	movs	r0, #0
 8003fca:	e681      	b.n	8003cd0 <prvParseDNSReply+0x20>
 8003fcc:	2000      	movs	r0, #0
	return ulIPAddress;
 8003fce:	e67f      	b.n	8003cd0 <prvParseDNSReply+0x20>
		if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 8003fd0:	782b      	ldrb	r3, [r5, #0]
 8003fd2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8003fd6:	2bc0      	cmp	r3, #192	; 0xc0
 8003fd8:	f43f aeb1 	beq.w	8003d3e <prvParseDNSReply+0x8e>
 8003fdc:	462b      	mov	r3, r5
 8003fde:	46ca      	mov	sl, r9
 8003fe0:	e6c0      	b.n	8003d64 <prvParseDNSReply+0xb4>
uint32_t ulIPAddress = 0UL;
 8003fe2:	2000      	movs	r0, #0
 8003fe4:	e674      	b.n	8003cd0 <prvParseDNSReply+0x20>
 8003fe6:	bf00      	nop
 8003fe8:	20000468 	.word	0x20000468
 8003fec:	2000046c 	.word	0x2000046c
 8003ff0:	200004c8 	.word	0x200004c8
 8003ff4:	20000454 	.word	0x20000454
 8003ff8:	2000045c 	.word	0x2000045c
 8003ffc:	0800ce00 	.word	0x0800ce00
 8004000:	20000010 	.word	0x20000010
 8004004:	200004d0 	.word	0x200004d0

08004008 <FreeRTOS_dnslookup>:
	{
 8004008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 800400a:	4b10      	ldr	r3, [pc, #64]	; (800404c <FreeRTOS_dnslookup+0x44>)
 800400c:	791b      	ldrb	r3, [r3, #4]
 800400e:	b1d3      	cbz	r3, 8004046 <FreeRTOS_dnslookup+0x3e>
 8004010:	4606      	mov	r6, r0
 8004012:	4d0f      	ldr	r5, [pc, #60]	; (8004050 <FreeRTOS_dnslookup+0x48>)
 8004014:	2400      	movs	r4, #0
			if( strncmp( xDNSCache[ x ].pcName, pcName, sizeof( xDNSCache[ x ].pcName ) ) == 0 )
 8004016:	2710      	movs	r7, #16
 8004018:	463a      	mov	r2, r7
 800401a:	4631      	mov	r1, r6
 800401c:	4628      	mov	r0, r5
 800401e:	f008 fba3 	bl	800c768 <strncmp>
 8004022:	b140      	cbz	r0, 8004036 <FreeRTOS_dnslookup+0x2e>
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 8004024:	3401      	adds	r4, #1
 8004026:	2c04      	cmp	r4, #4
 8004028:	d00b      	beq.n	8004042 <FreeRTOS_dnslookup+0x3a>
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 800402a:	f815 3f18 	ldrb.w	r3, [r5, #24]!
 800402e:	2b00      	cmp	r3, #0
 8004030:	d1f2      	bne.n	8004018 <FreeRTOS_dnslookup+0x10>
				*pulIP = 0;
 8004032:	2000      	movs	r0, #0
	}
 8004034:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					*pulIP = xDNSCache[ x ].ulIPAddress;
 8004036:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800403a:	4b04      	ldr	r3, [pc, #16]	; (800404c <FreeRTOS_dnslookup+0x44>)
 800403c:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8004040:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				*pulIP = 0;
 8004042:	2000      	movs	r0, #0
 8004044:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004046:	2000      	movs	r0, #0
 8004048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800404a:	bf00      	nop
 800404c:	20000468 	.word	0x20000468
 8004050:	2000046c 	.word	0x2000046c

08004054 <vDNSInitialise>:
	{
 8004054:	b508      	push	{r3, lr}
		vListInitialise( &xCallbackList );
 8004056:	4802      	ldr	r0, [pc, #8]	; (8004060 <vDNSInitialise+0xc>)
 8004058:	f004 fef8 	bl	8008e4c <vListInitialise>
 800405c:	bd08      	pop	{r3, pc}
 800405e:	bf00      	nop
 8004060:	20000454 	.word	0x20000454

08004064 <vDNSCheckCallBack>:
	{
 8004064:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004068:	4606      	mov	r6, r0
		vTaskSuspendAll();
 800406a:	f005 ffd9 	bl	800a020 <vTaskSuspendAll>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800406e:	4b1c      	ldr	r3, [pc, #112]	; (80040e0 <vDNSCheckCallBack+0x7c>)
 8004070:	68dd      	ldr	r5, [r3, #12]
 8004072:	3308      	adds	r3, #8
 8004074:	429d      	cmp	r5, r3
 8004076:	d027      	beq.n	80040c8 <vDNSCheckCallBack+0x64>
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 8004078:	f04f 0800 	mov.w	r8, #0
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800407c:	461f      	mov	r7, r3
 800407e:	e008      	b.n	8004092 <vDNSCheckCallBack+0x2e>
					uxListRemove( &pxCallback->xListItem );
 8004080:	f104 0014 	add.w	r0, r4, #20
 8004084:	f004 ff16 	bl	8008eb4 <uxListRemove>
					vPortFree( pxCallback );
 8004088:	4620      	mov	r0, r4
 800408a:	f005 f95b 	bl	8009344 <vPortFree>
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800408e:	42bd      	cmp	r5, r7
 8004090:	d01a      	beq.n	80040c8 <vDNSCheckCallBack+0x64>
				DNSCallback_t *pxCallback = ( DNSCallback_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8004092:	68ec      	ldr	r4, [r5, #12]
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 8004094:	686d      	ldr	r5, [r5, #4]
				if( ( pvSearchID != NULL ) && ( pvSearchID == pxCallback->pvSearchID ) )
 8004096:	b116      	cbz	r6, 800409e <vDNSCheckCallBack+0x3a>
 8004098:	6923      	ldr	r3, [r4, #16]
 800409a:	429e      	cmp	r6, r3
 800409c:	d0f0      	beq.n	8004080 <vDNSCheckCallBack+0x1c>
				else if( xTaskCheckForTimeOut( &pxCallback->xTimeoutState, &pxCallback->xRemaningTime ) != pdFALSE )
 800409e:	4621      	mov	r1, r4
 80040a0:	f104 0008 	add.w	r0, r4, #8
 80040a4:	f006 face 	bl	800a644 <xTaskCheckForTimeOut>
 80040a8:	2800      	cmp	r0, #0
 80040aa:	d0f0      	beq.n	800408e <vDNSCheckCallBack+0x2a>
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 80040ac:	6863      	ldr	r3, [r4, #4]
 80040ae:	4642      	mov	r2, r8
 80040b0:	6921      	ldr	r1, [r4, #16]
 80040b2:	f104 0028 	add.w	r0, r4, #40	; 0x28
 80040b6:	4798      	blx	r3
					uxListRemove( &pxCallback->xListItem );
 80040b8:	f104 0014 	add.w	r0, r4, #20
 80040bc:	f004 fefa 	bl	8008eb4 <uxListRemove>
					vPortFree( ( void * ) pxCallback );
 80040c0:	4620      	mov	r0, r4
 80040c2:	f005 f93f 	bl	8009344 <vPortFree>
 80040c6:	e7e2      	b.n	800408e <vDNSCheckCallBack+0x2a>
		xTaskResumeAll();
 80040c8:	f006 f884 	bl	800a1d4 <xTaskResumeAll>
		if( listLIST_IS_EMPTY( &xCallbackList ) )
 80040cc:	4b04      	ldr	r3, [pc, #16]	; (80040e0 <vDNSCheckCallBack+0x7c>)
 80040ce:	681b      	ldr	r3, [r3, #0]
 80040d0:	b10b      	cbz	r3, 80040d6 <vDNSCheckCallBack+0x72>
 80040d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			vIPSetDnsTimerEnableState( pdFALSE );
 80040d6:	2000      	movs	r0, #0
 80040d8:	f000 fdbe 	bl	8004c58 <vIPSetDnsTimerEnableState>
	}
 80040dc:	e7f9      	b.n	80040d2 <vDNSCheckCallBack+0x6e>
 80040de:	bf00      	nop
 80040e0:	20000454 	.word	0x20000454

080040e4 <FreeRTOS_gethostbyname_a>:
{
 80040e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80040e8:	b08b      	sub	sp, #44	; 0x2c
 80040ea:	4606      	mov	r6, r0
 80040ec:	460d      	mov	r5, r1
 80040ee:	4617      	mov	r7, r2
 80040f0:	4699      	mov	r9, r3
TickType_t xIdentifier = ( TickType_t )usIdentifier++;
 80040f2:	4b93      	ldr	r3, [pc, #588]	; (8004340 <FreeRTOS_gethostbyname_a+0x25c>)
 80040f4:	f8b3 8000 	ldrh.w	r8, [r3]
 80040f8:	f108 0201 	add.w	r2, r8, #1
 80040fc:	801a      	strh	r2, [r3, #0]
 80040fe:	f8cd 800c 	str.w	r8, [sp, #12]
		ulIPAddress = FreeRTOS_dnslookup( pcHostName );
 8004102:	f7ff ff81 	bl	8004008 <FreeRTOS_dnslookup>
 8004106:	4604      	mov	r4, r0
		if( pCallback != NULL )
 8004108:	2d00      	cmp	r5, #0
 800410a:	d048      	beq.n	800419e <FreeRTOS_gethostbyname_a+0xba>
			if( ulIPAddress == 0UL )
 800410c:	2800      	cmp	r0, #0
 800410e:	d13e      	bne.n	800418e <FreeRTOS_gethostbyname_a+0xaa>
		size_t lLength = strlen( pcHostName );
 8004110:	4630      	mov	r0, r6
 8004112:	f7fc f85d 	bl	80001d0 <strlen>
		DNSCallback_t *pxCallback = ( DNSCallback_t * )pvPortMalloc( sizeof( *pxCallback ) + lLength );
 8004116:	302c      	adds	r0, #44	; 0x2c
 8004118:	f005 f8ae 	bl	8009278 <pvPortMalloc>
		if( pxCallback != NULL )
 800411c:	4604      	mov	r4, r0
 800411e:	b1c8      	cbz	r0, 8004154 <FreeRTOS_gethostbyname_a+0x70>
			if( listLIST_IS_EMPTY( &xCallbackList ) )
 8004120:	4b88      	ldr	r3, [pc, #544]	; (8004344 <FreeRTOS_gethostbyname_a+0x260>)
 8004122:	681b      	ldr	r3, [r3, #0]
 8004124:	b353      	cbz	r3, 800417c <FreeRTOS_gethostbyname_a+0x98>
			strcpy( pxCallback->pcName, pcHostName );
 8004126:	4631      	mov	r1, r6
 8004128:	f104 0028 	add.w	r0, r4, #40	; 0x28
 800412c:	f008 fb00 	bl	800c730 <strcpy>
			pxCallback->pCallbackFunction = pCallbackFunction;
 8004130:	6065      	str	r5, [r4, #4]
			pxCallback->pvSearchID = pvSearchID;
 8004132:	6127      	str	r7, [r4, #16]
			pxCallback->xRemaningTime = xTimeout;
 8004134:	4620      	mov	r0, r4
 8004136:	f840 9b08 	str.w	r9, [r0], #8
			vTaskSetTimeOutState( &pxCallback->xTimeoutState );
 800413a:	f006 fa6d 	bl	800a618 <vTaskSetTimeOutState>
			listSET_LIST_ITEM_OWNER( &( pxCallback->xListItem ), ( void* ) pxCallback );
 800413e:	6224      	str	r4, [r4, #32]
			listSET_LIST_ITEM_VALUE( &( pxCallback->xListItem ), xIdentifier );
 8004140:	f844 8f14 	str.w	r8, [r4, #20]!
			vTaskSuspendAll();
 8004144:	f005 ff6c 	bl	800a020 <vTaskSuspendAll>
				vListInsertEnd( &xCallbackList, &pxCallback->xListItem );
 8004148:	4621      	mov	r1, r4
 800414a:	487e      	ldr	r0, [pc, #504]	; (8004344 <FreeRTOS_gethostbyname_a+0x260>)
 800414c:	f004 fe8c 	bl	8008e68 <vListInsertEnd>
			xTaskResumeAll();
 8004150:	f006 f840 	bl	800a1d4 <xTaskResumeAll>
TickType_t xReadTimeOut_ms = 1200U;
 8004154:	2300      	movs	r3, #0
 8004156:	9304      	str	r3, [sp, #16]
uint32_t ulIPAddress = 0UL;
 8004158:	2300      	movs	r3, #0
 800415a:	9305      	str	r3, [sp, #20]
TickType_t xWriteTimeOut_ms = 100U;
 800415c:	2364      	movs	r3, #100	; 0x64
 800415e:	9306      	str	r3, [sp, #24]
		for( pucPtr = pcHostName; *pucPtr; pucPtr++ )
 8004160:	7833      	ldrb	r3, [r6, #0]
 8004162:	2b00      	cmp	r3, #0
 8004164:	d05e      	beq.n	8004224 <FreeRTOS_gethostbyname_a+0x140>
			if( *pucPtr == '.' )
 8004166:	2b2e      	cmp	r3, #46	; 0x2e
 8004168:	d05f      	beq.n	800422a <FreeRTOS_gethostbyname_a+0x146>
 800416a:	4632      	mov	r2, r6
		for( pucPtr = pcHostName; *pucPtr; pucPtr++ )
 800416c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8004170:	b1d3      	cbz	r3, 80041a8 <FreeRTOS_gethostbyname_a+0xc4>
			if( *pucPtr == '.' )
 8004172:	2b2e      	cmp	r3, #46	; 0x2e
 8004174:	d1fa      	bne.n	800416c <FreeRTOS_gethostbyname_a+0x88>
				bHasDot = pdTRUE;
 8004176:	f04f 0b01 	mov.w	fp, #1
 800417a:	e017      	b.n	80041ac <FreeRTOS_gethostbyname_a+0xc8>
				vIPReloadDNSTimer( FreeRTOS_min_uint32( 1000U, xTimeout ) );
 800417c:	4648      	mov	r0, r9
 800417e:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 8004182:	bf28      	it	cs
 8004184:	f44f 707a 	movcs.w	r0, #1000	; 0x3e8
 8004188:	f000 fd76 	bl	8004c78 <vIPReloadDNSTimer>
 800418c:	e7cb      	b.n	8004126 <FreeRTOS_gethostbyname_a+0x42>
				pCallback( pcHostName, pvSearchID, ulIPAddress );
 800418e:	4602      	mov	r2, r0
 8004190:	4639      	mov	r1, r7
 8004192:	4630      	mov	r0, r6
 8004194:	47a8      	blx	r5
}
 8004196:	4620      	mov	r0, r4
 8004198:	b00b      	add	sp, #44	; 0x2c
 800419a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if( ulIPAddress == 0UL)
 800419e:	2800      	cmp	r0, #0
 80041a0:	d1f9      	bne.n	8004196 <FreeRTOS_gethostbyname_a+0xb2>
TickType_t xReadTimeOut_ms = 1200U;
 80041a2:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 80041a6:	e7d6      	b.n	8004156 <FreeRTOS_gethostbyname_a+0x72>
	BaseType_t bHasDot = pdFALSE;
 80041a8:	f04f 0b00 	mov.w	fp, #0
	xExpectedPayloadLength = sizeof( DNSMessage_t ) + strlen( pcHostName ) + sizeof( uint16_t ) + sizeof( uint16_t ) + 2u;
 80041ac:	4630      	mov	r0, r6
 80041ae:	f7fc f80f 	bl	80001d0 <strlen>
 80041b2:	f100 0312 	add.w	r3, r0, #18
 80041b6:	9302      	str	r3, [sp, #8]
TickType_t xTimeoutTime = pdMS_TO_TICKS( 200 );
 80041b8:	23c8      	movs	r3, #200	; 0xc8
 80041ba:	9307      	str	r3, [sp, #28]
	xSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 80041bc:	2211      	movs	r2, #17
 80041be:	2102      	movs	r1, #2
 80041c0:	4608      	mov	r0, r1
 80041c2:	f000 fdcb 	bl	8004d5c <FreeRTOS_socket>
 80041c6:	4b60      	ldr	r3, [pc, #384]	; (8004348 <FreeRTOS_gethostbyname_a+0x264>)
 80041c8:	6018      	str	r0, [r3, #0]
	xAddress.sin_port = 0u;
 80041ca:	2300      	movs	r3, #0
 80041cc:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	xReturn = FreeRTOS_bind( xSocket, &xAddress, sizeof( xAddress ) );
 80041d0:	2208      	movs	r2, #8
 80041d2:	a908      	add	r1, sp, #32
 80041d4:	f000 fee9 	bl	8004faa <FreeRTOS_bind>
	if( xReturn != 0 )
 80041d8:	bb50      	cbnz	r0, 8004230 <FreeRTOS_gethostbyname_a+0x14c>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVTIMEO, ( void * ) &xTimeoutTime, sizeof( TickType_t ) );
 80041da:	4c5b      	ldr	r4, [pc, #364]	; (8004348 <FreeRTOS_gethostbyname_a+0x264>)
 80041dc:	2504      	movs	r5, #4
 80041de:	9500      	str	r5, [sp, #0]
 80041e0:	ab07      	add	r3, sp, #28
 80041e2:	2200      	movs	r2, #0
 80041e4:	4611      	mov	r1, r2
 80041e6:	6820      	ldr	r0, [r4, #0]
 80041e8:	f001 fcbe 	bl	8005b68 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDTIMEO, ( void * ) &xTimeoutTime, sizeof( TickType_t ) );
 80041ec:	9500      	str	r5, [sp, #0]
 80041ee:	ab07      	add	r3, sp, #28
 80041f0:	2201      	movs	r2, #1
 80041f2:	2100      	movs	r1, #0
 80041f4:	6820      	ldr	r0, [r4, #0]
 80041f6:	f001 fcb7 	bl	8005b68 <FreeRTOS_setsockopt>
	return xSocket;
 80041fa:	f8d4 a000 	ldr.w	sl, [r4]
	if( xDNSSocket != NULL )
 80041fe:	f1ba 0f00 	cmp.w	sl, #0
 8004202:	d070      	beq.n	80042e6 <FreeRTOS_gethostbyname_a+0x202>
		FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_SNDTIMEO, ( void * ) &xWriteTimeOut_ms, sizeof( TickType_t ) );
 8004204:	462f      	mov	r7, r5
 8004206:	9500      	str	r5, [sp, #0]
 8004208:	ab06      	add	r3, sp, #24
 800420a:	2201      	movs	r2, #1
 800420c:	2100      	movs	r1, #0
 800420e:	4650      	mov	r0, sl
 8004210:	f001 fcaa 	bl	8005b68 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xDNSSocket, 0, FREERTOS_SO_RCVTIMEO, ( void * ) &xReadTimeOut_ms,  sizeof( TickType_t ) );
 8004214:	9500      	str	r5, [sp, #0]
 8004216:	ab04      	add	r3, sp, #16
 8004218:	2200      	movs	r2, #0
 800421a:	4611      	mov	r1, r2
 800421c:	4650      	mov	r0, sl
 800421e:	f001 fca3 	bl	8005b68 <FreeRTOS_setsockopt>
 8004222:	e06e      	b.n	8004302 <FreeRTOS_gethostbyname_a+0x21e>
	BaseType_t bHasDot = pdFALSE;
 8004224:	f04f 0b00 	mov.w	fp, #0
 8004228:	e7c0      	b.n	80041ac <FreeRTOS_gethostbyname_a+0xc8>
				bHasDot = pdTRUE;
 800422a:	f04f 0b01 	mov.w	fp, #1
 800422e:	e7bd      	b.n	80041ac <FreeRTOS_gethostbyname_a+0xc8>
		FreeRTOS_closesocket( xSocket );
 8004230:	4c45      	ldr	r4, [pc, #276]	; (8004348 <FreeRTOS_gethostbyname_a+0x264>)
 8004232:	6820      	ldr	r0, [r4, #0]
 8004234:	f000 fff4 	bl	8005220 <FreeRTOS_closesocket>
		xSocket = NULL;
 8004238:	2300      	movs	r3, #0
 800423a:	6023      	str	r3, [r4, #0]
 800423c:	e053      	b.n	80042e6 <FreeRTOS_gethostbyname_a+0x202>
		*pucStart = ( uint8_t ) ( ( uint32_t ) pucByte - ( uint32_t ) pucStart );
 800423e:	1b13      	subs	r3, r2, r4
		( *pucStart )--;
 8004240:	3b01      	subs	r3, #1
 8004242:	7023      	strb	r3, [r4, #0]
 8004244:	4614      	mov	r4, r2
	} while( *pucByte != 0x00 );
 8004246:	7813      	ldrb	r3, [r2, #0]
 8004248:	b163      	cbz	r3, 8004264 <FreeRTOS_gethostbyname_a+0x180>
		pucByte++;
 800424a:	1c62      	adds	r2, r4, #1
		while( ( *pucByte != 0x00 ) && ( *pucByte != '.' ) )
 800424c:	7863      	ldrb	r3, [r4, #1]
 800424e:	2b00      	cmp	r3, #0
 8004250:	d0f5      	beq.n	800423e <FreeRTOS_gethostbyname_a+0x15a>
 8004252:	2b2e      	cmp	r3, #46	; 0x2e
 8004254:	d0f3      	beq.n	800423e <FreeRTOS_gethostbyname_a+0x15a>
 8004256:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800425a:	2b00      	cmp	r3, #0
 800425c:	d0ef      	beq.n	800423e <FreeRTOS_gethostbyname_a+0x15a>
 800425e:	2b2e      	cmp	r3, #46	; 0x2e
 8004260:	d1f9      	bne.n	8004256 <FreeRTOS_gethostbyname_a+0x172>
 8004262:	e7ec      	b.n	800423e <FreeRTOS_gethostbyname_a+0x15a>
	vSetField16( pxTail, DNSTail_t, usType, dnsTYPE_A_HOST );	/* Type A: host */
 8004264:	2000      	movs	r0, #0
 8004266:	7050      	strb	r0, [r2, #1]
 8004268:	2301      	movs	r3, #1
 800426a:	7093      	strb	r3, [r2, #2]
	vSetField16( pxTail, DNSTail_t, usClass, dnsCLASS_IN );	/* 1: Class IN */
 800426c:	70d0      	strb	r0, [r2, #3]
 800426e:	7113      	strb	r3, [r2, #4]
	return ( ( uint32_t ) pucByte - ( uint32_t ) pucUDPPayloadBuffer + 1 ) + sizeof( *pxTail );
 8004270:	f1c5 0405 	rsb	r4, r5, #5
 8004274:	4414      	add	r4, r2
				FreeRTOS_GetAddressConfiguration( NULL, NULL, NULL, &ulIPAddress );
 8004276:	ab05      	add	r3, sp, #20
 8004278:	4602      	mov	r2, r0
 800427a:	4601      	mov	r1, r0
 800427c:	f000 f98c 	bl	8004598 <FreeRTOS_GetAddressConfiguration>
				if( bHasDot == pdFALSE )
 8004280:	f1bb 0f00 	cmp.w	fp, #0
 8004284:	d131      	bne.n	80042ea <FreeRTOS_gethostbyname_a+0x206>
					( ( DNSMessage_t * ) pucUDPPayloadBuffer) -> usFlags = 0;
 8004286:	9b07      	ldr	r3, [sp, #28]
 8004288:	2200      	movs	r2, #0
 800428a:	709a      	strb	r2, [r3, #2]
 800428c:	70da      	strb	r2, [r3, #3]
					xAddress.sin_addr = ipLLMNR_IP_ADDR;	/* Is in network byte order. */
 800428e:	4b2f      	ldr	r3, [pc, #188]	; (800434c <FreeRTOS_gethostbyname_a+0x268>)
 8004290:	9309      	str	r3, [sp, #36]	; 0x24
					xAddress.sin_port = FreeRTOS_ntohs( ipLLMNR_PORT );
 8004292:	f64e 3314 	movw	r3, #60180	; 0xeb14
 8004296:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
				ulIPAddress = 0UL;
 800429a:	2300      	movs	r3, #0
 800429c:	9305      	str	r3, [sp, #20]
				if( FreeRTOS_sendto( xDNSSocket, pucUDPPayloadBuffer, xPayloadLength, FREERTOS_ZERO_COPY, &xAddress, sizeof( xAddress ) ) != 0 )
 800429e:	2308      	movs	r3, #8
 80042a0:	9301      	str	r3, [sp, #4]
 80042a2:	ab08      	add	r3, sp, #32
 80042a4:	9300      	str	r3, [sp, #0]
 80042a6:	2301      	movs	r3, #1
 80042a8:	4622      	mov	r2, r4
 80042aa:	9907      	ldr	r1, [sp, #28]
 80042ac:	4650      	mov	r0, sl
 80042ae:	f000 feb3 	bl	8005018 <FreeRTOS_sendto>
 80042b2:	b308      	cbz	r0, 80042f8 <FreeRTOS_gethostbyname_a+0x214>
					lBytes = FreeRTOS_recvfrom( xDNSSocket, &pucUDPPayloadBuffer, 0, FREERTOS_ZERO_COPY, &xAddress, &ulAddressLength );
 80042b4:	4b26      	ldr	r3, [pc, #152]	; (8004350 <FreeRTOS_gethostbyname_a+0x26c>)
 80042b6:	9301      	str	r3, [sp, #4]
 80042b8:	ab08      	add	r3, sp, #32
 80042ba:	9300      	str	r3, [sp, #0]
 80042bc:	2301      	movs	r3, #1
 80042be:	2200      	movs	r2, #0
 80042c0:	a907      	add	r1, sp, #28
 80042c2:	4650      	mov	r0, sl
 80042c4:	f000 fde2 	bl	8004e8c <FreeRTOS_recvfrom>
					if( lBytes > 0 )
 80042c8:	2800      	cmp	r0, #0
 80042ca:	dd18      	ble.n	80042fe <FreeRTOS_gethostbyname_a+0x21a>
						ulIPAddress = prvParseDNSReply( pucUDPPayloadBuffer, xIdentifier );
 80042cc:	9903      	ldr	r1, [sp, #12]
 80042ce:	9807      	ldr	r0, [sp, #28]
 80042d0:	f7ff fcee 	bl	8003cb0 <prvParseDNSReply>
 80042d4:	9005      	str	r0, [sp, #20]
						FreeRTOS_ReleaseUDPPayloadBuffer( ( void * ) pucUDPPayloadBuffer );
 80042d6:	9807      	ldr	r0, [sp, #28]
 80042d8:	f000 f8b7 	bl	800444a <FreeRTOS_ReleaseUDPPayloadBuffer>
						if( ulIPAddress != 0UL )
 80042dc:	9b05      	ldr	r3, [sp, #20]
 80042de:	b173      	cbz	r3, 80042fe <FreeRTOS_gethostbyname_a+0x21a>
		FreeRTOS_closesocket( xDNSSocket );
 80042e0:	4650      	mov	r0, sl
 80042e2:	f000 ff9d 	bl	8005220 <FreeRTOS_closesocket>
	return ulIPAddress;
 80042e6:	9c05      	ldr	r4, [sp, #20]
	return ulIPAddress;
 80042e8:	e755      	b.n	8004196 <FreeRTOS_gethostbyname_a+0xb2>
					xAddress.sin_addr = ulIPAddress;
 80042ea:	9b05      	ldr	r3, [sp, #20]
 80042ec:	9309      	str	r3, [sp, #36]	; 0x24
					xAddress.sin_port = dnsDNS_PORT;
 80042ee:	f44f 5354 	mov.w	r3, #13568	; 0x3500
 80042f2:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
 80042f6:	e7d0      	b.n	800429a <FreeRTOS_gethostbyname_a+0x1b6>
					FreeRTOS_ReleaseUDPPayloadBuffer( ( void * ) pucUDPPayloadBuffer );
 80042f8:	9807      	ldr	r0, [sp, #28]
 80042fa:	f000 f8a6 	bl	800444a <FreeRTOS_ReleaseUDPPayloadBuffer>
		for( xAttempt = 0; xAttempt < ipconfigDNS_REQUEST_ATTEMPTS; xAttempt++ )
 80042fe:	3f01      	subs	r7, #1
 8004300:	d0ee      	beq.n	80042e0 <FreeRTOS_gethostbyname_a+0x1fc>
			pucUDPPayloadBuffer = ( uint8_t * ) FreeRTOS_GetUDPPayloadBuffer( xExpectedPayloadLength, portMAX_DELAY );
 8004302:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004306:	9802      	ldr	r0, [sp, #8]
 8004308:	f000 f870 	bl	80043ec <FreeRTOS_GetUDPPayloadBuffer>
 800430c:	4605      	mov	r5, r0
 800430e:	9007      	str	r0, [sp, #28]
			if( pucUDPPayloadBuffer != NULL )
 8004310:	2800      	cmp	r0, #0
 8004312:	d0f4      	beq.n	80042fe <FreeRTOS_gethostbyname_a+0x21a>
	memcpy( ( void * ) pucUDPPayloadBuffer, ( void * ) &xDefaultPartDNSHeader, sizeof( xDefaultPartDNSHeader ) );
 8004314:	4b0f      	ldr	r3, [pc, #60]	; (8004354 <FreeRTOS_gethostbyname_a+0x270>)
 8004316:	cb07      	ldmia	r3!, {r0, r1, r2}
 8004318:	6028      	str	r0, [r5, #0]
 800431a:	6069      	str	r1, [r5, #4]
 800431c:	60aa      	str	r2, [r5, #8]
	pxDNSMessageHeader->usIdentifier = ( uint16_t ) xIdentifier;
 800431e:	462c      	mov	r4, r5
 8004320:	f824 8b0c 	strh.w	r8, [r4], #12
	pucByte = pucStart + 1;
 8004324:	f105 090d 	add.w	r9, r5, #13
	strcpy( ( char * ) pucByte, pcHostName );
 8004328:	4631      	mov	r1, r6
 800432a:	4648      	mov	r0, r9
 800432c:	f008 fa00 	bl	800c730 <strcpy>
	pucByte += strlen( pcHostName );
 8004330:	4630      	mov	r0, r6
 8004332:	f7fb ff4d 	bl	80001d0 <strlen>
	*pucByte = 0x00u;
 8004336:	2300      	movs	r3, #0
 8004338:	f809 3000 	strb.w	r3, [r9, r0]
 800433c:	e785      	b.n	800424a <FreeRTOS_gethostbyname_a+0x166>
 800433e:	bf00      	nop
 8004340:	20000450 	.word	0x20000450
 8004344:	20000454 	.word	0x20000454
 8004348:	200004cc 	.word	0x200004cc
 800434c:	fc0000e0 	.word	0xfc0000e0
 8004350:	2000044c 	.word	0x2000044c
 8004354:	0800cb04 	.word	0x0800cb04

08004358 <FreeRTOS_gethostbyname>:
	{
 8004358:	b508      	push	{r3, lr}
		return FreeRTOS_gethostbyname_a( pcHostName, ( FOnDNSEvent ) NULL, ( void* )NULL, 0 );
 800435a:	2300      	movs	r3, #0
 800435c:	461a      	mov	r2, r3
 800435e:	4619      	mov	r1, r3
 8004360:	f7ff fec0 	bl	80040e4 <FreeRTOS_gethostbyname_a>
	}
 8004364:	bd08      	pop	{r3, pc}

08004366 <ulDNSHandlePacket>:
{
 8004366:	b508      	push	{r3, lr}
	prvParseDNSReply( pucUDPPayloadBuffer, ( uint32_t ) pxDNSMessageHeader->usIdentifier );
 8004368:	6980      	ldr	r0, [r0, #24]
 800436a:	f830 1f2a 	ldrh.w	r1, [r0, #42]!
 800436e:	f7ff fc9f 	bl	8003cb0 <prvParseDNSReply>
}
 8004372:	2000      	movs	r0, #0
 8004374:	bd08      	pop	{r3, pc}

08004376 <prvIPTimerStart>:
	#endif /* ipconfigUSE_TCP == 1 */
}
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
 8004376:	b538      	push	{r3, r4, r5, lr}
 8004378:	4604      	mov	r4, r0
 800437a:	460d      	mov	r5, r1
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 800437c:	3004      	adds	r0, #4
 800437e:	f006 f94b 	bl	800a618 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8004382:	60e5      	str	r5, [r4, #12]

	if( xTime == ( TickType_t ) 0 )
 8004384:	b145      	cbz	r5, 8004398 <prvIPTimerStart+0x22>
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8004386:	7823      	ldrb	r3, [r4, #0]
 8004388:	f36f 0341 	bfc	r3, #1, #1
 800438c:	7023      	strb	r3, [r4, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
 800438e:	7823      	ldrb	r3, [r4, #0]
 8004390:	f043 0301 	orr.w	r3, r3, #1
 8004394:	7023      	strb	r3, [r4, #0]
 8004396:	bd38      	pop	{r3, r4, r5, pc}
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 8004398:	7823      	ldrb	r3, [r4, #0]
 800439a:	f043 0302 	orr.w	r3, r3, #2
 800439e:	7023      	strb	r3, [r4, #0]
 80043a0:	e7f5      	b.n	800438e <prvIPTimerStart+0x18>

080043a2 <prvIPTimerCheck>:

static BaseType_t prvIPTimerCheck( IPTimer_t *pxTimer )
{
BaseType_t xReturn;

	if( pxTimer->bActive == pdFALSE_UNSIGNED )
 80043a2:	7803      	ldrb	r3, [r0, #0]
 80043a4:	f013 0f01 	tst.w	r3, #1
 80043a8:	d010      	beq.n	80043cc <prvIPTimerCheck+0x2a>
{
 80043aa:	b510      	push	{r4, lr}
 80043ac:	4604      	mov	r4, r0
	}
	else
	{
		/* The timer might have set the bExpired flag already, if not, check the
		value of xTimeOut against ulRemainingTime. */
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
 80043ae:	f013 0f02 	tst.w	r3, #2
 80043b2:	d105      	bne.n	80043c0 <prvIPTimerCheck+0x1e>
			( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE ) )
 80043b4:	f100 010c 	add.w	r1, r0, #12
 80043b8:	3004      	adds	r0, #4
 80043ba:	f006 f943 	bl	800a644 <xTaskCheckForTimeOut>
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
 80043be:	b138      	cbz	r0, 80043d0 <prvIPTimerCheck+0x2e>
		{
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
 80043c0:	6921      	ldr	r1, [r4, #16]
 80043c2:	4620      	mov	r0, r4
 80043c4:	f7ff ffd7 	bl	8004376 <prvIPTimerStart>
			xReturn = pdTRUE;
 80043c8:	2001      	movs	r0, #1
 80043ca:	bd10      	pop	{r4, pc}
		xReturn = pdFALSE;
 80043cc:	2000      	movs	r0, #0
 80043ce:	4770      	bx	lr
		}
		else
		{
			xReturn = pdFALSE;
 80043d0:	2000      	movs	r0, #0
		}
	}

	return xReturn;
}
 80043d2:	bd10      	pop	{r4, pc}

080043d4 <xIsCallingFromIPTask>:
{
 80043d4:	b508      	push	{r3, lr}
	if( xTaskGetCurrentTaskHandle() == xIPTaskHandle )
 80043d6:	f006 fa51 	bl	800a87c <xTaskGetCurrentTaskHandle>
 80043da:	4b03      	ldr	r3, [pc, #12]	; (80043e8 <xIsCallingFromIPTask+0x14>)
 80043dc:	681b      	ldr	r3, [r3, #0]
}
 80043de:	4283      	cmp	r3, r0
 80043e0:	bf14      	ite	ne
 80043e2:	2000      	movne	r0, #0
 80043e4:	2001      	moveq	r0, #1
 80043e6:	bd08      	pop	{r3, pc}
 80043e8:	20000528 	.word	0x20000528

080043ec <FreeRTOS_GetUDPPayloadBuffer>:
	return xHigherPriorityTaskWoken;
}
/*-----------------------------------------------------------*/

void *FreeRTOS_GetUDPPayloadBuffer( size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks )
{
 80043ec:	b508      	push	{r3, lr}
	{
		xBlockTimeTicks = ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS;
	}

	/* Obtain a network buffer with the required amount of storage. */
	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( UDPPacket_t ) + xRequestedSizeBytes, xBlockTimeTicks );
 80043ee:	f241 3388 	movw	r3, #5000	; 0x1388
 80043f2:	4299      	cmp	r1, r3
 80043f4:	bf28      	it	cs
 80043f6:	4619      	movcs	r1, r3
 80043f8:	302a      	adds	r0, #42	; 0x2a
 80043fa:	f004 f891 	bl	8008520 <pxGetNetworkBufferWithDescriptor>

	if( pxNetworkBuffer != NULL )
 80043fe:	b110      	cbz	r0, 8004406 <FreeRTOS_GetUDPPayloadBuffer+0x1a>
	{
		/* Leave space for the UPD header. */
		pvReturn = ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] );
 8004400:	6980      	ldr	r0, [r0, #24]
 8004402:	302a      	adds	r0, #42	; 0x2a
 8004404:	bd08      	pop	{r3, pc}
	}
	else
	{
		pvReturn = NULL;
 8004406:	2000      	movs	r0, #0
	}

	return ( void * ) pvReturn;
}
 8004408:	bd08      	pop	{r3, pc}

0800440a <pxDuplicateNetworkBufferWithDescriptor>:
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxDuplicateNetworkBufferWithDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer,
	BaseType_t xNewLength )
{
 800440a:	b538      	push	{r3, r4, r5, lr}
 800440c:	4605      	mov	r5, r0
 800440e:	4608      	mov	r0, r1
NetworkBufferDescriptor_t * pxNewBuffer;

	/* This function is only used when 'ipconfigZERO_COPY_TX_DRIVER' is set to 1.
	The transmit routine wants to have ownership of the network buffer
	descriptor, because it will pass the buffer straight to DMA. */
	pxNewBuffer = pxGetNetworkBufferWithDescriptor( ( size_t ) xNewLength, ( TickType_t ) 0 );
 8004410:	2100      	movs	r1, #0
 8004412:	f004 f885 	bl	8008520 <pxGetNetworkBufferWithDescriptor>

	if( pxNewBuffer != NULL )
 8004416:	4604      	mov	r4, r0
 8004418:	b150      	cbz	r0, 8004430 <pxDuplicateNetworkBufferWithDescriptor+0x26>
	{
		pxNewBuffer->ulIPAddress = pxNetworkBuffer->ulIPAddress;
 800441a:	696b      	ldr	r3, [r5, #20]
 800441c:	6143      	str	r3, [r0, #20]
		pxNewBuffer->usPort = pxNetworkBuffer->usPort;
 800441e:	8c2b      	ldrh	r3, [r5, #32]
 8004420:	8403      	strh	r3, [r0, #32]
		pxNewBuffer->usBoundPort = pxNetworkBuffer->usBoundPort;
 8004422:	8c6b      	ldrh	r3, [r5, #34]	; 0x22
 8004424:	8443      	strh	r3, [r0, #34]	; 0x22
		memcpy( pxNewBuffer->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 8004426:	69ea      	ldr	r2, [r5, #28]
 8004428:	69a9      	ldr	r1, [r5, #24]
 800442a:	6980      	ldr	r0, [r0, #24]
 800442c:	f008 f953 	bl	800c6d6 <memcpy>
	}

	return pxNewBuffer;
}
 8004430:	4620      	mov	r0, r4
 8004432:	bd38      	pop	{r3, r4, r5, pc}

08004434 <pxUDPPayloadBuffer_to_NetworkBuffer>:
NetworkBufferDescriptor_t *pxUDPPayloadBuffer_to_NetworkBuffer( void *pvBuffer )
{
uint8_t *pucBuffer;
NetworkBufferDescriptor_t *pxResult;

	if( pvBuffer == NULL )
 8004434:	b128      	cbz	r0, 8004442 <pxUDPPayloadBuffer_to_NetworkBuffer+0xe>
		the network buffer, usually 8 + 2 bytes. */
		pucBuffer -= ( sizeof( UDPPacket_t ) + ipBUFFER_PADDING );

		/* Here a pointer was placed to the network descriptor,
		As a pointer is dereferenced, make sure it is well aligned */
		if( ( ( ( uint32_t ) pucBuffer ) & ( sizeof( pucBuffer ) - 1 ) ) == 0 )
 8004436:	f010 0f03 	tst.w	r0, #3
 800443a:	d104      	bne.n	8004446 <pxUDPPayloadBuffer_to_NetworkBuffer+0x12>
		{
			/* The following statement may trigger a:
			warning: cast increases required alignment of target type [-Wcast-align].
			It has been confirmed though that the alignment is suitable. */
			pxResult = * ( ( NetworkBufferDescriptor_t ** ) pucBuffer );
 800443c:	f850 0c34 	ldr.w	r0, [r0, #-52]
 8004440:	4770      	bx	lr
		pxResult = NULL;
 8004442:	2000      	movs	r0, #0
 8004444:	4770      	bx	lr
		}
		else
		{
			pxResult = NULL;
 8004446:	2000      	movs	r0, #0
		}
	}

	return pxResult;
}
 8004448:	4770      	bx	lr

0800444a <FreeRTOS_ReleaseUDPPayloadBuffer>:
/*-----------------------------------------------------------*/

void FreeRTOS_ReleaseUDPPayloadBuffer( void *pvBuffer )
{
 800444a:	b508      	push	{r3, lr}
	vReleaseNetworkBufferAndDescriptor( pxUDPPayloadBuffer_to_NetworkBuffer( pvBuffer ) );
 800444c:	f7ff fff2 	bl	8004434 <pxUDPPayloadBuffer_to_NetworkBuffer>
 8004450:	f004 f840 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
 8004454:	bd08      	pop	{r3, pc}
	...

08004458 <FreeRTOS_IPInit>:
/*_RB_ Should we add an error or assert if the task priorities are set such that the servers won't function as expected? */
/*_HT_ There was a bug in FreeRTOS_TCP_IP.c that only occurred when the applications' priority was too high.
 As that bug has been repaired, there is not an urgent reason to warn.
 It is better though to use the advised priority scheme. */
BaseType_t FreeRTOS_IPInit( const uint8_t ucIPAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucNetMask[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucGatewayAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucDNSServerAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucMACAddress[ ipMAC_ADDRESS_LENGTH_BYTES ] )
{
 8004458:	b5f0      	push	{r4, r5, r6, r7, lr}
 800445a:	b083      	sub	sp, #12
 800445c:	4604      	mov	r4, r0
 800445e:	460f      	mov	r7, r1
 8004460:	4616      	mov	r6, r2
 8004462:	461d      	mov	r5, r3
#endif /* ipconfigDNS_USE_CALLBACKS != 0 */
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
	return xIPTaskInitialised;
 8004464:	4b42      	ldr	r3, [pc, #264]	; (8004570 <FreeRTOS_IPInit+0x118>)
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 8004466:	681b      	ldr	r3, [r3, #0]
 8004468:	bb33      	cbnz	r3, 80044b8 <FreeRTOS_IPInit+0x60>
	configASSERT( xNetworkEventQueue == NULL );
 800446a:	4b42      	ldr	r3, [pc, #264]	; (8004574 <FreeRTOS_IPInit+0x11c>)
 800446c:	681b      	ldr	r3, [r3, #0]
 800446e:	b123      	cbz	r3, 800447a <FreeRTOS_IPInit+0x22>
 8004470:	f240 31d7 	movw	r1, #983	; 0x3d7
 8004474:	4840      	ldr	r0, [pc, #256]	; (8004578 <FreeRTOS_IPInit+0x120>)
 8004476:	f007 ff73 	bl	800c360 <vAssertCalled>
	configASSERT( xIPTaskHandle == NULL );
 800447a:	4b40      	ldr	r3, [pc, #256]	; (800457c <FreeRTOS_IPInit+0x124>)
 800447c:	681b      	ldr	r3, [r3, #0]
 800447e:	b123      	cbz	r3, 800448a <FreeRTOS_IPInit+0x32>
 8004480:	f44f 7176 	mov.w	r1, #984	; 0x3d8
 8004484:	483c      	ldr	r0, [pc, #240]	; (8004578 <FreeRTOS_IPInit+0x120>)
 8004486:	f007 ff6b 	bl	800c360 <vAssertCalled>
	xNetworkEventQueue = xQueueCreate( ( UBaseType_t ) ipconfigEVENT_QUEUE_LENGTH, ( UBaseType_t ) sizeof( IPStackEvent_t ) );
 800448a:	2200      	movs	r2, #0
 800448c:	2108      	movs	r1, #8
 800448e:	201e      	movs	r0, #30
 8004490:	f005 f8fc 	bl	800968c <xQueueGenericCreate>
 8004494:	4b37      	ldr	r3, [pc, #220]	; (8004574 <FreeRTOS_IPInit+0x11c>)
 8004496:	6018      	str	r0, [r3, #0]
	configASSERT( xNetworkEventQueue );
 8004498:	b1a0      	cbz	r0, 80044c4 <FreeRTOS_IPInit+0x6c>
			vQueueAddToRegistry( xNetworkEventQueue, "NetEvnt" );
 800449a:	4939      	ldr	r1, [pc, #228]	; (8004580 <FreeRTOS_IPInit+0x128>)
 800449c:	f005 fb2c 	bl	8009af8 <vQueueAddToRegistry>
		if( xNetworkBuffersInitialise() == pdPASS )
 80044a0:	f003 ffce 	bl	8008440 <xNetworkBuffersInitialise>
 80044a4:	2801      	cmp	r0, #1
 80044a6:	d018      	beq.n	80044da <FreeRTOS_IPInit+0x82>
			vQueueDelete( xNetworkEventQueue );
 80044a8:	4c32      	ldr	r4, [pc, #200]	; (8004574 <FreeRTOS_IPInit+0x11c>)
 80044aa:	6820      	ldr	r0, [r4, #0]
 80044ac:	f005 fb58 	bl	8009b60 <vQueueDelete>
			xNetworkEventQueue = NULL;
 80044b0:	2000      	movs	r0, #0
 80044b2:	6020      	str	r0, [r4, #0]
}
 80044b4:	b003      	add	sp, #12
 80044b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 80044b8:	f240 31d6 	movw	r1, #982	; 0x3d6
 80044bc:	482e      	ldr	r0, [pc, #184]	; (8004578 <FreeRTOS_IPInit+0x120>)
 80044be:	f007 ff4f 	bl	800c360 <vAssertCalled>
 80044c2:	e7d2      	b.n	800446a <FreeRTOS_IPInit+0x12>
	configASSERT( xNetworkEventQueue );
 80044c4:	f240 31e3 	movw	r1, #995	; 0x3e3
 80044c8:	482b      	ldr	r0, [pc, #172]	; (8004578 <FreeRTOS_IPInit+0x120>)
 80044ca:	f007 ff49 	bl	800c360 <vAssertCalled>
	if( xNetworkEventQueue != NULL )
 80044ce:	4b29      	ldr	r3, [pc, #164]	; (8004574 <FreeRTOS_IPInit+0x11c>)
 80044d0:	6818      	ldr	r0, [r3, #0]
 80044d2:	2800      	cmp	r0, #0
 80044d4:	d1e1      	bne.n	800449a <FreeRTOS_IPInit+0x42>
BaseType_t xReturn = pdFALSE;
 80044d6:	2000      	movs	r0, #0
	return xReturn;
 80044d8:	e7ec      	b.n	80044b4 <FreeRTOS_IPInit+0x5c>
			xNetworkAddressing.ulDefaultIPAddress = FreeRTOS_inet_addr_quick( ucIPAddress[ 0 ], ucIPAddress[ 1 ], ucIPAddress[ 2 ], ucIPAddress[ 3 ] );
 80044da:	78e2      	ldrb	r2, [r4, #3]
 80044dc:	78a3      	ldrb	r3, [r4, #2]
 80044de:	041b      	lsls	r3, r3, #16
 80044e0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80044e4:	7822      	ldrb	r2, [r4, #0]
 80044e6:	4313      	orrs	r3, r2
 80044e8:	7862      	ldrb	r2, [r4, #1]
 80044ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80044ee:	4c25      	ldr	r4, [pc, #148]	; (8004584 <FreeRTOS_IPInit+0x12c>)
 80044f0:	6023      	str	r3, [r4, #0]
			xNetworkAddressing.ulNetMask = FreeRTOS_inet_addr_quick( ucNetMask[ 0 ], ucNetMask[ 1 ], ucNetMask[ 2 ], ucNetMask[ 3 ] );
 80044f2:	78f9      	ldrb	r1, [r7, #3]
 80044f4:	78ba      	ldrb	r2, [r7, #2]
 80044f6:	0412      	lsls	r2, r2, #16
 80044f8:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 80044fc:	7839      	ldrb	r1, [r7, #0]
 80044fe:	430a      	orrs	r2, r1
 8004500:	7879      	ldrb	r1, [r7, #1]
 8004502:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8004506:	6062      	str	r2, [r4, #4]
			xNetworkAddressing.ulGatewayAddress = FreeRTOS_inet_addr_quick( ucGatewayAddress[ 0 ], ucGatewayAddress[ 1 ], ucGatewayAddress[ 2 ], ucGatewayAddress[ 3 ] );
 8004508:	78f0      	ldrb	r0, [r6, #3]
 800450a:	78b1      	ldrb	r1, [r6, #2]
 800450c:	0409      	lsls	r1, r1, #16
 800450e:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 8004512:	7830      	ldrb	r0, [r6, #0]
 8004514:	4301      	orrs	r1, r0
 8004516:	7870      	ldrb	r0, [r6, #1]
 8004518:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800451c:	60a1      	str	r1, [r4, #8]
			xNetworkAddressing.ulDNSServerAddress = FreeRTOS_inet_addr_quick( ucDNSServerAddress[ 0 ], ucDNSServerAddress[ 1 ], ucDNSServerAddress[ 2 ], ucDNSServerAddress[ 3 ] );
 800451e:	78e8      	ldrb	r0, [r5, #3]
 8004520:	78a9      	ldrb	r1, [r5, #2]
 8004522:	0409      	lsls	r1, r1, #16
 8004524:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 8004528:	7828      	ldrb	r0, [r5, #0]
 800452a:	4301      	orrs	r1, r0
 800452c:	7868      	ldrb	r0, [r5, #1]
 800452e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8004532:	60e1      	str	r1, [r4, #12]
			xNetworkAddressing.ulBroadcastAddress = ( xNetworkAddressing.ulDefaultIPAddress & xNetworkAddressing.ulNetMask ) |  ~xNetworkAddressing.ulNetMask;
 8004534:	ea63 0602 	orn	r6, r3, r2
 8004538:	6126      	str	r6, [r4, #16]
			memcpy( &xDefaultAddressing, &xNetworkAddressing, sizeof( xDefaultAddressing ) );
 800453a:	4d13      	ldr	r5, [pc, #76]	; (8004588 <FreeRTOS_IPInit+0x130>)
 800453c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800453e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8004540:	602e      	str	r6, [r5, #0]
				*ipLOCAL_IP_ADDRESS_POINTER = 0x00UL;
 8004542:	4b12      	ldr	r3, [pc, #72]	; (800458c <FreeRTOS_IPInit+0x134>)
 8004544:	2400      	movs	r4, #0
 8004546:	615c      	str	r4, [r3, #20]
			memcpy( ( void * ) ipLOCAL_MAC_ADDRESS, ( void * ) ucMACAddress, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8004548:	9a08      	ldr	r2, [sp, #32]
 800454a:	6810      	ldr	r0, [r2, #0]
 800454c:	6018      	str	r0, [r3, #0]
 800454e:	8892      	ldrh	r2, [r2, #4]
 8004550:	809a      	strh	r2, [r3, #4]
			vNetworkSocketsInit();
 8004552:	f000 fbd3 	bl	8004cfc <vNetworkSocketsInit>
			xReturn = xTaskCreate( prvIPTask, "IP-task", ( uint16_t ) ipconfigIP_TASK_STACK_SIZE_WORDS, NULL, ( UBaseType_t ) ipconfigIP_TASK_PRIORITY, &xIPTaskHandle );
 8004556:	4b09      	ldr	r3, [pc, #36]	; (800457c <FreeRTOS_IPInit+0x124>)
 8004558:	9301      	str	r3, [sp, #4]
 800455a:	2305      	movs	r3, #5
 800455c:	9300      	str	r3, [sp, #0]
 800455e:	4623      	mov	r3, r4
 8004560:	f44f 7220 	mov.w	r2, #640	; 0x280
 8004564:	490a      	ldr	r1, [pc, #40]	; (8004590 <FreeRTOS_IPInit+0x138>)
 8004566:	480b      	ldr	r0, [pc, #44]	; (8004594 <FreeRTOS_IPInit+0x13c>)
 8004568:	f005 fb84 	bl	8009c74 <xTaskCreate>
 800456c:	e7a2      	b.n	80044b4 <FreeRTOS_IPInit+0x5c>
 800456e:	bf00      	nop
 8004570:	2000052c 	.word	0x2000052c
 8004574:	20000548 	.word	0x20000548
 8004578:	0800cb18 	.word	0x0800cb18
 800457c:	20000528 	.word	0x20000528
 8004580:	0800cb48 	.word	0x0800cb48
 8004584:	20000530 	.word	0x20000530
 8004588:	20000514 	.word	0x20000514
 800458c:	20000010 	.word	0x20000010
 8004590:	0800cb50 	.word	0x0800cb50
 8004594:	08004781 	.word	0x08004781

08004598 <FreeRTOS_GetAddressConfiguration>:
	if( pulIPAddress != NULL )
 8004598:	b198      	cbz	r0, 80045c2 <FreeRTOS_GetAddressConfiguration+0x2a>
{
 800459a:	b410      	push	{r4}
 800459c:	4604      	mov	r4, r0
		*pulIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800459e:	4810      	ldr	r0, [pc, #64]	; (80045e0 <FreeRTOS_GetAddressConfiguration+0x48>)
 80045a0:	6940      	ldr	r0, [r0, #20]
 80045a2:	6020      	str	r0, [r4, #0]
	if( pulNetMask != NULL )
 80045a4:	b111      	cbz	r1, 80045ac <FreeRTOS_GetAddressConfiguration+0x14>
		*pulNetMask = xNetworkAddressing.ulNetMask;
 80045a6:	480f      	ldr	r0, [pc, #60]	; (80045e4 <FreeRTOS_GetAddressConfiguration+0x4c>)
 80045a8:	6840      	ldr	r0, [r0, #4]
 80045aa:	6008      	str	r0, [r1, #0]
	if( pulGatewayAddress != NULL )
 80045ac:	b112      	cbz	r2, 80045b4 <FreeRTOS_GetAddressConfiguration+0x1c>
		*pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;
 80045ae:	490d      	ldr	r1, [pc, #52]	; (80045e4 <FreeRTOS_GetAddressConfiguration+0x4c>)
 80045b0:	6889      	ldr	r1, [r1, #8]
 80045b2:	6011      	str	r1, [r2, #0]
	if( pulDNSServerAddress != NULL )
 80045b4:	b113      	cbz	r3, 80045bc <FreeRTOS_GetAddressConfiguration+0x24>
		*pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;
 80045b6:	4a0b      	ldr	r2, [pc, #44]	; (80045e4 <FreeRTOS_GetAddressConfiguration+0x4c>)
 80045b8:	68d2      	ldr	r2, [r2, #12]
 80045ba:	601a      	str	r2, [r3, #0]
}
 80045bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80045c0:	4770      	bx	lr
	if( pulNetMask != NULL )
 80045c2:	b111      	cbz	r1, 80045ca <FreeRTOS_GetAddressConfiguration+0x32>
		*pulNetMask = xNetworkAddressing.ulNetMask;
 80045c4:	4807      	ldr	r0, [pc, #28]	; (80045e4 <FreeRTOS_GetAddressConfiguration+0x4c>)
 80045c6:	6840      	ldr	r0, [r0, #4]
 80045c8:	6008      	str	r0, [r1, #0]
	if( pulGatewayAddress != NULL )
 80045ca:	b112      	cbz	r2, 80045d2 <FreeRTOS_GetAddressConfiguration+0x3a>
		*pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;
 80045cc:	4905      	ldr	r1, [pc, #20]	; (80045e4 <FreeRTOS_GetAddressConfiguration+0x4c>)
 80045ce:	6889      	ldr	r1, [r1, #8]
 80045d0:	6011      	str	r1, [r2, #0]
	if( pulDNSServerAddress != NULL )
 80045d2:	2b00      	cmp	r3, #0
 80045d4:	d0f4      	beq.n	80045c0 <FreeRTOS_GetAddressConfiguration+0x28>
		*pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;
 80045d6:	4a03      	ldr	r2, [pc, #12]	; (80045e4 <FreeRTOS_GetAddressConfiguration+0x4c>)
 80045d8:	68d2      	ldr	r2, [r2, #12]
 80045da:	601a      	str	r2, [r3, #0]
 80045dc:	4770      	bx	lr
 80045de:	bf00      	nop
 80045e0:	20000010 	.word	0x20000010
 80045e4:	20000530 	.word	0x20000530

080045e8 <xSendEventStructToIPTask>:
{
 80045e8:	b538      	push	{r3, r4, r5, lr}
 80045ea:	4604      	mov	r4, r0
 80045ec:	460d      	mov	r5, r1
	return xIPTaskInitialised;
 80045ee:	4b17      	ldr	r3, [pc, #92]	; (800464c <xSendEventStructToIPTask+0x64>)
	if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
 80045f0:	681b      	ldr	r3, [r3, #0]
 80045f2:	b92b      	cbnz	r3, 8004600 <xSendEventStructToIPTask+0x18>
 80045f4:	f990 3000 	ldrsb.w	r3, [r0]
 80045f8:	b133      	cbz	r3, 8004608 <xSendEventStructToIPTask+0x20>
		xReturn = pdFAIL;
 80045fa:	2400      	movs	r4, #0
}
 80045fc:	4620      	mov	r0, r4
 80045fe:	bd38      	pop	{r3, r4, r5, pc}
			if( pxEvent->eEventType == eTCPTimerEvent )
 8004600:	f990 3000 	ldrsb.w	r3, [r0]
 8004604:	2b05      	cmp	r3, #5
 8004606:	d014      	beq.n	8004632 <xSendEventStructToIPTask+0x4a>
			if( ( xIsCallingFromIPTask() == pdTRUE ) && ( xTimeout > ( TickType_t ) 0 ) )
 8004608:	f7ff fee4 	bl	80043d4 <xIsCallingFromIPTask>
 800460c:	2801      	cmp	r0, #1
			xReturn = xQueueSendToBack( xNetworkEventQueue, pxEvent, xTimeout );
 800460e:	f04f 0300 	mov.w	r3, #0
 8004612:	bf14      	ite	ne
 8004614:	462a      	movne	r2, r5
 8004616:	461a      	moveq	r2, r3
 8004618:	4621      	mov	r1, r4
 800461a:	480d      	ldr	r0, [pc, #52]	; (8004650 <xSendEventStructToIPTask+0x68>)
 800461c:	6800      	ldr	r0, [r0, #0]
 800461e:	f005 f877 	bl	8009710 <xQueueGenericSend>
			if( xReturn == pdFAIL )
 8004622:	4604      	mov	r4, r0
 8004624:	2800      	cmp	r0, #0
 8004626:	d1e9      	bne.n	80045fc <xSendEventStructToIPTask+0x14>
				iptraceSTACK_TX_EVENT_LOST( pxEvent->eEventType );
 8004628:	2100      	movs	r1, #0
 800462a:	200b      	movs	r0, #11
 800462c:	f007 f910 	bl	800b850 <vExampleDebugStatUpdate>
 8004630:	e7e4      	b.n	80045fc <xSendEventStructToIPTask+0x14>
				xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 8004632:	4a08      	ldr	r2, [pc, #32]	; (8004654 <xSendEventStructToIPTask+0x6c>)
 8004634:	7813      	ldrb	r3, [r2, #0]
 8004636:	f043 0302 	orr.w	r3, r3, #2
 800463a:	7013      	strb	r3, [r2, #0]
				if( uxQueueMessagesWaiting( xNetworkEventQueue ) != 0u )
 800463c:	4b04      	ldr	r3, [pc, #16]	; (8004650 <xSendEventStructToIPTask+0x68>)
 800463e:	6818      	ldr	r0, [r3, #0]
 8004640:	f005 fa48 	bl	8009ad4 <uxQueueMessagesWaiting>
		if( xSendMessage != pdFALSE )
 8004644:	2800      	cmp	r0, #0
 8004646:	d0df      	beq.n	8004608 <xSendEventStructToIPTask+0x20>
			xReturn = pdPASS;
 8004648:	2401      	movs	r4, #1
	return xReturn;
 800464a:	e7d7      	b.n	80045fc <xSendEventStructToIPTask+0x14>
 800464c:	2000052c 	.word	0x2000052c
 8004650:	20000548 	.word	0x20000548
 8004654:	20000558 	.word	0x20000558

08004658 <FreeRTOS_NetworkDown>:
{
 8004658:	b508      	push	{r3, lr}
	if( xSendEventStructToIPTask( &xNetworkDownEvent, xDontBlock ) != pdPASS )
 800465a:	2100      	movs	r1, #0
 800465c:	4804      	ldr	r0, [pc, #16]	; (8004670 <FreeRTOS_NetworkDown+0x18>)
 800465e:	f7ff ffc3 	bl	80045e8 <xSendEventStructToIPTask>
 8004662:	2801      	cmp	r0, #1
		xNetworkDownEventPending = pdTRUE;
 8004664:	bf14      	ite	ne
 8004666:	2201      	movne	r2, #1
		xNetworkDownEventPending = pdFALSE;
 8004668:	2200      	moveq	r2, #0
 800466a:	4b02      	ldr	r3, [pc, #8]	; (8004674 <FreeRTOS_NetworkDown+0x1c>)
 800466c:	601a      	str	r2, [r3, #0]
 800466e:	bd08      	pop	{r3, pc}
 8004670:	0800cb60 	.word	0x0800cb60
 8004674:	20000544 	.word	0x20000544

08004678 <FreeRTOS_SendPingRequest>:
	{
 8004678:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800467c:	b082      	sub	sp, #8
	IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 800467e:	2303      	movs	r3, #3
 8004680:	f88d 3000 	strb.w	r3, [sp]
 8004684:	2300      	movs	r3, #0
 8004686:	9301      	str	r3, [sp, #4]
		if( xNumberOfBytesToSend < ( ( ipconfigNETWORK_MTU - sizeof( IPHeader_t ) ) - sizeof( ICMPHeader_t ) ) )
 8004688:	f5b1 6fb8 	cmp.w	r1, #1472	; 0x5c0
 800468c:	d303      	bcc.n	8004696 <FreeRTOS_SendPingRequest+0x1e>
	BaseType_t xReturn = pdFAIL;
 800468e:	2000      	movs	r0, #0
	}
 8004690:	b002      	add	sp, #8
 8004692:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
 8004696:	4616      	mov	r6, r2
 8004698:	460c      	mov	r4, r1
 800469a:	4680      	mov	r8, r0
			pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( xNumberOfBytesToSend + sizeof( ICMPPacket_t ), xBlockTimeTicks );
 800469c:	4611      	mov	r1, r2
 800469e:	f104 002a 	add.w	r0, r4, #42	; 0x2a
 80046a2:	f003 ff3d 	bl	8008520 <pxGetNetworkBufferWithDescriptor>
			if( pxNetworkBuffer != NULL )
 80046a6:	4605      	mov	r5, r0
 80046a8:	b380      	cbz	r0, 800470c <FreeRTOS_SendPingRequest+0x94>
				pxICMPHeader = ( ICMPHeader_t * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipIP_PAYLOAD_OFFSET ] );
 80046aa:	6980      	ldr	r0, [r0, #24]
				usSequenceNumber++;
 80046ac:	4918      	ldr	r1, [pc, #96]	; (8004710 <FreeRTOS_SendPingRequest+0x98>)
 80046ae:	880b      	ldrh	r3, [r1, #0]
 80046b0:	3301      	adds	r3, #1
 80046b2:	b29b      	uxth	r3, r3
 80046b4:	461a      	mov	r2, r3
 80046b6:	800b      	strh	r3, [r1, #0]
				pxICMPHeader->ucTypeOfMessage = ipICMP_ECHO_REQUEST;
 80046b8:	2308      	movs	r3, #8
 80046ba:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
				pxICMPHeader->ucTypeOfService = 0;
 80046be:	f04f 0900 	mov.w	r9, #0
 80046c2:	f880 9023 	strb.w	r9, [r0, #35]	; 0x23
				pxICMPHeader->usIdentifier = usSequenceNumber;
 80046c6:	84c2      	strh	r2, [r0, #38]	; 0x26
				pxICMPHeader->usSequenceNumber = usSequenceNumber;
 80046c8:	8502      	strh	r2, [r0, #40]	; 0x28
				memset( ( void * ) pucChar, ( int ) ipECHO_DATA_FILL_BYTE, xNumberOfBytesToSend );
 80046ca:	4622      	mov	r2, r4
 80046cc:	2178      	movs	r1, #120	; 0x78
 80046ce:	302a      	adds	r0, #42	; 0x2a
 80046d0:	f008 f826 	bl	800c720 <memset>
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = FREERTOS_SO_UDPCKSUM_OUT;
 80046d4:	69ab      	ldr	r3, [r5, #24]
 80046d6:	2202      	movs	r2, #2
 80046d8:	719a      	strb	r2, [r3, #6]
				pxNetworkBuffer->ulIPAddress = ulIPAddress;
 80046da:	f8c5 8014 	str.w	r8, [r5, #20]
				pxNetworkBuffer->usPort = ipPACKET_CONTAINS_ICMP_DATA;
 80046de:	f8a5 9020 	strh.w	r9, [r5, #32]
				pxNetworkBuffer->xDataLength = xNumberOfBytesToSend + sizeof( ICMPHeader_t );
 80046e2:	3408      	adds	r4, #8
 80046e4:	61ec      	str	r4, [r5, #28]
				xStackTxEvent.pvData = pxNetworkBuffer;
 80046e6:	9501      	str	r5, [sp, #4]
				if( xSendEventStructToIPTask( &xStackTxEvent, xBlockTimeTicks) != pdPASS )
 80046e8:	4631      	mov	r1, r6
 80046ea:	4668      	mov	r0, sp
 80046ec:	f7ff ff7c 	bl	80045e8 <xSendEventStructToIPTask>
 80046f0:	2801      	cmp	r0, #1
 80046f2:	d102      	bne.n	80046fa <FreeRTOS_SendPingRequest+0x82>
					xReturn = usSequenceNumber;
 80046f4:	4b06      	ldr	r3, [pc, #24]	; (8004710 <FreeRTOS_SendPingRequest+0x98>)
 80046f6:	8818      	ldrh	r0, [r3, #0]
 80046f8:	e7ca      	b.n	8004690 <FreeRTOS_SendPingRequest+0x18>
					vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80046fa:	4628      	mov	r0, r5
 80046fc:	f003 feea 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
					iptraceSTACK_TX_EVENT_LOST( ipSTACK_TX_EVENT );
 8004700:	4649      	mov	r1, r9
 8004702:	200b      	movs	r0, #11
 8004704:	f007 f8a4 	bl	800b850 <vExampleDebugStatUpdate>
	BaseType_t xReturn = pdFAIL;
 8004708:	4648      	mov	r0, r9
 800470a:	e7c1      	b.n	8004690 <FreeRTOS_SendPingRequest+0x18>
 800470c:	2000      	movs	r0, #0
		return xReturn;
 800470e:	e7bf      	b.n	8004690 <FreeRTOS_SendPingRequest+0x18>
 8004710:	200004d2 	.word	0x200004d2

08004714 <xSendEventToIPTask>:
{
 8004714:	b500      	push	{lr}
 8004716:	b083      	sub	sp, #12
	xEventMessage.eEventType = eEvent;
 8004718:	f88d 0000 	strb.w	r0, [sp]
	xEventMessage.pvData = ( void* )NULL;
 800471c:	2100      	movs	r1, #0
 800471e:	9101      	str	r1, [sp, #4]
	return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
 8004720:	4668      	mov	r0, sp
 8004722:	f7ff ff61 	bl	80045e8 <xSendEventStructToIPTask>
}
 8004726:	b003      	add	sp, #12
 8004728:	f85d fb04 	ldr.w	pc, [sp], #4

0800472c <vIPNetworkUpCalls>:
{
 800472c:	b508      	push	{r3, lr}
	xNetworkUp = pdTRUE;
 800472e:	2201      	movs	r2, #1
 8004730:	4b06      	ldr	r3, [pc, #24]	; (800474c <vIPNetworkUpCalls+0x20>)
 8004732:	601a      	str	r2, [r3, #0]
		vApplicationIPNetworkEventHook( eNetworkUp );
 8004734:	2000      	movs	r0, #0
 8004736:	f007 fe43 	bl	800c3c0 <vApplicationIPNetworkEventHook>
		vDNSInitialise();
 800473a:	f7ff fc8b 	bl	8004054 <vDNSInitialise>
	pxTimer->ulReloadTime = xTime;
 800473e:	4804      	ldr	r0, [pc, #16]	; (8004750 <vIPNetworkUpCalls+0x24>)
 8004740:	f242 7110 	movw	r1, #10000	; 0x2710
 8004744:	6101      	str	r1, [r0, #16]
	prvIPTimerStart( pxTimer, xTime );
 8004746:	f7ff fe16 	bl	8004376 <prvIPTimerStart>
 800474a:	bd08      	pop	{r3, pc}
 800474c:	2000054c 	.word	0x2000054c
 8004750:	200004d4 	.word	0x200004d4

08004754 <vReturnEthernetFrame>:
{
 8004754:	b538      	push	{r3, r4, r5, lr}
 8004756:	4604      	mov	r4, r0
		pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8004758:	6982      	ldr	r2, [r0, #24]
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ), sizeof( pxEthernetHeader->xDestinationAddress ) );
 800475a:	4613      	mov	r3, r2
 800475c:	f853 0f06 	ldr.w	r0, [r3, #6]!
 8004760:	6010      	str	r0, [r2, #0]
 8004762:	8898      	ldrh	r0, [r3, #4]
 8004764:	8090      	strh	r0, [r2, #4]
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8004766:	4d05      	ldr	r5, [pc, #20]	; (800477c <vReturnEthernetFrame+0x28>)
 8004768:	6828      	ldr	r0, [r5, #0]
 800476a:	f8c2 0006 	str.w	r0, [r2, #6]
 800476e:	88aa      	ldrh	r2, [r5, #4]
 8004770:	809a      	strh	r2, [r3, #4]
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 8004772:	4620      	mov	r0, r4
 8004774:	f004 f970 	bl	8008a58 <xNetworkInterfaceOutput>
 8004778:	bd38      	pop	{r3, r4, r5, pc}
 800477a:	bf00      	nop
 800477c:	20000010 	.word	0x20000010

08004780 <prvIPTask>:
{
 8004780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004784:	b089      	sub	sp, #36	; 0x24
	FreeRTOS_NetworkDown();
 8004786:	f7ff ff67 	bl	8004658 <FreeRTOS_NetworkDown>
	pxTimer->ulReloadTime = xTime;
 800478a:	48c2      	ldr	r0, [pc, #776]	; (8004a94 <prvIPTask+0x314>)
 800478c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8004790:	6101      	str	r1, [r0, #16]
	prvIPTimerStart( pxTimer, xTime );
 8004792:	f7ff fdf0 	bl	8004376 <prvIPTimerStart>
	xIPTaskInitialised = pdTRUE;
 8004796:	2201      	movs	r2, #1
 8004798:	4bbf      	ldr	r3, [pc, #764]	; (8004a98 <prvIPTask+0x318>)
 800479a:	601a      	str	r2, [r3, #0]
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 800479c:	4dbf      	ldr	r5, [pc, #764]	; (8004a9c <prvIPTask+0x31c>)
		if( prvIPTimerCheck( &xDHCPTimer ) != pdFALSE )
 800479e:	f8df 8320 	ldr.w	r8, [pc, #800]	; 8004ac0 <prvIPTask+0x340>
		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0u )
 80047a2:	4cbf      	ldr	r4, [pc, #764]	; (8004aa0 <prvIPTask+0x320>)
		if( xStart != ( TickType_t ) 0 )
 80047a4:	f8df 931c 	ldr.w	r9, [pc, #796]	; 8004ac4 <prvIPTask+0x344>
 80047a8:	e228      	b.n	8004bfc <prvIPTask+0x47c>
		xSendEventToIPTask( eARPTimerEvent );
 80047aa:	2002      	movs	r0, #2
 80047ac:	f7ff ffb2 	bl	8004714 <xSendEventToIPTask>
 80047b0:	e1a2      	b.n	8004af8 <prvIPTask+0x378>
			xSendEventToIPTask( eDHCPEvent );
 80047b2:	2004      	movs	r0, #4
 80047b4:	f7ff ffae 	bl	8004714 <xSendEventToIPTask>
 80047b8:	e1a4      	b.n	8004b04 <prvIPTask+0x384>
			vDNSCheckCallBack( NULL );
 80047ba:	2000      	movs	r0, #0
 80047bc:	f7ff fc52 	bl	8004064 <vDNSCheckCallBack>
 80047c0:	e1a6      	b.n	8004b10 <prvIPTask+0x390>
			xNextTime = xTCPTimerCheck( xWillSleep );
 80047c2:	faba f08a 	clz	r0, sl
 80047c6:	0940      	lsrs	r0, r0, #5
 80047c8:	f001 f8be 	bl	8005948 <xTCPTimerCheck>
			prvIPTimerStart( &xTCPTimer, xNextTime );
 80047cc:	4601      	mov	r1, r0
 80047ce:	4638      	mov	r0, r7
 80047d0:	f7ff fdd1 	bl	8004376 <prvIPTimerStart>
			xProcessedTCPMessage = 0;
 80047d4:	2200      	movs	r2, #0
 80047d6:	4bb3      	ldr	r3, [pc, #716]	; (8004aa4 <prvIPTask+0x324>)
 80047d8:	601a      	str	r2, [r3, #0]
 80047da:	e1b7      	b.n	8004b4c <prvIPTask+0x3cc>
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 80047dc:	f242 7210 	movw	r2, #10000	; 0x2710
		if( xDHCPTimer.bActive != pdFALSE_UNSIGNED )
 80047e0:	f898 3000 	ldrb.w	r3, [r8]
 80047e4:	f013 0f01 	tst.w	r3, #1
 80047e8:	d004      	beq.n	80047f4 <prvIPTask+0x74>
 80047ea:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80047ee:	429a      	cmp	r2, r3
 80047f0:	bf28      	it	cs
 80047f2:	461a      	movcs	r2, r3
 80047f4:	68fb      	ldr	r3, [r7, #12]
 80047f6:	429a      	cmp	r2, r3
 80047f8:	bf28      	it	cs
 80047fa:	461a      	movcs	r2, r3
		if( xDNSTimer.bActive != pdFALSE )
 80047fc:	7833      	ldrb	r3, [r6, #0]
 80047fe:	f013 0f01 	tst.w	r3, #1
 8004802:	d003      	beq.n	800480c <prvIPTask+0x8c>
 8004804:	68f3      	ldr	r3, [r6, #12]
 8004806:	429a      	cmp	r2, r3
 8004808:	bf28      	it	cs
 800480a:	461a      	movcs	r2, r3
		xReceivedEvent.eEventType = eNoEvent;
 800480c:	a908      	add	r1, sp, #32
 800480e:	23ff      	movs	r3, #255	; 0xff
 8004810:	f801 3d08 	strb.w	r3, [r1, #-8]!
		xQueueReceive( xNetworkEventQueue, ( void * ) &xReceivedEvent, xNextIPSleep );
 8004814:	2300      	movs	r3, #0
 8004816:	6820      	ldr	r0, [r4, #0]
 8004818:	f005 f888 	bl	800992c <xQueueGenericReceive>
		iptraceNETWORK_EVENT_RECEIVED( xReceivedEvent.eEventType );
 800481c:	6820      	ldr	r0, [r4, #0]
 800481e:	f005 f959 	bl	8009ad4 <uxQueueMessagesWaiting>
 8004822:	f1c0 011d 	rsb	r1, r0, #29
 8004826:	b289      	uxth	r1, r1
 8004828:	2005      	movs	r0, #5
 800482a:	f007 f811 	bl	800b850 <vExampleDebugStatUpdate>
		switch( xReceivedEvent.eEventType )
 800482e:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 8004832:	2b0b      	cmp	r3, #11
 8004834:	f200 8155 	bhi.w	8004ae2 <prvIPTask+0x362>
 8004838:	e8df f013 	tbh	[pc, r3, lsl #1]
 800483c:	0033000f 	.word	0x0033000f
 8004840:	01b50151 	.word	0x01b50151
 8004844:	01c501b9 	.word	0x01c501b9
 8004848:	01db01ca 	.word	0x01db01ca
 800484c:	01b10195 	.word	0x01b10195
 8004850:	01c101bd 	.word	0x01c101bd
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 8004854:	f242 7210 	movw	r2, #10000	; 0x2710
 8004858:	e7c2      	b.n	80047e0 <prvIPTask+0x60>
				xNetworkUp = pdFALSE;
 800485a:	2200      	movs	r2, #0
 800485c:	4b92      	ldr	r3, [pc, #584]	; (8004aa8 <prvIPTask+0x328>)
 800485e:	601a      	str	r2, [r3, #0]
	xARPTimer.bActive = pdFALSE_UNSIGNED;
 8004860:	782b      	ldrb	r3, [r5, #0]
 8004862:	f362 0300 	bfi	r3, r2, #0, #1
 8004866:	702b      	strb	r3, [r5, #0]
		if( xCallEventHook == pdTRUE )
 8004868:	4b90      	ldr	r3, [pc, #576]	; (8004aac <prvIPTask+0x32c>)
 800486a:	681b      	ldr	r3, [r3, #0]
 800486c:	2b01      	cmp	r3, #1
 800486e:	d00d      	beq.n	800488c <prvIPTask+0x10c>
		xCallEventHook = pdTRUE;
 8004870:	2201      	movs	r2, #1
 8004872:	4b8e      	ldr	r3, [pc, #568]	; (8004aac <prvIPTask+0x32c>)
 8004874:	601a      	str	r2, [r3, #0]
	if( xNetworkInterfaceInitialise() != pdPASS )
 8004876:	f004 f883 	bl	8008980 <xNetworkInterfaceInitialise>
 800487a:	2801      	cmp	r0, #1
 800487c:	d00a      	beq.n	8004894 <prvIPTask+0x114>
		vTaskDelay( ipINITIALISATION_RETRY_DELAY );
 800487e:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8004882:	f005 fd27 	bl	800a2d4 <vTaskDelay>
		FreeRTOS_NetworkDown();
 8004886:	f7ff fee7 	bl	8004658 <FreeRTOS_NetworkDown>
 800488a:	e12a      	b.n	8004ae2 <prvIPTask+0x362>
			vApplicationIPNetworkEventHook( eNetworkDown );
 800488c:	2001      	movs	r0, #1
 800488e:	f007 fd97 	bl	800c3c0 <vApplicationIPNetworkEventHook>
 8004892:	e7ed      	b.n	8004870 <prvIPTask+0xf0>
			vDHCPProcess( pdTRUE );
 8004894:	2001      	movs	r0, #1
 8004896:	f7ff f90d 	bl	8003ab4 <vDHCPProcess>
			xSendEventToIPTask( eDHCPEvent );
 800489a:	2004      	movs	r0, #4
 800489c:	f7ff ff3a 	bl	8004714 <xSendEventToIPTask>
 80048a0:	e11f      	b.n	8004ae2 <prvIPTask+0x362>
				prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
 80048a2:	f8dd a01c 	ldr.w	sl, [sp, #28]
	configASSERT( pxNetworkBuffer );
 80048a6:	f1ba 0f00 	cmp.w	sl, #0
 80048aa:	d014      	beq.n	80048d6 <prvIPTask+0x156>
	eReturned = ipCONSIDER_FRAME_FOR_PROCESSING( pxNetworkBuffer->pucEthernetBuffer );
 80048ac:	2301      	movs	r3, #1
 80048ae:	f88d 300f 	strb.w	r3, [sp, #15]
	if( eReturned == eProcessBuffer )
 80048b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80048b6:	b2db      	uxtb	r3, r3
 80048b8:	2b01      	cmp	r3, #1
 80048ba:	d012      	beq.n	80048e2 <prvIPTask+0x162>
	switch( eReturned )
 80048bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80048c0:	b2db      	uxtb	r3, r3
 80048c2:	2b02      	cmp	r3, #2
 80048c4:	f000 8106 	beq.w	8004ad4 <prvIPTask+0x354>
 80048c8:	2b03      	cmp	r3, #3
 80048ca:	f000 810a 	beq.w	8004ae2 <prvIPTask+0x362>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80048ce:	4650      	mov	r0, sl
 80048d0:	f003 fe00 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
 80048d4:	e105      	b.n	8004ae2 <prvIPTask+0x362>
	configASSERT( pxNetworkBuffer );
 80048d6:	f240 516d 	movw	r1, #1389	; 0x56d
 80048da:	4875      	ldr	r0, [pc, #468]	; (8004ab0 <prvIPTask+0x330>)
 80048dc:	f007 fd40 	bl	800c360 <vAssertCalled>
 80048e0:	e7e4      	b.n	80048ac <prvIPTask+0x12c>
	pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80048e2:	f8da b018 	ldr.w	fp, [sl, #24]
		switch( pxEthernetHeader->usFrameType )
 80048e6:	f8bb 300c 	ldrh.w	r3, [fp, #12]
 80048ea:	2b08      	cmp	r3, #8
 80048ec:	d009      	beq.n	8004902 <prvIPTask+0x182>
 80048ee:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
 80048f2:	f040 80eb 	bne.w	8004acc <prvIPTask+0x34c>
				eReturned = eARPProcessPacket( ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80048f6:	4658      	mov	r0, fp
 80048f8:	f7fe fd68 	bl	80033cc <eARPProcessPacket>
 80048fc:	f88d 000f 	strb.w	r0, [sp, #15]
 8004900:	e7dc      	b.n	80048bc <prvIPTask+0x13c>
			if( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U )
 8004902:	f8bb 3014 	ldrh.w	r3, [fp, #20]
 8004906:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800490a:	b29b      	uxth	r3, r3
 800490c:	2b00      	cmp	r3, #0
 800490e:	f040 80b7 	bne.w	8004a80 <prvIPTask+0x300>
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0x0Fu ) << 2 );
 8004912:	f89b 300e 	ldrb.w	r3, [fp, #14]
			else if( ( pxIPHeader->ucVersionHeaderLength < 0x45u ) || ( pxIPHeader->ucVersionHeaderLength > 0x4Fu ) )
 8004916:	f1a3 0245 	sub.w	r2, r3, #69	; 0x45
 800491a:	b2d2      	uxtb	r2, r2
 800491c:	2a0a      	cmp	r2, #10
 800491e:	f200 80b3 	bhi.w	8004a88 <prvIPTask+0x308>
		uint32_t ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;
 8004922:	f8db 201e 	ldr.w	r2, [fp, #30]
			else if( ( ulDestinationIPAddress != *ipLOCAL_IP_ADDRESS_POINTER ) &&
 8004926:	4963      	ldr	r1, [pc, #396]	; (8004ab4 <prvIPTask+0x334>)
 8004928:	6949      	ldr	r1, [r1, #20]
 800492a:	428a      	cmp	r2, r1
 800492c:	d00c      	beq.n	8004948 <prvIPTask+0x1c8>
 800492e:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
 8004932:	d009      	beq.n	8004948 <prvIPTask+0x1c8>
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 8004934:	4860      	ldr	r0, [pc, #384]	; (8004ab8 <prvIPTask+0x338>)
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
 8004936:	6900      	ldr	r0, [r0, #16]
 8004938:	4282      	cmp	r2, r0
 800493a:	d005      	beq.n	8004948 <prvIPTask+0x1c8>
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 800493c:	485f      	ldr	r0, [pc, #380]	; (8004abc <prvIPTask+0x33c>)
 800493e:	4282      	cmp	r2, r0
 8004940:	d002      	beq.n	8004948 <prvIPTask+0x1c8>
	if( eReturn == eProcessBuffer )
 8004942:	2900      	cmp	r1, #0
 8004944:	f040 80a2 	bne.w	8004a8c <prvIPTask+0x30c>
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0x0Fu ) << 2 );
 8004948:	009b      	lsls	r3, r3, #2
 800494a:	f003 033c 	and.w	r3, r3, #60	; 0x3c
	ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
 800494e:	f89b 2017 	ldrb.w	r2, [fp, #23]
 8004952:	9200      	str	r2, [sp, #0]
		if( uxHeaderLength > ipSIZE_OF_IPv4_HEADER )
 8004954:	2b14      	cmp	r3, #20
 8004956:	d818      	bhi.n	800498a <prvIPTask+0x20a>
		if( ucProtocol != ( uint8_t ) ipPROTOCOL_UDP )
 8004958:	9b00      	ldr	r3, [sp, #0]
 800495a:	2b11      	cmp	r3, #17
 800495c:	d06a      	beq.n	8004a34 <prvIPTask+0x2b4>
			vARPRefreshCacheEntry( &( pxIPPacket->xEthernetHeader.xSourceAddress ), pxIPHeader->ulSourceIPAddress );
 800495e:	f8db 101a 	ldr.w	r1, [fp, #26]
 8004962:	f10b 0006 	add.w	r0, fp, #6
 8004966:	f7fe fc99 	bl	800329c <vARPRefreshCacheEntry>
		switch( ucProtocol )
 800496a:	9b00      	ldr	r3, [sp, #0]
 800496c:	2b06      	cmp	r3, #6
 800496e:	d07b      	beq.n	8004a68 <prvIPTask+0x2e8>
 8004970:	2b11      	cmp	r3, #17
 8004972:	d05f      	beq.n	8004a34 <prvIPTask+0x2b4>
 8004974:	2b01      	cmp	r3, #1
 8004976:	f040 808b 	bne.w	8004a90 <prvIPTask+0x310>
					if( pxIPHeader->ulDestinationIPAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 800497a:	f8db 301e 	ldr.w	r3, [fp, #30]
 800497e:	4a4d      	ldr	r2, [pc, #308]	; (8004ab4 <prvIPTask+0x334>)
 8004980:	6952      	ldr	r2, [r2, #20]
 8004982:	4293      	cmp	r3, r2
 8004984:	d017      	beq.n	80049b6 <prvIPTask+0x236>
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8004986:	2301      	movs	r3, #1
 8004988:	e07b      	b.n	8004a82 <prvIPTask+0x302>
			const size_t optlen = ( ( size_t ) uxHeaderLength ) - ipSIZE_OF_IPv4_HEADER;
 800498a:	f1a3 0214 	sub.w	r2, r3, #20
 800498e:	4610      	mov	r0, r2
			const size_t  xMoveLen = pxNetworkBuffer->xDataLength - optlen - ipSIZE_OF_IPv4_HEADER - ipSIZE_OF_ETH_HEADER;
 8004990:	f8da 201c 	ldr.w	r2, [sl, #28]
 8004994:	3a22      	subs	r2, #34	; 0x22
const IPHeader_t * pxIPHeader = &( pxIPPacket->xIPHeader );
 8004996:	f10b 010e 	add.w	r1, fp, #14
			memmove( pucTarget, pucSource, xMoveLen );
 800499a:	9001      	str	r0, [sp, #4]
 800499c:	1a12      	subs	r2, r2, r0
 800499e:	4419      	add	r1, r3
 80049a0:	f10b 0022 	add.w	r0, fp, #34	; 0x22
 80049a4:	f007 fea2 	bl	800c6ec <memmove>
			pxNetworkBuffer->xDataLength -= optlen;
 80049a8:	f8da 301c 	ldr.w	r3, [sl, #28]
 80049ac:	9a01      	ldr	r2, [sp, #4]
 80049ae:	1a9b      	subs	r3, r3, r2
 80049b0:	f8ca 301c 	str.w	r3, [sl, #28]
 80049b4:	e7d0      	b.n	8004958 <prvIPTask+0x1d8>
					ICMPPacket_t *pxICMPPacket = ( ICMPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80049b6:	f8da 2018 	ldr.w	r2, [sl, #24]
		switch( pxICMPPacket->xICMPHeader.ucTypeOfMessage )
 80049ba:	f892 1022 	ldrb.w	r1, [r2, #34]	; 0x22
 80049be:	b1b1      	cbz	r1, 80049ee <prvIPTask+0x26e>
 80049c0:	2908      	cmp	r1, #8
 80049c2:	f040 8081 	bne.w	8004ac8 <prvIPTask+0x348>
		pxICMPHeader->ucTypeOfMessage = ( uint8_t ) ipICMP_ECHO_REPLY;
 80049c6:	2100      	movs	r1, #0
 80049c8:	f882 1022 	strb.w	r1, [r2, #34]	; 0x22
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 80049cc:	f8d2 101a 	ldr.w	r1, [r2, #26]
 80049d0:	f8c2 101e 	str.w	r1, [r2, #30]
		pxIPHeader->ulSourceIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 80049d4:	f8c2 301a 	str.w	r3, [r2, #26]
		if( pxICMPHeader->usChecksum >= FreeRTOS_htons( 0xFFFFu - usRequest ) )
 80049d8:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 80049da:	f64f 71f6 	movw	r1, #65526	; 0xfff6
 80049de:	428b      	cmp	r3, r1
			pxICMPHeader->usChecksum = ( uint16_t )
 80049e0:	bf8c      	ite	hi
 80049e2:	f503 7384 	addhi.w	r3, r3, #264	; 0x108
			pxICMPHeader->usChecksum = ( uint16_t )
 80049e6:	3308      	addls	r3, #8
 80049e8:	8493      	strh	r3, [r2, #36]	; 0x24
					eReturn = prvProcessICMPEchoRequest( pxICMPPacket );
 80049ea:	2302      	movs	r3, #2
 80049ec:	e049      	b.n	8004a82 <prvIPTask+0x302>
		usDataLength = pxICMPPacket->xIPHeader.usLength;
 80049ee:	8a11      	ldrh	r1, [r2, #16]
		usDataLength = FreeRTOS_ntohs( usDataLength );
 80049f0:	0a0b      	lsrs	r3, r1, #8
 80049f2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80049f6:	b29b      	uxth	r3, r3
		pucByte += sizeof( ICMPPacket_t );
 80049f8:	f102 012a 	add.w	r1, r2, #42	; 0x2a
		for( usCount = 0; usCount < usDataLength; usCount++ )
 80049fc:	2b1c      	cmp	r3, #28
 80049fe:	d015      	beq.n	8004a2c <prvIPTask+0x2ac>
			if( *pucByte != ipECHO_DATA_FILL_BYTE )
 8004a00:	f892 002a 	ldrb.w	r0, [r2, #42]	; 0x2a
 8004a04:	2878      	cmp	r0, #120	; 0x78
 8004a06:	d113      	bne.n	8004a30 <prvIPTask+0x2b0>
 8004a08:	3b1d      	subs	r3, #29
 8004a0a:	b29b      	uxth	r3, r3
 8004a0c:	332a      	adds	r3, #42	; 0x2a
 8004a0e:	4413      	add	r3, r2
		for( usCount = 0; usCount < usDataLength; usCount++ )
 8004a10:	428b      	cmp	r3, r1
 8004a12:	d005      	beq.n	8004a20 <prvIPTask+0x2a0>
			if( *pucByte != ipECHO_DATA_FILL_BYTE )
 8004a14:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8004a18:	2878      	cmp	r0, #120	; 0x78
 8004a1a:	d0f9      	beq.n	8004a10 <prvIPTask+0x290>
				eStatus = eInvalidData;
 8004a1c:	2002      	movs	r0, #2
 8004a1e:	e000      	b.n	8004a22 <prvIPTask+0x2a2>
	ePingReplyStatus_t eStatus = eSuccess;
 8004a20:	2000      	movs	r0, #0
		vApplicationPingReplyHook( eStatus, pxICMPPacket->xICMPHeader.usIdentifier );
 8004a22:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
 8004a24:	f007 fd8c 	bl	800c540 <vApplicationPingReplyHook>
	eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8004a28:	2300      	movs	r3, #0
 8004a2a:	e02a      	b.n	8004a82 <prvIPTask+0x302>
	ePingReplyStatus_t eStatus = eSuccess;
 8004a2c:	2000      	movs	r0, #0
 8004a2e:	e7f8      	b.n	8004a22 <prvIPTask+0x2a2>
				eStatus = eInvalidData;
 8004a30:	2002      	movs	r0, #2
 8004a32:	e7f6      	b.n	8004a22 <prvIPTask+0x2a2>
					UDPPacket_t *pxUDPPacket = ( UDPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8004a34:	f8da 2018 	ldr.w	r2, [sl, #24]
					pxNetworkBuffer->xDataLength = FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usLength ) - sizeof( UDPHeader_t );
 8004a38:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
 8004a3a:	0a0b      	lsrs	r3, r1, #8
 8004a3c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8004a40:	b29b      	uxth	r3, r3
 8004a42:	3b08      	subs	r3, #8
 8004a44:	f8ca 301c 	str.w	r3, [sl, #28]
					pxNetworkBuffer->usPort = pxUDPPacket->xUDPHeader.usSourcePort;
 8004a48:	8c53      	ldrh	r3, [r2, #34]	; 0x22
 8004a4a:	f8aa 3020 	strh.w	r3, [sl, #32]
					pxNetworkBuffer->ulIPAddress = pxUDPPacket->xIPHeader.ulSourceIPAddress;
 8004a4e:	f8d2 301a 	ldr.w	r3, [r2, #26]
 8004a52:	f8ca 3014 	str.w	r3, [sl, #20]
					if( xProcessReceivedUDPPacket( pxNetworkBuffer, pxUDPPacket->xUDPHeader.usDestinationPort ) == pdPASS )
 8004a56:	8c91      	ldrh	r1, [r2, #36]	; 0x24
 8004a58:	4650      	mov	r0, sl
 8004a5a:	f003 fc99 	bl	8008390 <xProcessReceivedUDPPacket>
						eReturn = eFrameConsumed;
 8004a5e:	2801      	cmp	r0, #1
 8004a60:	bf14      	ite	ne
 8004a62:	2301      	movne	r3, #1
 8004a64:	2303      	moveq	r3, #3
 8004a66:	e00c      	b.n	8004a82 <prvIPTask+0x302>
					if( xProcessReceivedTCPPacket( pxNetworkBuffer ) == pdPASS )
 8004a68:	4650      	mov	r0, sl
 8004a6a:	f002 fa9b 	bl	8006fa4 <xProcessReceivedTCPPacket>
						eReturn = eFrameConsumed;
 8004a6e:	2801      	cmp	r0, #1
 8004a70:	bf14      	ite	ne
 8004a72:	2301      	movne	r3, #1
 8004a74:	2303      	moveq	r3, #3
					xProcessedTCPMessage++;
 8004a76:	490b      	ldr	r1, [pc, #44]	; (8004aa4 <prvIPTask+0x324>)
 8004a78:	680a      	ldr	r2, [r1, #0]
 8004a7a:	3201      	adds	r2, #1
 8004a7c:	600a      	str	r2, [r1, #0]
 8004a7e:	e000      	b.n	8004a82 <prvIPTask+0x302>
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8004a80:	2300      	movs	r3, #0
				eReturned = prvProcessIPPacket( ( IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer );
 8004a82:	f88d 300f 	strb.w	r3, [sp, #15]
 8004a86:	e719      	b.n	80048bc <prvIPTask+0x13c>
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8004a88:	2300      	movs	r3, #0
 8004a8a:	e7fa      	b.n	8004a82 <prvIPTask+0x302>
 8004a8c:	2300      	movs	r3, #0
 8004a8e:	e7f8      	b.n	8004a82 <prvIPTask+0x302>
 8004a90:	2301      	movs	r3, #1
 8004a92:	e7f6      	b.n	8004a82 <prvIPTask+0x302>
 8004a94:	20000558 	.word	0x20000558
 8004a98:	2000052c 	.word	0x2000052c
 8004a9c:	200004d4 	.word	0x200004d4
 8004aa0:	20000548 	.word	0x20000548
 8004aa4:	20000550 	.word	0x20000550
 8004aa8:	2000054c 	.word	0x2000054c
 8004aac:	200004e8 	.word	0x200004e8
 8004ab0:	0800cb18 	.word	0x0800cb18
 8004ab4:	20000010 	.word	0x20000010
 8004ab8:	20000530 	.word	0x20000530
 8004abc:	fc0000e0 	.word	0xfc0000e0
 8004ac0:	200004ec 	.word	0x200004ec
 8004ac4:	20000554 	.word	0x20000554
	eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8004ac8:	2300      	movs	r3, #0
 8004aca:	e7da      	b.n	8004a82 <prvIPTask+0x302>
				eReturned = eReleaseBuffer;
 8004acc:	2300      	movs	r3, #0
 8004ace:	f88d 300f 	strb.w	r3, [sp, #15]
 8004ad2:	e6f3      	b.n	80048bc <prvIPTask+0x13c>
			vReturnEthernetFrame( pxNetworkBuffer, pdTRUE );
 8004ad4:	2101      	movs	r1, #1
 8004ad6:	4650      	mov	r0, sl
 8004ad8:	f7ff fe3c 	bl	8004754 <vReturnEthernetFrame>
 8004adc:	e001      	b.n	8004ae2 <prvIPTask+0x362>
				vARPAgeCache();
 8004ade:	f7fe fd69 	bl	80035b4 <vARPAgeCache>
		if( xNetworkDownEventPending != pdFALSE )
 8004ae2:	4b48      	ldr	r3, [pc, #288]	; (8004c04 <prvIPTask+0x484>)
 8004ae4:	681b      	ldr	r3, [r3, #0]
 8004ae6:	2b00      	cmp	r3, #0
 8004ae8:	f040 8086 	bne.w	8004bf8 <prvIPTask+0x478>
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 8004aec:	4628      	mov	r0, r5
 8004aee:	f7ff fc58 	bl	80043a2 <prvIPTimerCheck>
 8004af2:	2800      	cmp	r0, #0
 8004af4:	f47f ae59 	bne.w	80047aa <prvIPTask+0x2a>
		if( prvIPTimerCheck( &xDHCPTimer ) != pdFALSE )
 8004af8:	4640      	mov	r0, r8
 8004afa:	f7ff fc52 	bl	80043a2 <prvIPTimerCheck>
 8004afe:	2800      	cmp	r0, #0
 8004b00:	f47f ae57 	bne.w	80047b2 <prvIPTask+0x32>
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 8004b04:	4630      	mov	r0, r6
 8004b06:	f7ff fc4c 	bl	80043a2 <prvIPTimerCheck>
 8004b0a:	2800      	cmp	r0, #0
 8004b0c:	f47f ae55 	bne.w	80047ba <prvIPTask+0x3a>
		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0u )
 8004b10:	6820      	ldr	r0, [r4, #0]
 8004b12:	f004 ffdf 	bl	8009ad4 <uxQueueMessagesWaiting>
 8004b16:	4682      	mov	sl, r0
		xTimeNow = xTaskGetTickCount();
 8004b18:	f005 fa8a 	bl	800a030 <xTaskGetTickCount>
		if( xStart != ( TickType_t ) 0 )
 8004b1c:	f8d9 3000 	ldr.w	r3, [r9]
 8004b20:	b12b      	cbz	r3, 8004b2e <prvIPTask+0x3ae>
			ulNextInitialSequenceNumber += ipINITIAL_SEQUENCE_NUMBER_FACTOR * ( ( xTimeNow - xStart ) * portTICK_PERIOD_MS );
 8004b22:	4939      	ldr	r1, [pc, #228]	; (8004c08 <prvIPTask+0x488>)
 8004b24:	1ac3      	subs	r3, r0, r3
 8004b26:	680a      	ldr	r2, [r1, #0]
 8004b28:	eb02 2303 	add.w	r3, r2, r3, lsl #8
 8004b2c:	600b      	str	r3, [r1, #0]
		xStart = xTimeNow;
 8004b2e:	f8c9 0000 	str.w	r0, [r9]
		xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
 8004b32:	4638      	mov	r0, r7
 8004b34:	f7ff fc35 	bl	80043a2 <prvIPTimerCheck>
		if( ( xProcessedTCPMessage != pdFALSE ) && ( xWillSleep != pdFALSE ) )
 8004b38:	4b34      	ldr	r3, [pc, #208]	; (8004c0c <prvIPTask+0x48c>)
 8004b3a:	681b      	ldr	r3, [r3, #0]
 8004b3c:	b11b      	cbz	r3, 8004b46 <prvIPTask+0x3c6>
 8004b3e:	f1ba 0f00 	cmp.w	sl, #0
 8004b42:	f43f ae3e 	beq.w	80047c2 <prvIPTask+0x42>
		if( xCheckTCPSockets != pdFALSE )
 8004b46:	2800      	cmp	r0, #0
 8004b48:	f47f ae3b 	bne.w	80047c2 <prvIPTask+0x42>
	if( xARPTimer.bActive != pdFALSE_UNSIGNED )
 8004b4c:	782b      	ldrb	r3, [r5, #0]
 8004b4e:	f013 0f01 	tst.w	r3, #1
 8004b52:	f43f ae43 	beq.w	80047dc <prvIPTask+0x5c>
		if( xARPTimer.ulRemainingTime < xMaximumSleepTime )
 8004b56:	68ea      	ldr	r2, [r5, #12]
 8004b58:	f242 730f 	movw	r3, #9999	; 0x270f
 8004b5c:	429a      	cmp	r2, r3
 8004b5e:	f63f ae79 	bhi.w	8004854 <prvIPTask+0xd4>
			xMaximumSleepTime = xARPTimer.ulReloadTime;
 8004b62:	692a      	ldr	r2, [r5, #16]
 8004b64:	e63c      	b.n	80047e0 <prvIPTask+0x60>
				pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
 8004b66:	f8dd a01c 	ldr.w	sl, [sp, #28]
				xAddress.sin_addr = 0u;	/* For the moment. */
 8004b6a:	2300      	movs	r3, #0
 8004b6c:	9305      	str	r3, [sp, #20]
				xAddress.sin_port = FreeRTOS_ntohs( pxSocket->usLocalPort );
 8004b6e:	f8ba 1024 	ldrh.w	r1, [sl, #36]	; 0x24
 8004b72:	0a0a      	lsrs	r2, r1, #8
 8004b74:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8004b78:	f8ad 2012 	strh.w	r2, [sp, #18]
				pxSocket->usLocalPort = 0u;
 8004b7c:	f8aa 3024 	strh.w	r3, [sl, #36]	; 0x24
				vSocketBind( pxSocket, &xAddress, sizeof( xAddress ), pdFALSE );
 8004b80:	2208      	movs	r2, #8
 8004b82:	a904      	add	r1, sp, #16
 8004b84:	4650      	mov	r0, sl
 8004b86:	f000 fac7 	bl	8005118 <vSocketBind>
				pxSocket->xEventBits |= eSOCKET_BOUND;
 8004b8a:	f8da 3000 	ldr.w	r3, [sl]
 8004b8e:	f043 0310 	orr.w	r3, r3, #16
 8004b92:	f8ca 3000 	str.w	r3, [sl]
				vSocketWakeUpUser( pxSocket );
 8004b96:	4650      	mov	r0, sl
 8004b98:	f000 fc18 	bl	80053cc <vSocketWakeUpUser>
				break;
 8004b9c:	e7a1      	b.n	8004ae2 <prvIPTask+0x362>
				vSocketClose( ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData ) );
 8004b9e:	9807      	ldr	r0, [sp, #28]
 8004ba0:	f000 fb56 	bl	8005250 <vSocketClose>
				break;
 8004ba4:	e79d      	b.n	8004ae2 <prvIPTask+0x362>
				vProcessGeneratedUDPPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
 8004ba6:	9807      	ldr	r0, [sp, #28]
 8004ba8:	f003 fb8a 	bl	80082c0 <vProcessGeneratedUDPPacket>
				break;
 8004bac:	e799      	b.n	8004ae2 <prvIPTask+0x362>
					vDHCPProcess( pdFALSE );
 8004bae:	2000      	movs	r0, #0
 8004bb0:	f7fe ff80 	bl	8003ab4 <vDHCPProcess>
				break;
 8004bb4:	e795      	b.n	8004ae2 <prvIPTask+0x362>
					vSocketSelect( ( SocketSelect_t * ) ( xReceivedEvent.pvData ) );
 8004bb6:	9807      	ldr	r0, [sp, #28]
 8004bb8:	f001 fa62 	bl	8006080 <vSocketSelect>
				break;
 8004bbc:	e791      	b.n	8004ae2 <prvIPTask+0x362>
					FreeRTOS_SignalSocket( ( Socket_t ) xReceivedEvent.pvData );
 8004bbe:	9807      	ldr	r0, [sp, #28]
 8004bc0:	f001 fb12 	bl	80061e8 <FreeRTOS_SignalSocket>
				break;
 8004bc4:	e78d      	b.n	8004ae2 <prvIPTask+0x362>
					xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 8004bc6:	783b      	ldrb	r3, [r7, #0]
 8004bc8:	f043 0302 	orr.w	r3, r3, #2
 8004bcc:	703b      	strb	r3, [r7, #0]
				break;
 8004bce:	e788      	b.n	8004ae2 <prvIPTask+0x362>
					pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
 8004bd0:	f8dd a01c 	ldr.w	sl, [sp, #28]
					if( xTCPCheckNewClient( pxSocket ) != pdFALSE )
 8004bd4:	4650      	mov	r0, sl
 8004bd6:	f002 ff43 	bl	8007a60 <xTCPCheckNewClient>
 8004bda:	2800      	cmp	r0, #0
 8004bdc:	d081      	beq.n	8004ae2 <prvIPTask+0x362>
						pxSocket->xEventBits |= eSOCKET_ACCEPT;
 8004bde:	f8da 3000 	ldr.w	r3, [sl]
 8004be2:	f043 0304 	orr.w	r3, r3, #4
 8004be6:	f8ca 3000 	str.w	r3, [sl]
						vSocketWakeUpUser( pxSocket );
 8004bea:	4650      	mov	r0, sl
 8004bec:	f000 fbee 	bl	80053cc <vSocketWakeUpUser>
 8004bf0:	e777      	b.n	8004ae2 <prvIPTask+0x362>
					vTCPNetStat();
 8004bf2:	f001 f9ad 	bl	8005f50 <vTCPNetStat>
				break;
 8004bf6:	e774      	b.n	8004ae2 <prvIPTask+0x362>
			FreeRTOS_NetworkDown();
 8004bf8:	f7ff fd2e 	bl	8004658 <FreeRTOS_NetworkDown>
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 8004bfc:	4e04      	ldr	r6, [pc, #16]	; (8004c10 <prvIPTask+0x490>)
		xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
 8004bfe:	4f05      	ldr	r7, [pc, #20]	; (8004c14 <prvIPTask+0x494>)
 8004c00:	e774      	b.n	8004aec <prvIPTask+0x36c>
 8004c02:	bf00      	nop
 8004c04:	20000544 	.word	0x20000544
 8004c08:	20000574 	.word	0x20000574
 8004c0c:	20000550 	.word	0x20000550
 8004c10:	20000500 	.word	0x20000500
 8004c14:	20000558 	.word	0x20000558

08004c18 <FreeRTOS_GetIPAddress>:
}
 8004c18:	4b01      	ldr	r3, [pc, #4]	; (8004c20 <FreeRTOS_GetIPAddress+0x8>)
 8004c1a:	6958      	ldr	r0, [r3, #20]
 8004c1c:	4770      	bx	lr
 8004c1e:	bf00      	nop
 8004c20:	20000010 	.word	0x20000010

08004c24 <vIPSetDHCPTimerEnableState>:
		if( xEnableState != pdFALSE )
 8004c24:	b928      	cbnz	r0, 8004c32 <vIPSetDHCPTimerEnableState+0xe>
			xDHCPTimer.bActive = pdFALSE_UNSIGNED;
 8004c26:	4b06      	ldr	r3, [pc, #24]	; (8004c40 <vIPSetDHCPTimerEnableState+0x1c>)
 8004c28:	781a      	ldrb	r2, [r3, #0]
 8004c2a:	f36f 0200 	bfc	r2, #0, #1
 8004c2e:	701a      	strb	r2, [r3, #0]
 8004c30:	4770      	bx	lr
			xDHCPTimer.bActive = pdTRUE_UNSIGNED;
 8004c32:	4a03      	ldr	r2, [pc, #12]	; (8004c40 <vIPSetDHCPTimerEnableState+0x1c>)
 8004c34:	7813      	ldrb	r3, [r2, #0]
 8004c36:	f043 0301 	orr.w	r3, r3, #1
 8004c3a:	7013      	strb	r3, [r2, #0]
 8004c3c:	4770      	bx	lr
 8004c3e:	bf00      	nop
 8004c40:	200004ec 	.word	0x200004ec

08004c44 <vIPReloadDHCPTimer>:
	{
 8004c44:	b508      	push	{r3, lr}
 8004c46:	4601      	mov	r1, r0
	pxTimer->ulReloadTime = xTime;
 8004c48:	4802      	ldr	r0, [pc, #8]	; (8004c54 <vIPReloadDHCPTimer+0x10>)
 8004c4a:	6101      	str	r1, [r0, #16]
	prvIPTimerStart( pxTimer, xTime );
 8004c4c:	f7ff fb93 	bl	8004376 <prvIPTimerStart>
 8004c50:	bd08      	pop	{r3, pc}
 8004c52:	bf00      	nop
 8004c54:	200004ec 	.word	0x200004ec

08004c58 <vIPSetDnsTimerEnableState>:
		if( xEnableState != 0 )
 8004c58:	b928      	cbnz	r0, 8004c66 <vIPSetDnsTimerEnableState+0xe>
			xDNSTimer.bActive = pdFALSE;
 8004c5a:	4b06      	ldr	r3, [pc, #24]	; (8004c74 <vIPSetDnsTimerEnableState+0x1c>)
 8004c5c:	781a      	ldrb	r2, [r3, #0]
 8004c5e:	f36f 0200 	bfc	r2, #0, #1
 8004c62:	701a      	strb	r2, [r3, #0]
 8004c64:	4770      	bx	lr
			xDNSTimer.bActive = pdTRUE;
 8004c66:	4a03      	ldr	r2, [pc, #12]	; (8004c74 <vIPSetDnsTimerEnableState+0x1c>)
 8004c68:	7813      	ldrb	r3, [r2, #0]
 8004c6a:	f043 0301 	orr.w	r3, r3, #1
 8004c6e:	7013      	strb	r3, [r2, #0]
 8004c70:	4770      	bx	lr
 8004c72:	bf00      	nop
 8004c74:	20000500 	.word	0x20000500

08004c78 <vIPReloadDNSTimer>:
	{
 8004c78:	b508      	push	{r3, lr}
 8004c7a:	4601      	mov	r1, r0
	pxTimer->ulReloadTime = xTime;
 8004c7c:	4802      	ldr	r0, [pc, #8]	; (8004c88 <vIPReloadDNSTimer+0x10>)
 8004c7e:	6101      	str	r1, [r0, #16]
	prvIPTimerStart( pxTimer, xTime );
 8004c80:	f7ff fb79 	bl	8004376 <prvIPTimerStart>
 8004c84:	bd08      	pop	{r3, pc}
 8004c86:	bf00      	nop
 8004c88:	20000500 	.word	0x20000500

08004c8c <xIPIsNetworkTaskReady>:
}
 8004c8c:	4b01      	ldr	r3, [pc, #4]	; (8004c94 <xIPIsNetworkTaskReady+0x8>)
 8004c8e:	6818      	ldr	r0, [r3, #0]
 8004c90:	4770      	bx	lr
 8004c92:	bf00      	nop
 8004c94:	2000052c 	.word	0x2000052c

08004c98 <prvValidSocket>:

static BaseType_t prvValidSocket( FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound )
{
BaseType_t xReturn = pdTRUE;

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8004c98:	1e43      	subs	r3, r0, #1
 8004c9a:	f113 0f03 	cmn.w	r3, #3
 8004c9e:	d80a      	bhi.n	8004cb6 <prvValidSocket+0x1e>
	{
		xReturn = pdFALSE;
	}
	else if( ( xIsBound != pdFALSE ) && ( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE ) )
 8004ca0:	b10a      	cbz	r2, 8004ca6 <prvValidSocket+0xe>
 8004ca2:	6983      	ldr	r3, [r0, #24]
 8004ca4:	b14b      	cbz	r3, 8004cba <prvValidSocket+0x22>
	{
		/* The caller expects the socket to be bound, but it isn't. */
		xReturn = pdFALSE;
	}
	else if( pxSocket->ucProtocol != ( uint8_t ) xProtocol )
 8004ca6:	f890 0027 	ldrb.w	r0, [r0, #39]	; 0x27
 8004caa:	b2c9      	uxtb	r1, r1
 8004cac:	4288      	cmp	r0, r1
 8004cae:	bf14      	ite	ne
 8004cb0:	2000      	movne	r0, #0
 8004cb2:	2001      	moveq	r0, #1
 8004cb4:	4770      	bx	lr
		xReturn = pdFALSE;
 8004cb6:	2000      	movs	r0, #0
 8004cb8:	4770      	bx	lr
		xReturn = pdFALSE;
 8004cba:	2000      	movs	r0, #0
		/* Socket has a wrong type (UDP != TCP). */
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8004cbc:	4770      	bx	lr

08004cbe <pxListFindListItemWithValue>:
/*-----------------------------------------------------------*/

/* pxListFindListItemWithValue: find a list item in a bound socket list
'xWantedItemValue' refers to a port number */
static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItemValue )
{
 8004cbe:	b538      	push	{r3, r4, r5, lr}
 8004cc0:	4605      	mov	r5, r0
 8004cc2:	460c      	mov	r4, r1
const ListItem_t * pxResult = NULL;

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
 8004cc4:	f7ff ffe2 	bl	8004c8c <xIPIsNetworkTaskReady>
 8004cc8:	b190      	cbz	r0, 8004cf0 <pxListFindListItemWithValue+0x32>
 8004cca:	b19d      	cbz	r5, 8004cf4 <pxListFindListItemWithValue+0x36>
	{
		const ListItem_t *pxIterator;
		const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( pxList );
 8004ccc:	f105 0208 	add.w	r2, r5, #8
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8004cd0:	68e8      	ldr	r0, [r5, #12]
 8004cd2:	4282      	cmp	r2, r0
 8004cd4:	d010      	beq.n	8004cf8 <pxListFindListItemWithValue+0x3a>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 8004cd6:	6803      	ldr	r3, [r0, #0]
 8004cd8:	429c      	cmp	r4, r3
 8004cda:	d006      	beq.n	8004cea <pxListFindListItemWithValue+0x2c>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8004cdc:	6840      	ldr	r0, [r0, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8004cde:	4282      	cmp	r2, r0
 8004ce0:	d004      	beq.n	8004cec <pxListFindListItemWithValue+0x2e>
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 8004ce2:	6803      	ldr	r3, [r0, #0]
 8004ce4:	42a3      	cmp	r3, r4
 8004ce6:	d1f9      	bne.n	8004cdc <pxListFindListItemWithValue+0x1e>
			}
		}
	}

	return pxResult;
} /* Tested */
 8004ce8:	bd38      	pop	{r3, r4, r5, pc}
 8004cea:	bd38      	pop	{r3, r4, r5, pc}
const ListItem_t * pxResult = NULL;
 8004cec:	2000      	movs	r0, #0
 8004cee:	bd38      	pop	{r3, r4, r5, pc}
 8004cf0:	2000      	movs	r0, #0
 8004cf2:	bd38      	pop	{r3, r4, r5, pc}
 8004cf4:	2000      	movs	r0, #0
 8004cf6:	bd38      	pop	{r3, r4, r5, pc}
 8004cf8:	2000      	movs	r0, #0
	return pxResult;
 8004cfa:	e7f5      	b.n	8004ce8 <pxListFindListItemWithValue+0x2a>

08004cfc <vNetworkSocketsInit>:
{
 8004cfc:	b538      	push	{r3, r4, r5, lr}
	vListInitialise( &xBoundUDPSocketsList );
 8004cfe:	4812      	ldr	r0, [pc, #72]	; (8004d48 <vNetworkSocketsInit+0x4c>)
 8004d00:	f004 f8a4 	bl	8008e4c <vListInitialise>
	ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 8004d04:	f007 fbf2 	bl	800c4ec <uxRand>
	usNextPortToUse[ socketNEXT_UDP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 8004d08:	4c10      	ldr	r4, [pc, #64]	; (8004d4c <vNetworkSocketsInit+0x50>)
	ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 8004d0a:	0a43      	lsrs	r3, r0, #9
 8004d0c:	4d10      	ldr	r5, [pc, #64]	; (8004d50 <vNetworkSocketsInit+0x54>)
 8004d0e:	fba5 2303 	umull	r2, r3, r5, r3
 8004d12:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8004d16:	eba0 2043 	sub.w	r0, r0, r3, lsl #9
 8004d1a:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
	usNextPortToUse[ socketNEXT_UDP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 8004d1e:	8020      	strh	r0, [r4, #0]
		ulNextInitialSequenceNumber = ipconfigRAND32();
 8004d20:	f007 fbe4 	bl	800c4ec <uxRand>
 8004d24:	4b0b      	ldr	r3, [pc, #44]	; (8004d54 <vNetworkSocketsInit+0x58>)
 8004d26:	6018      	str	r0, [r3, #0]
		ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 8004d28:	f007 fbe0 	bl	800c4ec <uxRand>
 8004d2c:	0a43      	lsrs	r3, r0, #9
 8004d2e:	fba5 2303 	umull	r2, r3, r5, r3
 8004d32:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8004d36:	eba0 2043 	sub.w	r0, r0, r3, lsl #9
 8004d3a:	f500 4040 	add.w	r0, r0, #49152	; 0xc000
		usNextPortToUse[ socketNEXT_TCP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 8004d3e:	8060      	strh	r0, [r4, #2]
		vListInitialise( &xBoundTCPSocketsList );
 8004d40:	4805      	ldr	r0, [pc, #20]	; (8004d58 <vNetworkSocketsInit+0x5c>)
 8004d42:	f004 f883 	bl	8008e4c <vListInitialise>
 8004d46:	bd38      	pop	{r3, r4, r5, pc}
 8004d48:	20002850 	.word	0x20002850
 8004d4c:	2000056c 	.word	0x2000056c
 8004d50:	08421094 	.word	0x08421094
 8004d54:	20000574 	.word	0x20000574
 8004d58:	2000283c 	.word	0x2000283c

08004d5c <FreeRTOS_socket>:
{
 8004d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004d5e:	4606      	mov	r6, r0
 8004d60:	460c      	mov	r4, r1
 8004d62:	4615      	mov	r5, r2
	if( xIPIsNetworkTaskReady() == pdFALSE )
 8004d64:	f7ff ff92 	bl	8004c8c <xIPIsNetworkTaskReady>
 8004d68:	b1f0      	cbz	r0, 8004da8 <FreeRTOS_socket+0x4c>
		configASSERT( xDomain == FREERTOS_AF_INET );
 8004d6a:	2e02      	cmp	r6, #2
 8004d6c:	d004      	beq.n	8004d78 <FreeRTOS_socket+0x1c>
 8004d6e:	f44f 718c 	mov.w	r1, #280	; 0x118
 8004d72:	4843      	ldr	r0, [pc, #268]	; (8004e80 <FreeRTOS_socket+0x124>)
 8004d74:	f007 faf4 	bl	800c360 <vAssertCalled>
		configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
 8004d78:	4b42      	ldr	r3, [pc, #264]	; (8004e84 <FreeRTOS_socket+0x128>)
 8004d7a:	689b      	ldr	r3, [r3, #8]
 8004d7c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004d80:	d004      	beq.n	8004d8c <FreeRTOS_socket+0x30>
 8004d82:	f240 111b 	movw	r1, #283	; 0x11b
 8004d86:	483e      	ldr	r0, [pc, #248]	; (8004e80 <FreeRTOS_socket+0x124>)
 8004d88:	f007 faea 	bl	800c360 <vAssertCalled>
			configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
 8004d8c:	4b3e      	ldr	r3, [pc, #248]	; (8004e88 <FreeRTOS_socket+0x12c>)
 8004d8e:	689b      	ldr	r3, [r3, #8]
 8004d90:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004d94:	d004      	beq.n	8004da0 <FreeRTOS_socket+0x44>
 8004d96:	f240 111f 	movw	r1, #287	; 0x11f
 8004d9a:	4839      	ldr	r0, [pc, #228]	; (8004e80 <FreeRTOS_socket+0x124>)
 8004d9c:	f007 fae0 	bl	800c360 <vAssertCalled>
		if( xProtocol == FREERTOS_IPPROTO_UDP )
 8004da0:	2d11      	cmp	r5, #17
 8004da2:	d004      	beq.n	8004dae <FreeRTOS_socket+0x52>
		else if( xProtocol == FREERTOS_IPPROTO_TCP )
 8004da4:	2d06      	cmp	r5, #6
 8004da6:	d02c      	beq.n	8004e02 <FreeRTOS_socket+0xa6>
		xReturn = FREERTOS_INVALID_SOCKET;
 8004da8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8004dac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xType != FREERTOS_SOCK_DGRAM )
 8004dae:	2c02      	cmp	r4, #2
 8004db0:	bf14      	ite	ne
 8004db2:	2400      	movne	r4, #0
 8004db4:	2401      	moveq	r4, #1
			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
 8004db6:	264c      	movs	r6, #76	; 0x4c
	if( prvDetermineSocketSize( xDomain, xType, xProtocol, &uxSocketSize ) == pdFAIL )
 8004db8:	2c00      	cmp	r4, #0
 8004dba:	d05e      	beq.n	8004e7a <FreeRTOS_socket+0x11e>
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 8004dbc:	4630      	mov	r0, r6
 8004dbe:	f004 fa5b 	bl	8009278 <pvPortMalloc>
		if( pxSocket == NULL )
 8004dc2:	4604      	mov	r4, r0
 8004dc4:	b320      	cbz	r0, 8004e10 <FreeRTOS_socket+0xb4>
		else if( ( xEventGroup = xEventGroupCreate() ) == NULL )
 8004dc6:	f003 ff1f 	bl	8008c08 <xEventGroupCreate>
 8004dca:	4607      	mov	r7, r0
 8004dcc:	b338      	cbz	r0, 8004e1e <FreeRTOS_socket+0xc2>
			memset( pxSocket, '\0', uxSocketSize );
 8004dce:	4632      	mov	r2, r6
 8004dd0:	2100      	movs	r1, #0
 8004dd2:	4620      	mov	r0, r4
 8004dd4:	f007 fca4 	bl	800c720 <memset>
			pxSocket->xEventGroup = xEventGroup;
 8004dd8:	6067      	str	r7, [r4, #4]
			if( xProtocol == FREERTOS_IPPROTO_UDP )
 8004dda:	2d11      	cmp	r5, #17
 8004ddc:	d025      	beq.n	8004e2a <FreeRTOS_socket+0xce>
			vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 8004dde:	f104 0008 	add.w	r0, r4, #8
 8004de2:	f004 f83e 	bl	8008e62 <vListInitialiseItem>
			listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
 8004de6:	6164      	str	r4, [r4, #20]
			pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 8004de8:	f241 3388 	movw	r3, #5000	; 0x1388
 8004dec:	61e3      	str	r3, [r4, #28]
			pxSocket->xSendBlockTime    = ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 8004dee:	6223      	str	r3, [r4, #32]
			pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8004df0:	2302      	movs	r3, #2
 8004df2:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			pxSocket->ucProtocol        = ( uint8_t ) xProtocol; /* protocol: UDP or TCP */
 8004df6:	f884 5027 	strb.w	r5, [r4, #39]	; 0x27
				if( xProtocol == FREERTOS_IPPROTO_TCP )
 8004dfa:	2d06      	cmp	r5, #6
 8004dfc:	d02a      	beq.n	8004e54 <FreeRTOS_socket+0xf8>
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 8004dfe:	4620      	mov	r0, r4
	return xReturn;
 8004e00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xType != FREERTOS_SOCK_STREAM )
 8004e02:	2c01      	cmp	r4, #1
 8004e04:	bf14      	ite	ne
 8004e06:	2400      	movne	r4, #0
 8004e08:	2401      	moveq	r4, #1
			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
 8004e0a:	f44f 76d0 	mov.w	r6, #416	; 0x1a0
 8004e0e:	e7d3      	b.n	8004db8 <FreeRTOS_socket+0x5c>
			iptraceFAILED_TO_CREATE_SOCKET();
 8004e10:	2100      	movs	r1, #0
 8004e12:	2008      	movs	r0, #8
 8004e14:	f006 fd1c 	bl	800b850 <vExampleDebugStatUpdate>
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8004e18:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004e1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vPortFreeSocket( pxSocket );
 8004e1e:	4620      	mov	r0, r4
 8004e20:	f004 fa90 	bl	8009344 <vPortFree>
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8004e24:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004e28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8004e2a:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8004e2e:	f004 f80d 	bl	8008e4c <vListInitialise>
			vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 8004e32:	f104 0008 	add.w	r0, r4, #8
 8004e36:	f004 f814 	bl	8008e62 <vListInitialiseItem>
			listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
 8004e3a:	6164      	str	r4, [r4, #20]
			pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 8004e3c:	f241 3388 	movw	r3, #5000	; 0x1388
 8004e40:	61e3      	str	r3, [r4, #28]
			pxSocket->xSendBlockTime    = ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 8004e42:	6223      	str	r3, [r4, #32]
			pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8004e44:	2302      	movs	r3, #2
 8004e46:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			pxSocket->ucProtocol        = ( uint8_t ) xProtocol; /* protocol: UDP or TCP */
 8004e4a:	2311      	movs	r3, #17
 8004e4c:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 8004e50:	4620      	mov	r0, r4
 8004e52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					pxSocket->u.xTCP.usInitMSS    = pxSocket->u.xTCP.usCurMSS = ipconfigTCP_MSS;
 8004e54:	f240 53b4 	movw	r3, #1460	; 0x5b4
 8004e58:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
 8004e5c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
					pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 8004e60:	f241 131c 	movw	r3, #4380	; 0x111c
 8004e64:	66e3      	str	r3, [r4, #108]	; 0x6c
					pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH, ipconfigTCP_MSS );
 8004e66:	f640 3368 	movw	r3, #2920	; 0xb68
 8004e6a:	6723      	str	r3, [r4, #112]	; 0x70
						pxSocket->u.xTCP.uxRxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxRxStreamSize / 2 ) / ipconfigTCP_MSS );
 8004e6c:	2301      	movs	r3, #1
 8004e6e:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
						pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxTxStreamSize / 2 ) / ipconfigTCP_MSS );
 8004e72:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 8004e76:	4620      	mov	r0, r4
 8004e78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		xReturn = FREERTOS_INVALID_SOCKET;
 8004e7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004e7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004e80:	0800cb68 	.word	0x0800cb68
 8004e84:	20002850 	.word	0x20002850
 8004e88:	2000283c 	.word	0x2000283c

08004e8c <FreeRTOS_recvfrom>:
{
 8004e8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004e90:	b086      	sub	sp, #24
 8004e92:	4604      	mov	r4, r0
 8004e94:	4689      	mov	r9, r1
 8004e96:	4692      	mov	sl, r2
 8004e98:	4698      	mov	r8, r3
TickType_t xRemainingTime = ( TickType_t ) 0; /* Obsolete assignment, but some compilers output a warning if its not done. */
 8004e9a:	2300      	movs	r3, #0
 8004e9c:	9305      	str	r3, [sp, #20]
	if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_UDP, pdTRUE ) == pdFALSE )
 8004e9e:	2201      	movs	r2, #1
 8004ea0:	2111      	movs	r1, #17
 8004ea2:	f7ff fef9 	bl	8004c98 <prvValidSocket>
 8004ea6:	2800      	cmp	r0, #0
 8004ea8:	d05a      	beq.n	8004f60 <FreeRTOS_recvfrom+0xd4>
	lPacketCount = ( BaseType_t ) listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8004eaa:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	while( lPacketCount == 0 )
 8004eac:	2d00      	cmp	r5, #0
 8004eae:	d15a      	bne.n	8004f66 <FreeRTOS_recvfrom+0xda>
 8004eb0:	2300      	movs	r3, #0
			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8004eb2:	f008 0710 	and.w	r7, r8, #16
		xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_RECEIVE | eSOCKET_INTR,
 8004eb6:	461e      	mov	r6, r3
 8004eb8:	e025      	b.n	8004f06 <FreeRTOS_recvfrom+0x7a>
					xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_INTR,
 8004eba:	6860      	ldr	r0, [r4, #4]
 8004ebc:	9300      	str	r3, [sp, #0]
 8004ebe:	2201      	movs	r2, #1
 8004ec0:	2140      	movs	r1, #64	; 0x40
 8004ec2:	f003 feaf 	bl	8008c24 <xEventGroupWaitBits>
 8004ec6:	4605      	mov	r5, r0
	else if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004ec8:	f015 0f40 	tst.w	r5, #64	; 0x40
		lReturn = -pdFREERTOS_ERRNO_EINTR;
 8004ecc:	bf18      	it	ne
 8004ece:	f06f 0403 	mvnne.w	r4, #3
	else if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004ed2:	d03e      	beq.n	8004f52 <FreeRTOS_recvfrom+0xc6>
}
 8004ed4:	4620      	mov	r0, r4
 8004ed6:	b006      	add	sp, #24
 8004ed8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_RECEIVE | eSOCKET_INTR,
 8004edc:	9b05      	ldr	r3, [sp, #20]
 8004ede:	9300      	str	r3, [sp, #0]
 8004ee0:	4633      	mov	r3, r6
 8004ee2:	2201      	movs	r2, #1
 8004ee4:	2141      	movs	r1, #65	; 0x41
 8004ee6:	6860      	ldr	r0, [r4, #4]
 8004ee8:	f003 fe9c 	bl	8008c24 <xEventGroupWaitBits>
 8004eec:	4605      	mov	r5, r0
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8004eee:	f010 0f40 	tst.w	r0, #64	; 0x40
 8004ef2:	d114      	bne.n	8004f1e <FreeRTOS_recvfrom+0x92>
		if( lPacketCount != 0 )
 8004ef4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004ef6:	2b00      	cmp	r3, #0
 8004ef8:	d135      	bne.n	8004f66 <FreeRTOS_recvfrom+0xda>
		if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) )
 8004efa:	a905      	add	r1, sp, #20
 8004efc:	a803      	add	r0, sp, #12
 8004efe:	f005 fba1 	bl	800a644 <xTaskCheckForTimeOut>
 8004f02:	2301      	movs	r3, #1
 8004f04:	bb28      	cbnz	r0, 8004f52 <FreeRTOS_recvfrom+0xc6>
		if( xTimed == pdFALSE )
 8004f06:	2b00      	cmp	r3, #0
 8004f08:	d1e8      	bne.n	8004edc <FreeRTOS_recvfrom+0x50>
			xRemainingTime = pxSocket->xReceiveBlockTime;
 8004f0a:	69e3      	ldr	r3, [r4, #28]
 8004f0c:	9305      	str	r3, [sp, #20]
			if( xRemainingTime == ( TickType_t ) 0 )
 8004f0e:	2b00      	cmp	r3, #0
 8004f10:	d0d3      	beq.n	8004eba <FreeRTOS_recvfrom+0x2e>
			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8004f12:	2f00      	cmp	r7, #0
 8004f14:	d1d8      	bne.n	8004ec8 <FreeRTOS_recvfrom+0x3c>
			vTaskSetTimeOutState( &xTimeOut );
 8004f16:	a803      	add	r0, sp, #12
 8004f18:	f005 fb7e 	bl	800a618 <vTaskSetTimeOutState>
 8004f1c:	e7de      	b.n	8004edc <FreeRTOS_recvfrom+0x50>
				if( ( xEventBits & eSOCKET_RECEIVE ) != 0 )
 8004f1e:	f010 0f01 	tst.w	r0, #1
 8004f22:	d102      	bne.n	8004f2a <FreeRTOS_recvfrom+0x9e>
		lReturn = -pdFREERTOS_ERRNO_EINTR;
 8004f24:	f06f 0403 	mvn.w	r4, #3
 8004f28:	e7d4      	b.n	8004ed4 <FreeRTOS_recvfrom+0x48>
					xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_RECEIVE );
 8004f2a:	2101      	movs	r1, #1
 8004f2c:	6860      	ldr	r0, [r4, #4]
 8004f2e:	f003 ff1d 	bl	8008d6c <xEventGroupSetBits>
 8004f32:	e7f7      	b.n	8004f24 <FreeRTOS_recvfrom+0x98>
				uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 8004f34:	4628      	mov	r0, r5
 8004f36:	f003 ffbd 	bl	8008eb4 <uxListRemove>
 8004f3a:	e01b      	b.n	8004f74 <FreeRTOS_recvfrom+0xe8>
				iptraceRECVFROM_DISCARDING_BYTES( ( xBufferLength - lReturn ) );
 8004f3c:	2100      	movs	r1, #0
 8004f3e:	2009      	movs	r0, #9
 8004f40:	f006 fc86 	bl	800b850 <vExampleDebugStatUpdate>
				lReturn = ( int32_t )xBufferLength;
 8004f44:	4654      	mov	r4, sl
 8004f46:	e024      	b.n	8004f92 <FreeRTOS_recvfrom+0x106>
			*( ( void** ) pvBuffer ) = ( void * ) ( &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ) );
 8004f48:	69ab      	ldr	r3, [r5, #24]
 8004f4a:	332a      	adds	r3, #42	; 0x2a
 8004f4c:	f8c9 3000 	str.w	r3, [r9]
 8004f50:	e7c0      	b.n	8004ed4 <FreeRTOS_recvfrom+0x48>
		iptraceRECVFROM_TIMEOUT();
 8004f52:	2100      	movs	r1, #0
 8004f54:	200d      	movs	r0, #13
 8004f56:	f006 fc7b 	bl	800b850 <vExampleDebugStatUpdate>
		lReturn = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 8004f5a:	f06f 040a 	mvn.w	r4, #10
 8004f5e:	e7b9      	b.n	8004ed4 <FreeRTOS_recvfrom+0x48>
		return -pdFREERTOS_ERRNO_EINVAL;
 8004f60:	f06f 0415 	mvn.w	r4, #21
 8004f64:	e7b6      	b.n	8004ed4 <FreeRTOS_recvfrom+0x48>
		taskENTER_CRITICAL();
 8004f66:	f003 fffd 	bl	8008f64 <vPortEnterCritical>
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8004f6a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004f6c:	68dd      	ldr	r5, [r3, #12]
			if( ( xFlags & FREERTOS_MSG_PEEK ) == 0 )
 8004f6e:	f018 0604 	ands.w	r6, r8, #4
 8004f72:	d0df      	beq.n	8004f34 <FreeRTOS_recvfrom+0xa8>
		taskEXIT_CRITICAL();
 8004f74:	f004 f818 	bl	8008fa8 <vPortExitCritical>
		lReturn = ( int32_t ) pxNetworkBuffer->xDataLength;
 8004f78:	69ec      	ldr	r4, [r5, #28]
		if( pxSourceAddress != NULL )
 8004f7a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8004f7c:	b123      	cbz	r3, 8004f88 <FreeRTOS_recvfrom+0xfc>
			pxSourceAddress->sin_port = pxNetworkBuffer->usPort;
 8004f7e:	8c2b      	ldrh	r3, [r5, #32]
 8004f80:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8004f82:	8053      	strh	r3, [r2, #2]
			pxSourceAddress->sin_addr = pxNetworkBuffer->ulIPAddress;
 8004f84:	696b      	ldr	r3, [r5, #20]
 8004f86:	6053      	str	r3, [r2, #4]
		if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8004f88:	f018 0f01 	tst.w	r8, #1
 8004f8c:	d1dc      	bne.n	8004f48 <FreeRTOS_recvfrom+0xbc>
			if( lReturn > ( int32_t ) xBufferLength )
 8004f8e:	4554      	cmp	r4, sl
 8004f90:	dcd4      	bgt.n	8004f3c <FreeRTOS_recvfrom+0xb0>
			memcpy( pvBuffer, ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( size_t )lReturn );
 8004f92:	69a9      	ldr	r1, [r5, #24]
 8004f94:	4622      	mov	r2, r4
 8004f96:	312a      	adds	r1, #42	; 0x2a
 8004f98:	4648      	mov	r0, r9
 8004f9a:	f007 fb9c 	bl	800c6d6 <memcpy>
			if( ( xFlags & FREERTOS_MSG_PEEK ) == 0 )
 8004f9e:	2e00      	cmp	r6, #0
 8004fa0:	d198      	bne.n	8004ed4 <FreeRTOS_recvfrom+0x48>
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8004fa2:	4628      	mov	r0, r5
 8004fa4:	f003 fa96 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
 8004fa8:	e794      	b.n	8004ed4 <FreeRTOS_recvfrom+0x48>

08004faa <FreeRTOS_bind>:
	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8004faa:	1e43      	subs	r3, r0, #1
 8004fac:	f113 0f03 	cmn.w	r3, #3
 8004fb0:	d829      	bhi.n	8005006 <FreeRTOS_bind+0x5c>
	else if( socketSOCKET_IS_BOUND( pxSocket) != pdFALSE )
 8004fb2:	6983      	ldr	r3, [r0, #24]
 8004fb4:	bb53      	cbnz	r3, 800500c <FreeRTOS_bind+0x62>
{
 8004fb6:	b510      	push	{r4, lr}
 8004fb8:	b084      	sub	sp, #16
		xBindEvent.eEventType = eSocketBindEvent;
 8004fba:	2308      	movs	r3, #8
 8004fbc:	f88d 3008 	strb.w	r3, [sp, #8]
		xBindEvent.pvData = ( void * ) xSocket;
 8004fc0:	9003      	str	r0, [sp, #12]
		if( pxAddress != NULL )
 8004fc2:	b1e9      	cbz	r1, 8005000 <FreeRTOS_bind+0x56>
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 8004fc4:	884a      	ldrh	r2, [r1, #2]
 8004fc6:	fa22 f303 	lsr.w	r3, r2, r3
 8004fca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004fce:	8483      	strh	r3, [r0, #36]	; 0x24
 8004fd0:	4604      	mov	r4, r0
		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 8004fd2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004fd6:	a802      	add	r0, sp, #8
 8004fd8:	f7ff fb06 	bl	80045e8 <xSendEventStructToIPTask>
 8004fdc:	b1c8      	cbz	r0, 8005012 <FreeRTOS_bind+0x68>
			xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_BOUND, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, portMAX_DELAY );
 8004fde:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004fe2:	9300      	str	r3, [sp, #0]
 8004fe4:	2300      	movs	r3, #0
 8004fe6:	2201      	movs	r2, #1
 8004fe8:	2110      	movs	r1, #16
 8004fea:	6860      	ldr	r0, [r4, #4]
 8004fec:	f003 fe1a 	bl	8008c24 <xEventGroupWaitBits>
			if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
 8004ff0:	69a3      	ldr	r3, [r4, #24]
				xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8004ff2:	2b00      	cmp	r3, #0
 8004ff4:	bf14      	ite	ne
 8004ff6:	2000      	movne	r0, #0
 8004ff8:	f06f 0015 	mvneq.w	r0, #21
}
 8004ffc:	b004      	add	sp, #16
 8004ffe:	bd10      	pop	{r4, pc}
			pxSocket->usLocalPort = 0u;
 8005000:	2300      	movs	r3, #0
 8005002:	8483      	strh	r3, [r0, #36]	; 0x24
 8005004:	e7e4      	b.n	8004fd0 <FreeRTOS_bind+0x26>
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005006:	f06f 0015 	mvn.w	r0, #21
 800500a:	4770      	bx	lr
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800500c:	f06f 0015 	mvn.w	r0, #21
 8005010:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_ECANCELED;
 8005012:	f06f 008b 	mvn.w	r0, #139	; 0x8b
 8005016:	e7f1      	b.n	8004ffc <FreeRTOS_bind+0x52>

08005018 <FreeRTOS_sendto>:
{
 8005018:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800501c:	b087      	sub	sp, #28
 800501e:	4607      	mov	r7, r0
 8005020:	4614      	mov	r4, r2
 8005022:	461e      	mov	r6, r3
 8005024:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 8005028:	2303      	movs	r3, #3
 800502a:	f88d 3010 	strb.w	r3, [sp, #16]
 800502e:	2300      	movs	r3, #0
 8005030:	9305      	str	r3, [sp, #20]
	configASSERT( pvBuffer );
 8005032:	4689      	mov	r9, r1
 8005034:	b339      	cbz	r1, 8005086 <FreeRTOS_sendto+0x6e>
	if( xTotalDataLength <= ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH )
 8005036:	f5b4 6fb8 	cmp.w	r4, #1472	; 0x5c0
 800503a:	d865      	bhi.n	8005108 <FreeRTOS_sendto+0xf0>
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
 800503c:	69bb      	ldr	r3, [r7, #24]
 800503e:	b343      	cbz	r3, 8005092 <FreeRTOS_sendto+0x7a>
			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8005040:	f016 0f10 	tst.w	r6, #16
			xTicksToWait = pxSocket->xSendBlockTime;
 8005044:	bf0c      	ite	eq
 8005046:	6a3b      	ldreq	r3, [r7, #32]
				xTicksToWait = ( TickType_t ) 0;
 8005048:	2300      	movne	r3, #0
 800504a:	9301      	str	r3, [sp, #4]
			if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 800504c:	f016 0601 	ands.w	r6, r6, #1
 8005050:	d12c      	bne.n	80050ac <FreeRTOS_sendto+0x94>
				vTaskSetTimeOutState( &xTimeOut );
 8005052:	a802      	add	r0, sp, #8
 8005054:	f005 fae0 	bl	800a618 <vTaskSetTimeOutState>
				pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( xTotalDataLength + sizeof( UDPPacket_t ), xTicksToWait );
 8005058:	9901      	ldr	r1, [sp, #4]
 800505a:	f104 002a 	add.w	r0, r4, #42	; 0x2a
 800505e:	f003 fa5f 	bl	8008520 <pxGetNetworkBufferWithDescriptor>
				if( pxNetworkBuffer != NULL )
 8005062:	4605      	mov	r5, r0
 8005064:	2800      	cmp	r0, #0
 8005066:	d049      	beq.n	80050fc <FreeRTOS_sendto+0xe4>
					memcpy( ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( void * ) pvBuffer, xTotalDataLength );
 8005068:	6980      	ldr	r0, [r0, #24]
 800506a:	4622      	mov	r2, r4
 800506c:	4649      	mov	r1, r9
 800506e:	302a      	adds	r0, #42	; 0x2a
 8005070:	f007 fb31 	bl	800c6d6 <memcpy>
					if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
 8005074:	a901      	add	r1, sp, #4
 8005076:	a802      	add	r0, sp, #8
 8005078:	f005 fae4 	bl	800a644 <xTaskCheckForTimeOut>
 800507c:	2801      	cmp	r0, #1
 800507e:	d11a      	bne.n	80050b6 <FreeRTOS_sendto+0x9e>
						xTicksToWait = ( TickType_t ) 0;
 8005080:	2300      	movs	r3, #0
 8005082:	9301      	str	r3, [sp, #4]
 8005084:	e017      	b.n	80050b6 <FreeRTOS_sendto+0x9e>
	configASSERT( pvBuffer );
 8005086:	f240 313d 	movw	r1, #829	; 0x33d
 800508a:	4822      	ldr	r0, [pc, #136]	; (8005114 <FreeRTOS_sendto+0xfc>)
 800508c:	f007 f968 	bl	800c360 <vAssertCalled>
 8005090:	e7d1      	b.n	8005036 <FreeRTOS_sendto+0x1e>
			( FreeRTOS_bind( xSocket, NULL, 0u ) == 0 ) )
 8005092:	2200      	movs	r2, #0
 8005094:	4611      	mov	r1, r2
 8005096:	4638      	mov	r0, r7
 8005098:	f7ff ff87 	bl	8004faa <FreeRTOS_bind>
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
 800509c:	2800      	cmp	r0, #0
 800509e:	d0cf      	beq.n	8005040 <FreeRTOS_sendto+0x28>
			iptraceSENDTO_SOCKET_NOT_BOUND();
 80050a0:	2100      	movs	r1, #0
 80050a2:	200f      	movs	r0, #15
 80050a4:	f006 fbd4 	bl	800b850 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 80050a8:	2000      	movs	r0, #0
 80050aa:	e01e      	b.n	80050ea <FreeRTOS_sendto+0xd2>
				pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( (void*)pvBuffer );
 80050ac:	4648      	mov	r0, r9
 80050ae:	f7ff f9c1 	bl	8004434 <pxUDPPayloadBuffer_to_NetworkBuffer>
			if( pxNetworkBuffer != NULL )
 80050b2:	4605      	mov	r5, r0
 80050b4:	b310      	cbz	r0, 80050fc <FreeRTOS_sendto+0xe4>
				pxNetworkBuffer->xDataLength = xTotalDataLength;
 80050b6:	61ec      	str	r4, [r5, #28]
				pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
 80050b8:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 80050bc:	842b      	strh	r3, [r5, #32]
				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
 80050be:	68bb      	ldr	r3, [r7, #8]
 80050c0:	846b      	strh	r3, [r5, #34]	; 0x22
				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
 80050c2:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80050c6:	616b      	str	r3, [r5, #20]
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
 80050c8:	69ab      	ldr	r3, [r5, #24]
 80050ca:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 80050ce:	719a      	strb	r2, [r3, #6]
				xStackTxEvent.pvData = pxNetworkBuffer;
 80050d0:	9505      	str	r5, [sp, #20]
				if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
 80050d2:	9901      	ldr	r1, [sp, #4]
 80050d4:	a804      	add	r0, sp, #16
 80050d6:	f7ff fa87 	bl	80045e8 <xSendEventStructToIPTask>
 80050da:	2801      	cmp	r0, #1
 80050dc:	d008      	beq.n	80050f0 <FreeRTOS_sendto+0xd8>
					if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 80050de:	b14e      	cbz	r6, 80050f4 <FreeRTOS_sendto+0xdc>
					iptraceSTACK_TX_EVENT_LOST( ipSTACK_TX_EVENT );
 80050e0:	2100      	movs	r1, #0
 80050e2:	200b      	movs	r0, #11
 80050e4:	f006 fbb4 	bl	800b850 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 80050e8:	2000      	movs	r0, #0
} /* Tested */
 80050ea:	b007      	add	sp, #28
 80050ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					lReturn = ( int32_t ) xTotalDataLength;
 80050f0:	4620      	mov	r0, r4
 80050f2:	e7fa      	b.n	80050ea <FreeRTOS_sendto+0xd2>
						vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80050f4:	4628      	mov	r0, r5
 80050f6:	f003 f9ed 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
 80050fa:	e7f1      	b.n	80050e0 <FreeRTOS_sendto+0xc8>
				iptraceNO_BUFFER_FOR_SENDTO();
 80050fc:	2100      	movs	r1, #0
 80050fe:	2010      	movs	r0, #16
 8005100:	f006 fba6 	bl	800b850 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 8005104:	2000      	movs	r0, #0
 8005106:	e7f0      	b.n	80050ea <FreeRTOS_sendto+0xd2>
		iptraceSENDTO_DATA_TOO_LONG();
 8005108:	2100      	movs	r1, #0
 800510a:	200e      	movs	r0, #14
 800510c:	f006 fba0 	bl	800b850 <vExampleDebugStatUpdate>
int32_t lReturn = 0;
 8005110:	2000      	movs	r0, #0
	return lReturn;
 8005112:	e7ea      	b.n	80050ea <FreeRTOS_sendto+0xd2>
 8005114:	0800cb68 	.word	0x0800cb68

08005118 <vSocketBind>:
{
 8005118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800511c:	b085      	sub	sp, #20
 800511e:	4607      	mov	r7, r0
 8005120:	4688      	mov	r8, r1
 8005122:	469a      	mov	sl, r3
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005124:	f890 9027 	ldrb.w	r9, [r0, #39]	; 0x27
		pxSocketList = &xBoundUDPSocketsList;
 8005128:	4b39      	ldr	r3, [pc, #228]	; (8005210 <vSocketBind+0xf8>)
 800512a:	4a3a      	ldr	r2, [pc, #232]	; (8005214 <vSocketBind+0xfc>)
 800512c:	f1b9 0f06 	cmp.w	r9, #6
 8005130:	bf0c      	ite	eq
 8005132:	4691      	moveq	r9, r2
 8005134:	4699      	movne	r9, r3
	configASSERT( pxSocket );
 8005136:	b340      	cbz	r0, 800518a <vSocketBind+0x72>
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 8005138:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800513c:	d02b      	beq.n	8005196 <vSocketBind+0x7e>
		if( pxAddress == NULL )
 800513e:	f1b8 0f00 	cmp.w	r8, #0
 8005142:	d02e      	beq.n	80051a2 <vSocketBind+0x8a>
		if( pxAddress->sin_port == 0u )
 8005144:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 8005148:	b38b      	cbz	r3, 80051ae <vSocketBind+0x96>
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 800514a:	f1ba 0f00 	cmp.w	sl, #0
 800514e:	d003      	beq.n	8005158 <vSocketBind+0x40>
 8005150:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8005154:	2b06      	cmp	r3, #6
 8005156:	d006      	beq.n	8005166 <vSocketBind+0x4e>
			( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 8005158:	f8b8 1002 	ldrh.w	r1, [r8, #2]
 800515c:	4648      	mov	r0, r9
 800515e:	f7ff fdae 	bl	8004cbe <pxListFindListItemWithValue>
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 8005162:	2800      	cmp	r0, #0
 8005164:	d14c      	bne.n	8005200 <vSocketBind+0xe8>
			socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
 8005166:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 800516a:	60bb      	str	r3, [r7, #8]
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 800516c:	f8b8 2002 	ldrh.w	r2, [r8, #2]
 8005170:	0a13      	lsrs	r3, r2, #8
 8005172:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005176:	84bb      	strh	r3, [r7, #36]	; 0x24
				vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
 8005178:	f107 0108 	add.w	r1, r7, #8
 800517c:	4648      	mov	r0, r9
 800517e:	f003 fe73 	bl	8008e68 <vListInsertEnd>
BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
 8005182:	2000      	movs	r0, #0
} /* Tested */
 8005184:	b005      	add	sp, #20
 8005186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	configASSERT( pxSocket );
 800518a:	f240 4115 	movw	r1, #1045	; 0x415
 800518e:	4822      	ldr	r0, [pc, #136]	; (8005218 <vSocketBind+0x100>)
 8005190:	f007 f8e6 	bl	800c360 <vAssertCalled>
 8005194:	e7d3      	b.n	800513e <vSocketBind+0x26>
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 8005196:	f240 4116 	movw	r1, #1046	; 0x416
 800519a:	481f      	ldr	r0, [pc, #124]	; (8005218 <vSocketBind+0x100>)
 800519c:	f007 f8e0 	bl	800c360 <vAssertCalled>
 80051a0:	e7cd      	b.n	800513e <vSocketBind+0x26>
			pxAddress->sin_port = 0u;
 80051a2:	2300      	movs	r3, #0
 80051a4:	f8ad 300a 	strh.w	r3, [sp, #10]
			pxAddress = &xAddress;
 80051a8:	f10d 0808 	add.w	r8, sp, #8
 80051ac:	e7ca      	b.n	8005144 <vSocketBind+0x2c>
	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
 80051ae:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
		pxList = &xBoundUDPSocketsList;
 80051b2:	4a17      	ldr	r2, [pc, #92]	; (8005210 <vSocketBind+0xf8>)
 80051b4:	4917      	ldr	r1, [pc, #92]	; (8005214 <vSocketBind+0xfc>)
 80051b6:	2b06      	cmp	r3, #6
 80051b8:	bf18      	it	ne
 80051ba:	4611      	movne	r1, r2
 80051bc:	9101      	str	r1, [sp, #4]
 80051be:	2b06      	cmp	r3, #6
 80051c0:	bf0c      	ite	eq
 80051c2:	2601      	moveq	r6, #1
 80051c4:	2600      	movne	r6, #0
		++( usNextPortToUse[ xIndex ] );
 80051c6:	4d15      	ldr	r5, [pc, #84]	; (800521c <vSocketBind+0x104>)
			usNextPortToUse[ xIndex ] = socketAUTO_PORT_ALLOCATION_RESET_NUMBER;
 80051c8:	f44f 4b41 	mov.w	fp, #49408	; 0xc100
		++( usNextPortToUse[ xIndex ] );
 80051cc:	f835 3016 	ldrh.w	r3, [r5, r6, lsl #1]
 80051d0:	3301      	adds	r3, #1
 80051d2:	b29b      	uxth	r3, r3
		if( usNextPortToUse[ xIndex ] >= socketAUTO_PORT_ALLOCATION_MAX_NUMBER )
 80051d4:	f5b3 4f7f 	cmp.w	r3, #65280	; 0xff00
		++( usNextPortToUse[ xIndex ] );
 80051d8:	bf34      	ite	cc
 80051da:	f825 3016 	strhcc.w	r3, [r5, r6, lsl #1]
			usNextPortToUse[ xIndex ] = socketAUTO_PORT_ALLOCATION_RESET_NUMBER;
 80051de:	f825 b016 	strhcs.w	fp, [r5, r6, lsl #1]
		usResult = FreeRTOS_htons( usNextPortToUse[ xIndex ] );
 80051e2:	f835 3016 	ldrh.w	r3, [r5, r6, lsl #1]
 80051e6:	0a1c      	lsrs	r4, r3, #8
 80051e8:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80051ec:	b2a4      	uxth	r4, r4
		if( pxListFindListItemWithValue( pxList, ( TickType_t ) usResult ) == NULL )
 80051ee:	4621      	mov	r1, r4
 80051f0:	9801      	ldr	r0, [sp, #4]
 80051f2:	f7ff fd64 	bl	8004cbe <pxListFindListItemWithValue>
 80051f6:	2800      	cmp	r0, #0
 80051f8:	d1e8      	bne.n	80051cc <vSocketBind+0xb4>
			pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
 80051fa:	f8a8 4002 	strh.w	r4, [r8, #2]
 80051fe:	e7a4      	b.n	800514a <vSocketBind+0x32>
		iptraceBIND_FAILED( xSocket, ( FreeRTOS_ntohs( pxAddress->sin_port ) ) );
 8005200:	2100      	movs	r1, #0
 8005202:	200c      	movs	r0, #12
 8005204:	f006 fb24 	bl	800b850 <vExampleDebugStatUpdate>
 8005208:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 800520c:	e7ba      	b.n	8005184 <vSocketBind+0x6c>
 800520e:	bf00      	nop
 8005210:	20002850 	.word	0x20002850
 8005214:	2000283c 	.word	0x2000283c
 8005218:	0800cb68 	.word	0x0800cb68
 800521c:	2000056c 	.word	0x2000056c

08005220 <FreeRTOS_closesocket>:
{
 8005220:	b500      	push	{lr}
 8005222:	b083      	sub	sp, #12
xCloseEvent.eEventType = eSocketCloseEvent;
 8005224:	2309      	movs	r3, #9
 8005226:	f88d 3000 	strb.w	r3, [sp]
xCloseEvent.pvData = ( void * ) xSocket;
 800522a:	9001      	str	r0, [sp, #4]
	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
 800522c:	3801      	subs	r0, #1
 800522e:	f110 0f03 	cmn.w	r0, #3
 8005232:	d903      	bls.n	800523c <FreeRTOS_closesocket+0x1c>
		xResult = 0;
 8005234:	2000      	movs	r0, #0
}
 8005236:	b003      	add	sp, #12
 8005238:	f85d fb04 	ldr.w	pc, [sp], #4
		if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) 0 ) == pdFAIL )
 800523c:	2100      	movs	r1, #0
 800523e:	4668      	mov	r0, sp
 8005240:	f7ff f9d2 	bl	80045e8 <xSendEventStructToIPTask>
 8005244:	2800      	cmp	r0, #0
			xResult = 1;
 8005246:	bf0c      	ite	eq
 8005248:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
 800524c:	2001      	movne	r0, #1
 800524e:	e7f2      	b.n	8005236 <FreeRTOS_closesocket+0x16>

08005250 <vSocketClose>:
{
 8005250:	b538      	push	{r3, r4, r5, lr}
 8005252:	4604      	mov	r4, r0
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005254:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005258:	2b06      	cmp	r3, #6
 800525a:	d00f      	beq.n	800527c <vSocketClose+0x2c>
	if( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE )
 800525c:	69a3      	ldr	r3, [r4, #24]
 800525e:	2b00      	cmp	r3, #0
 8005260:	d137      	bne.n	80052d2 <vSocketClose+0x82>
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8005262:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005266:	2b11      	cmp	r3, #17
 8005268:	d038      	beq.n	80052dc <vSocketClose+0x8c>
	if( pxSocket->xEventGroup )
 800526a:	6860      	ldr	r0, [r4, #4]
 800526c:	b108      	cbz	r0, 8005272 <vSocketClose+0x22>
		vEventGroupDelete( pxSocket->xEventGroup );
 800526e:	f003 fdc9 	bl	8008e04 <vEventGroupDelete>
	vPortFreeSocket( pxSocket );
 8005272:	4620      	mov	r0, r4
 8005274:	f004 f866 	bl	8009344 <vPortFree>
} /* Tested */
 8005278:	2000      	movs	r0, #0
 800527a:	bd38      	pop	{r3, r4, r5, pc}
				if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800527c:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800527e:	b108      	cbz	r0, 8005284 <vSocketClose+0x34>
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8005280:	f003 f928 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
				vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
 8005284:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
 8005288:	f002 fd59 	bl	8007d3e <vTCPWindowDestroy>
			if( pxSocket->u.xTCP.rxStream != NULL )
 800528c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800528e:	b108      	cbz	r0, 8005294 <vSocketClose+0x44>
				vPortFreeLarge( pxSocket->u.xTCP.rxStream );
 8005290:	f004 f858 	bl	8009344 <vPortFree>
			if( pxSocket->u.xTCP.txStream != NULL )
 8005294:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8005296:	b108      	cbz	r0, 800529c <vSocketClose+0x4c>
				vPortFreeLarge( pxSocket->u.xTCP.txStream );
 8005298:	f004 f854 	bl	8009344 <vPortFree>
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
 800529c:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800529e:	4a17      	ldr	r2, [pc, #92]	; (80052fc <vSocketClose+0xac>)
 80052a0:	68d3      	ldr	r3, [r2, #12]
 80052a2:	3208      	adds	r2, #8
 80052a4:	4293      	cmp	r3, r2
 80052a6:	d0d9      	beq.n	800525c <vSocketClose+0xc>
 80052a8:	4610      	mov	r0, r2
 80052aa:	e002      	b.n	80052b2 <vSocketClose+0x62>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 80052ac:	685b      	ldr	r3, [r3, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 80052ae:	4283      	cmp	r3, r0
 80052b0:	d0d4      	beq.n	800525c <vSocketClose+0xc>
			pxOtherSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 80052b2:	68da      	ldr	r2, [r3, #12]
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
 80052b4:	f892 1053 	ldrb.w	r1, [r2, #83]	; 0x53
 80052b8:	2901      	cmp	r1, #1
 80052ba:	d1f7      	bne.n	80052ac <vSocketClose+0x5c>
 80052bc:	8c91      	ldrh	r1, [r2, #36]	; 0x24
 80052be:	42a9      	cmp	r1, r5
 80052c0:	d1f4      	bne.n	80052ac <vSocketClose+0x5c>
				( pxOtherSocket->u.xTCP.usChildCount ) )
 80052c2:	f8b2 104e 	ldrh.w	r1, [r2, #78]	; 0x4e
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
 80052c6:	2900      	cmp	r1, #0
 80052c8:	d0f0      	beq.n	80052ac <vSocketClose+0x5c>
				pxOtherSocket->u.xTCP.usChildCount--;
 80052ca:	3901      	subs	r1, #1
 80052cc:	f8a2 104e 	strh.w	r1, [r2, #78]	; 0x4e
 80052d0:	e7c4      	b.n	800525c <vSocketClose+0xc>
		uxListRemove( &( pxSocket->xBoundSocketListItem ) );
 80052d2:	f104 0008 	add.w	r0, r4, #8
 80052d6:	f003 fded 	bl	8008eb4 <uxListRemove>
 80052da:	e7c2      	b.n	8005262 <vSocketClose+0x12>
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 80052dc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80052de:	2b00      	cmp	r3, #0
 80052e0:	d0c3      	beq.n	800526a <vSocketClose+0x1a>
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 80052e2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80052e4:	68dd      	ldr	r5, [r3, #12]
			uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 80052e6:	4628      	mov	r0, r5
 80052e8:	f003 fde4 	bl	8008eb4 <uxListRemove>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80052ec:	4628      	mov	r0, r5
 80052ee:	f003 f8f1 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 80052f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80052f4:	2b00      	cmp	r3, #0
 80052f6:	d1f4      	bne.n	80052e2 <vSocketClose+0x92>
 80052f8:	e7b7      	b.n	800526a <vSocketClose+0x1a>
 80052fa:	bf00      	nop
 80052fc:	2000283c 	.word	0x2000283c

08005300 <pxUDPSocketLookup>:

/*-----------------------------------------------------------*/

FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
{
 8005300:	b510      	push	{r4, lr}

	/* Looking up a socket is quite simple, find a match with the local port.

	See if there is a list item associated with the port number on the
	list of bound sockets. */
	pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
 8005302:	4601      	mov	r1, r0
 8005304:	4807      	ldr	r0, [pc, #28]	; (8005324 <pxUDPSocketLookup+0x24>)
 8005306:	f7ff fcda 	bl	8004cbe <pxListFindListItemWithValue>

	if( pxListItem != NULL )
 800530a:	b148      	cbz	r0, 8005320 <pxUDPSocketLookup+0x20>
	{
		/* The owner of the list item is the socket itself. */
		pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxListItem );
 800530c:	68c4      	ldr	r4, [r0, #12]
		configASSERT( pxSocket != NULL );
 800530e:	b10c      	cbz	r4, 8005314 <pxUDPSocketLookup+0x14>
	}
	return pxSocket;
}
 8005310:	4620      	mov	r0, r4
 8005312:	bd10      	pop	{r4, pc}
		configASSERT( pxSocket != NULL );
 8005314:	f240 61d1 	movw	r1, #1745	; 0x6d1
 8005318:	4803      	ldr	r0, [pc, #12]	; (8005328 <pxUDPSocketLookup+0x28>)
 800531a:	f007 f821 	bl	800c360 <vAssertCalled>
 800531e:	e7f7      	b.n	8005310 <pxUDPSocketLookup+0x10>
FreeRTOS_Socket_t *pxSocket = NULL;
 8005320:	2400      	movs	r4, #0
	return pxSocket;
 8005322:	e7f5      	b.n	8005310 <pxUDPSocketLookup+0x10>
 8005324:	20002850 	.word	0x20002850
 8005328:	0800cb68 	.word	0x0800cb68

0800532c <FreeRTOS_inet_addr>:
/*-----------------------------------------------------------*/

#if ipconfigINCLUDE_FULL_INET_ADDR == 1

	uint32_t FreeRTOS_inet_addr( const char * pcIPAddress )
	{
 800532c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800532e:	b083      	sub	sp, #12
 8005330:	ad01      	add	r5, sp, #4
 8005332:	4686      	mov	lr, r0
	const char *pcPointerOnEntering;
	uint32_t ulReturn = 0UL, ulValue;
	UBaseType_t uxOctetNumber;
	BaseType_t xResult = pdPASS;

		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 8005334:	2400      	movs	r4, #0
		{
			ulValue = 0ul;
			pcPointerOnEntering = pcIPAddress;

			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8005336:	4626      	mov	r6, r4
			}

			/* Check characters were read. */
			if( pcIPAddress == pcPointerOnEntering )
			{
				xResult = pdFAIL;
 8005338:	4627      	mov	r7, r4
 800533a:	e004      	b.n	8005346 <FreeRTOS_inet_addr+0x1a>
						pcIPAddress++;
					}
				}
			}

			if( xResult == pdFAIL )
 800533c:	b381      	cbz	r1, 80053a0 <FreeRTOS_inet_addr+0x74>
		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 800533e:	3401      	adds	r4, #1
 8005340:	2c04      	cmp	r4, #4
 8005342:	d02d      	beq.n	80053a0 <FreeRTOS_inet_addr+0x74>
 8005344:	4686      	mov	lr, r0
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8005346:	7802      	ldrb	r2, [r0, #0]
 8005348:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 800534c:	b2db      	uxtb	r3, r3
 800534e:	2b09      	cmp	r3, #9
 8005350:	bf98      	it	ls
 8005352:	4633      	movls	r3, r6
 8005354:	d819      	bhi.n	800538a <FreeRTOS_inet_addr+0x5e>
				ulValue *= ulDecimalBase;
 8005356:	eb03 0383 	add.w	r3, r3, r3, lsl #2
				ulValue += ( ( uint32_t ) ( *pcIPAddress ) - ( uint32_t ) '0' );
 800535a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800535e:	3b30      	subs	r3, #48	; 0x30
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 8005360:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8005364:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8005368:	b2c9      	uxtb	r1, r1
 800536a:	2909      	cmp	r1, #9
 800536c:	d9f3      	bls.n	8005356 <FreeRTOS_inet_addr+0x2a>
			if( pcIPAddress == pcPointerOnEntering )
 800536e:	ebb0 010e 	subs.w	r1, r0, lr
 8005372:	bf18      	it	ne
 8005374:	2101      	movne	r1, #1
			if( ulValue > 0xffUL )
 8005376:	2bff      	cmp	r3, #255	; 0xff
 8005378:	d811      	bhi.n	800539e <FreeRTOS_inet_addr+0x72>
				ucOctet[ uxOctetNumber ] = ( uint8_t ) ulValue;
 800537a:	f805 3b01 	strb.w	r3, [r5], #1
				if( uxOctetNumber < ( socketMAX_IP_ADDRESS_OCTETS - 1u ) )
 800537e:	2c02      	cmp	r4, #2
 8005380:	d8dc      	bhi.n	800533c <FreeRTOS_inet_addr+0x10>
					if( *pcIPAddress != '.' )
 8005382:	2a2e      	cmp	r2, #46	; 0x2e
 8005384:	d10b      	bne.n	800539e <FreeRTOS_inet_addr+0x72>
						pcIPAddress++;
 8005386:	3001      	adds	r0, #1
 8005388:	e7d8      	b.n	800533c <FreeRTOS_inet_addr+0x10>
			while( ( *pcIPAddress >= '0' ) && ( *pcIPAddress <= '9' ) )
 800538a:	4633      	mov	r3, r6
				xResult = pdFAIL;
 800538c:	4639      	mov	r1, r7
 800538e:	e7f4      	b.n	800537a <FreeRTOS_inet_addr+0x4e>
	uint32_t ulReturn = 0UL, ulValue;
 8005390:	2000      	movs	r0, #0
		{
			ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
		}

		return ulReturn;
	}
 8005392:	b003      	add	sp, #12
 8005394:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint32_t ulReturn = 0UL, ulValue;
 8005396:	2000      	movs	r0, #0
 8005398:	e7fb      	b.n	8005392 <FreeRTOS_inet_addr+0x66>
 800539a:	2000      	movs	r0, #0
		return ulReturn;
 800539c:	e7f9      	b.n	8005392 <FreeRTOS_inet_addr+0x66>
		for( uxOctetNumber = 0u; uxOctetNumber < socketMAX_IP_ADDRESS_OCTETS; uxOctetNumber++ )
 800539e:	2100      	movs	r1, #0
		if( *pcIPAddress != ( char ) 0 )
 80053a0:	7803      	ldrb	r3, [r0, #0]
 80053a2:	2b00      	cmp	r3, #0
 80053a4:	d1f4      	bne.n	8005390 <FreeRTOS_inet_addr+0x64>
		if( uxOctetNumber != socketMAX_IP_ADDRESS_OCTETS )
 80053a6:	2c04      	cmp	r4, #4
 80053a8:	d1f5      	bne.n	8005396 <FreeRTOS_inet_addr+0x6a>
		if( xResult == pdPASS )
 80053aa:	2900      	cmp	r1, #0
 80053ac:	d0f5      	beq.n	800539a <FreeRTOS_inet_addr+0x6e>
			ulReturn = FreeRTOS_inet_addr_quick( ucOctet[ 0 ], ucOctet[ 1 ], ucOctet[ 2 ], ucOctet[ 3 ] );
 80053ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80053b2:	f89d 0006 	ldrb.w	r0, [sp, #6]
 80053b6:	0400      	lsls	r0, r0, #16
 80053b8:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 80053bc:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80053c0:	4318      	orrs	r0, r3
 80053c2:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80053c6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 80053ca:	e7e2      	b.n	8005392 <FreeRTOS_inet_addr+0x66>

080053cc <vSocketWakeUpUser>:
}

/*-----------------------------------------------------------*/

void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket )
{
 80053cc:	b510      	push	{r4, lr}
 80053ce:	4604      	mov	r4, r0
	}
	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		if( pxSocket->pxSocketSet != NULL )
 80053d0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80053d2:	b11b      	cbz	r3, 80053dc <vSocketWakeUpUser+0x10>
		{
			EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & eSELECT_ALL;
 80053d4:	6801      	ldr	r1, [r0, #0]
 80053d6:	f3c1 2103 	ubfx	r1, r1, #8, #4
			if( xSelectBits != 0ul )
 80053da:	b949      	cbnz	r1, 80053f0 <vSocketWakeUpUser+0x24>
				pxSocket->xSocketBits |= xSelectBits;
				xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
			}
		}

		pxSocket->xEventBits &= eSOCKET_ALL;
 80053dc:	6821      	ldr	r1, [r4, #0]
 80053de:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80053e2:	6021      	str	r1, [r4, #0]
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0u ) )
 80053e4:	6860      	ldr	r0, [r4, #4]
 80053e6:	b100      	cbz	r0, 80053ea <vSocketWakeUpUser+0x1e>
 80053e8:	b949      	cbnz	r1, 80053fe <vSocketWakeUpUser+0x32>
	{
		xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
	}

	pxSocket->xEventBits = 0ul;
 80053ea:	2300      	movs	r3, #0
 80053ec:	6023      	str	r3, [r4, #0]
 80053ee:	bd10      	pop	{r4, pc}
				pxSocket->xSocketBits |= xSelectBits;
 80053f0:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80053f2:	430a      	orrs	r2, r1
 80053f4:	6302      	str	r2, [r0, #48]	; 0x30
				xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
 80053f6:	6818      	ldr	r0, [r3, #0]
 80053f8:	f003 fcb8 	bl	8008d6c <xEventGroupSetBits>
 80053fc:	e7ee      	b.n	80053dc <vSocketWakeUpUser+0x10>
		xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
 80053fe:	f003 fcb5 	bl	8008d6c <xEventGroupSetBits>
 8005402:	e7f2      	b.n	80053ea <vSocketWakeUpUser+0x1e>

08005404 <FreeRTOS_accept>:
	 * if the server socket is in listen mode and receives a connection request
	 * The new socket will be bound already to the same port number as the listing
	 * socket.
	 */
	Socket_t FreeRTOS_accept( Socket_t xServerSocket, struct freertos_sockaddr *pxAddress, socklen_t *pxAddressLength )
	{
 8005404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005408:	b08b      	sub	sp, #44	; 0x2c
 800540a:	4605      	mov	r5, r0
 800540c:	460e      	mov	r6, r1
 800540e:	4691      	mov	r9, r2
	TickType_t xRemainingTime;
	BaseType_t xTimed = pdFALSE, xAsk = pdFALSE;
	TimeOut_t xTimeOut;
	IPStackEvent_t xAskEvent;

		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8005410:	2201      	movs	r2, #1
 8005412:	2106      	movs	r1, #6
 8005414:	f7ff fc40 	bl	8004c98 <prvValidSocket>
 8005418:	b1d0      	cbz	r0, 8005450 <FreeRTOS_accept+0x4c>
		{
			/* Not a valid socket or wrong type */
			pxClientSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
		}
		else if( ( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED ) &&
 800541a:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 800541e:	f013 0f08 	tst.w	r3, #8
 8005422:	d10a      	bne.n	800543a <FreeRTOS_accept+0x36>
 8005424:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 8005428:	2b01      	cmp	r3, #1
 800542a:	d002      	beq.n	8005432 <FreeRTOS_accept+0x2e>
				 ( pxSocket->u.xTCP.ucTCPState != eTCP_LISTEN ) )
		{
			/* Parent socket is not in listening mode */
			pxClientSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 800542c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8005430:	e010      	b.n	8005454 <FreeRTOS_accept+0x50>
 8005432:	f04f 0a00 	mov.w	sl, #0
 8005436:	4657      	mov	r7, sl
 8005438:	e002      	b.n	8005440 <FreeRTOS_accept+0x3c>
 800543a:	f04f 0a00 	mov.w	sl, #0
 800543e:	4657      	mov	r7, sl
					{
						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
					}
					else
					{
						pxClientSocket = pxSocket;
 8005440:	9503      	str	r5, [sp, #12]
 8005442:	f04f 0800 	mov.w	r8, #0

				if( xAsk != pdFALSE )
				{
					/* Ask to set an event in 'xEventGroup' as soon as a new
					client gets connected for this listening socket. */
					xAskEvent.eEventType = eTCPAcceptEvent;
 8005446:	f04f 0b06 	mov.w	fp, #6
 800544a:	e027      	b.n	800549c <FreeRTOS_accept+0x98>
 800544c:	4644      	mov	r4, r8
 800544e:	e05d      	b.n	800550c <FreeRTOS_accept+0x108>
			pxClientSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8005450:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_ACCEPT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
			}
		}

		return ( Socket_t ) pxClientSocket;
	}
 8005454:	4620      	mov	r0, r4
 8005456:	b00b      	add	sp, #44	; 0x2c
 8005458:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800545c:	2400      	movs	r4, #0
 800545e:	e7f9      	b.n	8005454 <FreeRTOS_accept+0x50>
 8005460:	2400      	movs	r4, #0
 8005462:	e7f7      	b.n	8005454 <FreeRTOS_accept+0x50>
				xTaskResumeAll();
 8005464:	f004 feb6 	bl	800a1d4 <xTaskResumeAll>
				if( xAsk != pdFALSE )
 8005468:	f1ba 0f00 	cmp.w	sl, #0
 800546c:	d1ee      	bne.n	800544c <FreeRTOS_accept+0x48>
				if( xTimed == pdFALSE )
 800546e:	b937      	cbnz	r7, 800547e <FreeRTOS_accept+0x7a>
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8005470:	69eb      	ldr	r3, [r5, #28]
 8005472:	9309      	str	r3, [sp, #36]	; 0x24
					if( xRemainingTime == ( TickType_t ) 0 )
 8005474:	2b00      	cmp	r3, #0
 8005476:	d0f1      	beq.n	800545c <FreeRTOS_accept+0x58>
					vTaskSetTimeOutState( &xTimeOut );
 8005478:	a807      	add	r0, sp, #28
 800547a:	f005 f8cd 	bl	800a618 <vTaskSetTimeOutState>
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 800547e:	a909      	add	r1, sp, #36	; 0x24
 8005480:	a807      	add	r0, sp, #28
 8005482:	f005 f8df 	bl	800a644 <xTaskCheckForTimeOut>
 8005486:	2800      	cmp	r0, #0
 8005488:	d1ea      	bne.n	8005460 <FreeRTOS_accept+0x5c>
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_ACCEPT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 800548a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800548c:	9300      	str	r3, [sp, #0]
 800548e:	4643      	mov	r3, r8
 8005490:	2201      	movs	r2, #1
 8005492:	2104      	movs	r1, #4
 8005494:	6868      	ldr	r0, [r5, #4]
 8005496:	f003 fbc5 	bl	8008c24 <xEventGroupWaitBits>
 800549a:	2701      	movs	r7, #1
				vTaskSuspendAll();
 800549c:	f004 fdc0 	bl	800a020 <vTaskSuspendAll>
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 80054a0:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 80054a4:	f013 0f08 	tst.w	r3, #8
						pxClientSocket = pxSocket->u.xTCP.pxPeerSocket;
 80054a8:	bf0c      	ite	eq
 80054aa:	6d6c      	ldreq	r4, [r5, #84]	; 0x54
						pxClientSocket = pxSocket;
 80054ac:	9c03      	ldrne	r4, [sp, #12]
					if( pxClientSocket != NULL )
 80054ae:	2c00      	cmp	r4, #0
 80054b0:	d0d8      	beq.n	8005464 <FreeRTOS_accept+0x60>
						pxSocket->u.xTCP.pxPeerSocket = NULL;
 80054b2:	f8c5 8054 	str.w	r8, [r5, #84]	; 0x54
						if( pxClientSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED )
 80054b6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80054ba:	f013 0f02 	tst.w	r3, #2
 80054be:	d0d1      	beq.n	8005464 <FreeRTOS_accept+0x60>
							pxClientSocket->u.xTCP.bits.bPassAccept = pdFALSE_UNSIGNED;
 80054c0:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80054c4:	f36f 0341 	bfc	r3, #1, #1
 80054c8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
				xTaskResumeAll();
 80054cc:	f004 fe82 	bl	800a1d4 <xTaskResumeAll>
					if( pxAddress != NULL )
 80054d0:	b18e      	cbz	r6, 80054f6 <FreeRTOS_accept+0xf2>
						pxAddress->sin_addr = FreeRTOS_ntohl( pxClientSocket->u.xTCP.ulRemoteIP );
 80054d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80054d4:	0e1a      	lsrs	r2, r3, #24
 80054d6:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80054da:	0219      	lsls	r1, r3, #8
 80054dc:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80054e0:	430a      	orrs	r2, r1
 80054e2:	0a1b      	lsrs	r3, r3, #8
 80054e4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80054e8:	4313      	orrs	r3, r2
 80054ea:	6073      	str	r3, [r6, #4]
						pxAddress->sin_port = FreeRTOS_ntohs( pxClientSocket->u.xTCP.usRemotePort );
 80054ec:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 80054ee:	0a13      	lsrs	r3, r2, #8
 80054f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80054f4:	8073      	strh	r3, [r6, #2]
					if( pxAddressLength != NULL )
 80054f6:	f1b9 0f00 	cmp.w	r9, #0
 80054fa:	d002      	beq.n	8005502 <FreeRTOS_accept+0xfe>
						*pxAddressLength = sizeof( *pxAddress );
 80054fc:	2308      	movs	r3, #8
 80054fe:	f8c9 3000 	str.w	r3, [r9]
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8005502:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8005506:	f013 0f08 	tst.w	r3, #8
 800550a:	d10d      	bne.n	8005528 <FreeRTOS_accept+0x124>
					xAskEvent.eEventType = eTCPAcceptEvent;
 800550c:	f88d b014 	strb.w	fp, [sp, #20]
					xAskEvent.pvData = ( void * ) pxSocket;
 8005510:	9b03      	ldr	r3, [sp, #12]
 8005512:	9306      	str	r3, [sp, #24]
					xSendEventStructToIPTask( &xAskEvent, portMAX_DELAY );
 8005514:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8005518:	a805      	add	r0, sp, #20
 800551a:	f7ff f865 	bl	80045e8 <xSendEventStructToIPTask>
				if( pxClientSocket != NULL )
 800551e:	2c00      	cmp	r4, #0
 8005520:	d198      	bne.n	8005454 <FreeRTOS_accept+0x50>
 8005522:	f04f 0a01 	mov.w	sl, #1
 8005526:	e7a2      	b.n	800546e <FreeRTOS_accept+0x6a>
				if( xAsk != pdFALSE )
 8005528:	f1ba 0f00 	cmp.w	sl, #0
 800552c:	d1ee      	bne.n	800550c <FreeRTOS_accept+0x108>
 800552e:	e791      	b.n	8005454 <FreeRTOS_accept+0x50>

08005530 <FreeRTOS_recv>:
	/*
	 * Read incoming data from a TCP socket
	 * Only after the last byte has been read, a close error might be returned
	 */
	BaseType_t FreeRTOS_recv( Socket_t xSocket, void *pvBuffer, size_t xBufferLength, BaseType_t xFlags )
	{
 8005530:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005534:	b086      	sub	sp, #24
 8005536:	4604      	mov	r4, r0
 8005538:	4689      	mov	r9, r1
 800553a:	4692      	mov	sl, r2
 800553c:	4698      	mov	r8, r3
	TimeOut_t xTimeOut;
	EventBits_t xEventBits = ( EventBits_t ) 0;

		/* Check if the socket is valid, has type TCP and if it is bound to a
		port. */
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800553e:	2201      	movs	r2, #1
 8005540:	2106      	movs	r1, #6
 8005542:	f7ff fba9 	bl	8004c98 <prvValidSocket>
 8005546:	2800      	cmp	r0, #0
 8005548:	f000 80b7 	beq.w	80056ba <FreeRTOS_recv+0x18a>
		{
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.rxStream != NULL )
 800554c:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800554e:	b16a      	cbz	r2, 800556c <FreeRTOS_recv+0x3c>
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 8005550:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8005552:	6811      	ldr	r1, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005554:	6912      	ldr	r2, [r2, #16]
 8005556:	4413      	add	r3, r2
 8005558:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 800555a:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 800555c:	bf98      	it	ls
 800555e:	1a9b      	subls	r3, r3, r2
			{
				xByteCount = ( BaseType_t )uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 8005560:	461d      	mov	r5, r3
			else
			{
				xByteCount = 0;
			}

			while( xByteCount == 0 )
 8005562:	b99b      	cbnz	r3, 800558c <FreeRTOS_recv+0x5c>
 8005564:	2600      	movs	r6, #0
						}
						#endif /* ipconfigSUPPORT_SIGNALS */
						break;
					}

					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8005566:	f008 0710 	and.w	r7, r8, #16
 800556a:	e05b      	b.n	8005624 <FreeRTOS_recv+0xf4>
 800556c:	2600      	movs	r6, #0
 800556e:	4635      	mov	r5, r6
 8005570:	e7f9      	b.n	8005566 <FreeRTOS_recv+0x36>
					if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 8005572:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005576:	f003 0308 	and.w	r3, r3, #8
						xByteCount = -pdFREERTOS_ERRNO_ENOTCONN;
 800557a:	2b00      	cmp	r3, #0
 800557c:	bf14      	ite	ne
 800557e:	f06f 050b 	mvnne.w	r5, #11
 8005582:	f06f 057f 	mvneq.w	r5, #127	; 0x7f
					xByteCount = 0;
				}
			}

		#if( ipconfigSUPPORT_SIGNALS != 0 )
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 8005586:	f016 0f40 	tst.w	r6, #64	; 0x40
 800558a:	d123      	bne.n	80055d4 <FreeRTOS_recv+0xa4>
				}
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
			}
			else
		#endif /* ipconfigSUPPORT_SIGNALS */
			if( xByteCount > 0 )
 800558c:	2d00      	cmp	r5, #0
 800558e:	dd26      	ble.n	80055de <FreeRTOS_recv+0xae>
			{
				if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8005590:	f018 0f01 	tst.w	r8, #1
 8005594:	d063      	beq.n	800565e <FreeRTOS_recv+0x12e>
					}
				}
				else
				{
					/* Zero-copy reception of data: pvBuffer is a pointer to a pointer. */
					xByteCount = ( BaseType_t ) uxStreamBufferGetPtr( pxSocket->u.xTCP.rxStream, (uint8_t **)pvBuffer );
 8005596:	6f62      	ldr	r2, [r4, #116]	; 0x74
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData );
static portINLINE size_t uxStreamBufferGetPtr( StreamBuffer_t *pxBuffer, uint8_t **ppucData )
{
size_t uxNextTail = pxBuffer->uxTail;
 8005598:	6810      	ldr	r0, [r2, #0]
size_t uxHead = pxBuffer->uxHead;
 800559a:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 800559c:	6815      	ldr	r5, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 800559e:	6911      	ldr	r1, [r2, #16]
 80055a0:	440b      	add	r3, r1
 80055a2:	1b5b      	subs	r3, r3, r5
	if ( uxCount >= pxBuffer->LENGTH )
 80055a4:	4299      	cmp	r1, r3
		uxCount -= pxBuffer->LENGTH;
 80055a6:	bf98      	it	ls
 80055a8:	1a5b      	subls	r3, r3, r1
size_t uxSize = uxStreamBufferGetSize( pxBuffer );

	*ppucData = pxBuffer->ucArray + uxNextTail;
 80055aa:	f102 0114 	add.w	r1, r2, #20
 80055ae:	4401      	add	r1, r0
 80055b0:	f8c9 1000 	str.w	r1, [r9]

	return FreeRTOS_min_uint32( uxSize, pxBuffer->LENGTH - uxNextTail );
 80055b4:	6915      	ldr	r5, [r2, #16]
 80055b6:	1a2d      	subs	r5, r5, r0


	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return a >= b ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 80055b8:	429d      	cmp	r5, r3
 80055ba:	bf28      	it	cs
 80055bc:	461d      	movcs	r5, r3
 80055be:	e00e      	b.n	80055de <FreeRTOS_recv+0xae>
							xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_INTR,
 80055c0:	9300      	str	r3, [sp, #0]
 80055c2:	2201      	movs	r2, #1
 80055c4:	2140      	movs	r1, #64	; 0x40
 80055c6:	6860      	ldr	r0, [r4, #4]
 80055c8:	f003 fb2c 	bl	8008c24 <xEventGroupWaitBits>
 80055cc:	4606      	mov	r6, r0
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 80055ce:	f016 0f40 	tst.w	r6, #64	; 0x40
 80055d2:	d075      	beq.n	80056c0 <FreeRTOS_recv+0x190>
				if( ( xEventBits & ( eSOCKET_RECEIVE | eSOCKET_CLOSED ) ) != 0 )
 80055d4:	f016 0f21 	tst.w	r6, #33	; 0x21
 80055d8:	d139      	bne.n	800564e <FreeRTOS_recv+0x11e>
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 80055da:	f06f 0503 	mvn.w	r5, #3
				}
			}
		} /* prvValidSocket() */

		return xByteCount;
	}
 80055de:	4628      	mov	r0, r5
 80055e0:	b006      	add	sp, #24
 80055e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 80055e6:	a905      	add	r1, sp, #20
 80055e8:	a803      	add	r0, sp, #12
 80055ea:	f005 f82b 	bl	800a644 <xTaskCheckForTimeOut>
 80055ee:	2800      	cmp	r0, #0
 80055f0:	d1ed      	bne.n	80055ce <FreeRTOS_recv+0x9e>
				xEventBits = xEventGroupWaitBits( pxSocket->xEventGroup,
 80055f2:	9b05      	ldr	r3, [sp, #20]
 80055f4:	9300      	str	r3, [sp, #0]
 80055f6:	2300      	movs	r3, #0
 80055f8:	2201      	movs	r2, #1
 80055fa:	2161      	movs	r1, #97	; 0x61
 80055fc:	6860      	ldr	r0, [r4, #4]
 80055fe:	f003 fb11 	bl	8008c24 <xEventGroupWaitBits>
 8005602:	4606      	mov	r6, r0
					if( ( xEventBits & eSOCKET_INTR ) != 0u )
 8005604:	f010 0f40 	tst.w	r0, #64	; 0x40
 8005608:	d1e4      	bne.n	80055d4 <FreeRTOS_recv+0xa4>
				if( pxSocket->u.xTCP.rxStream != NULL )
 800560a:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800560c:	2501      	movs	r5, #1
 800560e:	b14a      	cbz	r2, 8005624 <FreeRTOS_recv+0xf4>
size_t uxHead = pxBuffer->uxHead;
 8005610:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8005612:	6811      	ldr	r1, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005614:	6912      	ldr	r2, [r2, #16]
 8005616:	4413      	add	r3, r2
 8005618:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 800561a:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 800561c:	bf98      	it	ls
 800561e:	1a9b      	subls	r3, r3, r2
 8005620:	2501      	movs	r5, #1
			while( xByteCount == 0 )
 8005622:	b993      	cbnz	r3, 800564a <FreeRTOS_recv+0x11a>
				switch( pxSocket->u.xTCP.ucTCPState )
 8005624:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005628:	2b00      	cmp	r3, #0
 800562a:	d0a2      	beq.n	8005572 <FreeRTOS_recv+0x42>
 800562c:	3b08      	subs	r3, #8
 800562e:	2b01      	cmp	r3, #1
 8005630:	d99f      	bls.n	8005572 <FreeRTOS_recv+0x42>
				if( xTimed == pdFALSE )
 8005632:	2d00      	cmp	r5, #0
 8005634:	d1d7      	bne.n	80055e6 <FreeRTOS_recv+0xb6>
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8005636:	69e3      	ldr	r3, [r4, #28]
 8005638:	9305      	str	r3, [sp, #20]
					if( xRemainingTime == ( TickType_t ) 0 )
 800563a:	2b00      	cmp	r3, #0
 800563c:	d0c0      	beq.n	80055c0 <FreeRTOS_recv+0x90>
					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 800563e:	2f00      	cmp	r7, #0
 8005640:	d1c5      	bne.n	80055ce <FreeRTOS_recv+0x9e>
					vTaskSetTimeOutState( &xTimeOut );
 8005642:	a803      	add	r0, sp, #12
 8005644:	f004 ffe8 	bl	800a618 <vTaskSetTimeOutState>
 8005648:	e7cd      	b.n	80055e6 <FreeRTOS_recv+0xb6>
					xByteCount = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.rxStream );
 800564a:	461d      	mov	r5, r3
 800564c:	e79e      	b.n	800558c <FreeRTOS_recv+0x5c>
					xEventGroupSetBits( pxSocket->xEventGroup, xEventBits );
 800564e:	f026 0140 	bic.w	r1, r6, #64	; 0x40
 8005652:	6860      	ldr	r0, [r4, #4]
 8005654:	f003 fb8a 	bl	8008d6c <xEventGroupSetBits>
				xByteCount = -pdFREERTOS_ERRNO_EINTR;
 8005658:	f06f 0503 	mvn.w	r5, #3
 800565c:	e7bf      	b.n	80055de <FreeRTOS_recv+0xae>
					xByteCount = ( BaseType_t ) uxStreamBufferGet( pxSocket->u.xTCP.rxStream, 0ul, ( uint8_t * ) pvBuffer, ( size_t ) xBufferLength, ( xFlags & FREERTOS_MSG_PEEK ) != 0 );
 800565e:	f3c8 0380 	ubfx	r3, r8, #2, #1
 8005662:	9300      	str	r3, [sp, #0]
 8005664:	4653      	mov	r3, sl
 8005666:	464a      	mov	r2, r9
 8005668:	2100      	movs	r1, #0
 800566a:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800566c:	f000 fe39 	bl	80062e2 <uxStreamBufferGet>
 8005670:	4605      	mov	r5, r0
					if( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED )
 8005672:	f994 3040 	ldrsb.w	r3, [r4, #64]	; 0x40
 8005676:	2b00      	cmp	r3, #0
 8005678:	dab1      	bge.n	80055de <FreeRTOS_recv+0xae>
						size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800567a:	6f62      	ldr	r2, [r4, #116]	; 0x74
size_t uxFront = pxBuffer->uxFront;
 800567c:	68d1      	ldr	r1, [r2, #12]
size_t uxTail = pxBuffer->uxTail;
 800567e:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005680:	6912      	ldr	r2, [r2, #16]
 8005682:	4413      	add	r3, r2
 8005684:	3b01      	subs	r3, #1
 8005686:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8005688:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 800568a:	bf98      	it	ls
 800568c:	1a9b      	subls	r3, r3, r2
						if( uxFrontSpace >= pxSocket->u.xTCP.uxEnoughSpace )
 800568e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8005690:	429a      	cmp	r2, r3
 8005692:	d8a4      	bhi.n	80055de <FreeRTOS_recv+0xae>
							pxSocket->u.xTCP.bits.bLowWater = pdFALSE_UNSIGNED;
 8005694:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005698:	f36f 13c7 	bfc	r3, #7, #1
 800569c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
							pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 80056a0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80056a4:	f043 0301 	orr.w	r3, r3, #1
 80056a8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
							pxSocket->u.xTCP.usTimeout = 1u; /* because bLowWater is cleared. */
 80056ac:	2301      	movs	r3, #1
 80056ae:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
							xSendEventToIPTask( eTCPTimerEvent );
 80056b2:	2005      	movs	r0, #5
 80056b4:	f7ff f82e 	bl	8004714 <xSendEventToIPTask>
 80056b8:	e791      	b.n	80055de <FreeRTOS_recv+0xae>
			xByteCount = -pdFREERTOS_ERRNO_EINVAL;
 80056ba:	f06f 0515 	mvn.w	r5, #21
 80056be:	e78e      	b.n	80055de <FreeRTOS_recv+0xae>
			if( ( xEventBits & eSOCKET_INTR ) != 0 )
 80056c0:	2500      	movs	r5, #0
 80056c2:	e78c      	b.n	80055de <FreeRTOS_recv+0xae>

080056c4 <FreeRTOS_send>:
	 * Send data using a TCP socket.  It is not necessary to have the socket
	 * connected already.  Outgoing data will be stored and delivered as soon as
	 * the socket gets connected.
	 */
	BaseType_t FreeRTOS_send( Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags )
	{
 80056c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80056c8:	b089      	sub	sp, #36	; 0x24
 80056ca:	4604      	mov	r4, r0
 80056cc:	460f      	mov	r7, r1
 80056ce:	4615      	mov	r5, r2
 80056d0:	9203      	str	r2, [sp, #12]
 80056d2:	469b      	mov	fp, r3
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 80056d4:	2201      	movs	r2, #1
 80056d6:	2106      	movs	r1, #6
 80056d8:	f7ff fade 	bl	8004c98 <prvValidSocket>
 80056dc:	2800      	cmp	r0, #0
 80056de:	f000 80ba 	beq.w	8005856 <FreeRTOS_send+0x192>
		else if( pxSocket->u.xTCP.bits.bMallocError != pdFALSE_UNSIGNED )
 80056e2:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80056e6:	f013 0f08 	tst.w	r3, #8
 80056ea:	f040 80b8 	bne.w	800585e <FreeRTOS_send+0x19a>
		else if( pxSocket->u.xTCP.ucTCPState == eCLOSED )
 80056ee:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80056f2:	2b00      	cmp	r3, #0
 80056f4:	f000 80b7 	beq.w	8005866 <FreeRTOS_send+0x1a2>
		else if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 80056f8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80056fc:	f013 0f40 	tst.w	r3, #64	; 0x40
 8005700:	f040 80b5 	bne.w	800586e <FreeRTOS_send+0x1aa>
		else if( xDataLength == 0ul )
 8005704:	2d00      	cmp	r5, #0
 8005706:	f000 80b5 	beq.w	8005874 <FreeRTOS_send+0x1b0>
		else if( pxSocket->u.xTCP.txStream == NULL )
 800570a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800570c:	b1a3      	cbz	r3, 8005738 <FreeRTOS_send+0x74>
		xByteCount = ( BaseType_t ) prvTCPSendCheck( pxSocket, uxDataLength );

		if( xByteCount > 0 )
		{
			/* xBytesLeft is number of bytes to send, will count to zero. */
			xBytesLeft = ( BaseType_t ) uxDataLength;
 800570e:	9b03      	ldr	r3, [sp, #12]
 8005710:	9302      	str	r3, [sp, #8]

			/* xByteCount is number of bytes that can be sent now. */
			xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 8005712:	6fa2      	ldr	r2, [r4, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 8005714:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8005716:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005718:	6912      	ldr	r2, [r2, #16]
 800571a:	4413      	add	r3, r2
 800571c:	3b01      	subs	r3, #1
 800571e:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8005720:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8005722:	bf98      	it	ls
 8005724:	1a9b      	subls	r3, r3, r2

			/* While there are still bytes to be sent. */
			while( xBytesLeft > 0 )
 8005726:	9a03      	ldr	r2, [sp, #12]
 8005728:	2a00      	cmp	r2, #0
 800572a:	f340 8087 	ble.w	800583c <FreeRTOS_send+0x178>
 800572e:	4615      	mov	r5, r2
 8005730:	f04f 0a00 	mov.w	sl, #0
						xTaskResumeAll();
					}

					/* Send a message to the IP-task so it can work on this
					socket.  Data is sent, let the IP-task work on it. */
					pxSocket->u.xTCP.usTimeout = 1u;
 8005734:	2601      	movs	r6, #1
 8005736:	e054      	b.n	80057e2 <FreeRTOS_send+0x11e>
				pxSocket->u.xTCP.uxEnoughSpace = ( 4ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why multiply by 4?  Maybe sock80_PERCENT?*/
			}
		}
		else
		{
			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
 8005738:	6f23      	ldr	r3, [r4, #112]	; 0x70
		}

		/* Add an extra 4 (or 8) bytes. */
		uxLength += sizeof( size_t );
 800573a:	3304      	adds	r3, #4

		/* And make the length a multiple of sizeof( size_t ). */
		uxLength &= ~( sizeof( size_t ) - 1u );
 800573c:	f023 0503 	bic.w	r5, r3, #3

		uxSize = sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) + uxLength;

		pxBuffer = ( StreamBuffer_t * )pvPortMallocLarge( uxSize );
 8005740:	f105 0014 	add.w	r0, r5, #20
 8005744:	f003 fd98 	bl	8009278 <pvPortMalloc>

		if( pxBuffer == NULL )
 8005748:	b138      	cbz	r0, 800575a <FreeRTOS_send+0x96>
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
		}
		else
		{
			/* Clear the markers of the stream */
			memset( pxBuffer, '\0', sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 800574a:	2200      	movs	r2, #0
 800574c:	6002      	str	r2, [r0, #0]
 800574e:	6042      	str	r2, [r0, #4]
 8005750:	6082      	str	r2, [r0, #8]
 8005752:	60c2      	str	r2, [r0, #12]
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 8005754:	6105      	str	r5, [r0, #16]
			{
				pxSocket->u.xTCP.rxStream = pxBuffer;
			}
			else
			{
				pxSocket->u.xTCP.txStream = pxBuffer;
 8005756:	67a0      	str	r0, [r4, #120]	; 0x78
 8005758:	e7d9      	b.n	800570e <FreeRTOS_send+0x4a>
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
 800575a:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 800575e:	f043 0308 	orr.w	r3, r3, #8
 8005762:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8005766:	2108      	movs	r1, #8
 8005768:	4620      	mov	r0, r4
 800576a:	f000 ffcb 	bl	8006704 <vTCPStateChange>
			if( pxSocket->u.xTCP.txStream == NULL )
 800576e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005770:	2b00      	cmp	r3, #0
 8005772:	d1cc      	bne.n	800570e <FreeRTOS_send+0x4a>
				xResult = -pdFREERTOS_ERRNO_ENOMEM;
 8005774:	f06f 030b 	mvn.w	r3, #11
 8005778:	9302      	str	r3, [sp, #8]
 800577a:	e068      	b.n	800584e <FreeRTOS_send+0x18a>
					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0ul, ( const uint8_t * ) pvBuffer, ( size_t ) xByteCount );
 800577c:	463a      	mov	r2, r7
 800577e:	2100      	movs	r1, #0
 8005780:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8005782:	f000 fd4a 	bl	800621a <uxStreamBufferAdd>
 8005786:	4681      	mov	r9, r0
 8005788:	4680      	mov	r8, r0
					pxSocket->u.xTCP.usTimeout = 1u;
 800578a:	f8a4 6048 	strh.w	r6, [r4, #72]	; 0x48
					if( xIsCallingFromIPTask() == pdFALSE )
 800578e:	f7fe fe21 	bl	80043d4 <xIsCallingFromIPTask>
 8005792:	2800      	cmp	r0, #0
 8005794:	d044      	beq.n	8005820 <FreeRTOS_send+0x15c>
					if( xBytesLeft == 0 )
 8005796:	ebb5 0508 	subs.w	r5, r5, r8
 800579a:	d058      	beq.n	800584e <FreeRTOS_send+0x18a>
					pvBuffer = ( void * ) ( ( ( const uint8_t * ) pvBuffer) + xByteCount );
 800579c:	444f      	add	r7, r9
				if( xTimed == pdFALSE )
 800579e:	f1ba 0f00 	cmp.w	sl, #0
 80057a2:	d141      	bne.n	8005828 <FreeRTOS_send+0x164>
					xRemainingTime = pxSocket->xSendBlockTime;
 80057a4:	6a23      	ldr	r3, [r4, #32]
 80057a6:	9307      	str	r3, [sp, #28]
					if( xRemainingTime == ( TickType_t ) 0 )
 80057a8:	2b00      	cmp	r3, #0
 80057aa:	d043      	beq.n	8005834 <FreeRTOS_send+0x170>
					if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 80057ac:	f01b 0f10 	tst.w	fp, #16
 80057b0:	d140      	bne.n	8005834 <FreeRTOS_send+0x170>
					vTaskSetTimeOutState( &xTimeOut );
 80057b2:	a805      	add	r0, sp, #20
 80057b4:	f004 ff30 	bl	800a618 <vTaskSetTimeOutState>
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_SEND | eSOCKET_CLOSED,
 80057b8:	9b07      	ldr	r3, [sp, #28]
 80057ba:	9300      	str	r3, [sp, #0]
 80057bc:	2300      	movs	r3, #0
 80057be:	4632      	mov	r2, r6
 80057c0:	2122      	movs	r1, #34	; 0x22
 80057c2:	6860      	ldr	r0, [r4, #4]
 80057c4:	f003 fa2e 	bl	8008c24 <xEventGroupWaitBits>
				xByteCount = ( BaseType_t ) uxStreamBufferGetSpace( pxSocket->u.xTCP.txStream );
 80057c8:	6fa2      	ldr	r2, [r4, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 80057ca:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 80057cc:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 80057ce:	6912      	ldr	r2, [r2, #16]
 80057d0:	4413      	add	r3, r2
 80057d2:	3b01      	subs	r3, #1
 80057d4:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 80057d6:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 80057d8:	bf98      	it	ls
 80057da:	1a9b      	subls	r3, r3, r2
 80057dc:	46b2      	mov	sl, r6
			while( xBytesLeft > 0 )
 80057de:	2d00      	cmp	r5, #0
 80057e0:	dd28      	ble.n	8005834 <FreeRTOS_send+0x170>
				if( xByteCount > 0 )
 80057e2:	2b00      	cmp	r3, #0
 80057e4:	dddb      	ble.n	800579e <FreeRTOS_send+0xda>
 80057e6:	42ab      	cmp	r3, r5
 80057e8:	bfa8      	it	ge
 80057ea:	462b      	movge	r3, r5
					if( ( pxSocket->u.xTCP.bits.bCloseAfterSend != pdFALSE_UNSIGNED ) && ( xByteCount == xBytesLeft ) )
 80057ec:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 80057f0:	f012 0f10 	tst.w	r2, #16
 80057f4:	d0c2      	beq.n	800577c <FreeRTOS_send+0xb8>
 80057f6:	429d      	cmp	r5, r3
 80057f8:	d1c0      	bne.n	800577c <FreeRTOS_send+0xb8>
						vTaskSuspendAll();
 80057fa:	f004 fc11 	bl	800a020 <vTaskSuspendAll>
						pxSocket->u.xTCP.bits.bCloseRequested = pdTRUE_UNSIGNED;
 80057fe:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005802:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005806:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
					xByteCount = ( BaseType_t ) uxStreamBufferAdd( pxSocket->u.xTCP.txStream, 0ul, ( const uint8_t * ) pvBuffer, ( size_t ) xByteCount );
 800580a:	462b      	mov	r3, r5
 800580c:	463a      	mov	r2, r7
 800580e:	2100      	movs	r1, #0
 8005810:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8005812:	f000 fd02 	bl	800621a <uxStreamBufferAdd>
 8005816:	4681      	mov	r9, r0
 8005818:	4680      	mov	r8, r0
						xTaskResumeAll();
 800581a:	f004 fcdb 	bl	800a1d4 <xTaskResumeAll>
 800581e:	e7b4      	b.n	800578a <FreeRTOS_send+0xc6>
						xSendEventToIPTask( eTCPTimerEvent );
 8005820:	2005      	movs	r0, #5
 8005822:	f7fe ff77 	bl	8004714 <xSendEventToIPTask>
 8005826:	e7b6      	b.n	8005796 <FreeRTOS_send+0xd2>
					if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) != pdFALSE )
 8005828:	a907      	add	r1, sp, #28
 800582a:	a805      	add	r0, sp, #20
 800582c:	f004 ff0a 	bl	800a644 <xTaskCheckForTimeOut>
 8005830:	2800      	cmp	r0, #0
 8005832:	d0c1      	beq.n	80057b8 <FreeRTOS_send+0xf4>
			if( xByteCount == 0 )
 8005834:	9b03      	ldr	r3, [sp, #12]
 8005836:	1b5b      	subs	r3, r3, r5
 8005838:	9302      	str	r3, [sp, #8]
 800583a:	d108      	bne.n	800584e <FreeRTOS_send+0x18a>
				if( pxSocket->u.xTCP.ucTCPState > eESTABLISHED )
 800583c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
					xByteCount = ( BaseType_t ) -pdFREERTOS_ERRNO_ENOSPC;
 8005840:	2b05      	cmp	r3, #5
 8005842:	bf8c      	ite	hi
 8005844:	f06f 037f 	mvnhi.w	r3, #127	; 0x7f
 8005848:	f06f 031b 	mvnls.w	r3, #27
 800584c:	9302      	str	r3, [sp, #8]
	}
 800584e:	9802      	ldr	r0, [sp, #8]
 8005850:	b009      	add	sp, #36	; 0x24
 8005852:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xResult = -pdFREERTOS_ERRNO_EINVAL;
 8005856:	f06f 0315 	mvn.w	r3, #21
 800585a:	9302      	str	r3, [sp, #8]
 800585c:	e7f7      	b.n	800584e <FreeRTOS_send+0x18a>
			xResult = -pdFREERTOS_ERRNO_ENOMEM;
 800585e:	f06f 030b 	mvn.w	r3, #11
 8005862:	9302      	str	r3, [sp, #8]
 8005864:	e7f3      	b.n	800584e <FreeRTOS_send+0x18a>
			xResult = -pdFREERTOS_ERRNO_ENOTCONN;
 8005866:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 800586a:	9302      	str	r3, [sp, #8]
 800586c:	e7ef      	b.n	800584e <FreeRTOS_send+0x18a>
			xResult = 0;
 800586e:	2300      	movs	r3, #0
 8005870:	9302      	str	r3, [sp, #8]
 8005872:	e7ec      	b.n	800584e <FreeRTOS_send+0x18a>
			xResult = 0;
 8005874:	2300      	movs	r3, #0
 8005876:	9302      	str	r3, [sp, #8]
 8005878:	e7e9      	b.n	800584e <FreeRTOS_send+0x18a>

0800587a <FreeRTOS_listen>:
	{
 800587a:	b538      	push	{r3, r4, r5, lr}
 800587c:	4604      	mov	r4, r0
 800587e:	460d      	mov	r5, r1
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 8005880:	2201      	movs	r2, #1
 8005882:	2106      	movs	r1, #6
 8005884:	f7ff fa08 	bl	8004c98 <prvValidSocket>
 8005888:	2800      	cmp	r0, #0
 800588a:	d038      	beq.n	80058fe <FreeRTOS_listen+0x84>
		else if( ( pxSocket->u.xTCP.ucTCPState != eCLOSED ) && ( pxSocket->u.xTCP.ucTCPState != eCLOSE_WAIT ) )
 800588c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005890:	f013 0ff7 	tst.w	r3, #247	; 0xf7
 8005894:	d136      	bne.n	8005904 <FreeRTOS_listen+0x8a>
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
 8005896:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800589a:	429d      	cmp	r5, r3
 800589c:	bfa8      	it	ge
 800589e:	461d      	movge	r5, r3
			pxSocket->u.xTCP.usBacklog = ( uint16_t )FreeRTOS_min_int32( ( int32_t ) 0xffff, ( int32_t ) xBacklog );
 80058a0:	f8a4 5050 	strh.w	r5, [r4, #80]	; 0x50
			if( pxSocket->u.xTCP.bits.bReuseSocket )
 80058a4:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80058a8:	f013 0f08 	tst.w	r3, #8
 80058ac:	d021      	beq.n	80058f2 <FreeRTOS_listen+0x78>
				if( pxSocket->u.xTCP.rxStream != NULL )
 80058ae:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80058b0:	b123      	cbz	r3, 80058bc <FreeRTOS_listen+0x42>
	pxBuffer->uxHead = 0u;
 80058b2:	2200      	movs	r2, #0
 80058b4:	609a      	str	r2, [r3, #8]
	pxBuffer->uxTail = 0u;
 80058b6:	601a      	str	r2, [r3, #0]
	pxBuffer->uxFront = 0u;
 80058b8:	60da      	str	r2, [r3, #12]
	pxBuffer->uxMid = 0u;
 80058ba:	605a      	str	r2, [r3, #4]
				if( pxSocket->u.xTCP.txStream != NULL )
 80058bc:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80058be:	b123      	cbz	r3, 80058ca <FreeRTOS_listen+0x50>
	pxBuffer->uxHead = 0u;
 80058c0:	2200      	movs	r2, #0
 80058c2:	609a      	str	r2, [r3, #8]
	pxBuffer->uxTail = 0u;
 80058c4:	601a      	str	r2, [r3, #0]
	pxBuffer->uxFront = 0u;
 80058c6:	60da      	str	r2, [r3, #12]
	pxBuffer->uxMid = 0u;
 80058c8:	605a      	str	r2, [r3, #4]
				memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, '\0', sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 80058ca:	2246      	movs	r2, #70	; 0x46
 80058cc:	2100      	movs	r1, #0
 80058ce:	f104 0082 	add.w	r0, r4, #130	; 0x82
 80058d2:	f006 ff25 	bl	800c720 <memset>
				memset( &pxSocket->u.xTCP.xTCPWindow, '\0', sizeof( pxSocket->u.xTCP.xTCPWindow ) );
 80058d6:	22c0      	movs	r2, #192	; 0xc0
 80058d8:	2100      	movs	r1, #0
 80058da:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
 80058de:	f006 ff1f 	bl	800c720 <memset>
				memset( &pxSocket->u.xTCP.bits, '\0', sizeof( pxSocket->u.xTCP.bits ) );
 80058e2:	2300      	movs	r3, #0
 80058e4:	6423      	str	r3, [r4, #64]	; 0x40
				pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE_UNSIGNED;
 80058e6:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80058ea:	f043 0308 	orr.w	r3, r3, #8
 80058ee:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			vTCPStateChange( pxSocket, eTCP_LISTEN );
 80058f2:	2101      	movs	r1, #1
 80058f4:	4620      	mov	r0, r4
 80058f6:	f000 ff05 	bl	8006704 <vTCPStateChange>
	BaseType_t xResult = 0;
 80058fa:	2000      	movs	r0, #0
 80058fc:	bd38      	pop	{r3, r4, r5, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 80058fe:	f06f 005e 	mvn.w	r0, #94	; 0x5e
 8005902:	bd38      	pop	{r3, r4, r5, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 8005904:	f06f 005e 	mvn.w	r0, #94	; 0x5e
	}
 8005908:	bd38      	pop	{r3, r4, r5, pc}

0800590a <FreeRTOS_shutdown>:
	{
 800590a:	b510      	push	{r4, lr}
 800590c:	4604      	mov	r4, r0
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdTRUE ) == pdFALSE )
 800590e:	2201      	movs	r2, #1
 8005910:	2106      	movs	r1, #6
 8005912:	f7ff f9c1 	bl	8004c98 <prvValidSocket>
 8005916:	b188      	cbz	r0, 800593c <FreeRTOS_shutdown+0x32>
		else if ( pxSocket->u.xTCP.ucTCPState != eESTABLISHED )
 8005918:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 800591c:	2b05      	cmp	r3, #5
 800591e:	d110      	bne.n	8005942 <FreeRTOS_shutdown+0x38>
			pxSocket->u.xTCP.bits.bUserShutdown = pdTRUE_UNSIGNED;
 8005920:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005924:	f043 0320 	orr.w	r3, r3, #32
 8005928:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			pxSocket->u.xTCP.usTimeout = 1u;
 800592c:	2301      	movs	r3, #1
 800592e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
			xSendEventToIPTask( eTCPTimerEvent );
 8005932:	2005      	movs	r0, #5
 8005934:	f7fe feee 	bl	8004714 <xSendEventToIPTask>
			xResult = 0;
 8005938:	2000      	movs	r0, #0
 800593a:	bd10      	pop	{r4, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 800593c:	f06f 005e 	mvn.w	r0, #94	; 0x5e
 8005940:	bd10      	pop	{r4, pc}
			xResult = -pdFREERTOS_ERRNO_EOPNOTSUPP;
 8005942:	f06f 005e 	mvn.w	r0, #94	; 0x5e
	}
 8005946:	bd10      	pop	{r4, pc}

08005948 <xTCPTimerCheck>:
	{
 8005948:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800594c:	4681      	mov	r9, r0
	TickType_t xNow = xTaskGetTickCount();
 800594e:	f004 fb6f 	bl	800a030 <xTaskGetTickCount>
	TickType_t xDelta = xNow - xLastTime;
 8005952:	4b1f      	ldr	r3, [pc, #124]	; (80059d0 <xTCPTimerCheck+0x88>)
 8005954:	681e      	ldr	r6, [r3, #0]
 8005956:	1b86      	subs	r6, r0, r6
	ListItem_t *pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8005958:	4a1e      	ldr	r2, [pc, #120]	; (80059d4 <xTCPTimerCheck+0x8c>)
 800595a:	68d4      	ldr	r4, [r2, #12]
		xLastTime = xNow;
 800595c:	6018      	str	r0, [r3, #0]
			xDelta = 1u;
 800595e:	2e00      	cmp	r6, #0
 8005960:	bf08      	it	eq
 8005962:	2601      	moveq	r6, #1
		while( pxIterator != pxEnd )
 8005964:	f102 0308 	add.w	r3, r2, #8
 8005968:	429c      	cmp	r4, r3
 800596a:	d02c      	beq.n	80059c6 <xTCPTimerCheck+0x7e>
 800596c:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
				pxSocket->u.xTCP.usTimeout = 0u;
 8005970:	f04f 0a00 	mov.w	sl, #0
		while( pxIterator != pxEnd )
 8005974:	461f      	mov	r7, r3
 8005976:	e012      	b.n	800599e <xTCPTimerCheck+0x56>
				pxSocket->u.xTCP.usTimeout = 0u;
 8005978:	f8a5 a048 	strh.w	sl, [r5, #72]	; 0x48
				if( xTCPSocketCheck( pxSocket ) < 0 )
 800597c:	4628      	mov	r0, r5
 800597e:	f001 f935 	bl	8006bec <xTCPSocketCheck>
 8005982:	2800      	cmp	r0, #0
 8005984:	da16      	bge.n	80059b4 <xTCPTimerCheck+0x6c>
 8005986:	e008      	b.n	800599a <xTCPTimerCheck+0x52>
					vSocketWakeUpUser( pxSocket );
 8005988:	4628      	mov	r0, r5
 800598a:	f7ff fd1f 	bl	80053cc <vSocketWakeUpUser>
			if( ( pxSocket->u.xTCP.usTimeout != 0u ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTimeout ) )
 800598e:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 8005992:	b113      	cbz	r3, 800599a <xTCPTimerCheck+0x52>
 8005994:	4598      	cmp	r8, r3
 8005996:	bf28      	it	cs
 8005998:	4698      	movcs	r8, r3
		while( pxIterator != pxEnd )
 800599a:	42bc      	cmp	r4, r7
 800599c:	d015      	beq.n	80059ca <xTCPTimerCheck+0x82>
			pxSocket = ( FreeRTOS_Socket_t * )listGET_LIST_ITEM_OWNER( pxIterator );
 800599e:	68e5      	ldr	r5, [r4, #12]
			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 80059a0:	6864      	ldr	r4, [r4, #4]
			if( pxSocket->u.xTCP.usTimeout == 0u )
 80059a2:	f8b5 3048 	ldrh.w	r3, [r5, #72]	; 0x48
 80059a6:	2b00      	cmp	r3, #0
 80059a8:	d0f7      	beq.n	800599a <xTCPTimerCheck+0x52>
			if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
 80059aa:	42b3      	cmp	r3, r6
 80059ac:	d9e4      	bls.n	8005978 <xTCPTimerCheck+0x30>
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDelta );
 80059ae:	1b9b      	subs	r3, r3, r6
 80059b0:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
			if( pxSocket->xEventBits != 0u )
 80059b4:	682b      	ldr	r3, [r5, #0]
 80059b6:	2b00      	cmp	r3, #0
 80059b8:	d0e9      	beq.n	800598e <xTCPTimerCheck+0x46>
				if( xWillSleep != pdFALSE )
 80059ba:	f1b9 0f00 	cmp.w	r9, #0
 80059be:	d1e3      	bne.n	8005988 <xTCPTimerCheck+0x40>
					xShortest = ( TickType_t ) 0;
 80059c0:	f04f 0800 	mov.w	r8, #0
 80059c4:	e7e3      	b.n	800598e <xTCPTimerCheck+0x46>
		while( pxIterator != pxEnd )
 80059c6:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
	}
 80059ca:	4640      	mov	r0, r8
 80059cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80059d0:	20000570 	.word	0x20000570
 80059d4:	2000283c 	.word	0x2000283c

080059d8 <pxTCPSocketLookup>:
	{
 80059d8:	b4f0      	push	{r4, r5, r6, r7}
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 80059da:	4811      	ldr	r0, [pc, #68]	; (8005a20 <pxTCPSocketLookup+0x48>)
 80059dc:	68c4      	ldr	r4, [r0, #12]
 80059de:	3008      	adds	r0, #8
 80059e0:	4284      	cmp	r4, r0
 80059e2:	d01b      	beq.n	8005a1c <pxTCPSocketLookup+0x44>
 80059e4:	2000      	movs	r0, #0
			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 80059e6:	b289      	uxth	r1, r1
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 80059e8:	b29b      	uxth	r3, r3
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 80059ea:	4f0e      	ldr	r7, [pc, #56]	; (8005a24 <pxTCPSocketLookup+0x4c>)
 80059ec:	e003      	b.n	80059f6 <pxTCPSocketLookup+0x1e>
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 80059ee:	4628      	mov	r0, r5
			 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 80059f0:	6864      	ldr	r4, [r4, #4]
		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 80059f2:	42bc      	cmp	r4, r7
 80059f4:	d010      	beq.n	8005a18 <pxTCPSocketLookup+0x40>
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 80059f6:	68e5      	ldr	r5, [r4, #12]
			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 80059f8:	8cae      	ldrh	r6, [r5, #36]	; 0x24
 80059fa:	428e      	cmp	r6, r1
 80059fc:	d1f8      	bne.n	80059f0 <pxTCPSocketLookup+0x18>
				if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 80059fe:	f895 6053 	ldrb.w	r6, [r5, #83]	; 0x53
 8005a02:	2e01      	cmp	r6, #1
 8005a04:	d0f3      	beq.n	80059ee <pxTCPSocketLookup+0x16>
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 8005a06:	8fae      	ldrh	r6, [r5, #60]	; 0x3c
 8005a08:	429e      	cmp	r6, r3
 8005a0a:	d1f1      	bne.n	80059f0 <pxTCPSocketLookup+0x18>
 8005a0c:	6bae      	ldr	r6, [r5, #56]	; 0x38
 8005a0e:	4296      	cmp	r6, r2
 8005a10:	d1ee      	bne.n	80059f0 <pxTCPSocketLookup+0x18>
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8005a12:	2d00      	cmp	r5, #0
 8005a14:	bf18      	it	ne
 8005a16:	4628      	movne	r0, r5
	}
 8005a18:	bcf0      	pop	{r4, r5, r6, r7}
 8005a1a:	4770      	bx	lr
	FreeRTOS_Socket_t *pxResult = NULL, *pxListenSocket = NULL;
 8005a1c:	2000      	movs	r0, #0
 8005a1e:	e7fb      	b.n	8005a18 <pxTCPSocketLookup+0x40>
 8005a20:	2000283c 	.word	0x2000283c
 8005a24:	20002844 	.word	0x20002844

08005a28 <lTCPAddRxdata>:
	/*
	 * Add data to the RxStream.  When uxOffset > 0, data has come in out-of-order
	 * and will be put in front of the head so it can not be popped by the user.
	 */
	int32_t lTCPAddRxdata( FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount )
	{
 8005a28:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005a2c:	4604      	mov	r4, r0
 8005a2e:	460e      	mov	r6, r1
 8005a30:	4617      	mov	r7, r2
 8005a32:	4698      	mov	r8, r3
	StreamBuffer_t *pxStream = pxSocket->u.xTCP.rxStream;
 8005a34:	6f45      	ldr	r5, [r0, #116]	; 0x74
		/* int32_t uxStreamBufferAdd( pxBuffer, uxOffset, pucData, aCount )
		if( pucData != NULL ) copy data the the buffer
		if( pucData == NULL ) no copying, just advance rxHead
		if( uxOffset != 0 ) Just store data which has come out-of-order
		if( uxOffset == 0 ) Also advance rxHead */
		if( pxStream == NULL )
 8005a36:	b345      	cbz	r5, 8005a8a <lTCPAddRxdata+0x62>
				pcData = NULL;
			}
		}
		#endif /* ipconfigUSE_CALLBACKS */

		xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
 8005a38:	4643      	mov	r3, r8
 8005a3a:	463a      	mov	r2, r7
 8005a3c:	4631      	mov	r1, r6
 8005a3e:	4628      	mov	r0, r5
 8005a40:	f000 fbeb 	bl	800621a <uxStreamBufferAdd>
 8005a44:	4605      	mov	r5, r0
					pxStream->uxFront ) );
			}
		}
		#endif /* ipconfigHAS_DEBUG_PRINTF */

		if( uxOffset == 0u )
 8005a46:	b9ee      	cbnz	r6, 8005a84 <lTCPAddRxdata+0x5c>
					}
				} else
			#endif /* ipconfigUSE_CALLBACKS */
			{
				/* See if running out of space. */
				if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
 8005a48:	f994 3040 	ldrsb.w	r3, [r4, #64]	; 0x40
 8005a4c:	2b00      	cmp	r3, #0
 8005a4e:	db0c      	blt.n	8005a6a <lTCPAddRxdata+0x42>
				{
					size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 8005a50:	6f62      	ldr	r2, [r4, #116]	; 0x74
size_t uxFront = pxBuffer->uxFront;
 8005a52:	68d1      	ldr	r1, [r2, #12]
size_t uxTail = pxBuffer->uxTail;
 8005a54:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005a56:	6912      	ldr	r2, [r2, #16]
 8005a58:	4413      	add	r3, r2
 8005a5a:	3b01      	subs	r3, #1
 8005a5c:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8005a5e:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 8005a60:	bf98      	it	ls
 8005a62:	1a9b      	subls	r3, r3, r2
					if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace  )
 8005a64:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005a66:	429a      	cmp	r2, r3
 8005a68:	d23f      	bcs.n	8005aea <lTCPAddRxdata+0xc2>
					}
				}

				/* New incoming data is available, wake up the user.   User's
				semaphores will be set just before the IP-task goes asleep. */
				pxSocket->xEventBits |= eSOCKET_RECEIVE;
 8005a6a:	6823      	ldr	r3, [r4, #0]
 8005a6c:	f043 0201 	orr.w	r2, r3, #1
 8005a70:	6022      	str	r2, [r4, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
 8005a72:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005a74:	f012 0f01 	tst.w	r2, #1
 8005a78:	d004      	beq.n	8005a84 <lTCPAddRxdata+0x5c>
					{
						pxSocket->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
 8005a7a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005a7e:	f043 0301 	orr.w	r3, r3, #1
 8005a82:	6023      	str	r3, [r4, #0]
				#endif
			}
		}

		return xResult;
	}
 8005a84:	4628      	mov	r0, r5
 8005a86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			uxLength = pxSocket->u.xTCP.uxRxStreamSize;
 8005a8a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
			if( pxSocket->u.xTCP.uxLittleSpace == 0ul )
 8005a8c:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8005a8e:	b92a      	cbnz	r2, 8005a9c <lTCPAddRxdata+0x74>
				pxSocket->u.xTCP.uxLittleSpace  = ( 1ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why divide by 5?  Can this be changed to a #define? */
 8005a90:	f1a2 3233 	sub.w	r2, r2, #858993459	; 0x33333333
 8005a94:	fba2 1203 	umull	r1, r2, r2, r3
 8005a98:	0892      	lsrs	r2, r2, #2
 8005a9a:	6642      	str	r2, [r0, #100]	; 0x64
			if( pxSocket->u.xTCP.uxEnoughSpace == 0ul )
 8005a9c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8005a9e:	b92a      	cbnz	r2, 8005aac <lTCPAddRxdata+0x84>
				pxSocket->u.xTCP.uxEnoughSpace = ( 4ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why multiply by 4?  Maybe sock80_PERCENT?*/
 8005aa0:	009a      	lsls	r2, r3, #2
 8005aa2:	491b      	ldr	r1, [pc, #108]	; (8005b10 <lTCPAddRxdata+0xe8>)
 8005aa4:	fba1 1202 	umull	r1, r2, r1, r2
 8005aa8:	0892      	lsrs	r2, r2, #2
 8005aaa:	66a2      	str	r2, [r4, #104]	; 0x68
		uxLength += sizeof( size_t );
 8005aac:	3304      	adds	r3, #4
		uxLength &= ~( sizeof( size_t ) - 1u );
 8005aae:	f023 0903 	bic.w	r9, r3, #3
		pxBuffer = ( StreamBuffer_t * )pvPortMallocLarge( uxSize );
 8005ab2:	f109 0014 	add.w	r0, r9, #20
 8005ab6:	f003 fbdf 	bl	8009278 <pvPortMalloc>
		if( pxBuffer == NULL )
 8005aba:	4605      	mov	r5, r0
 8005abc:	b140      	cbz	r0, 8005ad0 <lTCPAddRxdata+0xa8>
			memset( pxBuffer, '\0', sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 8005abe:	2300      	movs	r3, #0
 8005ac0:	6003      	str	r3, [r0, #0]
 8005ac2:	6043      	str	r3, [r0, #4]
 8005ac4:	6083      	str	r3, [r0, #8]
 8005ac6:	60c3      	str	r3, [r0, #12]
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 8005ac8:	f8c0 9010 	str.w	r9, [r0, #16]
				pxSocket->u.xTCP.rxStream = pxBuffer;
 8005acc:	6760      	str	r0, [r4, #116]	; 0x74
 8005ace:	e7b3      	b.n	8005a38 <lTCPAddRxdata+0x10>
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
 8005ad0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005ad4:	f043 0308 	orr.w	r3, r3, #8
 8005ad8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8005adc:	2108      	movs	r1, #8
 8005ade:	4620      	mov	r0, r4
 8005ae0:	f000 fe10 	bl	8006704 <vTCPStateChange>
				return -1;
 8005ae4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8005ae8:	e7cc      	b.n	8005a84 <lTCPAddRxdata+0x5c>
						pxSocket->u.xTCP.bits.bLowWater = pdTRUE_UNSIGNED;
 8005aea:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005aee:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005af2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
						pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8005af6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8005afa:	f043 0301 	orr.w	r3, r3, #1
 8005afe:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
						pxSocket->u.xTCP.usTimeout = 1u;
 8005b02:	2301      	movs	r3, #1
 8005b04:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
 8005b08:	2005      	movs	r0, #5
 8005b0a:	f7fe fe03 	bl	8004714 <xSendEventToIPTask>
 8005b0e:	e7ac      	b.n	8005a6a <lTCPAddRxdata+0x42>
 8005b10:	cccccccd 	.word	0xcccccccd

08005b14 <FreeRTOS_tx_space>:
	BaseType_t FreeRTOS_tx_space( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005b14:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005b18:	2b06      	cmp	r3, #6
 8005b1a:	d10d      	bne.n	8005b38 <FreeRTOS_tx_space+0x24>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 8005b1c:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8005b1e:	b14b      	cbz	r3, 8005b34 <FreeRTOS_tx_space+0x20>
size_t uxHead = pxBuffer->uxHead;
 8005b20:	689a      	ldr	r2, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 8005b22:	6818      	ldr	r0, [r3, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8005b24:	691b      	ldr	r3, [r3, #16]
 8005b26:	4418      	add	r0, r3
 8005b28:	3801      	subs	r0, #1
 8005b2a:	1a80      	subs	r0, r0, r2
	if( uxCount >= pxBuffer->LENGTH )
 8005b2c:	4283      	cmp	r3, r0
 8005b2e:	d805      	bhi.n	8005b3c <FreeRTOS_tx_space+0x28>
		uxCount -= pxBuffer->LENGTH;
 8005b30:	1ac0      	subs	r0, r0, r3
 8005b32:	4770      	bx	lr
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSpace ( pxSocket->u.xTCP.txStream );
			}
			else
			{
				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 8005b34:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8005b36:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005b38:	f06f 0015 	mvn.w	r0, #21
			}
		}

		return xReturn;
	}
 8005b3c:	4770      	bx	lr

08005b3e <FreeRTOS_tx_size>:
	BaseType_t FreeRTOS_tx_size( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005b3e:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005b42:	2b06      	cmp	r3, #6
 8005b44:	d10a      	bne.n	8005b5c <FreeRTOS_tx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 8005b46:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8005b48:	b15b      	cbz	r3, 8005b62 <FreeRTOS_tx_size+0x24>
size_t uxHead = pxBuffer->uxHead;
 8005b4a:	6898      	ldr	r0, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 8005b4c:	681a      	ldr	r2, [r3, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005b4e:	691b      	ldr	r3, [r3, #16]
 8005b50:	4418      	add	r0, r3
 8005b52:	1a80      	subs	r0, r0, r2
	if ( uxCount >= pxBuffer->LENGTH )
 8005b54:	4283      	cmp	r3, r0
 8005b56:	d805      	bhi.n	8005b64 <FreeRTOS_tx_size+0x26>
		uxCount -= pxBuffer->LENGTH;
 8005b58:	1ac0      	subs	r0, r0, r3
 8005b5a:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005b5c:	f06f 0015 	mvn.w	r0, #21
 8005b60:	4770      	bx	lr
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.txStream );
			}
			else
			{
				xReturn = 0;
 8005b62:	2000      	movs	r0, #0
			}
		}

		return xReturn;
	}
 8005b64:	4770      	bx	lr
	...

08005b68 <FreeRTOS_setsockopt>:
{
 8005b68:	b570      	push	{r4, r5, r6, lr}
 8005b6a:	b082      	sub	sp, #8
 8005b6c:	4615      	mov	r5, r2
 8005b6e:	461e      	mov	r6, r3
	configASSERT( xSocket );
 8005b70:	4604      	mov	r4, r0
 8005b72:	b1a0      	cbz	r0, 8005b9e <FreeRTOS_setsockopt+0x36>
	switch( lOptionName )
 8005b74:	2d0f      	cmp	r5, #15
 8005b76:	f200 810c 	bhi.w	8005d92 <FreeRTOS_setsockopt+0x22a>
 8005b7a:	e8df f015 	tbh	[pc, r5, lsl #1]
 8005b7e:	0016      	.short	0x0016
 8005b80:	002c001c 	.word	0x002c001c
 8005b84:	003d010a 	.word	0x003d010a
 8005b88:	010a003d 	.word	0x010a003d
 8005b8c:	010a010a 	.word	0x010a010a
 8005b90:	010a010a 	.word	0x010a010a
 8005b94:	00a70091 	.word	0x00a70091
 8005b98:	00bc0060 	.word	0x00bc0060
 8005b9c:	00e9      	.short	0x00e9
	configASSERT( xSocket );
 8005b9e:	f44f 61a8 	mov.w	r1, #1344	; 0x540
 8005ba2:	488f      	ldr	r0, [pc, #572]	; (8005de0 <FreeRTOS_setsockopt+0x278>)
 8005ba4:	f006 fbdc 	bl	800c360 <vAssertCalled>
 8005ba8:	e7e4      	b.n	8005b74 <FreeRTOS_setsockopt+0xc>
			pxSocket->xReceiveBlockTime = *( ( TickType_t * ) pvOptionValue );
 8005baa:	6833      	ldr	r3, [r6, #0]
 8005bac:	61e3      	str	r3, [r4, #28]
			xReturn = 0;
 8005bae:	2300      	movs	r3, #0
} /* Tested */
 8005bb0:	4618      	mov	r0, r3
 8005bb2:	b002      	add	sp, #8
 8005bb4:	bd70      	pop	{r4, r5, r6, pc}
			pxSocket->xSendBlockTime = *( ( TickType_t * ) pvOptionValue );
 8005bb6:	6833      	ldr	r3, [r6, #0]
 8005bb8:	6223      	str	r3, [r4, #32]
			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8005bba:	f894 2027 	ldrb.w	r2, [r4, #39]	; 0x27
 8005bbe:	2a11      	cmp	r2, #17
 8005bc0:	d001      	beq.n	8005bc6 <FreeRTOS_setsockopt+0x5e>
			xReturn = 0;
 8005bc2:	2300      	movs	r3, #0
 8005bc4:	e7f4      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
				if( pxSocket->xSendBlockTime > ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS )
 8005bc6:	f241 3288 	movw	r2, #5000	; 0x1388
 8005bca:	4293      	cmp	r3, r2
 8005bcc:	f240 80e4 	bls.w	8005d98 <FreeRTOS_setsockopt+0x230>
					pxSocket->xSendBlockTime = ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS;
 8005bd0:	6222      	str	r2, [r4, #32]
			xReturn = 0;
 8005bd2:	2300      	movs	r3, #0
 8005bd4:	e7ec      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
			lOptionValue = ( BaseType_t ) pvOptionValue;
 8005bd6:	4633      	mov	r3, r6
			if( lOptionValue == 0 )
 8005bd8:	b936      	cbnz	r6, 8005be8 <FreeRTOS_setsockopt+0x80>
				pxSocket->ucSocketOptions &= ( uint8_t ) ~FREERTOS_SO_UDPCKSUM_OUT;
 8005bda:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
 8005bde:	f022 0202 	bic.w	r2, r2, #2
 8005be2:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
 8005be6:	e7e3      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
				pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8005be8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8005bec:	f043 0302 	orr.w	r3, r3, #2
 8005bf0:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
			xReturn = 0;
 8005bf4:	2300      	movs	r3, #0
 8005bf6:	e7db      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005bf8:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005bfc:	2b06      	cmp	r3, #6
 8005bfe:	f040 80cd 	bne.w	8005d9c <FreeRTOS_setsockopt+0x234>
					if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 8005c02:	2d04      	cmp	r5, #4
 8005c04:	d005      	beq.n	8005c12 <FreeRTOS_setsockopt+0xaa>
 8005c06:	2d05      	cmp	r5, #5
 8005c08:	d013      	beq.n	8005c32 <FreeRTOS_setsockopt+0xca>
					ulNewValue = *( ( uint32_t * ) pvOptionValue );
 8005c0a:	6833      	ldr	r3, [r6, #0]
						pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
 8005c0c:	66e3      	str	r3, [r4, #108]	; 0x6c
				xReturn = 0;
 8005c0e:	2300      	movs	r3, #0
 8005c10:	e7ce      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
					if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 8005c12:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005c14:	2b00      	cmp	r3, #0
 8005c16:	f040 80c4 	bne.w	8005da2 <FreeRTOS_setsockopt+0x23a>
						ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 8005c1a:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d) { return d * ( ( a + d - 1u ) / d ); }
 8005c1e:	6833      	ldr	r3, [r6, #0]
 8005c20:	3b01      	subs	r3, #1
 8005c22:	4413      	add	r3, r2
 8005c24:	fbb3 f3f2 	udiv	r3, r3, r2
 8005c28:	fb02 f303 	mul.w	r3, r2, r3
						pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 8005c2c:	6723      	str	r3, [r4, #112]	; 0x70
				xReturn = 0;
 8005c2e:	2300      	movs	r3, #0
 8005c30:	e7be      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
						( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 8005c32:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8005c34:	2b00      	cmp	r3, #0
 8005c36:	f040 80b7 	bne.w	8005da8 <FreeRTOS_setsockopt+0x240>
					ulNewValue = *( ( uint32_t * ) pvOptionValue );
 8005c3a:	6833      	ldr	r3, [r6, #0]
 8005c3c:	e7e6      	b.n	8005c0c <FreeRTOS_setsockopt+0xa4>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005c3e:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005c42:	2b06      	cmp	r3, #6
 8005c44:	f040 80b3 	bne.w	8005dae <FreeRTOS_setsockopt+0x246>
					if( ( pxSocket->u.xTCP.txStream != NULL ) || ( pxSocket->u.xTCP.rxStream != NULL ) )
 8005c48:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005c4a:	2b00      	cmp	r3, #0
 8005c4c:	f040 80b2 	bne.w	8005db4 <FreeRTOS_setsockopt+0x24c>
 8005c50:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8005c52:	2b00      	cmp	r3, #0
 8005c54:	f040 80b1 	bne.w	8005dba <FreeRTOS_setsockopt+0x252>
					FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDBUF, &( pxProps->lTxBufSize ), sizeof( pxProps->lTxBufSize ) );
 8005c58:	2504      	movs	r5, #4
 8005c5a:	9500      	str	r5, [sp, #0]
 8005c5c:	4633      	mov	r3, r6
 8005c5e:	462a      	mov	r2, r5
 8005c60:	2100      	movs	r1, #0
 8005c62:	4620      	mov	r0, r4
 8005c64:	f7ff ff80 	bl	8005b68 <FreeRTOS_setsockopt>
					FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVBUF, &( pxProps->lRxBufSize ), sizeof( pxProps->lRxBufSize ) );
 8005c68:	9500      	str	r5, [sp, #0]
 8005c6a:	f106 0308 	add.w	r3, r6, #8
 8005c6e:	2205      	movs	r2, #5
 8005c70:	2100      	movs	r1, #0
 8005c72:	4620      	mov	r0, r4
 8005c74:	f7ff ff78 	bl	8005b68 <FreeRTOS_setsockopt>
						pxSocket->u.xTCP.uxRxWinSize = ( uint32_t )pxProps->lRxWinSize;	/* Fixed value: size of the TCP reception window */
 8005c78:	68f3      	ldr	r3, [r6, #12]
 8005c7a:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
						pxSocket->u.xTCP.uxTxWinSize = ( uint32_t )pxProps->lTxWinSize;	/* Fixed value: size of the TCP transmit window */
 8005c7e:	6873      	ldr	r3, [r6, #4]
 8005c80:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
					if( pxSocket->u.xTCP.xTCPWindow.u.bits.bHasInit != pdFALSE_UNSIGNED )
 8005c84:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
 8005c88:	f012 0f01 	tst.w	r2, #1
 8005c8c:	f000 8098 	beq.w	8005dc0 <FreeRTOS_setsockopt+0x258>
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxRxWinSize * pxSocket->u.xTCP.usInitMSS;
 8005c90:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket->u.xTCP.usInitMSS;
 8005c94:	fb03 f302 	mul.w	r3, r3, r2
 8005c98:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
				xReturn = 0;
 8005c9c:	2300      	movs	r3, #0
 8005c9e:	e787      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005ca0:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005ca4:	2b06      	cmp	r3, #6
 8005ca6:	f040 808d 	bne.w	8005dc4 <FreeRTOS_setsockopt+0x25c>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 8005caa:	6833      	ldr	r3, [r6, #0]
 8005cac:	b13b      	cbz	r3, 8005cbe <FreeRTOS_setsockopt+0x156>
						pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE_UNSIGNED;
 8005cae:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005cb2:	f043 0308 	orr.w	r3, r3, #8
 8005cb6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
				xReturn = 0;
 8005cba:	2300      	movs	r3, #0
 8005cbc:	e778      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE_UNSIGNED;
 8005cbe:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8005cc2:	f36f 02c3 	bfc	r2, #3, #1
 8005cc6:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 8005cca:	e771      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005ccc:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005cd0:	2b06      	cmp	r3, #6
 8005cd2:	d17a      	bne.n	8005dca <FreeRTOS_setsockopt+0x262>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 8005cd4:	6833      	ldr	r3, [r6, #0]
 8005cd6:	b13b      	cbz	r3, 8005ce8 <FreeRTOS_setsockopt+0x180>
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE_UNSIGNED;
 8005cd8:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8005cdc:	f043 0310 	orr.w	r3, r3, #16
 8005ce0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
				xReturn = 0;
 8005ce4:	2300      	movs	r3, #0
 8005ce6:	e763      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE_UNSIGNED;
 8005ce8:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8005cec:	f36f 1204 	bfc	r2, #4, #1
 8005cf0:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
 8005cf4:	e75c      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005cf6:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005cfa:	2b06      	cmp	r3, #6
 8005cfc:	d168      	bne.n	8005dd0 <FreeRTOS_setsockopt+0x268>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 8005cfe:	6833      	ldr	r3, [r6, #0]
 8005d00:	b183      	cbz	r3, 8005d24 <FreeRTOS_setsockopt+0x1bc>
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdTRUE_UNSIGNED;
 8005d02:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 8005d06:	f043 0302 	orr.w	r3, r3, #2
 8005d0a:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
 8005d0e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 8005d12:	f013 0f02 	tst.w	r3, #2
 8005d16:	d15e      	bne.n	8005dd6 <FreeRTOS_setsockopt+0x26e>
 8005d18:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005d1c:	2b04      	cmp	r3, #4
 8005d1e:	d808      	bhi.n	8005d32 <FreeRTOS_setsockopt+0x1ca>
				xReturn = 0;
 8005d20:	2300      	movs	r3, #0
 8005d22:	e745      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE_UNSIGNED;
 8005d24:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 8005d28:	f36f 0341 	bfc	r3, #1, #1
 8005d2c:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
 8005d30:	e7ed      	b.n	8005d0e <FreeRTOS_setsockopt+0x1a6>
						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
 8005d32:	4620      	mov	r0, r4
 8005d34:	f7ff ff03 	bl	8005b3e <FreeRTOS_tx_size>
						( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8005d38:	4603      	mov	r3, r0
 8005d3a:	2800      	cmp	r0, #0
 8005d3c:	f43f af38 	beq.w	8005bb0 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.usTimeout = 1u; /* to set/clear bSendFullSize */
 8005d40:	2301      	movs	r3, #1
 8005d42:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
 8005d46:	2005      	movs	r0, #5
 8005d48:	f7fe fce4 	bl	8004714 <xSendEventToIPTask>
				xReturn = 0;
 8005d4c:	2300      	movs	r3, #0
 8005d4e:	e72f      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005d50:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 8005d54:	2b06      	cmp	r3, #6
 8005d56:	d140      	bne.n	8005dda <FreeRTOS_setsockopt+0x272>
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 8005d58:	6833      	ldr	r3, [r6, #0]
 8005d5a:	b19b      	cbz	r3, 8005d84 <FreeRTOS_setsockopt+0x21c>
						pxSocket->u.xTCP.bits.bRxStopped = pdTRUE_UNSIGNED;
 8005d5c:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005d60:	f043 0304 	orr.w	r3, r3, #4
 8005d64:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
					pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8005d68:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8005d6c:	f043 0301 	orr.w	r3, r3, #1
 8005d70:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = 1u; /* to set/clear bRxStopped */
 8005d74:	2301      	movs	r3, #1
 8005d76:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
					xSendEventToIPTask( eTCPTimerEvent );
 8005d7a:	2005      	movs	r0, #5
 8005d7c:	f7fe fcca 	bl	8004714 <xSendEventToIPTask>
				xReturn = 0;
 8005d80:	2300      	movs	r3, #0
				break;
 8005d82:	e715      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
						pxSocket->u.xTCP.bits.bRxStopped = pdFALSE_UNSIGNED;
 8005d84:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005d88:	f36f 0382 	bfc	r3, #2, #1
 8005d8c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8005d90:	e7ea      	b.n	8005d68 <FreeRTOS_setsockopt+0x200>
			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
 8005d92:	f06f 036c 	mvn.w	r3, #108	; 0x6c
 8005d96:	e70b      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
			xReturn = 0;
 8005d98:	2300      	movs	r3, #0
 8005d9a:	e709      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005d9c:	f06f 0315 	mvn.w	r3, #21
 8005da0:	e706      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005da2:	f06f 0315 	mvn.w	r3, #21
 8005da6:	e703      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005da8:	f06f 0315 	mvn.w	r3, #21
 8005dac:	e700      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005dae:	f06f 0315 	mvn.w	r3, #21
 8005db2:	e6fd      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005db4:	f06f 0315 	mvn.w	r3, #21
 8005db8:	e6fa      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005dba:	f06f 0315 	mvn.w	r3, #21
 8005dbe:	e6f7      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
				xReturn = 0;
 8005dc0:	2300      	movs	r3, #0
 8005dc2:	e6f5      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005dc4:	f06f 0315 	mvn.w	r3, #21
 8005dc8:	e6f2      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005dca:	f06f 0315 	mvn.w	r3, #21
 8005dce:	e6ef      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005dd0:	f06f 0315 	mvn.w	r3, #21
 8005dd4:	e6ec      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
				xReturn = 0;
 8005dd6:	2300      	movs	r3, #0
 8005dd8:	e6ea      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005dda:	f06f 0315 	mvn.w	r3, #21
	return xReturn;
 8005dde:	e6e7      	b.n	8005bb0 <FreeRTOS_setsockopt+0x48>
 8005de0:	0800cb68 	.word	0x0800cb68

08005de4 <FreeRTOS_issocketconnected>:
	BaseType_t FreeRTOS_issocketconnected( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn = pdFALSE;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005de4:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005de8:	2b06      	cmp	r3, #6
 8005dea:	d108      	bne.n	8005dfe <FreeRTOS_issocketconnected+0x1a>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
		{
			if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
 8005dec:	f890 0053 	ldrb.w	r0, [r0, #83]	; 0x53
 8005df0:	3805      	subs	r0, #5
 8005df2:	b2c0      	uxtb	r0, r0
 8005df4:	2802      	cmp	r0, #2
 8005df6:	bf8c      	ite	hi
 8005df8:	2000      	movhi	r0, #0
 8005dfa:	2001      	movls	r0, #1
 8005dfc:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005dfe:	f06f 0015 	mvn.w	r0, #21
				}
			}
		}

		return xReturn;
	}
 8005e02:	4770      	bx	lr

08005e04 <FreeRTOS_connect>:
	{
 8005e04:	b570      	push	{r4, r5, r6, lr}
 8005e06:	b086      	sub	sp, #24
 8005e08:	4604      	mov	r4, r0
 8005e0a:	460d      	mov	r5, r1
		if( prvValidSocket( pxSocket, FREERTOS_IPPROTO_TCP, pdFALSE ) == pdFALSE )
 8005e0c:	2200      	movs	r2, #0
 8005e0e:	2106      	movs	r1, #6
 8005e10:	f7fe ff42 	bl	8004c98 <prvValidSocket>
 8005e14:	2800      	cmp	r0, #0
 8005e16:	d06c      	beq.n	8005ef2 <FreeRTOS_connect+0xee>
		else if( FreeRTOS_issocketconnected( pxSocket ) > 0 )
 8005e18:	4620      	mov	r0, r4
 8005e1a:	f7ff ffe3 	bl	8005de4 <FreeRTOS_issocketconnected>
 8005e1e:	2800      	cmp	r0, #0
 8005e20:	dd02      	ble.n	8005e28 <FreeRTOS_connect+0x24>
			xResult = -pdFREERTOS_ERRNO_EISCONN;
 8005e22:	f06f 037e 	mvn.w	r3, #126	; 0x7e
 8005e26:	e066      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
		else if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
 8005e28:	69a3      	ldr	r3, [r4, #24]
 8005e2a:	b14b      	cbz	r3, 8005e40 <FreeRTOS_connect+0x3c>
		switch( pxSocket->u.xTCP.ucTCPState )
 8005e2c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005e30:	2b02      	cmp	r3, #2
 8005e32:	d063      	beq.n	8005efc <FreeRTOS_connect+0xf8>
 8005e34:	2b08      	cmp	r3, #8
 8005e36:	d00c      	beq.n	8005e52 <FreeRTOS_connect+0x4e>
 8005e38:	b15b      	cbz	r3, 8005e52 <FreeRTOS_connect+0x4e>
			default:			return -pdFREERTOS_ERRNO_EAGAIN;
 8005e3a:	f06f 030a 	mvn.w	r3, #10
 8005e3e:	e05a      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
			xResult = FreeRTOS_bind( ( Socket_t ) pxSocket, NULL, 0u );
 8005e40:	2200      	movs	r2, #0
 8005e42:	4611      	mov	r1, r2
 8005e44:	4620      	mov	r0, r4
 8005e46:	f7ff f8b0 	bl	8004faa <FreeRTOS_bind>
		if( xResult == 0 )
 8005e4a:	4603      	mov	r3, r0
 8005e4c:	2800      	cmp	r0, #0
 8005e4e:	d0ed      	beq.n	8005e2c <FreeRTOS_connect+0x28>
 8005e50:	e051      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
				pxSocket->u.xTCP.bits.bConnPrepared = pdFALSE_UNSIGNED;
 8005e52:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8005e56:	f36f 03c3 	bfc	r3, #3, #1
 8005e5a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
				pxSocket->u.xTCP.ucRepCount = 0u;
 8005e5e:	2300      	movs	r3, #0
 8005e60:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
				pxSocket->u.xTCP.usRemotePort = FreeRTOS_ntohs( pxAddress->sin_port );
 8005e64:	886a      	ldrh	r2, [r5, #2]
 8005e66:	0a13      	lsrs	r3, r2, #8
 8005e68:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005e6c:	87a3      	strh	r3, [r4, #60]	; 0x3c
				pxSocket->u.xTCP.ulRemoteIP = FreeRTOS_ntohl( pxAddress->sin_addr );
 8005e6e:	686b      	ldr	r3, [r5, #4]
 8005e70:	0e1a      	lsrs	r2, r3, #24
 8005e72:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8005e76:	0219      	lsls	r1, r3, #8
 8005e78:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8005e7c:	430a      	orrs	r2, r1
 8005e7e:	0a1b      	lsrs	r3, r3, #8
 8005e80:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005e84:	4313      	orrs	r3, r2
 8005e86:	63a3      	str	r3, [r4, #56]	; 0x38
				vTCPStateChange( pxSocket, eCONNECT_SYN );
 8005e88:	2102      	movs	r1, #2
 8005e8a:	4620      	mov	r0, r4
 8005e8c:	f000 fc3a 	bl	8006704 <vTCPStateChange>
				pxSocket->u.xTCP.usTimeout = 1u;
 8005e90:	2301      	movs	r3, #1
 8005e92:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
				if( xSendEventToIPTask( eTCPTimerEvent ) != pdPASS )
 8005e96:	2005      	movs	r0, #5
 8005e98:	f7fe fc3c 	bl	8004714 <xSendEventToIPTask>
 8005e9c:	4605      	mov	r5, r0
 8005e9e:	2801      	cmp	r0, #1
 8005ea0:	d12f      	bne.n	8005f02 <FreeRTOS_connect+0xfe>
 8005ea2:	2300      	movs	r3, #0
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_CONNECT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 8005ea4:	461e      	mov	r6, r3
 8005ea6:	e013      	b.n	8005ed0 <FreeRTOS_connect+0xcc>
				xResult = FreeRTOS_issocketconnected( pxSocket );
 8005ea8:	4620      	mov	r0, r4
 8005eaa:	f7ff ff9b 	bl	8005de4 <FreeRTOS_issocketconnected>
				if( xResult < 0 )
 8005eae:	1e03      	subs	r3, r0, #0
 8005eb0:	db21      	blt.n	8005ef6 <FreeRTOS_connect+0xf2>
				if( xResult > 0 )
 8005eb2:	dc19      	bgt.n	8005ee8 <FreeRTOS_connect+0xe4>
				if( xTaskCheckForTimeOut( &xTimeOut, &xRemainingTime ) )
 8005eb4:	a905      	add	r1, sp, #20
 8005eb6:	a803      	add	r0, sp, #12
 8005eb8:	f004 fbc4 	bl	800a644 <xTaskCheckForTimeOut>
 8005ebc:	b9b0      	cbnz	r0, 8005eec <FreeRTOS_connect+0xe8>
				xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_CONNECT, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, xRemainingTime );
 8005ebe:	9b05      	ldr	r3, [sp, #20]
 8005ec0:	9300      	str	r3, [sp, #0]
 8005ec2:	4633      	mov	r3, r6
 8005ec4:	2201      	movs	r2, #1
 8005ec6:	2108      	movs	r1, #8
 8005ec8:	6860      	ldr	r0, [r4, #4]
 8005eca:	f002 feab 	bl	8008c24 <xEventGroupWaitBits>
 8005ece:	462b      	mov	r3, r5
				if( xTimed == pdFALSE )
 8005ed0:	2b00      	cmp	r3, #0
 8005ed2:	d1e9      	bne.n	8005ea8 <FreeRTOS_connect+0xa4>
					xRemainingTime = pxSocket->xReceiveBlockTime;
 8005ed4:	69e3      	ldr	r3, [r4, #28]
 8005ed6:	9305      	str	r3, [sp, #20]
					if( xRemainingTime == ( TickType_t )0 )
 8005ed8:	b11b      	cbz	r3, 8005ee2 <FreeRTOS_connect+0xde>
					vTaskSetTimeOutState( &xTimeOut );
 8005eda:	a803      	add	r0, sp, #12
 8005edc:	f004 fb9c 	bl	800a618 <vTaskSetTimeOutState>
 8005ee0:	e7e2      	b.n	8005ea8 <FreeRTOS_connect+0xa4>
						xResult = -pdFREERTOS_ERRNO_EWOULDBLOCK;
 8005ee2:	f06f 030a 	mvn.w	r3, #10
 8005ee6:	e006      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
					xResult = 0;
 8005ee8:	2300      	movs	r3, #0
 8005eea:	e004      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
					xResult = -pdFREERTOS_ERRNO_ETIMEDOUT;
 8005eec:	f06f 0373 	mvn.w	r3, #115	; 0x73
		return xResult;
 8005ef0:	e001      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
			xResult = -pdFREERTOS_ERRNO_EBADF;
 8005ef2:	f06f 0308 	mvn.w	r3, #8
	}
 8005ef6:	4618      	mov	r0, r3
 8005ef8:	b006      	add	sp, #24
 8005efa:	bd70      	pop	{r4, r5, r6, pc}
			case eCONNECT_SYN:	return -pdFREERTOS_ERRNO_EINPROGRESS;
 8005efc:	f06f 0376 	mvn.w	r3, #118	; 0x76
 8005f00:	e7f9      	b.n	8005ef6 <FreeRTOS_connect+0xf2>
					xResult = -pdFREERTOS_ERRNO_ECANCELED;
 8005f02:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 8005f06:	e7f6      	b.n	8005ef6 <FreeRTOS_connect+0xf2>

08005f08 <FreeRTOS_rx_size>:
	BaseType_t FreeRTOS_rx_size( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8005f08:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 8005f0c:	2b06      	cmp	r3, #6
 8005f0e:	d10a      	bne.n	8005f26 <FreeRTOS_rx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else if( pxSocket->u.xTCP.rxStream != NULL )
 8005f10:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8005f12:	b15b      	cbz	r3, 8005f2c <FreeRTOS_rx_size+0x24>
size_t uxHead = pxBuffer->uxHead;
 8005f14:	6898      	ldr	r0, [r3, #8]
size_t uxTail = pxBuffer->uxTail;
 8005f16:	681a      	ldr	r2, [r3, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8005f18:	691b      	ldr	r3, [r3, #16]
 8005f1a:	4418      	add	r0, r3
 8005f1c:	1a80      	subs	r0, r0, r2
	if ( uxCount >= pxBuffer->LENGTH )
 8005f1e:	4283      	cmp	r3, r0
 8005f20:	d805      	bhi.n	8005f2e <FreeRTOS_rx_size+0x26>
		uxCount -= pxBuffer->LENGTH;
 8005f22:	1ac0      	subs	r0, r0, r3
 8005f24:	4770      	bx	lr
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8005f26:	f06f 0015 	mvn.w	r0, #21
 8005f2a:	4770      	bx	lr
		{
			xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
		}
		else
		{
			xReturn = 0;
 8005f2c:	2000      	movs	r0, #0
		}

		return xReturn;
	}
 8005f2e:	4770      	bx	lr

08005f30 <FreeRTOS_netstat>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	void FreeRTOS_netstat( void )
	{
 8005f30:	b500      	push	{lr}
 8005f32:	b083      	sub	sp, #12
	IPStackEvent_t xAskEvent;

		/* Ask the IP-task to call vTCPNetStat()
		 * to avoid accessing xBoundTCPSocketsList
		 */
		xAskEvent.eEventType = eTCPNetStat;
 8005f34:	2307      	movs	r3, #7
 8005f36:	f88d 3000 	strb.w	r3, [sp]
		xAskEvent.pvData = ( void * ) NULL;
 8005f3a:	2300      	movs	r3, #0
 8005f3c:	9301      	str	r3, [sp, #4]
		xSendEventStructToIPTask( &xAskEvent, 1000u );
 8005f3e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8005f42:	4668      	mov	r0, sp
 8005f44:	f7fe fb50 	bl	80045e8 <xSendEventStructToIPTask>
	}
 8005f48:	b003      	add	sp, #12
 8005f4a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08005f50 <vTCPNetStat>:
/*-----------------------------------------------------------*/

#if( ( ipconfigHAS_PRINTF != 0 ) && ( ipconfigUSE_TCP == 1 ) )

	void vTCPNetStat( void )
	{
 8005f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f54:	b08d      	sub	sp, #52	; 0x34
	/* Show a simple listing of all created sockets and their connections */
	ListItem_t *pxIterator;
	BaseType_t count = 0;

		if( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) == pdFALSE )
 8005f56:	4b40      	ldr	r3, [pc, #256]	; (8006058 <vTCPNetStat+0x108>)
 8005f58:	689b      	ldr	r3, [r3, #8]
 8005f5a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005f5e:	d005      	beq.n	8005f6c <vTCPNetStat+0x1c>
		{
			FreeRTOS_printf( ( "PLUS-TCP not initialized\n" ) );
 8005f60:	483e      	ldr	r0, [pc, #248]	; (800605c <vTCPNetStat+0x10c>)
 8005f62:	f005 fd71 	bl	800ba48 <lUDPLoggingPrintf>
				count,
				uxGetMinimumFreeNetworkBuffers( ),
				uxGetNumberOfFreeNetworkBuffers( ),
				ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ) );
		}
	}
 8005f66:	b00d      	add	sp, #52	; 0x34
 8005f68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			FreeRTOS_printf( ( "Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n" ) );
 8005f6c:	483c      	ldr	r0, [pc, #240]	; (8006060 <vTCPNetStat+0x110>)
 8005f6e:	f005 fd6b 	bl	800ba48 <lUDPLoggingPrintf>
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8005f72:	4b39      	ldr	r3, [pc, #228]	; (8006058 <vTCPNetStat+0x108>)
 8005f74:	68de      	ldr	r6, [r3, #12]
 8005f76:	3308      	adds	r3, #8
 8005f78:	429e      	cmp	r6, r3
 8005f7a:	d06b      	beq.n	8006054 <vTCPNetStat+0x104>
 8005f7c:	2700      	movs	r7, #0
				FreeRTOS_printf( ( "TCP %5d %-16lxip:%5d %d/%d %-13.13s %6lu %6u%s\n",
 8005f7e:	46b9      	mov	r9, r7
 8005f80:	e02d      	b.n	8005fde <vTCPNetStat+0x8e>
 8005f82:	f8b4 a024 	ldrh.w	sl, [r4, #36]	; 0x24
 8005f86:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005f88:	9307      	str	r3, [sp, #28]
 8005f8a:	f8b4 b03c 	ldrh.w	fp, [r4, #60]	; 0x3c
 8005f8e:	6f67      	ldr	r7, [r4, #116]	; 0x74
 8005f90:	3700      	adds	r7, #0
 8005f92:	bf18      	it	ne
 8005f94:	2701      	movne	r7, #1
 8005f96:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005f98:	f113 0800 	adds.w	r8, r3, #0
 8005f9c:	bf18      	it	ne
 8005f9e:	f04f 0801 	movne.w	r8, #1
 8005fa2:	f894 0053 	ldrb.w	r0, [r4, #83]	; 0x53
 8005fa6:	f001 fd51 	bl	8007a4c <FreeRTOS_GetTCPStateName>
 8005faa:	a908      	add	r1, sp, #32
 8005fac:	9105      	str	r1, [sp, #20]
 8005fae:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
 8005fb2:	9304      	str	r3, [sp, #16]
 8005fb4:	4b2b      	ldr	r3, [pc, #172]	; (8006064 <vTCPNetStat+0x114>)
 8005fb6:	429d      	cmp	r5, r3
 8005fb8:	bf28      	it	cs
 8005fba:	461d      	movcs	r5, r3
 8005fbc:	9503      	str	r5, [sp, #12]
 8005fbe:	9002      	str	r0, [sp, #8]
 8005fc0:	f8cd 8004 	str.w	r8, [sp, #4]
 8005fc4:	9700      	str	r7, [sp, #0]
 8005fc6:	465b      	mov	r3, fp
 8005fc8:	9a07      	ldr	r2, [sp, #28]
 8005fca:	4651      	mov	r1, sl
 8005fcc:	4826      	ldr	r0, [pc, #152]	; (8006068 <vTCPNetStat+0x118>)
 8005fce:	f005 fd3b 	bl	800ba48 <lUDPLoggingPrintf>
				count++;
 8005fd2:	f109 0901 	add.w	r9, r9, #1
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8005fd6:	6876      	ldr	r6, [r6, #4]
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8005fd8:	4b24      	ldr	r3, [pc, #144]	; (800606c <vTCPNetStat+0x11c>)
 8005fda:	429e      	cmp	r6, r3
 8005fdc:	d018      	beq.n	8006010 <vTCPNetStat+0xc0>
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8005fde:	68f4      	ldr	r4, [r6, #12]
					TickType_t age = xTaskGetTickCount() - pxSocket->u.xTCP.xLastAliveTime;
 8005fe0:	f004 f826 	bl	800a030 <xTaskGetTickCount>
 8005fe4:	6de5      	ldr	r5, [r4, #92]	; 0x5c
 8005fe6:	1b45      	subs	r5, r0, r5
				char ucChildText[16] = "";
 8005fe8:	2300      	movs	r3, #0
 8005fea:	9308      	str	r3, [sp, #32]
 8005fec:	9309      	str	r3, [sp, #36]	; 0x24
 8005fee:	930a      	str	r3, [sp, #40]	; 0x28
 8005ff0:	930b      	str	r3, [sp, #44]	; 0x2c
				if (pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN)
 8005ff2:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8005ff6:	2b01      	cmp	r3, #1
 8005ff8:	d1c3      	bne.n	8005f82 <vTCPNetStat+0x32>
					snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
 8005ffa:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8005ffe:	f8b4 2050 	ldrh.w	r2, [r4, #80]	; 0x50
 8006002:	9200      	str	r2, [sp, #0]
 8006004:	4a1a      	ldr	r2, [pc, #104]	; (8006070 <vTCPNetStat+0x120>)
 8006006:	2110      	movs	r1, #16
 8006008:	a808      	add	r0, sp, #32
 800600a:	f006 f85a 	bl	800c0c2 <snprintf>
 800600e:	e7b8      	b.n	8005f82 <vTCPNetStat+0x32>
 8006010:	464f      	mov	r7, r9
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 8006012:	4b18      	ldr	r3, [pc, #96]	; (8006074 <vTCPNetStat+0x124>)
 8006014:	68dc      	ldr	r4, [r3, #12]
 8006016:	3308      	adds	r3, #8
 8006018:	429c      	cmp	r4, r3
 800601a:	d00d      	beq.n	8006038 <vTCPNetStat+0xe8>
				FreeRTOS_printf( ( "UDP Port %5u\n",
 800601c:	4e16      	ldr	r6, [pc, #88]	; (8006078 <vTCPNetStat+0x128>)
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 800601e:	461d      	mov	r5, r3
				FreeRTOS_printf( ( "UDP Port %5u\n",
 8006020:	6823      	ldr	r3, [r4, #0]
 8006022:	0a19      	lsrs	r1, r3, #8
 8006024:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 8006028:	b289      	uxth	r1, r1
 800602a:	4630      	mov	r0, r6
 800602c:	f005 fd0c 	bl	800ba48 <lUDPLoggingPrintf>
				count++;
 8006030:	3701      	adds	r7, #1
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8006032:	6864      	ldr	r4, [r4, #4]
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 8006034:	42ac      	cmp	r4, r5
 8006036:	d1f3      	bne.n	8006020 <vTCPNetStat+0xd0>
			FreeRTOS_printf( ( "FreeRTOS_netstat: %lu sockets %lu < %lu < %d buffers free\n",
 8006038:	f002 fad4 	bl	80085e4 <uxGetMinimumFreeNetworkBuffers>
 800603c:	4604      	mov	r4, r0
 800603e:	f002 facb 	bl	80085d8 <uxGetNumberOfFreeNetworkBuffers>
 8006042:	2319      	movs	r3, #25
 8006044:	9300      	str	r3, [sp, #0]
 8006046:	4603      	mov	r3, r0
 8006048:	4622      	mov	r2, r4
 800604a:	4639      	mov	r1, r7
 800604c:	480b      	ldr	r0, [pc, #44]	; (800607c <vTCPNetStat+0x12c>)
 800604e:	f005 fcfb 	bl	800ba48 <lUDPLoggingPrintf>
	}
 8006052:	e788      	b.n	8005f66 <vTCPNetStat+0x16>
	BaseType_t count = 0;
 8006054:	2700      	movs	r7, #0
 8006056:	e7dc      	b.n	8006012 <vTCPNetStat+0xc2>
 8006058:	2000283c 	.word	0x2000283c
 800605c:	0800cba0 	.word	0x0800cba0
 8006060:	0800cbbc 	.word	0x0800cbbc
 8006064:	000f423f 	.word	0x000f423f
 8006068:	0800cc0c 	.word	0x0800cc0c
 800606c:	20002844 	.word	0x20002844
 8006070:	0800cc04 	.word	0x0800cc04
 8006074:	20002850 	.word	0x20002850
 8006078:	0800cc3c 	.word	0x0800cc3c
 800607c:	0800cc4c 	.word	0x0800cc4c

08006080 <vSocketSelect>:
/*-----------------------------------------------------------*/

#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )

	void vSocketSelect( SocketSelect_t *pxSocketSet )
	{
 8006080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006084:	b085      	sub	sp, #20
 8006086:	4606      	mov	r6, r0
		BaseType_t xLastRound = 0;
	#endif

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;
		pxSocketSet->pxSocket = NULL;
 8006088:	2300      	movs	r3, #0
 800608a:	6083      	str	r3, [r0, #8]
 800608c:	f04f 0a01 	mov.w	sl, #1
		EventBits_t xGroupBits = 0;
 8006090:	4698      	mov	r8, r3
			else
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8006092:	4b51      	ldr	r3, [pc, #324]	; (80061d8 <vSocketSelect+0x158>)
 8006094:	3308      	adds	r3, #8
 8006096:	9303      	str	r3, [sp, #12]
 8006098:	f8df b148 	ldr.w	fp, [pc, #328]	; 80061e4 <vSocketSelect+0x164>
 800609c:	f10b 0308 	add.w	r3, fp, #8
 80060a0:	9301      	str	r3, [sp, #4]
 80060a2:	e070      	b.n	8006186 <vSocketSelect+0x106>
 80060a4:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 80060a8:	f003 0306 	and.w	r3, r3, #6
 80060ac:	9302      	str	r3, [sp, #8]
								bAccepted = pdTRUE;
							}
						}

						/* Is the set owner interested in READ events? */
						if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
 80060ae:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80060b0:	f013 0f01 	tst.w	r3, #1
 80060b4:	d01b      	beq.n	80060ee <vSocketSelect+0x6e>
						{
							if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 80060b6:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 80060ba:	2a01      	cmp	r2, #1
 80060bc:	d004      	beq.n	80060c8 <vSocketSelect+0x48>
								if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != 0 ) )
								{
									xSocketBits |= eSELECT_READ;
								}
							}
							else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 80060be:	9b02      	ldr	r3, [sp, #8]
 80060c0:	b15b      	cbz	r3, 80060da <vSocketSelect+0x5a>
				xSocketBits = 0;
 80060c2:	f04f 0900 	mov.w	r9, #0
 80060c6:	e014      	b.n	80060f2 <vSocketSelect+0x72>
								if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != 0 ) )
 80060c8:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 80060ca:	2a00      	cmp	r2, #0
 80060cc:	f000 8081 	beq.w	80061d2 <vSocketSelect+0x152>
 80060d0:	f892 9040 	ldrb.w	r9, [r2, #64]	; 0x40
 80060d4:	f3c9 0940 	ubfx	r9, r9, #1, #1
 80060d8:	e016      	b.n	8006108 <vSocketSelect+0x88>
							else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 80060da:	4628      	mov	r0, r5
 80060dc:	f7ff ff14 	bl	8005f08 <FreeRTOS_rx_size>
 80060e0:	2800      	cmp	r0, #0
 80060e2:	bfd4      	ite	le
 80060e4:	f04f 0900 	movle.w	r9, #0
 80060e8:	f04f 0901 	movgt.w	r9, #1
 80060ec:	e001      	b.n	80060f2 <vSocketSelect+0x72>
				xSocketBits = 0;
 80060ee:	f04f 0900 	mov.w	r9, #0
							{
								xSocketBits |= eSELECT_READ;
							}
						}
						/* Is the set owner interested in EXCEPTION events? */
						if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
 80060f2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80060f4:	f013 0f04 	tst.w	r3, #4
 80060f8:	d006      	beq.n	8006108 <vSocketSelect+0x88>
						{
							if( ( pxSocket->u.xTCP.ucTCPState == eCLOSE_WAIT ) || ( pxSocket->u.xTCP.ucTCPState == eCLOSED ) )
 80060fa:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 80060fe:	f012 0ff7 	tst.w	r2, #247	; 0xf7
							{
								xSocketBits |= eSELECT_EXCEPT;
 8006102:	bf08      	it	eq
 8006104:	f049 0904 	orreq.w	r9, r9, #4
							}
						}

						/* Is the set owner interested in WRITE events? */
						if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
 8006108:	f013 0f02 	tst.w	r3, #2
 800610c:	d01c      	beq.n	8006148 <vSocketSelect+0xc8>
						{
							BaseType_t bMatch = pdFALSE;

							if( bAccepted != 0 )
 800610e:	9b02      	ldr	r3, [sp, #8]
 8006110:	b183      	cbz	r3, 8006134 <vSocketSelect+0xb4>
								}
							}

							if( bMatch == pdFALSE )
							{
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 8006112:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006116:	f013 0f08 	tst.w	r3, #8
 800611a:	d015      	beq.n	8006148 <vSocketSelect+0xc8>
 800611c:	f895 2053 	ldrb.w	r2, [r5, #83]	; 0x53
 8006120:	2a04      	cmp	r2, #4
 8006122:	d911      	bls.n	8006148 <vSocketSelect+0xc8>
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8006124:	f013 0f10 	tst.w	r3, #16
 8006128:	d10e      	bne.n	8006148 <vSocketSelect+0xc8>
									( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
								{
									pxSocket->u.xTCP.bits.bConnPassed = pdTRUE_UNSIGNED;
 800612a:	f043 0310 	orr.w	r3, r3, #16
 800612e:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 8006132:	e004      	b.n	800613e <vSocketSelect+0xbe>
								if( FreeRTOS_tx_space( pxSocket ) > 0 )
 8006134:	4628      	mov	r0, r5
 8006136:	f7ff fced 	bl	8005b14 <FreeRTOS_tx_space>
							if( bMatch == pdFALSE )
 800613a:	2800      	cmp	r0, #0
 800613c:	dde9      	ble.n	8006112 <vSocketSelect+0x92>
								}
							}

							if( bMatch != pdFALSE )
							{
								xSocketBits |= eSELECT_WRITE;
 800613e:	f049 0902 	orr.w	r9, r9, #2
 8006142:	e001      	b.n	8006148 <vSocketSelect+0xc8>
				xSocketBits = 0;
 8006144:	f04f 0900 	mov.w	r9, #0
					/* The WRITE and EXCEPT bits are not used for UDP */
				}	/* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */

				/* Each socket keeps its own event flags, which are looked-up
				by FreeRTOS_FD_ISSSET() */
				pxSocket->xSocketBits = xSocketBits;
 8006148:	f8c5 9030 	str.w	r9, [r5, #48]	; 0x30

				/* The ORed value will be used to set the bits in the event
				group. */
				xGroupBits |= xSocketBits;
 800614c:	ea48 0809 	orr.w	r8, r8, r9
				 pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8006150:	6864      	ldr	r4, [r4, #4]
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8006152:	42bc      	cmp	r4, r7
 8006154:	d012      	beq.n	800617c <vSocketSelect+0xfc>
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8006156:	68e5      	ldr	r5, [r4, #12]
				if( pxSocket->pxSocketSet != pxSocketSet )
 8006158:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800615a:	429e      	cmp	r6, r3
 800615c:	d1f8      	bne.n	8006150 <vSocketSelect+0xd0>
					if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP )
 800615e:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
 8006162:	2b06      	cmp	r3, #6
 8006164:	d09e      	beq.n	80060a4 <vSocketSelect+0x24>
					if( ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) &&
 8006166:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8006168:	f013 0f01 	tst.w	r3, #1
 800616c:	d0ea      	beq.n	8006144 <vSocketSelect+0xc4>
 800616e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8006170:	f113 0900 	adds.w	r9, r3, #0
 8006174:	bf18      	it	ne
 8006176:	f04f 0901 	movne.w	r9, #1
 800617a:	e7e5      	b.n	8006148 <vSocketSelect+0xc8>
		for( xRound = 0; xRound <= xLastRound; xRound++ )
 800617c:	f1ba 0f01 	cmp.w	sl, #1
 8006180:	dc0b      	bgt.n	800619a <vSocketSelect+0x11a>
 8006182:	f10a 0a01 	add.w	sl, sl, #1
			if( xRound == 0 )
 8006186:	f1ba 0f01 	cmp.w	sl, #1
 800618a:	d01b      	beq.n	80061c4 <vSocketSelect+0x144>
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 800618c:	f8db 400c 	ldr.w	r4, [fp, #12]
 8006190:	9b01      	ldr	r3, [sp, #4]
 8006192:	429c      	cmp	r4, r3
 8006194:	d0f2      	beq.n	800617c <vSocketSelect+0xfc>
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
 8006196:	4f11      	ldr	r7, [pc, #68]	; (80061dc <vSocketSelect+0x15c>)
 8006198:	e7dd      	b.n	8006156 <vSocketSelect+0xd6>

			}	/* for( pxIterator ... ) */
		}	/* for( xRound = 0; xRound <= xLastRound; xRound++ ) */

		xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 800619a:	2100      	movs	r1, #0
 800619c:	6830      	ldr	r0, [r6, #0]
 800619e:	f002 fdc5 	bl	8008d2c <xEventGroupClearBits>
 80061a2:	f000 0007 	and.w	r0, r0, #7
			and cleared in FreeRTOS_select(). */
			xBitsToClear &= ( EventBits_t ) ~eSELECT_INTR;
		}
		#endif /* ipconfigSUPPORT_SIGNALS */

		if( xBitsToClear != 0 )
 80061a6:	ea30 0108 	bics.w	r1, r0, r8
 80061aa:	d107      	bne.n	80061bc <vSocketSelect+0x13c>
		{
			xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
		}

		/* Now include eSELECT_CALL_IP to wakeup the caller. */
		xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | eSELECT_CALL_IP );
 80061ac:	f048 0110 	orr.w	r1, r8, #16
 80061b0:	6830      	ldr	r0, [r6, #0]
 80061b2:	f002 fddb 	bl	8008d6c <xEventGroupSetBits>
	}
 80061b6:	b005      	add	sp, #20
 80061b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
 80061bc:	6830      	ldr	r0, [r6, #0]
 80061be:	f002 fdb5 	bl	8008d2c <xEventGroupClearBits>
 80061c2:	e7f3      	b.n	80061ac <vSocketSelect+0x12c>
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 80061c4:	4b04      	ldr	r3, [pc, #16]	; (80061d8 <vSocketSelect+0x158>)
 80061c6:	68dc      	ldr	r4, [r3, #12]
 80061c8:	9b03      	ldr	r3, [sp, #12]
 80061ca:	429c      	cmp	r4, r3
 80061cc:	d0d9      	beq.n	8006182 <vSocketSelect+0x102>
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundUDPSocketsList );
 80061ce:	4f04      	ldr	r7, [pc, #16]	; (80061e0 <vSocketSelect+0x160>)
 80061d0:	e7c1      	b.n	8006156 <vSocketSelect+0xd6>
 80061d2:	f04f 0900 	mov.w	r9, #0
 80061d6:	e797      	b.n	8006108 <vSocketSelect+0x88>
 80061d8:	20002850 	.word	0x20002850
 80061dc:	20002844 	.word	0x20002844
 80061e0:	20002858 	.word	0x20002858
 80061e4:	2000283c 	.word	0x2000283c

080061e8 <FreeRTOS_SignalSocket>:
	BaseType_t FreeRTOS_SignalSocket( Socket_t xSocket )
	{
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
	BaseType_t xReturn;

		if( pxSocket == NULL )
 80061e8:	b188      	cbz	r0, 800620e <FreeRTOS_SignalSocket+0x26>
	{
 80061ea:	b508      	push	{r3, lr}
 80061ec:	4603      	mov	r3, r0
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
		}
		else
	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
		if( ( pxSocket->pxSocketSet != NULL ) && ( pxSocket->pxSocketSet->xSelectGroup != NULL ) )
 80061ee:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80061f0:	b132      	cbz	r2, 8006200 <FreeRTOS_SignalSocket+0x18>
 80061f2:	6810      	ldr	r0, [r2, #0]
 80061f4:	b120      	cbz	r0, 8006200 <FreeRTOS_SignalSocket+0x18>
		{
			xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_INTR );
 80061f6:	2108      	movs	r1, #8
 80061f8:	f002 fdb8 	bl	8008d6c <xEventGroupSetBits>
			xReturn = 0;
 80061fc:	2000      	movs	r0, #0
 80061fe:	bd08      	pop	{r3, pc}
		}
		else
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
		if( pxSocket->xEventGroup != NULL )
 8006200:	6858      	ldr	r0, [r3, #4]
 8006202:	b138      	cbz	r0, 8006214 <FreeRTOS_SignalSocket+0x2c>
		{
			xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_INTR );
 8006204:	2140      	movs	r1, #64	; 0x40
 8006206:	f002 fdb1 	bl	8008d6c <xEventGroupSetBits>
			xReturn = 0;
 800620a:	2000      	movs	r0, #0
 800620c:	bd08      	pop	{r3, pc}
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800620e:	f06f 0015 	mvn.w	r0, #21
 8006212:	4770      	bx	lr
		}
		else
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8006214:	f06f 0015 	mvn.w	r0, #21
		}

		return xReturn;
	}
 8006218:	bd08      	pop	{r3, pc}

0800621a <uxStreamBufferAdd>:
 * an offset from uxHead while uxHead will not be moved yet.  This possibility
 * will be used when TCP data is received while earlier data is still missing.
 * If 'pucData' equals NULL, the function is called to advance 'uxHead' only.
 */
size_t uxStreamBufferAdd( StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxCount )
{
 800621a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
size_t uxHead = pxBuffer->uxHead;
 800621e:	6884      	ldr	r4, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 8006220:	6805      	ldr	r5, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8006222:	6906      	ldr	r6, [r0, #16]
 8006224:	4435      	add	r5, r6
 8006226:	3d01      	subs	r5, #1
 8006228:	1b2c      	subs	r4, r5, r4
	if( uxCount >= pxBuffer->LENGTH )
 800622a:	42a6      	cmp	r6, r4
		uxCount -= pxBuffer->LENGTH;
 800622c:	bf98      	it	ls
 800622e:	1ba4      	subls	r4, r4, r6
size_t uxSpace, uxNextHead, uxFirst;

	uxSpace = uxStreamBufferGetSpace( pxBuffer );

	/* If uxOffset > 0, items can be placed in front of uxHead */
	if( uxSpace > uxOffset )
 8006230:	42a1      	cmp	r1, r4
 8006232:	d22d      	bcs.n	8006290 <uxStreamBufferAdd+0x76>
	{
		uxSpace -= uxOffset;
 8006234:	1a64      	subs	r4, r4, r1
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 8006236:	429c      	cmp	r4, r3
 8006238:	bf28      	it	cs
 800623a:	461c      	movcs	r4, r3

	/* The number of bytes that can be written is the minimum of the number of
	bytes requested and the number available. */
	uxCount = FreeRTOS_min_uint32( uxSpace, uxCount );

	if( uxCount != 0u )
 800623c:	b34c      	cbz	r4, 8006292 <uxStreamBufferAdd+0x78>
 800623e:	4691      	mov	r9, r2
 8006240:	4688      	mov	r8, r1
 8006242:	4605      	mov	r5, r0
	{
		uxNextHead = pxBuffer->uxHead;
 8006244:	6887      	ldr	r7, [r0, #8]

		if( uxOffset != 0u )
 8006246:	b339      	cbz	r1, 8006298 <uxStreamBufferAdd+0x7e>
		{
			/* ( uxOffset > 0 ) means: write in front if the uxHead marker */
			uxNextHead += uxOffset;
 8006248:	440f      	add	r7, r1
			if( uxNextHead >= pxBuffer->LENGTH )
 800624a:	42b7      	cmp	r7, r6
 800624c:	d300      	bcc.n	8006250 <uxStreamBufferAdd+0x36>
			{
				uxNextHead -= pxBuffer->LENGTH;
 800624e:	1bbf      	subs	r7, r7, r6
			}
		}

		if( pucData != NULL )
 8006250:	f1b9 0f00 	cmp.w	r9, #0
 8006254:	d035      	beq.n	80062c2 <uxStreamBufferAdd+0xa8>
		{
			/* Calculate the number of bytes that can be added in the first
			write - which may be less than the total number of bytes that need
			to be added if the buffer will wrap back to the beginning. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 8006256:	1bf6      	subs	r6, r6, r7
 8006258:	42a6      	cmp	r6, r4
 800625a:	bf28      	it	cs
 800625c:	4626      	movcs	r6, r4

			/* Write as many bytes as can be written in the first write. */
			memcpy( ( void* ) ( pxBuffer->ucArray + uxNextHead ), pucData, uxFirst );
 800625e:	f105 0a14 	add.w	sl, r5, #20
 8006262:	4632      	mov	r2, r6
 8006264:	4649      	mov	r1, r9
 8006266:	eb0a 0007 	add.w	r0, sl, r7
 800626a:	f006 fa34 	bl	800c6d6 <memcpy>

			/* If the number of bytes written was less than the number that
			could be written in the first write... */
			if( uxCount > uxFirst )
 800626e:	42b4      	cmp	r4, r6
 8006270:	d927      	bls.n	80062c2 <uxStreamBufferAdd+0xa8>
			{
				/* ...then write the remaining bytes to the start of the
				buffer. */
				memcpy( ( void * )pxBuffer->ucArray, pucData + uxFirst, uxCount - uxFirst );
 8006272:	1ba2      	subs	r2, r4, r6
 8006274:	eb09 0106 	add.w	r1, r9, r6
 8006278:	4650      	mov	r0, sl
 800627a:	f006 fa2c 	bl	800c6d6 <memcpy>
			}
		}

		if( uxOffset == 0u )
 800627e:	f1b8 0f00 	cmp.w	r8, #0
 8006282:	d11e      	bne.n	80062c2 <uxStreamBufferAdd+0xa8>
 8006284:	e017      	b.n	80062b6 <uxStreamBufferAdd+0x9c>
		if( uxLeft <= uxRight )
 8006286:	428f      	cmp	r7, r1
 8006288:	bf34      	ite	cc
 800628a:	2200      	movcc	r2, #0
 800628c:	2201      	movcs	r2, #1
 800628e:	e024      	b.n	80062da <uxStreamBufferAdd+0xc0>
 8006290:	2400      	movs	r4, #0
			pxBuffer->uxFront = uxNextHead;
		}
	}

	return uxCount;
}
 8006292:	4620      	mov	r0, r4
 8006294:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if( pucData != NULL )
 8006298:	b16a      	cbz	r2, 80062b6 <uxStreamBufferAdd+0x9c>
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 800629a:	1bf6      	subs	r6, r6, r7
 800629c:	42a6      	cmp	r6, r4
 800629e:	bf28      	it	cs
 80062a0:	4626      	movcs	r6, r4
			memcpy( ( void* ) ( pxBuffer->ucArray + uxNextHead ), pucData, uxFirst );
 80062a2:	f100 0a14 	add.w	sl, r0, #20
 80062a6:	4632      	mov	r2, r6
 80062a8:	4649      	mov	r1, r9
 80062aa:	eb0a 0007 	add.w	r0, sl, r7
 80062ae:	f006 fa12 	bl	800c6d6 <memcpy>
			if( uxCount > uxFirst )
 80062b2:	42b4      	cmp	r4, r6
 80062b4:	d8dd      	bhi.n	8006272 <uxStreamBufferAdd+0x58>
			uxNextHead += uxCount;
 80062b6:	4427      	add	r7, r4
			if( uxNextHead >= pxBuffer->LENGTH )
 80062b8:	692b      	ldr	r3, [r5, #16]
 80062ba:	429f      	cmp	r7, r3
				uxNextHead -= pxBuffer->LENGTH;
 80062bc:	bf28      	it	cs
 80062be:	1aff      	subcs	r7, r7, r3
			pxBuffer->uxHead = uxNextHead;
 80062c0:	60af      	str	r7, [r5, #8]
		if( xStreamBufferLessThenEqual( pxBuffer, pxBuffer->uxFront, uxNextHead ) != pdFALSE )
 80062c2:	68e9      	ldr	r1, [r5, #12]
size_t uxTail = pxBuffer->uxTail;
 80062c4:	682b      	ldr	r3, [r5, #0]
	if( ( uxLeft < uxTail ) ^ ( uxRight < uxTail ) )
 80062c6:	429f      	cmp	r7, r3
 80062c8:	bf2c      	ite	cs
 80062ca:	2200      	movcs	r2, #0
 80062cc:	2201      	movcc	r2, #1
 80062ce:	4299      	cmp	r1, r3
 80062d0:	bf2c      	ite	cs
 80062d2:	2300      	movcs	r3, #0
 80062d4:	2301      	movcc	r3, #1
 80062d6:	4293      	cmp	r3, r2
 80062d8:	d0d5      	beq.n	8006286 <uxStreamBufferAdd+0x6c>
 80062da:	2a00      	cmp	r2, #0
 80062dc:	d0d9      	beq.n	8006292 <uxStreamBufferAdd+0x78>
			pxBuffer->uxFront = uxNextHead;
 80062de:	60ef      	str	r7, [r5, #12]
 80062e0:	e7d7      	b.n	8006292 <uxStreamBufferAdd+0x78>

080062e2 <uxStreamBufferGet>:
 * If 'pucData' equals NULL, the function is called to advance 'lTail' only.
 * if 'xPeek' is pdTRUE, or if 'uxOffset' is non-zero, the 'lTail' pointer will
 * not be advanced.
 */
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek )
{
 80062e2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
size_t uxHead = pxBuffer->uxHead;
 80062e6:	6885      	ldr	r5, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 80062e8:	6804      	ldr	r4, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80062ea:	6906      	ldr	r6, [r0, #16]
 80062ec:	4435      	add	r5, r6
 80062ee:	1b2c      	subs	r4, r5, r4
	if ( uxCount >= pxBuffer->LENGTH )
 80062f0:	42a6      	cmp	r6, r4
		uxCount -= pxBuffer->LENGTH;
 80062f2:	bf98      	it	ls
 80062f4:	1ba4      	subls	r4, r4, r6
size_t uxSize, uxCount, uxFirst, uxNextTail;

	/* How much data is available? */
	uxSize = uxStreamBufferGetSize( pxBuffer );

	if( uxSize > uxOffset )
 80062f6:	42a1      	cmp	r1, r4
 80062f8:	d22f      	bcs.n	800635a <uxStreamBufferGet+0x78>
	{
		uxSize -= uxOffset;
 80062fa:	1a64      	subs	r4, r4, r1
 80062fc:	429c      	cmp	r4, r3
 80062fe:	bf28      	it	cs
 8006300:	461c      	movcs	r4, r3
	}

	/* Use the minimum of the wanted bytes and the available bytes. */
	uxCount = FreeRTOS_min_uint32( uxSize, uxMaxCount );

	if( uxCount > 0u )
 8006302:	b35c      	cbz	r4, 800635c <uxStreamBufferGet+0x7a>
	{
		uxNextTail = pxBuffer->uxTail;
 8006304:	6807      	ldr	r7, [r0, #0]

		if( uxOffset != 0u )
 8006306:	b119      	cbz	r1, 8006310 <uxStreamBufferGet+0x2e>
		{
			uxNextTail += uxOffset;
 8006308:	440f      	add	r7, r1
			if( uxNextTail >= pxBuffer->LENGTH )
 800630a:	42b7      	cmp	r7, r6
			{
				uxNextTail -= pxBuffer->LENGTH;
 800630c:	bf28      	it	cs
 800630e:	1bbf      	subcs	r7, r7, r6
 8006310:	4690      	mov	r8, r2
 8006312:	460d      	mov	r5, r1
 8006314:	4681      	mov	r9, r0
			}
		}

		if( pucData != NULL )
 8006316:	b16a      	cbz	r2, 8006334 <uxStreamBufferGet+0x52>
		{
			/* Calculate the number of bytes that can be read - which may be
			less than the number wanted if the data wraps around to the start of
			the buffer. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextTail, uxCount );
 8006318:	1bf6      	subs	r6, r6, r7
 800631a:	42a6      	cmp	r6, r4
 800631c:	bf28      	it	cs
 800631e:	4626      	movcs	r6, r4

			/* Obtain the number of bytes it is possible to obtain in the first
			read. */
			memcpy( pucData, pxBuffer->ucArray + uxNextTail, uxFirst );
 8006320:	f100 0a14 	add.w	sl, r0, #20
 8006324:	4632      	mov	r2, r6
 8006326:	eb0a 0107 	add.w	r1, sl, r7
 800632a:	4640      	mov	r0, r8
 800632c:	f006 f9d3 	bl	800c6d6 <memcpy>

			/* If the total number of wanted bytes is greater than the number
			that could be read in the first read... */
			if( uxCount > uxFirst )
 8006330:	42b4      	cmp	r4, r6
 8006332:	d80b      	bhi.n	800634c <uxStreamBufferGet+0x6a>
				/*...then read the remaining bytes from the start of the buffer. */
				memcpy( pucData + uxFirst, pxBuffer->ucArray, uxCount - uxFirst );
			}
		}

		if( ( xPeek == pdFALSE ) && ( uxOffset == 0UL ) )
 8006334:	9b08      	ldr	r3, [sp, #32]
 8006336:	b98b      	cbnz	r3, 800635c <uxStreamBufferGet+0x7a>
 8006338:	b985      	cbnz	r5, 800635c <uxStreamBufferGet+0x7a>
		{
			/* Move the tail pointer to effecively remove the data read from
			the buffer. */
			uxNextTail += uxCount;
 800633a:	4427      	add	r7, r4

			if( uxNextTail >= pxBuffer->LENGTH )
 800633c:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8006340:	429f      	cmp	r7, r3
			{
				uxNextTail -= pxBuffer->LENGTH;
 8006342:	bf28      	it	cs
 8006344:	1aff      	subcs	r7, r7, r3
			}

			pxBuffer->uxTail = uxNextTail;
 8006346:	f8c9 7000 	str.w	r7, [r9]
 800634a:	e007      	b.n	800635c <uxStreamBufferGet+0x7a>
				memcpy( pucData + uxFirst, pxBuffer->ucArray, uxCount - uxFirst );
 800634c:	1ba2      	subs	r2, r4, r6
 800634e:	4651      	mov	r1, sl
 8006350:	eb08 0006 	add.w	r0, r8, r6
 8006354:	f006 f9bf 	bl	800c6d6 <memcpy>
 8006358:	e7ec      	b.n	8006334 <uxStreamBufferGet+0x52>
 800635a:	2400      	movs	r4, #0
		}
	}

	return uxCount;
}
 800635c:	4620      	mov	r0, r4
 800635e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08006364 <prvSocketSetMSS>:

static void prvSocketSetMSS( FreeRTOS_Socket_t *pxSocket )
{
uint32_t ulMSS = ipconfigTCP_MSS;

	if( ( ( FreeRTOS_ntohl( pxSocket->u.xTCP.ulRemoteIP ) ^ *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) != 0ul )
 8006364:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8006366:	0e13      	lsrs	r3, r2, #24
 8006368:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800636c:	0211      	lsls	r1, r2, #8
 800636e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006372:	430b      	orrs	r3, r1
 8006374:	0a12      	lsrs	r2, r2, #8
 8006376:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800637a:	4313      	orrs	r3, r2
 800637c:	4a08      	ldr	r2, [pc, #32]	; (80063a0 <prvSocketSetMSS+0x3c>)
 800637e:	6952      	ldr	r2, [r2, #20]
 8006380:	4053      	eors	r3, r2
 8006382:	4a08      	ldr	r2, [pc, #32]	; (80063a4 <prvSocketSetMSS+0x40>)
 8006384:	6852      	ldr	r2, [r2, #4]
 8006386:	4013      	ands	r3, r2
	{
		/* Data for this peer will pass through a router, and maybe through
		the internet.  Limit the MSS to 1400 bytes or less. */
		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) REDUCED_MSS_THROUGH_INTERNET, ulMSS );
 8006388:	2b00      	cmp	r3, #0
	}

	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort ) );

	pxSocket->u.xTCP.usInitMSS = pxSocket->u.xTCP.usCurMSS = ( uint16_t ) ulMSS;
 800638a:	f240 53b4 	movw	r3, #1460	; 0x5b4
 800638e:	bf18      	it	ne
 8006390:	f44f 63af 	movne.w	r3, #1400	; 0x578
 8006394:	f8a0 304a 	strh.w	r3, [r0, #74]	; 0x4a
 8006398:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
 800639c:	4770      	bx	lr
 800639e:	bf00      	nop
 80063a0:	20000010 	.word	0x20000010
 80063a4:	20000530 	.word	0x20000530

080063a8 <prvTCPAddTxData>:
{
 80063a8:	b510      	push	{r4, lr}
	lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
 80063aa:	6f82      	ldr	r2, [r0, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 80063ac:	6891      	ldr	r1, [r2, #8]
size_t uxMid = pxBuffer->uxMid;
 80063ae:	6854      	ldr	r4, [r2, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80063b0:	6913      	ldr	r3, [r2, #16]
 80063b2:	4419      	add	r1, r3
 80063b4:	1b09      	subs	r1, r1, r4
	if ( uxCount >= pxBuffer->LENGTH )
 80063b6:	428b      	cmp	r3, r1
		uxCount -= pxBuffer->LENGTH;
 80063b8:	bf98      	it	ls
 80063ba:	1ac9      	subls	r1, r1, r3
	if( lLength > 0 )
 80063bc:	2900      	cmp	r1, #0
 80063be:	dd1b      	ble.n	80063f8 <prvTCPAddTxData+0x50>
 80063c0:	4604      	mov	r4, r0
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
 80063c2:	6852      	ldr	r2, [r2, #4]
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
 80063c4:	30dc      	adds	r0, #220	; 0xdc
 80063c6:	f001 fe11 	bl	8007fec <lTCPWindowTxAdd>
		if( lCount > 0 )
 80063ca:	2800      	cmp	r0, #0
 80063cc:	dd14      	ble.n	80063f8 <prvTCPAddTxData+0x50>
			vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
 80063ce:	6fa3      	ldr	r3, [r4, #120]	; 0x78
size_t uxHead = pxBuffer->uxHead;
 80063d0:	689a      	ldr	r2, [r3, #8]
size_t uxMid = pxBuffer->uxMid;
 80063d2:	685c      	ldr	r4, [r3, #4]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80063d4:	6919      	ldr	r1, [r3, #16]
 80063d6:	440a      	add	r2, r1
 80063d8:	1b12      	subs	r2, r2, r4
	if ( uxCount >= pxBuffer->LENGTH )
 80063da:	4291      	cmp	r1, r2
		uxCount -= pxBuffer->LENGTH;
 80063dc:	bf98      	it	ls
 80063de:	1a52      	subls	r2, r2, r1
	pxBuffer->uxMid += uxCount;
 80063e0:	685c      	ldr	r4, [r3, #4]
 80063e2:	4290      	cmp	r0, r2
 80063e4:	bf94      	ite	ls
 80063e6:	1822      	addls	r2, r4, r0
 80063e8:	18a2      	addhi	r2, r4, r2
 80063ea:	605a      	str	r2, [r3, #4]
	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
 80063ec:	685a      	ldr	r2, [r3, #4]
 80063ee:	4291      	cmp	r1, r2
 80063f0:	d802      	bhi.n	80063f8 <prvTCPAddTxData+0x50>
		pxBuffer->uxMid -= pxBuffer->LENGTH;
 80063f2:	685a      	ldr	r2, [r3, #4]
 80063f4:	1a51      	subs	r1, r2, r1
 80063f6:	6059      	str	r1, [r3, #4]
 80063f8:	bd10      	pop	{r4, pc}
	...

080063fc <prvTCPReturnPacket>:
{
 80063fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006400:	b08a      	sub	sp, #40	; 0x28
 8006402:	461d      	mov	r5, r3
	if( pxNetworkBuffer == NULL )
 8006404:	460e      	mov	r6, r1
 8006406:	2900      	cmp	r1, #0
 8006408:	f000 80a3 	beq.w	8006552 <prvTCPReturnPacket+0x156>
		pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800640c:	69b4      	ldr	r4, [r6, #24]
		if( pxSocket != NULL )
 800640e:	2800      	cmp	r0, #0
 8006410:	f000 80d0 	beq.w	80065b4 <prvTCPReturnPacket+0x1b8>
			if( pxSocket->u.xTCP.rxStream != NULL )
 8006414:	6f41      	ldr	r1, [r0, #116]	; 0x74
 8006416:	2900      	cmp	r1, #0
 8006418:	f000 80a3 	beq.w	8006562 <prvTCPReturnPacket+0x166>
size_t uxFront = pxBuffer->uxFront;
 800641c:	68cf      	ldr	r7, [r1, #12]
size_t uxTail = pxBuffer->uxTail;
 800641e:	680b      	ldr	r3, [r1, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8006420:	6909      	ldr	r1, [r1, #16]
 8006422:	440b      	add	r3, r1
 8006424:	3b01      	subs	r3, #1
 8006426:	1bdb      	subs	r3, r3, r7
	if( uxCount >= pxBuffer->LENGTH )
 8006428:	4299      	cmp	r1, r3
 800642a:	f200 809d 	bhi.w	8006568 <prvTCPReturnPacket+0x16c>
		uxCount -= pxBuffer->LENGTH;
 800642e:	eba3 0c01 	sub.w	ip, r3, r1
			ulSpace = FreeRTOS_min_uint32( pxSocket->u.xTCP.ulRxCurWinSize, pxTCPWindow->xSize.ulRxWindowLength );
 8006432:	f8d0 e0d0 	ldr.w	lr, [r0, #208]	; 0xd0
 8006436:	f8d0 70e0 	ldr.w	r7, [r0, #224]	; 0xe0
			if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStopped != pdFALSE_UNSIGNED ) )
 800643a:	496d      	ldr	r1, [pc, #436]	; (80065f0 <prvTCPReturnPacket+0x1f4>)
 800643c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800643e:	4019      	ands	r1, r3
 8006440:	2900      	cmp	r1, #0
 8006442:	f040 8093 	bne.w	800656c <prvTCPReturnPacket+0x170>
 8006446:	4577      	cmp	r7, lr
 8006448:	bf28      	it	cs
 800644a:	4677      	movcs	r7, lr
			if( ( ulSpace < pxSocket->u.xTCP.usCurMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usCurMSS ) )
 800644c:	f8b0 104a 	ldrh.w	r1, [r0, #74]	; 0x4a
 8006450:	428f      	cmp	r7, r1
 8006452:	d202      	bcs.n	800645a <prvTCPReturnPacket+0x5e>
				ulSpace = pxSocket->u.xTCP.usCurMSS;
 8006454:	458c      	cmp	ip, r1
 8006456:	bf28      	it	cs
 8006458:	460f      	movcs	r7, r1
			ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
 800645a:	f890 30c9 	ldrb.w	r3, [r0, #201]	; 0xc9
 800645e:	fa27 f303 	lsr.w	r3, r7, r3
 8006462:	f64f 71fc 	movw	r1, #65532	; 0xfffc
 8006466:	428b      	cmp	r3, r1
 8006468:	bf28      	it	cs
 800646a:	460b      	movcs	r3, r1
			pxTCPPacket->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
 800646c:	0219      	lsls	r1, r3, #8
 800646e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8006472:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 8006476:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800647a:	430b      	orrs	r3, r1
 800647c:	8623      	strh	r3, [r4, #48]	; 0x30
			pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
 800647e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8006482:	f36f 0300 	bfc	r3, #0, #1
 8006486:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
			pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
 800648a:	f8d0 10ec 	ldr.w	r1, [r0, #236]	; 0xec
 800648e:	440f      	add	r7, r1
 8006490:	6447      	str	r7, [r0, #68]	; 0x44
				if( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED )
 8006492:	f013 0f02 	tst.w	r3, #2
 8006496:	d06b      	beq.n	8006570 <prvTCPReturnPacket+0x174>
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 8006498:	b2db      	uxtb	r3, r3
					pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 800649a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 800649e:	f043 0304 	orr.w	r3, r3, #4
 80064a2:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
					pxTCPPacket->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1UL;
 80064a6:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 80064aa:	3b01      	subs	r3, #1
					pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 80064ac:	0e19      	lsrs	r1, r3, #24
 80064ae:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 80064b2:	021f      	lsls	r7, r3, #8
 80064b4:	f407 077f 	and.w	r7, r7, #16711680	; 0xff0000
 80064b8:	4339      	orrs	r1, r7
 80064ba:	0a1b      	lsrs	r3, r3, #8
 80064bc:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80064c0:	430b      	orrs	r3, r1
 80064c2:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
			pxTCPPacket->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
 80064c6:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
 80064ca:	0e19      	lsrs	r1, r3, #24
 80064cc:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 80064d0:	0218      	lsls	r0, r3, #8
 80064d2:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 80064d6:	4301      	orrs	r1, r0
 80064d8:	0a1b      	lsrs	r3, r3, #8
 80064da:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80064de:	430b      	orrs	r3, r1
 80064e0:	f8c4 302a 	str.w	r3, [r4, #42]	; 0x2a
		pxIPHeader->ucTimeToLive           = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 80064e4:	2380      	movs	r3, #128	; 0x80
 80064e6:	75a3      	strb	r3, [r4, #22]
		pxIPHeader->usLength               = FreeRTOS_htons( ulLen );
 80064e8:	0a13      	lsrs	r3, r2, #8
 80064ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80064ee:	8223      	strh	r3, [r4, #16]
		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ) )
 80064f0:	4b40      	ldr	r3, [pc, #256]	; (80065f4 <prvTCPReturnPacket+0x1f8>)
 80064f2:	695b      	ldr	r3, [r3, #20]
 80064f4:	b90b      	cbnz	r3, 80064fa <prvTCPReturnPacket+0xfe>
			ulSourceAddress = pxIPHeader->ulDestinationIPAddress;
 80064f6:	f8d4 301e 	ldr.w	r3, [r4, #30]
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 80064fa:	f8d4 101a 	ldr.w	r1, [r4, #26]
 80064fe:	f8c4 101e 	str.w	r1, [r4, #30]
		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
 8006502:	f8c4 301a 	str.w	r3, [r4, #26]
		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 8006506:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8006508:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
 800650a:	8461      	strh	r1, [r4, #34]	; 0x22
 800650c:	84a3      	strh	r3, [r4, #36]	; 0x24
		pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
 800650e:	483a      	ldr	r0, [pc, #232]	; (80065f8 <prvTCPReturnPacket+0x1fc>)
 8006510:	8803      	ldrh	r3, [r0, #0]
 8006512:	0a19      	lsrs	r1, r3, #8
 8006514:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 8006518:	8261      	strh	r1, [r4, #18]
		usPacketIdentifier++;
 800651a:	3301      	adds	r3, #1
 800651c:	8003      	strh	r3, [r0, #0]
		pxIPHeader->usFragmentOffset = 0u;
 800651e:	2300      	movs	r3, #0
 8006520:	7523      	strb	r3, [r4, #20]
 8006522:	7563      	strb	r3, [r4, #21]
		pxNetworkBuffer->xDataLength = ulLen + ipSIZE_OF_ETH_HEADER;
 8006524:	320e      	adds	r2, #14
 8006526:	61f2      	str	r2, [r6, #28]
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ),
 8006528:	4627      	mov	r7, r4
 800652a:	f857 3f06 	ldr.w	r3, [r7, #6]!
 800652e:	6023      	str	r3, [r4, #0]
 8006530:	88bb      	ldrh	r3, [r7, #4]
 8006532:	80a3      	strh	r3, [r4, #4]
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8006534:	4b2f      	ldr	r3, [pc, #188]	; (80065f4 <prvTCPReturnPacket+0x1f8>)
 8006536:	6818      	ldr	r0, [r3, #0]
 8006538:	f8c4 0006 	str.w	r0, [r4, #6]
 800653c:	889b      	ldrh	r3, [r3, #4]
 800653e:	80bb      	strh	r3, [r7, #4]
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 8006540:	4629      	mov	r1, r5
 8006542:	4630      	mov	r0, r6
 8006544:	f002 fa88 	bl	8008a58 <xNetworkInterfaceOutput>
		if( xReleaseAfterSend == pdFALSE )
 8006548:	2d00      	cmp	r5, #0
 800654a:	d042      	beq.n	80065d2 <prvTCPReturnPacket+0x1d6>
}
 800654c:	b00a      	add	sp, #40	; 0x28
 800654e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		xTempBuffer.pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 8006552:	f100 0382 	add.w	r3, r0, #130	; 0x82
 8006556:	9307      	str	r3, [sp, #28]
		xTempBuffer.xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 8006558:	2346      	movs	r3, #70	; 0x46
 800655a:	9308      	str	r3, [sp, #32]
		xReleaseAfterSend = pdFALSE;
 800655c:	2500      	movs	r5, #0
		pxNetworkBuffer = &xTempBuffer;
 800655e:	ae01      	add	r6, sp, #4
 8006560:	e754      	b.n	800640c <prvTCPReturnPacket+0x10>
				ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 8006562:	f8d0 c06c 	ldr.w	ip, [r0, #108]	; 0x6c
 8006566:	e764      	b.n	8006432 <prvTCPReturnPacket+0x36>
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8006568:	469c      	mov	ip, r3
 800656a:	e762      	b.n	8006432 <prvTCPReturnPacket+0x36>
				ulSpace = 0u;
 800656c:	2700      	movs	r7, #0
 800656e:	e76d      	b.n	800644c <prvTCPReturnPacket+0x50>
				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber );
 8006570:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8006574:	0e19      	lsrs	r1, r3, #24
 8006576:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 800657a:	021f      	lsls	r7, r3, #8
 800657c:	f407 077f 	and.w	r7, r7, #16711680	; 0xff0000
 8006580:	4339      	orrs	r1, r7
 8006582:	0a1b      	lsrs	r3, r3, #8
 8006584:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006588:	430b      	orrs	r3, r1
 800658a:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
				if( ( pxTCPPacket->xTCPHeader.ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u )
 800658e:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006592:	f013 0f01 	tst.w	r3, #1
 8006596:	d096      	beq.n	80064c6 <prvTCPReturnPacket+0xca>
					uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + ipSIZE_OF_IPv4_HEADER ) );
 8006598:	f1a2 0128 	sub.w	r1, r2, #40	; 0x28
					if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
 800659c:	f8d0 7108 	ldr.w	r7, [r0, #264]	; 0x108
 80065a0:	4439      	add	r1, r7
 80065a2:	f8d0 7100 	ldr.w	r7, [r0, #256]	; 0x100
 80065a6:	42b9      	cmp	r1, r7
						pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_FIN );
 80065a8:	bf1c      	itt	ne
 80065aa:	f023 0301 	bicne.w	r3, r3, #1
 80065ae:	f884 302f 	strbne.w	r3, [r4, #47]	; 0x2f
 80065b2:	e788      	b.n	80064c6 <prvTCPReturnPacket+0xca>
			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
 80065b4:	f8d4 3026 	ldr.w	r3, [r4, #38]	; 0x26
 80065b8:	f8d4 102a 	ldr.w	r1, [r4, #42]	; 0x2a
 80065bc:	f8c4 1026 	str.w	r1, [r4, #38]	; 0x26
 80065c0:	f8c4 302a 	str.w	r3, [r4, #42]	; 0x2a
		pxIPHeader->ucTimeToLive           = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 80065c4:	2380      	movs	r3, #128	; 0x80
 80065c6:	75a3      	strb	r3, [r4, #22]
		pxIPHeader->usLength               = FreeRTOS_htons( ulLen );
 80065c8:	0a13      	lsrs	r3, r2, #8
 80065ca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80065ce:	8223      	strh	r3, [r4, #16]
 80065d0:	e791      	b.n	80064f6 <prvTCPReturnPacket+0xfa>
			vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort);
 80065d2:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 80065d4:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 80065d6:	8462      	strh	r2, [r4, #34]	; 0x22
 80065d8:	84a3      	strh	r3, [r4, #36]	; 0x24
			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
 80065da:	f8d4 301e 	ldr.w	r3, [r4, #30]
 80065de:	f8c4 301a 	str.w	r3, [r4, #26]
			memcpy( pxEthernetHeader->xSourceAddress.ucBytes, pxEthernetHeader->xDestinationAddress.ucBytes, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 80065e2:	6823      	ldr	r3, [r4, #0]
 80065e4:	f8c4 3006 	str.w	r3, [r4, #6]
 80065e8:	88a3      	ldrh	r3, [r4, #4]
 80065ea:	80bb      	strh	r3, [r7, #4]
}
 80065ec:	e7ae      	b.n	800654c <prvTCPReturnPacket+0x150>
 80065ee:	bf00      	nop
 80065f0:	00040080 	.word	0x00040080
 80065f4:	20000010 	.word	0x20000010
 80065f8:	200004d0 	.word	0x200004d0

080065fc <prvTCPSendReset>:
{
 80065fc:	b508      	push	{r3, lr}
 80065fe:	4601      	mov	r1, r0
	TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006600:	6983      	ldr	r3, [r0, #24]
		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_RST;
 8006602:	2214      	movs	r2, #20
 8006604:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER + 0u ) << 2;
 8006608:	2250      	movs	r2, #80	; 0x50
 800660a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
		prvTCPReturnPacket( NULL, pxNetworkBuffer, ( uint32_t ) xSendLength, pdFALSE );
 800660e:	2300      	movs	r3, #0
 8006610:	2228      	movs	r2, #40	; 0x28
 8006612:	4618      	mov	r0, r3
 8006614:	f7ff fef2 	bl	80063fc <prvTCPReturnPacket>
}
 8006618:	2000      	movs	r0, #0
 800661a:	bd08      	pop	{r3, pc}

0800661c <prvTCPCreateWindow>:
{
 800661c:	b510      	push	{r4, lr}
 800661e:	b082      	sub	sp, #8
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxTxWinSize,
 8006620:	f8d0 20d8 	ldr.w	r2, [r0, #216]	; 0xd8
 8006624:	f240 51b4 	movw	r1, #1460	; 0x5b4
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxRxWinSize,
 8006628:	f8d0 40d4 	ldr.w	r4, [r0, #212]	; 0xd4
	vTCPWindowCreate(
 800662c:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 8006630:	9301      	str	r3, [sp, #4]
 8006632:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8006636:	9300      	str	r3, [sp, #0]
 8006638:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
 800663c:	fb01 f202 	mul.w	r2, r1, r2
 8006640:	fb01 f104 	mul.w	r1, r1, r4
 8006644:	30dc      	adds	r0, #220	; 0xdc
 8006646:	f001 fbc9 	bl	8007ddc <vTCPWindowCreate>
}
 800664a:	b002      	add	sp, #8
 800664c:	bd10      	pop	{r4, pc}
	...

08006650 <prvTCPNextTimeout>:
{
 8006650:	b510      	push	{r4, lr}
 8006652:	b082      	sub	sp, #8
 8006654:	4604      	mov	r4, r0
TickType_t ulDelayMs = ( TickType_t ) 20000;
 8006656:	f644 6320 	movw	r3, #20000	; 0x4e20
 800665a:	9301      	str	r3, [sp, #4]
	if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 800665c:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 8006660:	2b02      	cmp	r3, #2
 8006662:	d006      	beq.n	8006672 <prvTCPNextTimeout+0x22>
	else if( pxSocket->u.xTCP.usTimeout == 0u )
 8006664:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
 8006668:	b363      	cbz	r3, 80066c4 <prvTCPNextTimeout+0x74>
	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 800666a:	f8b4 0048 	ldrh.w	r0, [r4, #72]	; 0x48
}
 800666e:	b002      	add	sp, #8
 8006670:	bd10      	pop	{r4, pc}
		if( pxSocket->u.xTCP.bits.bConnPrepared )
 8006672:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8006676:	f013 0f08 	tst.w	r3, #8
 800667a:	d014      	beq.n	80066a6 <prvTCPNextTimeout+0x56>
			if( pxSocket->u.xTCP.ucRepCount < 3u )
 800667c:	f890 3052 	ldrb.w	r3, [r0, #82]	; 0x52
 8006680:	2b02      	cmp	r3, #2
 8006682:	d80c      	bhi.n	800669e <prvTCPNextTimeout+0x4e>
				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1u ) );
 8006684:	3b01      	subs	r3, #1
 8006686:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800668a:	409a      	lsls	r2, r3
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 800668c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8006690:	fb03 f302 	mul.w	r3, r3, r2
 8006694:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8006698:	d20d      	bcs.n	80066b6 <prvTCPNextTimeout+0x66>
 800669a:	2301      	movs	r3, #1
 800669c:	e00f      	b.n	80066be <prvTCPNextTimeout+0x6e>
				ulDelayMs = 11000UL;
 800669e:	f642 23f8 	movw	r3, #11000	; 0x2af8
 80066a2:	9301      	str	r3, [sp, #4]
 80066a4:	e002      	b.n	80066ac <prvTCPNextTimeout+0x5c>
			ulDelayMs = 500UL;
 80066a6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 80066aa:	9301      	str	r3, [sp, #4]
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 80066ac:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80066b0:	9a01      	ldr	r2, [sp, #4]
 80066b2:	fb03 f302 	mul.w	r3, r3, r2
 80066b6:	4a12      	ldr	r2, [pc, #72]	; (8006700 <prvTCPNextTimeout+0xb0>)
 80066b8:	fba2 2303 	umull	r2, r3, r2, r3
 80066bc:	099b      	lsrs	r3, r3, #6
 80066be:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 80066c2:	e7d2      	b.n	800666a <prvTCPNextTimeout+0x1a>
		BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs );
 80066c4:	aa01      	add	r2, sp, #4
 80066c6:	f8d0 10cc 	ldr.w	r1, [r0, #204]	; 0xcc
 80066ca:	30dc      	adds	r0, #220	; 0xdc
 80066cc:	f001 fcfe 	bl	80080cc <xTCPWindowTxHasData>
		if( ulDelayMs == 0u )
 80066d0:	9b01      	ldr	r3, [sp, #4]
 80066d2:	b92b      	cbnz	r3, 80066e0 <prvTCPNextTimeout+0x90>
			ulDelayMs = xResult ? 1UL : 20000UL;
 80066d4:	2800      	cmp	r0, #0
 80066d6:	f644 6320 	movw	r3, #20000	; 0x4e20
 80066da:	bf18      	it	ne
 80066dc:	2301      	movne	r3, #1
 80066de:	9301      	str	r3, [sp, #4]
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 80066e0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80066e4:	9a01      	ldr	r2, [sp, #4]
 80066e6:	fb03 f302 	mul.w	r3, r3, r2
 80066ea:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80066ee:	bf23      	ittte	cs
 80066f0:	4a03      	ldrcs	r2, [pc, #12]	; (8006700 <prvTCPNextTimeout+0xb0>)
 80066f2:	fba2 2303 	umullcs	r2, r3, r2, r3
 80066f6:	099b      	lsrcs	r3, r3, #6
 80066f8:	2301      	movcc	r3, #1
 80066fa:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 80066fe:	e7b4      	b.n	800666a <prvTCPNextTimeout+0x1a>
 8006700:	10624dd3 	.word	0x10624dd3

08006704 <vTCPStateChange>:
{
 8006704:	b570      	push	{r4, r5, r6, lr}
 8006706:	4604      	mov	r4, r0
 8006708:	460d      	mov	r5, r1
BaseType_t bBefore = ( BaseType_t ) NOW_CONNECTED( pxSocket->u.xTCP.ucTCPState );	/* Was it connected ? */
 800670a:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 800670e:	2b04      	cmp	r3, #4
 8006710:	d961      	bls.n	80067d6 <vTCPStateChange+0xd2>
 8006712:	2b08      	cmp	r3, #8
 8006714:	d05f      	beq.n	80067d6 <vTCPStateChange+0xd2>
BaseType_t bAfter  = ( BaseType_t ) NOW_CONNECTED( eTCPState );						/* Is it connected now ? */
 8006716:	2904      	cmp	r1, #4
 8006718:	d817      	bhi.n	800674a <vTCPStateChange+0x46>
			pxSocket->xEventBits |= eSOCKET_CLOSED;
 800671a:	6823      	ldr	r3, [r4, #0]
 800671c:	f043 0220 	orr.w	r2, r3, #32
 8006720:	6022      	str	r2, [r4, #0]
				if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
 8006722:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006724:	f012 0f04 	tst.w	r2, #4
 8006728:	d002      	beq.n	8006730 <vTCPStateChange+0x2c>
					pxSocket->xEventBits |= ( eSELECT_EXCEPT << SOCKET_EVENT_BIT_COUNT );
 800672a:	f443 6384 	orr.w	r3, r3, #1056	; 0x420
 800672e:	6023      	str	r3, [r4, #0]
	switch( uxStatus )
 8006730:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006734:	2b0b      	cmp	r3, #11
 8006736:	f200 80ae 	bhi.w	8006896 <vTCPStateChange+0x192>
 800673a:	e8df f003 	tbb	[pc, r3]
 800673e:	ac2f      	.short	0xac2f
 8006740:	acacacac 	.word	0xacacacac
 8006744:	2f2f2fac 	.word	0x2f2f2fac
 8006748:	2fac      	.short	0x2fac
BaseType_t bBefore = ( BaseType_t ) NOW_CONNECTED( pxSocket->u.xTCP.ucTCPState );	/* Was it connected ? */
 800674a:	2301      	movs	r3, #1
 800674c:	e046      	b.n	80067dc <vTCPStateChange+0xd8>
					configASSERT( xParent != NULL );
 800674e:	f240 51c5 	movw	r1, #1477	; 0x5c5
 8006752:	485b      	ldr	r0, [pc, #364]	; (80068c0 <vTCPStateChange+0x1bc>)
 8006754:	f005 fe04 	bl	800c360 <vAssertCalled>
 8006758:	e05d      	b.n	8006816 <vTCPStateChange+0x112>
				if( xParent != NULL )
 800675a:	b11c      	cbz	r4, 8006764 <vTCPStateChange+0x60>
					xParent = pxSocket;
 800675c:	4626      	mov	r6, r4
 800675e:	e04c      	b.n	80067fa <vTCPStateChange+0xf6>
						xParent->u.xTCP.pxPeerSocket = pxSocket;
 8006760:	6574      	str	r4, [r6, #84]	; 0x54
 8006762:	e04d      	b.n	8006800 <vTCPStateChange+0xfc>
					xParent = pxSocket;
 8006764:	4626      	mov	r6, r4
 8006766:	e056      	b.n	8006816 <vTCPStateChange+0x112>
				pxSocket->xEventBits |= eSOCKET_CONNECT;
 8006768:	6823      	ldr	r3, [r4, #0]
 800676a:	f043 0208 	orr.w	r2, r3, #8
 800676e:	6022      	str	r2, [r4, #0]
					if( pxSocket->xSelectBits & eSELECT_WRITE )
 8006770:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006772:	f012 0f02 	tst.w	r2, #2
 8006776:	d0db      	beq.n	8006730 <vTCPStateChange+0x2c>
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 8006778:	f443 7302 	orr.w	r3, r3, #520	; 0x208
 800677c:	6023      	str	r3, [r4, #0]
 800677e:	e7d7      	b.n	8006730 <vTCPStateChange+0x2c>
		if( eTCPState == eCLOSED )
 8006780:	2d00      	cmp	r5, #0
 8006782:	d174      	bne.n	800686e <vTCPStateChange+0x16a>
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 8006784:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006788:	f013 0f06 	tst.w	r3, #6
 800678c:	d06f      	beq.n	800686e <vTCPStateChange+0x16a>
				if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 800678e:	f013 0f08 	tst.w	r3, #8
 8006792:	d16c      	bne.n	800686e <vTCPStateChange+0x16a>
					FreeRTOS_closesocket( pxSocket );
 8006794:	4620      	mov	r0, r4
 8006796:	f7fe fd43 	bl	8005220 <FreeRTOS_closesocket>
 800679a:	e068      	b.n	800686e <vTCPStateChange+0x16a>
	switch( uxStatus )
 800679c:	2600      	movs	r6, #0
			pxSocket->u.xTCP.usTimeout = 0u;
 800679e:	2300      	movs	r3, #0
 80067a0:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 80067a4:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 80067a8:	f003 fc42 	bl	800a030 <xTaskGetTickCount>
 80067ac:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 80067ae:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 80067b2:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80067b6:	f36f 0341 	bfc	r3, #1, #1
 80067ba:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 80067be:	2300      	movs	r3, #0
 80067c0:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 80067c4:	f003 fc34 	bl	800a030 <xTaskGetTickCount>
 80067c8:	65e0      	str	r0, [r4, #92]	; 0x5c
	if( xParent != NULL )
 80067ca:	2e00      	cmp	r6, #0
 80067cc:	d077      	beq.n	80068be <vTCPStateChange+0x1ba>
		vSocketWakeUpUser( xParent );
 80067ce:	4630      	mov	r0, r6
 80067d0:	f7fe fdfc 	bl	80053cc <vSocketWakeUpUser>
}
 80067d4:	bd70      	pop	{r4, r5, r6, pc}
BaseType_t bAfter  = ( BaseType_t ) NOW_CONNECTED( eTCPState );						/* Is it connected now ? */
 80067d6:	2d04      	cmp	r5, #4
 80067d8:	d9d2      	bls.n	8006780 <vTCPStateChange+0x7c>
 80067da:	2300      	movs	r3, #0
 80067dc:	2d08      	cmp	r5, #8
 80067de:	d043      	beq.n	8006868 <vTCPStateChange+0x164>
	if( bBefore != bAfter )
 80067e0:	2b00      	cmp	r3, #0
 80067e2:	d1cd      	bne.n	8006780 <vTCPStateChange+0x7c>
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 80067e4:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80067e8:	f013 0f04 	tst.w	r3, #4
 80067ec:	d0bc      	beq.n	8006768 <vTCPStateChange+0x64>
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 80067ee:	f013 0f08 	tst.w	r3, #8
 80067f2:	d1b2      	bne.n	800675a <vTCPStateChange+0x56>
					xParent = pxSocket->u.xTCP.pxPeerSocket;
 80067f4:	6d66      	ldr	r6, [r4, #84]	; 0x54
					configASSERT( xParent != NULL );
 80067f6:	2e00      	cmp	r6, #0
 80067f8:	d0a9      	beq.n	800674e <vTCPStateChange+0x4a>
					if( xParent->u.xTCP.pxPeerSocket == NULL )
 80067fa:	6d73      	ldr	r3, [r6, #84]	; 0x54
 80067fc:	2b00      	cmp	r3, #0
 80067fe:	d0af      	beq.n	8006760 <vTCPStateChange+0x5c>
					xParent->xEventBits |= eSOCKET_ACCEPT;
 8006800:	6833      	ldr	r3, [r6, #0]
 8006802:	f043 0204 	orr.w	r2, r3, #4
 8006806:	6032      	str	r2, [r6, #0]
						if( ( xParent->xSelectBits & eSELECT_READ ) != 0 )
 8006808:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800680a:	f012 0f01 	tst.w	r2, #1
 800680e:	d002      	beq.n	8006816 <vTCPStateChange+0x112>
							xParent->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
 8006810:	f443 7382 	orr.w	r3, r3, #260	; 0x104
 8006814:	6033      	str	r3, [r6, #0]
				pxSocket->u.xTCP.pxPeerSocket = NULL;
 8006816:	2300      	movs	r3, #0
 8006818:	6563      	str	r3, [r4, #84]	; 0x54
				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 800681a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
 800681e:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8006822:	f043 0302 	orr.w	r3, r3, #2
 8006826:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
	switch( uxStatus )
 800682a:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 800682e:	2b0b      	cmp	r3, #11
 8006830:	d8b8      	bhi.n	80067a4 <vTCPStateChange+0xa0>
 8006832:	a201      	add	r2, pc, #4	; (adr r2, 8006838 <vTCPStateChange+0x134>)
 8006834:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006838:	0800679f 	.word	0x0800679f
 800683c:	080067a5 	.word	0x080067a5
 8006840:	080067a5 	.word	0x080067a5
 8006844:	080067a5 	.word	0x080067a5
 8006848:	080067a5 	.word	0x080067a5
 800684c:	080067a5 	.word	0x080067a5
 8006850:	080067a5 	.word	0x080067a5
 8006854:	0800679f 	.word	0x0800679f
 8006858:	0800679f 	.word	0x0800679f
 800685c:	0800679f 	.word	0x0800679f
 8006860:	080067a5 	.word	0x080067a5
 8006864:	0800679f 	.word	0x0800679f
	if( bBefore != bAfter )
 8006868:	2b00      	cmp	r3, #0
 800686a:	f47f af56 	bne.w	800671a <vTCPStateChange+0x16>
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 800686e:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8006872:	f003 fbdd 	bl	800a030 <xTaskGetTickCount>
 8006876:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 8006878:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800687c:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8006880:	f36f 0341 	bfc	r3, #1, #1
 8006884:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 8006888:	2300      	movs	r3, #0
 800688a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 800688e:	f003 fbcf 	bl	800a030 <xTaskGetTickCount>
 8006892:	65e0      	str	r0, [r4, #92]	; 0x5c
 8006894:	bd70      	pop	{r4, r5, r6, pc}
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 8006896:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 800689a:	f003 fbc9 	bl	800a030 <xTaskGetTickCount>
 800689e:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 80068a0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 80068a4:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 80068a8:	f36f 0341 	bfc	r3, #1, #1
 80068ac:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 80068b0:	2300      	movs	r3, #0
 80068b2:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 80068b6:	f003 fbbb 	bl	800a030 <xTaskGetTickCount>
 80068ba:	65e0      	str	r0, [r4, #92]	; 0x5c
 80068bc:	bd70      	pop	{r4, r5, r6, pc}
 80068be:	bd70      	pop	{r4, r5, r6, pc}
 80068c0:	0800cd60 	.word	0x0800cd60

080068c4 <prvTCPPrepareSend>:
{
 80068c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80068c8:	b085      	sub	sp, #20
 80068ca:	4605      	mov	r5, r0
 80068cc:	4689      	mov	r9, r1
 80068ce:	4616      	mov	r6, r2
	if( ( *ppxNetworkBuffer ) != NULL )
 80068d0:	680b      	ldr	r3, [r1, #0]
 80068d2:	b37b      	cbz	r3, 8006934 <prvTCPPrepareSend+0x70>
		pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
 80068d4:	699c      	ldr	r4, [r3, #24]
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 80068d6:	f105 0bdc 	add.w	fp, r5, #220	; 0xdc
	lStreamPos = 0;
 80068da:	2300      	movs	r3, #0
 80068dc:	9303      	str	r3, [sp, #12]
	pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_ACK;
 80068de:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 80068e2:	f043 0310 	orr.w	r3, r3, #16
 80068e6:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	if( pxSocket->u.xTCP.txStream != NULL )
 80068ea:	6fab      	ldr	r3, [r5, #120]	; 0x78
 80068ec:	2b00      	cmp	r3, #0
 80068ee:	f000 810e 	beq.w	8006b0e <prvTCPPrepareSend+0x24a>
		if( pxSocket->u.xTCP.usCurMSS > 1u )
 80068f2:	f8b5 304a 	ldrh.w	r3, [r5, #74]	; 0x4a
 80068f6:	2b01      	cmp	r3, #1
 80068f8:	f240 808a 	bls.w	8006a10 <prvTCPPrepareSend+0x14c>
			lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos );
 80068fc:	aa03      	add	r2, sp, #12
 80068fe:	f8d5 10cc 	ldr.w	r1, [r5, #204]	; 0xcc
 8006902:	4658      	mov	r0, fp
 8006904:	f001 fc1c 	bl	8008140 <ulTCPWindowTxGet>
 8006908:	4682      	mov	sl, r0
 800690a:	4607      	mov	r7, r0
		if( lDataLen > 0 )
 800690c:	2800      	cmp	r0, #0
 800690e:	f340 8100 	ble.w	8006b12 <prvTCPPrepareSend+0x24e>
			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
 8006912:	f8d9 8000 	ldr.w	r8, [r9]
	if( xBufferAllocFixedSize != pdFALSE )
 8006916:	4ba6      	ldr	r3, [pc, #664]	; (8006bb0 <prvTCPPrepareSend+0x2ec>)
 8006918:	681b      	ldr	r3, [r3, #0]
 800691a:	b173      	cbz	r3, 800693a <prvTCPPrepareSend+0x76>
	if( xResize != pdFALSE )
 800691c:	f1b8 0f00 	cmp.w	r8, #0
 8006920:	d05c      	beq.n	80069dc <prvTCPPrepareSend+0x118>
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 8006922:	f106 0336 	add.w	r3, r6, #54	; 0x36
 8006926:	4403      	add	r3, r0
 8006928:	f8c8 301c 	str.w	r3, [r8, #28]
			if( pxNewBuffer != NULL )
 800692c:	f1b8 0f00 	cmp.w	r8, #0
 8006930:	d116      	bne.n	8006960 <prvTCPPrepareSend+0x9c>
 8006932:	e0b0      	b.n	8006a96 <prvTCPPrepareSend+0x1d2>
		pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 8006934:	f100 0482 	add.w	r4, r0, #130	; 0x82
 8006938:	e7cd      	b.n	80068d6 <prvTCPPrepareSend+0x12>
			( int32_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + lDataLen );
 800693a:	f106 0036 	add.w	r0, r6, #54	; 0x36
 800693e:	4450      	add	r0, sl
	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
 8006940:	2846      	cmp	r0, #70	; 0x46
 8006942:	bfb8      	it	lt
 8006944:	2046      	movlt	r0, #70	; 0x46
		xResize = ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < (size_t)lNeeded );
 8006946:	f1b8 0f00 	cmp.w	r8, #0
 800694a:	f000 810d 	beq.w	8006b68 <prvTCPPrepareSend+0x2a4>
	if( xResize != pdFALSE )
 800694e:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8006952:	4283      	cmp	r3, r0
 8006954:	d344      	bcc.n	80069e0 <prvTCPPrepareSend+0x11c>
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 8006956:	f106 0336 	add.w	r3, r6, #54	; 0x36
 800695a:	4453      	add	r3, sl
 800695c:	f8c8 301c 	str.w	r3, [r8, #28]
				*ppxNetworkBuffer = pxNewBuffer;
 8006960:	f8c9 8000 	str.w	r8, [r9]
				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
 8006964:	f8d8 4018 	ldr.w	r4, [r8, #24]
				pucSendData = pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 8006968:	f106 0236 	add.w	r2, r6, #54	; 0x36
 800696c:	4422      	add	r2, r4
				uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, ( size_t ) lStreamPos );
 800696e:	6fa8      	ldr	r0, [r5, #120]	; 0x78
 8006970:	f8d0 e000 	ldr.w	lr, [r0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8006974:	6903      	ldr	r3, [r0, #16]
 8006976:	9903      	ldr	r1, [sp, #12]
 8006978:	4419      	add	r1, r3
 800697a:	eba1 010e 	sub.w	r1, r1, lr
	if ( uxCount >= pxBuffer->LENGTH )
 800697e:	428b      	cmp	r3, r1
		uxCount -= pxBuffer->LENGTH;
 8006980:	bf98      	it	ls
 8006982:	1ac9      	subls	r1, r1, r3
				ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, ( size_t ) lDataLen, pdTRUE );
 8006984:	2301      	movs	r3, #1
 8006986:	9300      	str	r3, [sp, #0]
 8006988:	4653      	mov	r3, sl
 800698a:	f7ff fcaa 	bl	80062e2 <uxStreamBufferGet>
				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) )
 800698e:	f8b5 3040 	ldrh.w	r3, [r5, #64]	; 0x40
 8006992:	f423 537e 	bic.w	r3, r3, #16256	; 0x3f80
 8006996:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800699a:	045b      	lsls	r3, r3, #17
 800699c:	0c5b      	lsrs	r3, r3, #17
 800699e:	2b40      	cmp	r3, #64	; 0x40
 80069a0:	d137      	bne.n	8006a12 <prvTCPPrepareSend+0x14e>
					ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStreamPos, pxSocket->u.xTCP.txStream->uxHead );
 80069a2:	6faa      	ldr	r2, [r5, #120]	; 0x78
 80069a4:	6893      	ldr	r3, [r2, #8]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 80069a6:	6912      	ldr	r2, [r2, #16]
 80069a8:	4413      	add	r3, r2
 80069aa:	9903      	ldr	r1, [sp, #12]
 80069ac:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 80069ae:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 80069b0:	bf98      	it	ls
 80069b2:	1a9b      	subls	r3, r3, r2
					if( ulDistance == ulDataGot )
 80069b4:	4298      	cmp	r0, r3
 80069b6:	d12c      	bne.n	8006a12 <prvTCPPrepareSend+0x14e>
						pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
 80069b8:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 80069bc:	f043 0301 	orr.w	r3, r3, #1
 80069c0:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLen;
 80069c4:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
 80069c8:	4453      	add	r3, sl
 80069ca:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 80069ce:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 80069d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80069d6:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
 80069da:	e01a      	b.n	8006a12 <prvTCPPrepareSend+0x14e>
		lNeeded = ( int32_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
 80069dc:	f240 50f2 	movw	r0, #1522	; 0x5f2
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 80069e0:	2100      	movs	r1, #0
 80069e2:	f001 fd9d 	bl	8008520 <pxGetNetworkBufferWithDescriptor>
		if( pxReturn != NULL )
 80069e6:	2800      	cmp	r0, #0
 80069e8:	f000 808e 	beq.w	8006b08 <prvTCPPrepareSend+0x244>
			if( pxNetworkBuffer )
 80069ec:	f1b8 0f00 	cmp.w	r8, #0
 80069f0:	d00c      	beq.n	8006a0c <prvTCPPrepareSend+0x148>
				memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 80069f2:	f8d8 201c 	ldr.w	r2, [r8, #28]
 80069f6:	f8d8 1018 	ldr.w	r1, [r8, #24]
 80069fa:	4604      	mov	r4, r0
 80069fc:	6980      	ldr	r0, [r0, #24]
 80069fe:	f005 fe6a 	bl	800c6d6 <memcpy>
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8006a02:	4640      	mov	r0, r8
 8006a04:	f001 fd66 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 8006a08:	46a0      	mov	r8, r4
 8006a0a:	e7a9      	b.n	8006960 <prvTCPPrepareSend+0x9c>
 8006a0c:	4680      	mov	r8, r0
 8006a0e:	e0b0      	b.n	8006b72 <prvTCPPrepareSend+0x2ae>
	lDataLen = 0;
 8006a10:	2700      	movs	r7, #0
	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
 8006a12:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 8006a16:	2b05      	cmp	r3, #5
 8006a18:	f000 8081 	beq.w	8006b1e <prvTCPPrepareSend+0x25a>
	if( ( lDataLen > 0 ) ||
 8006a1c:	2f00      	cmp	r7, #0
 8006a1e:	dd3c      	ble.n	8006a9a <prvTCPPrepareSend+0x1d6>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 8006a20:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006a24:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8006a28:	f106 0214 	add.w	r2, r6, #20
 8006a2c:	0092      	lsls	r2, r2, #2
 8006a2e:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 8006a32:	f043 0210 	orr.w	r2, r3, #16
 8006a36:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_PSH;
 8006a3a:	f043 0318 	orr.w	r3, r3, #24
 8006a3e:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
		lDataLen += ( int32_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 8006a42:	3628      	adds	r6, #40	; 0x28
 8006a44:	4437      	add	r7, r6
}
 8006a46:	4638      	mov	r0, r7
 8006a48:	b005      	add	sp, #20
 8006a4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 8006a4e:	4658      	mov	r0, fp
 8006a50:	f001 fb36 	bl	80080c0 <xTCPWindowTxDone>
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 8006a54:	2800      	cmp	r0, #0
 8006a56:	d067      	beq.n	8006b28 <prvTCPPrepareSend+0x264>
			pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
 8006a58:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8006a5c:	f36f 1345 	bfc	r3, #5, #1
 8006a60:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
 8006a64:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006a68:	f043 0301 	orr.w	r3, r3, #1
 8006a6c:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 8006a70:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8006a74:	f043 0341 	orr.w	r3, r3, #65	; 0x41
 8006a78:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 8006a7c:	f8d5 30fc 	ldr.w	r3, [r5, #252]	; 0xfc
 8006a80:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
 8006a84:	2106      	movs	r1, #6
 8006a86:	4628      	mov	r0, r5
 8006a88:	f7ff fe3c 	bl	8006704 <vTCPStateChange>
 8006a8c:	e04c      	b.n	8006b28 <prvTCPPrepareSend+0x264>
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8006a8e:	2108      	movs	r1, #8
 8006a90:	4628      	mov	r0, r5
 8006a92:	f7ff fe37 	bl	8006704 <vTCPStateChange>
	pxTCPPacket = ( TCPPacket_t * ) ( pucEthernetBuffer );
 8006a96:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 8006a9a:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006a9e:	f013 0f03 	tst.w	r3, #3
 8006aa2:	d0d0      	beq.n	8006a46 <prvTCPPrepareSend+0x182>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 8006aa4:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006aa8:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8006aac:	f106 0214 	add.w	r2, r6, #20
 8006ab0:	0092      	lsls	r2, r2, #2
 8006ab2:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 8006ab6:	f043 0210 	orr.w	r2, r3, #16
 8006aba:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
		if( lDataLen != 0l )
 8006abe:	2f00      	cmp	r7, #0
 8006ac0:	d0bf      	beq.n	8006a42 <prvTCPPrepareSend+0x17e>
 8006ac2:	e7ba      	b.n	8006a3a <prvTCPPrepareSend+0x176>
				TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastAliveTime;
 8006ac4:	f003 fab4 	bl	800a030 <xTaskGetTickCount>
 8006ac8:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 8006aca:	1ac0      	subs	r0, r0, r3
				if( pxSocket->u.xTCP.ucKeepRepCount )
 8006acc:	f895 1058 	ldrb.w	r1, [r5, #88]	; 0x58
					xMax = ( 3u * configTICK_RATE_HZ );
 8006ad0:	f640 32b8 	movw	r2, #3000	; 0xbb8
 8006ad4:	f644 6320 	movw	r3, #20000	; 0x4e20
 8006ad8:	2900      	cmp	r1, #0
 8006ada:	bf18      	it	ne
 8006adc:	4613      	movne	r3, r2
				if( xAge > xMax )
 8006ade:	4283      	cmp	r3, r0
 8006ae0:	d22e      	bcs.n	8006b40 <prvTCPPrepareSend+0x27c>
					pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 8006ae2:	f003 faa5 	bl	800a030 <xTaskGetTickCount>
 8006ae6:	65e8      	str	r0, [r5, #92]	; 0x5c
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdTRUE_UNSIGNED;
 8006ae8:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006aec:	f043 0302 	orr.w	r3, r3, #2
 8006af0:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500 ) );
 8006af4:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8006af8:	f8a5 3048 	strh.w	r3, [r5, #72]	; 0x48
					pxSocket->u.xTCP.ucKeepRepCount++;
 8006afc:	f895 3058 	ldrb.w	r3, [r5, #88]	; 0x58
 8006b00:	3301      	adds	r3, #1
 8006b02:	f885 3058 	strb.w	r3, [r5, #88]	; 0x58
 8006b06:	e01b      	b.n	8006b40 <prvTCPPrepareSend+0x27c>
				lDataLen = -1;
 8006b08:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8006b0c:	e786      	b.n	8006a1c <prvTCPPrepareSend+0x158>
	lDataLen = 0;
 8006b0e:	2700      	movs	r7, #0
 8006b10:	e77f      	b.n	8006a12 <prvTCPPrepareSend+0x14e>
	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
 8006b12:	2800      	cmp	r0, #0
 8006b14:	db38      	blt.n	8006b88 <prvTCPPrepareSend+0x2c4>
 8006b16:	f895 3053 	ldrb.w	r3, [r5, #83]	; 0x53
 8006b1a:	2b05      	cmp	r3, #5
 8006b1c:	d1bd      	bne.n	8006a9a <prvTCPPrepareSend+0x1d6>
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 8006b1e:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
 8006b22:	f013 0f20 	tst.w	r3, #32
 8006b26:	d192      	bne.n	8006a4e <prvTCPPrepareSend+0x18a>
			if( pxSocket->u.xTCP.ucKeepRepCount > 3u )
 8006b28:	f895 3058 	ldrb.w	r3, [r5, #88]	; 0x58
 8006b2c:	2b03      	cmp	r3, #3
 8006b2e:	d8ae      	bhi.n	8006a8e <prvTCPPrepareSend+0x1ca>
			if( ( lDataLen == 0 ) && ( pxSocket->u.xTCP.bits.bWinChange == pdFALSE_UNSIGNED ) )
 8006b30:	2f00      	cmp	r7, #0
 8006b32:	f47f af73 	bne.w	8006a1c <prvTCPPrepareSend+0x158>
 8006b36:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006b3a:	f013 0f01 	tst.w	r3, #1
 8006b3e:	d0c1      	beq.n	8006ac4 <prvTCPPrepareSend+0x200>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 8006b40:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006b44:	f013 0f03 	tst.w	r3, #3
 8006b48:	f43f af7d 	beq.w	8006a46 <prvTCPPrepareSend+0x182>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 8006b4c:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006b50:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8006b54:	f106 0214 	add.w	r2, r6, #20
 8006b58:	0092      	lsls	r2, r2, #2
 8006b5a:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 8006b5e:	f043 0310 	orr.w	r3, r3, #16
 8006b62:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
 8006b66:	e76c      	b.n	8006a42 <prvTCPPrepareSend+0x17e>
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 8006b68:	2100      	movs	r1, #0
 8006b6a:	f001 fcd9 	bl	8008520 <pxGetNetworkBufferWithDescriptor>
		if( pxReturn != NULL )
 8006b6e:	4680      	mov	r8, r0
 8006b70:	b138      	cbz	r0, 8006b82 <prvTCPPrepareSend+0x2be>
				memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 8006b72:	2246      	movs	r2, #70	; 0x46
 8006b74:	f105 0182 	add.w	r1, r5, #130	; 0x82
 8006b78:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8006b7c:	f005 fdab 	bl	800c6d6 <memcpy>
 8006b80:	e6ee      	b.n	8006960 <prvTCPPrepareSend+0x9c>
				lDataLen = -1;
 8006b82:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8006b86:	e749      	b.n	8006a1c <prvTCPPrepareSend+0x158>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 8006b88:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8006b8c:	f013 0f03 	tst.w	r3, #3
 8006b90:	f43f af59 	beq.w	8006a46 <prvTCPPrepareSend+0x182>
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 8006b94:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 8006b98:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8006b9c:	f106 0214 	add.w	r2, r6, #20
 8006ba0:	0092      	lsls	r2, r2, #2
 8006ba2:	f884 202e 	strb.w	r2, [r4, #46]	; 0x2e
		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 8006ba6:	f043 0210 	orr.w	r2, r3, #16
 8006baa:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
 8006bae:	e744      	b.n	8006a3a <prvTCPPrepareSend+0x176>
 8006bb0:	0800ce00 	.word	0x0800ce00

08006bb4 <prvTCPSendRepeated>:
{
 8006bb4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006bb8:	4681      	mov	r9, r0
 8006bba:	4688      	mov	r8, r1
 8006bbc:	2408      	movs	r4, #8
int32_t lResult = 0;
 8006bbe:	2600      	movs	r6, #0
		xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 8006bc0:	4637      	mov	r7, r6
 8006bc2:	463a      	mov	r2, r7
 8006bc4:	4641      	mov	r1, r8
 8006bc6:	4648      	mov	r0, r9
 8006bc8:	f7ff fe7c 	bl	80068c4 <prvTCPPrepareSend>
		if( xSendLength <= 0 )
 8006bcc:	1e05      	subs	r5, r0, #0
 8006bce:	dd09      	ble.n	8006be4 <prvTCPSendRepeated+0x30>
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 8006bd0:	463b      	mov	r3, r7
 8006bd2:	462a      	mov	r2, r5
 8006bd4:	f8d8 1000 	ldr.w	r1, [r8]
 8006bd8:	4648      	mov	r0, r9
 8006bda:	f7ff fc0f 	bl	80063fc <prvTCPReturnPacket>
		lResult += xSendLength;
 8006bde:	442e      	add	r6, r5
	for( uxIndex = 0u; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 8006be0:	3c01      	subs	r4, #1
 8006be2:	d1ee      	bne.n	8006bc2 <prvTCPSendRepeated+0xe>
}
 8006be4:	4630      	mov	r0, r6
 8006be6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08006bec <xTCPSocketCheck>:
{
 8006bec:	b530      	push	{r4, r5, lr}
 8006bee:	b085      	sub	sp, #20
 8006bf0:	4604      	mov	r4, r0
	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != NULL ) )
 8006bf2:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
 8006bf6:	2b04      	cmp	r3, #4
 8006bf8:	f240 8145 	bls.w	8006e86 <xTCPSocketCheck+0x29a>
 8006bfc:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8006bfe:	2b00      	cmp	r3, #0
 8006c00:	f000 8129 	beq.w	8006e56 <xTCPSocketCheck+0x26a>
		prvTCPAddTxData( pxSocket );
 8006c04:	f7ff fbd0 	bl	80063a8 <prvTCPAddTxData>
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8006c08:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8006c0a:	2800      	cmp	r0, #0
 8006c0c:	f040 813e 	bne.w	8006e8c <xTCPSocketCheck+0x2a0>
 8006c10:	e00e      	b.n	8006c30 <xTCPSocketCheck+0x44>
					prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER, ipconfigZERO_COPY_TX_DRIVER );
 8006c12:	2300      	movs	r3, #0
 8006c14:	2228      	movs	r2, #40	; 0x28
 8006c16:	4601      	mov	r1, r0
 8006c18:	4620      	mov	r0, r4
 8006c1a:	f7ff fbef 	bl	80063fc <prvTCPReturnPacket>
 8006c1e:	e140      	b.n	8006ea2 <xTCPSocketCheck+0x2b6>
BaseType_t xReady = pdFALSE;
 8006c20:	2500      	movs	r5, #0
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8006c22:	f001 fc57 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
				pxSocket->u.xTCP.pxAckMessage = NULL;
 8006c26:	2300      	movs	r3, #0
 8006c28:	67e3      	str	r3, [r4, #124]	; 0x7c
	if( xReady == pdFALSE )
 8006c2a:	2d00      	cmp	r5, #0
 8006c2c:	f040 8102 	bne.w	8006e34 <xTCPSocketCheck+0x248>
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 8006c30:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006c34:	2b04      	cmp	r3, #4
 8006c36:	f200 8112 	bhi.w	8006e5e <xTCPSocketCheck+0x272>
 8006c3a:	2b02      	cmp	r3, #2
 8006c3c:	d012      	beq.n	8006c64 <xTCPSocketCheck+0x78>
		prvTCPNextTimeout( pxSocket );
 8006c3e:	4620      	mov	r0, r4
 8006c40:	f7ff fd06 	bl	8006650 <prvTCPNextTimeout>
		switch( pxSocket->u.xTCP.ucTCPState )
 8006c44:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006c48:	2b08      	cmp	r3, #8
 8006c4a:	f200 80fa 	bhi.w	8006e42 <xTCPSocketCheck+0x256>
 8006c4e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8006c52:	00f5      	.short	0x00f5
 8006c54:	00f800f5 	.word	0x00f800f5
 8006c58:	00f800f8 	.word	0x00f800f8
 8006c5c:	00f800f5 	.word	0x00f800f5
 8006c60:	00f500f8 	.word	0x00f500f8
		if( pxSocket->u.xTCP.ucRepCount >= 3u )
 8006c64:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8006c68:	2b02      	cmp	r3, #2
 8006c6a:	f200 80be 	bhi.w	8006dea <xTCPSocketCheck+0x1fe>
		else if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) || ( prvTCPPrepareConnect( pxSocket ) == pdTRUE ) )
 8006c6e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006c72:	f013 0f08 	tst.w	r3, #8
 8006c76:	d178      	bne.n	8006d6a <xTCPSocketCheck+0x17e>
		memset( xEthAddress.ucBytes, '\0', sizeof( xEthAddress.ucBytes ) );
 8006c78:	2300      	movs	r3, #0
 8006c7a:	9302      	str	r3, [sp, #8]
 8006c7c:	f8ad 300c 	strh.w	r3, [sp, #12]
	ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 8006c80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006c82:	0e1a      	lsrs	r2, r3, #24
 8006c84:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006c88:	0219      	lsls	r1, r3, #8
 8006c8a:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006c8e:	430a      	orrs	r2, r1
 8006c90:	0a1b      	lsrs	r3, r3, #8
 8006c92:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006c96:	4313      	orrs	r3, r2
 8006c98:	a804      	add	r0, sp, #16
 8006c9a:	f840 3d0c 	str.w	r3, [r0, #-12]!
	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );
 8006c9e:	a902      	add	r1, sp, #8
 8006ca0:	f7fc fbe6 	bl	8003470 <eARPGetCacheEntry>
	switch( eReturned )
 8006ca4:	2801      	cmp	r0, #1
 8006ca6:	f040 80a5 	bne.w	8006df4 <xTCPSocketCheck+0x208>
		pxSocket->u.xTCP.ucRepCount = 0u;
 8006caa:	2500      	movs	r5, #0
 8006cac:	f884 5052 	strb.w	r5, [r4, #82]	; 0x52
		pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
 8006cb0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006cb4:	f043 0308 	orr.w	r3, r3, #8
 8006cb8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, '\0', sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 8006cbc:	2246      	movs	r2, #70	; 0x46
 8006cbe:	4629      	mov	r1, r5
 8006cc0:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8006cc4:	f005 fd2c 	bl	800c720 <memset>
		memcpy( &pxTCPPacket->xEthernetHeader.xSourceAddress, &xEthAddress, sizeof( xEthAddress ) );
 8006cc8:	9802      	ldr	r0, [sp, #8]
 8006cca:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 8006cce:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8006cd2:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
		pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
 8006cd6:	2308      	movs	r3, #8
 8006cd8:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
 8006cdc:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f
		pxIPHeader->ucVersionHeaderLength = 0x45u;
 8006ce0:	2345      	movs	r3, #69	; 0x45
 8006ce2:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
		pxIPHeader->usLength = FreeRTOS_htons( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
 8006ce6:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 8006cea:	2338      	movs	r3, #56	; 0x38
 8006cec:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 8006cf0:	2380      	movs	r3, #128	; 0x80
 8006cf2:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
		pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
 8006cf6:	2306      	movs	r3, #6
 8006cf8:	f884 3099 	strb.w	r3, [r4, #153]	; 0x99
		pxIPHeader->ulDestinationIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8006cfc:	4b6f      	ldr	r3, [pc, #444]	; (8006ebc <xTCPSocketCheck+0x2d0>)
 8006cfe:	695b      	ldr	r3, [r3, #20]
 8006d00:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 8006d04:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006d06:	0e1a      	lsrs	r2, r3, #24
 8006d08:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006d0c:	0219      	lsls	r1, r3, #8
 8006d0e:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006d12:	430a      	orrs	r2, r1
 8006d14:	0a1b      	lsrs	r3, r3, #8
 8006d16:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006d1a:	4313      	orrs	r3, r2
 8006d1c:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
		pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
 8006d20:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8006d22:	0a13      	lsrs	r3, r2, #8
 8006d24:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006d28:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 8006d2c:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 8006d2e:	0a13      	lsrs	r3, r2, #8
 8006d30:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006d34:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0ul;
 8006d38:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulNextInitialSequenceNumber;
 8006d3c:	4a60      	ldr	r2, [pc, #384]	; (8006ec0 <xTCPSocketCheck+0x2d4>)
 8006d3e:	6813      	ldr	r3, [r2, #0]
 8006d40:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		ulNextInitialSequenceNumber += 0x102UL;
 8006d44:	f503 7381 	add.w	r3, r3, #258	; 0x102
 8006d48:	6013      	str	r3, [r2, #0]
		pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50u;
 8006d4a:	2350      	movs	r3, #80	; 0x50
 8006d4c:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_SYN;
 8006d50:	2302      	movs	r3, #2
 8006d52:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
		prvSocketSetMSS( pxSocket );
 8006d56:	4620      	mov	r0, r4
 8006d58:	f7ff fb04 	bl	8006364 <prvSocketSetMSS>
		pxSocket->u.xTCP.ulRxCurWinSize = pxSocket->u.xTCP.usInitMSS;
 8006d5c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8006d60:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		prvTCPCreateWindow( pxSocket );
 8006d64:	4620      	mov	r0, r4
 8006d66:	f7ff fc59 	bl	800661c <prvTCPCreateWindow>
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 8006d6a:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) TCP_OPT_MSS;
 8006d6e:	2202      	movs	r2, #2
 8006d70:	f884 20b8 	strb.w	r2, [r4, #184]	; 0xb8
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) TCP_OPT_MSS_LEN;
 8006d74:	2204      	movs	r2, #4
 8006d76:	f884 20b9 	strb.w	r2, [r4, #185]	; 0xb9
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 8006d7a:	0a1a      	lsrs	r2, r3, #8
 8006d7c:	f884 20ba 	strb.w	r2, [r4, #186]	; 0xba
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffu );
 8006d80:	f884 30bb 	strb.w	r3, [r4, #187]	; 0xbb
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 8006d84:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8006d88:	fb02 f203 	mul.w	r2, r2, r3
		while( uxWinSize > 0xfffful )
 8006d8c:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8006d90:	d339      	bcc.n	8006e06 <xTCPSocketCheck+0x21a>
 8006d92:	2300      	movs	r3, #0
			uxWinSize >>= 1;
 8006d94:	0852      	lsrs	r2, r2, #1
			ucFactor++;
 8006d96:	3301      	adds	r3, #1
 8006d98:	b2db      	uxtb	r3, r3
		while( uxWinSize > 0xfffful )
 8006d9a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8006d9e:	d2f9      	bcs.n	8006d94 <xTCPSocketCheck+0x1a8>
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 8006da0:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
		pxTCPHeader->ucOptdata[ 4 ] = TCP_OPT_NOOP;
 8006da4:	2201      	movs	r2, #1
 8006da6:	f884 20bc 	strb.w	r2, [r4, #188]	; 0xbc
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( TCP_OPT_WSOPT );
 8006daa:	2103      	movs	r1, #3
 8006dac:	f884 10bd 	strb.w	r1, [r4, #189]	; 0xbd
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( TCP_OPT_WSOPT_LEN );
 8006db0:	f884 10be 	strb.w	r1, [r4, #190]	; 0xbe
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 8006db4:	f884 30bf 	strb.w	r3, [r4, #191]	; 0xbf
			pxTCPHeader->ucOptdata[ uxOptionsLength + 0 ] = TCP_OPT_NOOP;
 8006db8:	f884 20c0 	strb.w	r2, [r4, #192]	; 0xc0
			pxTCPHeader->ucOptdata[ uxOptionsLength + 1 ] = TCP_OPT_NOOP;
 8006dbc:	f884 20c1 	strb.w	r2, [r4, #193]	; 0xc1
			pxTCPHeader->ucOptdata[ uxOptionsLength + 2 ] = TCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 8006dc0:	2304      	movs	r3, #4
 8006dc2:	f884 30c2 	strb.w	r3, [r4, #194]	; 0xc2
			pxTCPHeader->ucOptdata[ uxOptionsLength + 3 ] = 2;	/* 2: length of this option. */
 8006dc6:	2302      	movs	r3, #2
 8006dc8:	f884 30c3 	strb.w	r3, [r4, #195]	; 0xc3
			pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8006dcc:	2380      	movs	r3, #128	; 0x80
 8006dce:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
			pxSocket->u.xTCP.ucRepCount++;
 8006dd2:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8006dd6:	4413      	add	r3, r2
 8006dd8:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
			prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
 8006ddc:	2300      	movs	r3, #0
 8006dde:	2234      	movs	r2, #52	; 0x34
 8006de0:	4619      	mov	r1, r3
 8006de2:	4620      	mov	r0, r4
 8006de4:	f7ff fb0a 	bl	80063fc <prvTCPReturnPacket>
 8006de8:	e729      	b.n	8006c3e <xTCPSocketCheck+0x52>
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8006dea:	2108      	movs	r1, #8
 8006dec:	4620      	mov	r0, r4
 8006dee:	f7ff fc89 	bl	8006704 <vTCPStateChange>
 8006df2:	e724      	b.n	8006c3e <xTCPSocketCheck+0x52>
		pxSocket->u.xTCP.ucRepCount++;
 8006df4:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8006df8:	3301      	adds	r3, #1
 8006dfa:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
		FreeRTOS_OutputARPRequest( ulRemoteIP );
 8006dfe:	9801      	ldr	r0, [sp, #4]
 8006e00:	f7fc fbc8 	bl	8003594 <FreeRTOS_OutputARPRequest>
 8006e04:	e71b      	b.n	8006c3e <xTCPSocketCheck+0x52>
		ucFactor = 0u;
 8006e06:	2300      	movs	r3, #0
 8006e08:	e7ca      	b.n	8006da0 <xTCPSocketCheck+0x1b4>
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8006e0a:	2108      	movs	r1, #8
 8006e0c:	4620      	mov	r0, r4
 8006e0e:	f7ff fc79 	bl	8006704 <vTCPStateChange>
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 8006e12:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006e16:	f013 0f04 	tst.w	r3, #4
 8006e1a:	d00d      	beq.n	8006e38 <xTCPSocketCheck+0x24c>
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 8006e1c:	f013 0f08 	tst.w	r3, #8
 8006e20:	d002      	beq.n	8006e28 <xTCPSocketCheck+0x23c>
					xResult = -1;
 8006e22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006e26:	e00a      	b.n	8006e3e <xTCPSocketCheck+0x252>
						vSocketClose( pxSocket );
 8006e28:	4620      	mov	r0, r4
 8006e2a:	f7fe fa11 	bl	8005250 <vSocketClose>
					xResult = -1;
 8006e2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006e32:	e004      	b.n	8006e3e <xTCPSocketCheck+0x252>
BaseType_t xResult = 0;
 8006e34:	2000      	movs	r0, #0
 8006e36:	e002      	b.n	8006e3e <xTCPSocketCheck+0x252>
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 8006e38:	2001      	movs	r0, #1
 8006e3a:	e000      	b.n	8006e3e <xTCPSocketCheck+0x252>
		switch( pxSocket->u.xTCP.ucTCPState )
 8006e3c:	2000      	movs	r0, #0
}
 8006e3e:	b005      	add	sp, #20
 8006e40:	bd30      	pop	{r4, r5, pc}
			TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastActTime;
 8006e42:	f003 f8f5 	bl	800a030 <xTaskGetTickCount>
 8006e46:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8006e48:	1ac0      	subs	r0, r0, r3
			if( xAge > ( ipconfigTCP_HANG_PROTECTION_TIME * configTICK_RATE_HZ ) )
 8006e4a:	f247 5330 	movw	r3, #30000	; 0x7530
 8006e4e:	4298      	cmp	r0, r3
 8006e50:	d8db      	bhi.n	8006e0a <xTCPSocketCheck+0x21e>
 8006e52:	2001      	movs	r0, #1
 8006e54:	e7f3      	b.n	8006e3e <xTCPSocketCheck+0x252>
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8006e56:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8006e58:	b9c0      	cbnz	r0, 8006e8c <xTCPSocketCheck+0x2a0>
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 8006e5a:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
	if( pxSocket->u.xTCP.ucTCPState != eCONNECT_SYN )
 8006e5e:	2b02      	cmp	r3, #2
 8006e60:	f43f af00 	beq.w	8006c64 <xTCPSocketCheck+0x78>
		pxNetworkBuffer = NULL;
 8006e64:	a904      	add	r1, sp, #16
 8006e66:	2300      	movs	r3, #0
 8006e68:	f841 3d08 	str.w	r3, [r1, #-8]!
		lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 8006e6c:	4620      	mov	r0, r4
 8006e6e:	f7ff fea1 	bl	8006bb4 <prvTCPSendRepeated>
		if( pxNetworkBuffer != NULL )
 8006e72:	9802      	ldr	r0, [sp, #8]
 8006e74:	2800      	cmp	r0, #0
 8006e76:	f43f aee2 	beq.w	8006c3e <xTCPSocketCheck+0x52>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8006e7a:	f001 fb2b 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
 8006e7e:	e6de      	b.n	8006c3e <xTCPSocketCheck+0x52>
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 8006e80:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006e84:	e6d9      	b.n	8006c3a <xTCPSocketCheck+0x4e>
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8006e86:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8006e88:	2800      	cmp	r0, #0
 8006e8a:	d0f9      	beq.n	8006e80 <xTCPSocketCheck+0x294>
			if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
 8006e8c:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 8006e90:	f013 0f20 	tst.w	r3, #32
 8006e94:	f47f aec4 	bne.w	8006c20 <xTCPSocketCheck+0x34>
				if( pxSocket->u.xTCP.ucTCPState != eCLOSED )
 8006e98:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8006e9c:	2b00      	cmp	r3, #0
 8006e9e:	f47f aeb8 	bne.w	8006c12 <xTCPSocketCheck+0x26>
				if( prvTCPNextTimeout( pxSocket ) > 1 )
 8006ea2:	4620      	mov	r0, r4
 8006ea4:	f7ff fbd4 	bl	8006650 <prvTCPNextTimeout>
 8006ea8:	2801      	cmp	r0, #1
 8006eaa:	bf94      	ite	ls
 8006eac:	2500      	movls	r5, #0
 8006eae:	2501      	movhi	r5, #1
			if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8006eb0:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8006eb2:	2800      	cmp	r0, #0
 8006eb4:	f43f aeb9 	beq.w	8006c2a <xTCPSocketCheck+0x3e>
 8006eb8:	e6b3      	b.n	8006c22 <xTCPSocketCheck+0x36>
 8006eba:	bf00      	nop
 8006ebc:	20000010 	.word	0x20000010
 8006ec0:	20000574 	.word	0x20000574

08006ec4 <prvTCPHandleFin>:
{
 8006ec4:	b538      	push	{r3, r4, r5, lr}
 8006ec6:	4604      	mov	r4, r0
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006ec8:	698d      	ldr	r5, [r1, #24]
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 8006eca:	f8d5 302a 	ldr.w	r3, [r5, #42]	; 0x2a
	if( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u )
 8006ece:	f895 202f 	ldrb.w	r2, [r5, #47]	; 0x2f
 8006ed2:	f012 0f01 	tst.w	r2, #1
 8006ed6:	d004      	beq.n	8006ee2 <prvTCPHandleFin+0x1e>
		pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1u;
 8006ed8:	f8d0 20f0 	ldr.w	r2, [r0, #240]	; 0xf0
 8006edc:	3201      	adds	r2, #1
 8006ede:	f8c0 20ec 	str.w	r2, [r0, #236]	; 0xec
	if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 8006ee2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8006ee6:	f012 0f40 	tst.w	r2, #64	; 0x40
 8006eea:	d129      	bne.n	8006f40 <prvTCPHandleFin+0x7c>
		pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 8006eec:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8006ef0:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 8006ef4:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8006ef8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
	if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
 8006efc:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8006f00:	f012 0f01 	tst.w	r2, #1
 8006f04:	d033      	beq.n	8006f6e <prvTCPHandleFin+0xaa>
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1u;
 8006f06:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8006f0a:	3301      	adds	r3, #1
 8006f0c:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
 8006f10:	f994 3041 	ldrsb.w	r3, [r4, #65]	; 0x41
 8006f14:	2b00      	cmp	r3, #0
 8006f16:	db36      	blt.n	8006f86 <prvTCPHandleFin+0xc2>
			pxTCPHeader->ucTCPFlags = 0u;
 8006f18:	2300      	movs	r3, #0
 8006f1a:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
	pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 8006f1e:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8006f22:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
	if( pxTCPHeader->ucTCPFlags != 0u )
 8006f26:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
 8006f2a:	b3c3      	cbz	r3, 8006f9e <prvTCPHandleFin+0xda>
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength );
 8006f2c:	f894 0118 	ldrb.w	r0, [r4, #280]	; 0x118
 8006f30:	3028      	adds	r0, #40	; 0x28
	pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) << 2 );
 8006f32:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
 8006f36:	3314      	adds	r3, #20
 8006f38:	009b      	lsls	r3, r3, #2
 8006f3a:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
}
 8006f3e:	bd38      	pop	{r3, r4, r5, pc}
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 8006f40:	0e1a      	lsrs	r2, r3, #24
 8006f42:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8006f46:	0219      	lsls	r1, r3, #8
 8006f48:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8006f4c:	430a      	orrs	r2, r1
 8006f4e:	0a1b      	lsrs	r3, r3, #8
 8006f50:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006f54:	4313      	orrs	r3, r2
		if( ulAckNr == pxTCPWindow->tx.ulFINSequenceNumber + 1u )
 8006f56:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 8006f5a:	3201      	adds	r2, #1
 8006f5c:	4293      	cmp	r3, r2
 8006f5e:	d1cd      	bne.n	8006efc <prvTCPHandleFin+0x38>
			pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
 8006f60:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8006f64:	f043 0301 	orr.w	r3, r3, #1
 8006f68:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8006f6c:	e7c6      	b.n	8006efc <prvTCPHandleFin+0x38>
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 8006f6e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8006f72:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_FIN;
 8006f76:	2311      	movs	r3, #17
 8006f78:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
		vTCPStateChange( pxSocket, eLAST_ACK );
 8006f7c:	210a      	movs	r1, #10
 8006f7e:	4620      	mov	r0, r4
 8006f80:	f7ff fbc0 	bl	8006704 <vTCPStateChange>
 8006f84:	e7cb      	b.n	8006f1e <prvTCPHandleFin+0x5a>
			if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
 8006f86:	f012 0f02 	tst.w	r2, #2
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 8006f8a:	bf0c      	ite	eq
 8006f8c:	2310      	moveq	r3, #16
				pxTCPHeader->ucTCPFlags = 0u;
 8006f8e:	2300      	movne	r3, #0
 8006f90:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8006f94:	2108      	movs	r1, #8
 8006f96:	4620      	mov	r0, r4
 8006f98:	f7ff fbb4 	bl	8006704 <vTCPStateChange>
 8006f9c:	e7bf      	b.n	8006f1e <prvTCPHandleFin+0x5a>
 8006f9e:	2000      	movs	r0, #0
 8006fa0:	e7c7      	b.n	8006f32 <prvTCPHandleFin+0x6e>
	...

08006fa4 <xProcessReceivedTCPPacket>:
 *		prvTCPSendRepeated()
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC
*/
BaseType_t xProcessReceivedTCPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 8006fa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006fa8:	b089      	sub	sp, #36	; 0x24
 8006faa:	9005      	str	r0, [sp, #20]
FreeRTOS_Socket_t *pxSocket;
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8006fac:	f8d0 8018 	ldr.w	r8, [r0, #24]
uint16_t ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags;
 8006fb0:	f898 502f 	ldrb.w	r5, [r8, #47]	; 0x2f
uint32_t ulLocalIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulDestinationIPAddress );
 8006fb4:	f8d8 401e 	ldr.w	r4, [r8, #30]
uint16_t xLocalPort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usDestinationPort );
 8006fb8:	f8b8 1024 	ldrh.w	r1, [r8, #36]	; 0x24
uint32_t ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 8006fbc:	f8d8 001a 	ldr.w	r0, [r8, #26]
uint16_t xRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 8006fc0:	f8b8 3022 	ldrh.w	r3, [r8, #34]	; 0x22
 8006fc4:	0a1a      	lsrs	r2, r3, #8
 8006fc6:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
uint32_t ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 8006fca:	0e06      	lsrs	r6, r0, #24
 8006fcc:	ea46 6600 	orr.w	r6, r6, r0, lsl #24
 8006fd0:	0202      	lsls	r2, r0, #8
 8006fd2:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8006fd6:	4316      	orrs	r6, r2
 8006fd8:	0a00      	lsrs	r0, r0, #8
 8006fda:	f400 427f 	and.w	r2, r0, #65280	; 0xff00
uint16_t xLocalPort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usDestinationPort );
 8006fde:	0a08      	lsrs	r0, r1, #8
 8006fe0:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
uint32_t ulLocalIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulDestinationIPAddress );
 8006fe4:	0e20      	lsrs	r0, r4, #24
 8006fe6:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 8006fea:	0227      	lsls	r7, r4, #8
 8006fec:	f407 077f 	and.w	r7, r7, #16711680	; 0xff0000
 8006ff0:	4338      	orrs	r0, r7
 8006ff2:	0a24      	lsrs	r4, r4, #8
 8006ff4:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
BaseType_t xResult = pdPASS;

	/* Find the destination socket, and if not found: return a socket listing to
	the destination PORT. */
	pxSocket = ( FreeRTOS_Socket_t * ) pxTCPSocketLookup( ulLocalIP, xLocalPort, ulRemoteIP, xRemotePort );
 8006ff8:	b29b      	uxth	r3, r3
 8006ffa:	4332      	orrs	r2, r6
 8006ffc:	b289      	uxth	r1, r1
 8006ffe:	4320      	orrs	r0, r4
 8007000:	f7fe fcea 	bl	80059d8 <pxTCPSocketLookup>

	if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE ) )
 8007004:	b160      	cbz	r0, 8007020 <xProcessReceivedTCPPacket+0x7c>
 8007006:	4604      	mov	r4, r0
 8007008:	f890 3053 	ldrb.w	r3, [r0, #83]	; 0x53
	switch( uxStatus )
 800700c:	2b0b      	cmp	r3, #11
 800700e:	d816      	bhi.n	800703e <xProcessReceivedTCPPacket+0x9a>
 8007010:	e8df f003 	tbb	[pc, r3]
 8007014:	15151506 	.word	0x15151506
 8007018:	06151515 	.word	0x06151515
 800701c:	06150606 	.word	0x06150606
		the other party will get a ECONN error.  There are two exceptions:
		1) A packet that already has the RST flag set.
		2) A packet that only has the ACK flag set.
		A packet with only the ACK flag set might be the last ACK in
	 	a three-way hand-shake that closes a connection. */
		if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_ACK ) &&
 8007020:	f005 031f 	and.w	r3, r5, #31
 8007024:	2b10      	cmp	r3, #16
 8007026:	d002      	beq.n	800702e <xProcessReceivedTCPPacket+0x8a>
 8007028:	f015 0f04 	tst.w	r5, #4
 800702c:	d003      	beq.n	8007036 <xProcessReceivedTCPPacket+0x92>
		}

		/* And finally, calculate when this socket wants to be woken up. */
		prvTCPNextTimeout ( pxSocket );
		/* Return pdPASS to tell that the network buffer is 'consumed'. */
		xResult = pdPASS;
 800702e:	2000      	movs	r0, #0
	}

	/* pdPASS being returned means the buffer has been consumed. */
	return xResult;
}
 8007030:	b009      	add	sp, #36	; 0x24
 8007032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			prvTCPSendReset( pxNetworkBuffer );
 8007036:	9805      	ldr	r0, [sp, #20]
 8007038:	f7ff fae0 	bl	80065fc <prvTCPSendReset>
 800703c:	e7f7      	b.n	800702e <xProcessReceivedTCPPacket+0x8a>
		pxSocket->u.xTCP.ucRepCount = 0u;
 800703e:	2200      	movs	r2, #0
 8007040:	f880 2052 	strb.w	r2, [r0, #82]	; 0x52
		if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 8007044:	2b01      	cmp	r3, #1
 8007046:	f000 80c8 	beq.w	80071da <xProcessReceivedTCPPacket+0x236>
			if( ( ucTCPFlags & ipTCP_FLAG_RST ) != 0u )
 800704a:	f015 0f04 	tst.w	r5, #4
 800704e:	f040 8183 	bne.w	8007358 <xProcessReceivedTCPPacket+0x3b4>
			else if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) )
 8007052:	f005 051f 	and.w	r5, r5, #31
 8007056:	2d02      	cmp	r5, #2
 8007058:	f000 8182 	beq.w	8007360 <xProcessReceivedTCPPacket+0x3bc>
				memcpy( pxSocket->u.xTCP.xPacket.u.ucLastPacket + lOffset, pxNetworkBuffer->pucEthernetBuffer + lOffset, ipSIZE_OF_TCP_HEADER );
 800705c:	9a05      	ldr	r2, [sp, #20]
 800705e:	6992      	ldr	r2, [r2, #24]
 8007060:	f852 1f22 	ldr.w	r1, [r2, #34]!
 8007064:	6856      	ldr	r6, [r2, #4]
 8007066:	6895      	ldr	r5, [r2, #8]
 8007068:	68d0      	ldr	r0, [r2, #12]
 800706a:	f8c4 10a4 	str.w	r1, [r4, #164]	; 0xa4
 800706e:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
 8007072:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
 8007076:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
 800707a:	6911      	ldr	r1, [r2, #16]
 800707c:	f8c4 10b4 	str.w	r1, [r4, #180]	; 0xb4
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 8007080:	f002 ffd6 	bl	800a030 <xTaskGetTickCount>
 8007084:	6620      	str	r0, [r4, #96]	; 0x60
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 8007086:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800708a:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 800708e:	f36f 0341 	bfc	r3, #1, #1
 8007092:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 8007096:	2300      	movs	r3, #0
 8007098:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 800709c:	f002 ffc8 	bl	800a030 <xTaskGetTickCount>
 80070a0:	65e0      	str	r0, [r4, #92]	; 0x5c
		if( ( pxTCPPacket->xTCPHeader.ucTCPOffset & TCP_OFFSET_LENGTH_BITS ) > TCP_OFFSET_STANDARD_LENGTH )
 80070a2:	f898 302e 	ldrb.w	r3, [r8, #46]	; 0x2e
 80070a6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80070aa:	2b50      	cmp	r3, #80	; 0x50
 80070ac:	f200 815c 	bhi.w	8007368 <xProcessReceivedTCPPacket+0x3c4>
			pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPPacket->xTCPHeader.usWindow );
 80070b0:	f8b8 2030 	ldrh.w	r2, [r8, #48]	; 0x30
 80070b4:	0a13      	lsrs	r3, r2, #8
 80070b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80070ba:	b29b      	uxth	r3, r3
				( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 80070bc:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
 80070c0:	4093      	lsls	r3, r2
			pxSocket->u.xTCP.ulWindowSize =
 80070c2:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 80070c6:	f8dd 9014 	ldr.w	r9, [sp, #20]
 80070ca:	f8d9 6018 	ldr.w	r6, [r9, #24]
uint32_t ulSequenceNumber = FreeRTOS_ntohl (pxTCPHeader->ulSequenceNumber);
 80070ce:	f8d6 3026 	ldr.w	r3, [r6, #38]	; 0x26
 80070d2:	0e1a      	lsrs	r2, r3, #24
 80070d4:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 80070d8:	0219      	lsls	r1, r3, #8
 80070da:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80070de:	430a      	orrs	r2, r1
 80070e0:	0a1b      	lsrs	r3, r3, #8
 80070e2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80070e6:	ea42 0803 	orr.w	r8, r2, r3
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 80070ea:	f896 b02f 	ldrb.w	fp, [r6, #47]	; 0x2f
    lTCPHeaderLength = ( BaseType_t ) ( ( pxTCPHeader->ucTCPOffset & VALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2 );
 80070ee:	f896 302e 	ldrb.w	r3, [r6, #46]	; 0x2e
 80070f2:	089b      	lsrs	r3, r3, #2
 80070f4:	f003 033c 	and.w	r3, r3, #60	; 0x3c
	*ppucRecvData = pxNetworkBuffer->pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + lTCPHeaderLength;
 80070f8:	f103 0722 	add.w	r7, r3, #34	; 0x22
 80070fc:	4437      	add	r7, r6
	lReceiveLength = ( ( int32_t ) pxNetworkBuffer->xDataLength ) - ( int32_t ) ipSIZE_OF_ETH_HEADER;
 80070fe:	f8d9 501c 	ldr.w	r5, [r9, #28]
 8007102:	f1a5 010e 	sub.w	r1, r5, #14
	lLength =  ( int32_t )FreeRTOS_htons( pxTCPPacket->xIPHeader.usLength );
 8007106:	8a35      	ldrh	r5, [r6, #16]
 8007108:	0a2a      	lsrs	r2, r5, #8
 800710a:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 800710e:	b295      	uxth	r5, r2
 8007110:	428d      	cmp	r5, r1
 8007112:	bfa8      	it	ge
 8007114:	460d      	movge	r5, r1
	if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER ) )
 8007116:	3314      	adds	r3, #20
 8007118:	429d      	cmp	r5, r3
		lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER );
 800711a:	bfcc      	ite	gt
 800711c:	1aed      	subgt	r5, r5, r3
		lReceiveLength = 0;
 800711e:	2500      	movle	r5, #0
	if( ( pxTCPHeader->ucTCPFlags & ipTCP_FLAG_URG ) != 0u )
 8007120:	f01b 0f20 	tst.w	fp, #32
 8007124:	d009      	beq.n	800713a <xProcessReceivedTCPPacket+0x196>
		lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
 8007126:	8eb2      	ldrh	r2, [r6, #52]	; 0x34
 8007128:	0a13      	lsrs	r3, r2, #8
 800712a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800712e:	b29b      	uxth	r3, r3
		*ppucRecvData += lUrgentLength;
 8007130:	441f      	add	r7, r3
		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
 8007132:	42ab      	cmp	r3, r5
 8007134:	bfd4      	ite	le
 8007136:	1aed      	suble	r5, r5, r3
 8007138:	1b6d      	subgt	r5, r5, r5
	ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
 800713a:	9502      	str	r5, [sp, #8]
	if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
 800713c:	f894 2053 	ldrb.w	r2, [r4, #83]	; 0x53
 8007140:	2a04      	cmp	r2, #4
 8007142:	d906      	bls.n	8007152 <xProcessReceivedTCPPacket+0x1ae>
		if ( pxTCPWindow->rx.ulCurrentSequenceNumber == ulSequenceNumber + 1u )
 8007144:	f108 0301 	add.w	r3, r8, #1
 8007148:	f8d4 10ec 	ldr.w	r1, [r4, #236]	; 0xec
 800714c:	4299      	cmp	r1, r3
 800714e:	f000 81d6 	beq.w	80074fe <xProcessReceivedTCPPacket+0x55a>
	if( ( ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSequenceNumber ) ) > 0 )
 8007152:	9b02      	ldr	r3, [sp, #8]
 8007154:	eb08 0a03 	add.w	sl, r8, r3
 8007158:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 800715c:	ebaa 0303 	sub.w	r3, sl, r3
 8007160:	2b00      	cmp	r3, #0
		pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
 8007162:	bfc8      	it	gt
 8007164:	f8c4 a0f4 	strgt.w	sl, [r4, #244]	; 0xf4
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 8007168:	f104 03dc 	add.w	r3, r4, #220	; 0xdc
 800716c:	9303      	str	r3, [sp, #12]
	if( ( ulReceiveLength > 0u ) && ( pxSocket->u.xTCP.ucTCPState >= eSYN_RECEIVED ) )
 800716e:	9b02      	ldr	r3, [sp, #8]
 8007170:	2b00      	cmp	r3, #0
 8007172:	f000 81e1 	beq.w	8007538 <xProcessReceivedTCPPacket+0x594>
 8007176:	2a03      	cmp	r2, #3
 8007178:	f240 81de 	bls.w	8007538 <xProcessReceivedTCPPacket+0x594>
		if ( pxSocket->u.xTCP.rxStream )
 800717c:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800717e:	2a00      	cmp	r2, #0
 8007180:	f000 81c4 	beq.w	800750c <xProcessReceivedTCPPacket+0x568>
size_t uxHead = pxBuffer->uxHead;
 8007184:	6891      	ldr	r1, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 8007186:	6813      	ldr	r3, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8007188:	6912      	ldr	r2, [r2, #16]
 800718a:	4413      	add	r3, r2
 800718c:	3b01      	subs	r3, #1
 800718e:	1a5b      	subs	r3, r3, r1
	if( uxCount >= pxBuffer->LENGTH )
 8007190:	429a      	cmp	r2, r3
 8007192:	d800      	bhi.n	8007196 <xProcessReceivedTCPPacket+0x1f2>
		uxCount -= pxBuffer->LENGTH;
 8007194:	1a9b      	subs	r3, r3, r2
	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 8007196:	f8d9 2018 	ldr.w	r2, [r9, #24]
 800719a:	f8d2 2026 	ldr.w	r2, [r2, #38]	; 0x26
 800719e:	0e10      	lsrs	r0, r2, #24
 80071a0:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 80071a4:	0211      	lsls	r1, r2, #8
 80071a6:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 80071aa:	4308      	orrs	r0, r1
 80071ac:	0a12      	lsrs	r2, r2, #8
 80071ae:	f402 417f 	and.w	r1, r2, #65280	; 0xff00
		lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace );
 80071b2:	9a02      	ldr	r2, [sp, #8]
 80071b4:	4301      	orrs	r1, r0
 80071b6:	9803      	ldr	r0, [sp, #12]
 80071b8:	f000 fe60 	bl	8007e7c <lTCPWindowRxCheck>
		if( lOffset >= 0 )
 80071bc:	1e01      	subs	r1, r0, #0
 80071be:	f2c0 83f9 	blt.w	80079b4 <xProcessReceivedTCPPacket+0xa10>
			lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRecvData, ulReceiveLength );
 80071c2:	9b02      	ldr	r3, [sp, #8]
 80071c4:	463a      	mov	r2, r7
 80071c6:	4620      	mov	r0, r4
 80071c8:	f7fe fc2e 	bl	8005a28 <lTCPAddRxdata>
			if( lStored != ( int32_t ) ulReceiveLength )
 80071cc:	4285      	cmp	r5, r0
 80071ce:	f000 83f1 	beq.w	80079b4 <xProcessReceivedTCPPacket+0xa10>
				prvTCPSendReset( pxNetworkBuffer );
 80071d2:	4648      	mov	r0, r9
 80071d4:	f7ff fa12 	bl	80065fc <prvTCPSendReset>
 80071d8:	e3bc      	b.n	8007954 <xProcessReceivedTCPPacket+0x9b0>
			if( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_SYN )
 80071da:	f005 031f 	and.w	r3, r5, #31
 80071de:	2b02      	cmp	r3, #2
 80071e0:	d007      	beq.n	80071f2 <xProcessReceivedTCPPacket+0x24e>
				if( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u )
 80071e2:	f015 0f04 	tst.w	r5, #4
 80071e6:	f47f af22 	bne.w	800702e <xProcessReceivedTCPPacket+0x8a>
					prvTCPSendReset( pxNetworkBuffer );
 80071ea:	9805      	ldr	r0, [sp, #20]
 80071ec:	f7ff fa06 	bl	80065fc <prvTCPSendReset>
 80071f0:	e71d      	b.n	800702e <xProcessReceivedTCPPacket+0x8a>
				pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
 80071f2:	9d05      	ldr	r5, [sp, #20]
/*-----------------------------------------------------------*/

static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80071f4:	69af      	ldr	r7, [r5, #24]
FreeRTOS_Socket_t *pxReturn;

	/* A pure SYN (without ACK) has come in, create a new socket to answer
	it. */
	if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 80071f6:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80071fa:	f013 0f08 	tst.w	r3, #8
 80071fe:	d043      	beq.n	8007288 <xProcessReceivedTCPPacket+0x2e4>
	{
		/* The flag bReuseSocket indicates that the same instance of the
		listening socket should be used for the connection. */
		pxReturn = pxSocket;
		pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 8007200:	f043 0304 	orr.w	r3, r3, #4
 8007204:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
		pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 8007208:	6560      	str	r0, [r4, #84]	; 0x54
		}
	}

	if( pxReturn != NULL )
	{
		pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 800720a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 800720c:	0a13      	lsrs	r3, r2, #8
 800720e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007212:	87a3      	strh	r3, [r4, #60]	; 0x3c
		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 8007214:	f8d7 301a 	ldr.w	r3, [r7, #26]
 8007218:	0e1a      	lsrs	r2, r3, #24
 800721a:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 800721e:	0219      	lsls	r1, r3, #8
 8007220:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8007224:	430a      	orrs	r2, r1
 8007226:	0a1b      	lsrs	r3, r3, #8
 8007228:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800722c:	4313      	orrs	r3, r2
 800722e:	63a3      	str	r3, [r4, #56]	; 0x38
		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulNextInitialSequenceNumber;
 8007230:	4ebc      	ldr	r6, [pc, #752]	; (8007524 <xProcessReceivedTCPPacket+0x580>)
 8007232:	6833      	ldr	r3, [r6, #0]
 8007234:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108

		/* Here is the SYN action. */
		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 8007238:	f8d7 3026 	ldr.w	r3, [r7, #38]	; 0x26
 800723c:	0e1a      	lsrs	r2, r3, #24
 800723e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8007242:	0219      	lsls	r1, r3, #8
 8007244:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 8007248:	430a      	orrs	r2, r1
 800724a:	0a1b      	lsrs	r3, r3, #8
 800724c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8007250:	4313      	orrs	r3, r2
 8007252:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
		prvSocketSetMSS( pxReturn );
 8007256:	4620      	mov	r0, r4
 8007258:	f7ff f884 	bl	8006364 <prvSocketSetMSS>

		prvTCPCreateWindow( pxReturn );
 800725c:	4620      	mov	r0, r4
 800725e:	f7ff f9dd 	bl	800661c <prvTCPCreateWindow>

		/* It is recommended to increase the ISS for each new connection with a value of 0x102. */
		ulNextInitialSequenceNumber += INITIAL_SEQUENCE_NUMBER_INCREMENT;
 8007262:	6833      	ldr	r3, [r6, #0]
 8007264:	f503 7381 	add.w	r3, r3, #258	; 0x102
 8007268:	6033      	str	r3, [r6, #0]

		vTCPStateChange( pxReturn, eSYN_FIRST );
 800726a:	2103      	movs	r1, #3
 800726c:	4620      	mov	r0, r4
 800726e:	f7ff fa49 	bl	8006704 <vTCPStateChange>

		/* Make a copy of the header up to the TCP header.  It is needed later
		on, whenever data must be sent to the peer. */
		memcpy( pxReturn->u.xTCP.xPacket.u.ucLastPacket, pxNetworkBuffer->pucEthernetBuffer, sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) );
 8007272:	2246      	movs	r2, #70	; 0x46
 8007274:	69a9      	ldr	r1, [r5, #24]
 8007276:	f104 0082 	add.w	r0, r4, #130	; 0x82
 800727a:	f005 fa2c 	bl	800c6d6 <memcpy>
	if( xResult != pdFAIL )
 800727e:	2c00      	cmp	r4, #0
 8007280:	f47f aefe 	bne.w	8007080 <xProcessReceivedTCPPacket+0xdc>
 8007284:	2000      	movs	r0, #0
 8007286:	e6d3      	b.n	8007030 <xProcessReceivedTCPPacket+0x8c>
		if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 8007288:	f8b0 204e 	ldrh.w	r2, [r0, #78]	; 0x4e
 800728c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8007290:	429a      	cmp	r2, r3
 8007292:	d249      	bcs.n	8007328 <xProcessReceivedTCPPacket+0x384>
			FreeRTOS_Socket_t *pxNewSocket = (FreeRTOS_Socket_t *)
 8007294:	2206      	movs	r2, #6
 8007296:	2101      	movs	r1, #1
 8007298:	2002      	movs	r0, #2
 800729a:	f7fd fd5f 	bl	8004d5c <FreeRTOS_socket>
 800729e:	4606      	mov	r6, r0
			if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 80072a0:	1e43      	subs	r3, r0, #1
 80072a2:	f113 0f03 	cmn.w	r3, #3
 80072a6:	d84e      	bhi.n	8007346 <xProcessReceivedTCPPacket+0x3a2>
 */
static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket )
{
struct freertos_sockaddr xAddress;

	pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
 80072a8:	69e3      	ldr	r3, [r4, #28]
 80072aa:	61c3      	str	r3, [r0, #28]
	pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
 80072ac:	6a23      	ldr	r3, [r4, #32]
 80072ae:	6203      	str	r3, [r0, #32]
	pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
 80072b0:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 80072b4:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
	pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
 80072b8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80072ba:	66c3      	str	r3, [r0, #108]	; 0x6c
	pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
 80072bc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80072be:	6703      	str	r3, [r0, #112]	; 0x70
	pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
 80072c0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80072c2:	6643      	str	r3, [r0, #100]	; 0x64
	pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
 80072c4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80072c6:	6683      	str	r3, [r0, #104]	; 0x68
	pxNewSocket->u.xTCP.uxRxWinSize  = pxSocket->u.xTCP.uxRxWinSize;
 80072c8:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80072cc:	f8c0 30d4 	str.w	r3, [r0, #212]	; 0xd4
	pxNewSocket->u.xTCP.uxTxWinSize  = pxSocket->u.xTCP.uxTxWinSize;
 80072d0:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 80072d4:	f8c0 30d8 	str.w	r3, [r0, #216]	; 0xd8

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		/* Child socket of listening sockets will inherit the Socket Set
		Otherwise the owner has no chance of including it into the set. */
		if( pxSocket->pxSocketSet )
 80072d8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80072da:	b123      	cbz	r3, 80072e6 <xProcessReceivedTCPPacket+0x342>
		{
			pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
 80072dc:	6283      	str	r3, [r0, #40]	; 0x28
			pxNewSocket->xSelectBits = pxSocket->xSelectBits | eSELECT_READ | eSELECT_EXCEPT;
 80072de:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80072e0:	f043 0305 	orr.w	r3, r3, #5
 80072e4:	62c3      	str	r3, [r0, #44]	; 0x2c
		}
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	/* And bind it to the same local port as its parent. */
	xAddress.sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
 80072e6:	4b90      	ldr	r3, [pc, #576]	; (8007528 <xProcessReceivedTCPPacket+0x584>)
 80072e8:	695b      	ldr	r3, [r3, #20]
 80072ea:	9307      	str	r3, [sp, #28]
	xAddress.sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 80072ec:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 80072ee:	0a13      	lsrs	r3, r2, #8
 80072f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80072f4:	f8ad 301a 	strh.w	r3, [sp, #26]
		orphan temporarily.  Once this socket is really connected, the owner of
		the server socket will be notified. */

		/* When bPassQueued is true, the socket is an orphan until it gets
		connected. */
		pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 80072f8:	f896 3040 	ldrb.w	r3, [r6, #64]	; 0x40
 80072fc:	f043 0304 	orr.w	r3, r3, #4
 8007300:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
		pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
 8007304:	6574      	str	r4, [r6, #84]	; 0x54
			pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
		}
	}
	#endif

	pxSocket->u.xTCP.usChildCount++;
 8007306:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 800730a:	3301      	adds	r3, #1
 800730c:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
		pxSocket->u.xTCP.usChildCount,
		pxSocket->u.xTCP.usBacklog,
		pxSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );

	/* Now bind the child socket to the same port as the listening socket. */
	if( vSocketBind ( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
 8007310:	2301      	movs	r3, #1
 8007312:	2208      	movs	r2, #8
 8007314:	a906      	add	r1, sp, #24
 8007316:	4630      	mov	r0, r6
 8007318:	f7fd fefe 	bl	8005118 <vSocketBind>
 800731c:	b9b8      	cbnz	r0, 800734e <xProcessReceivedTCPPacket+0x3aa>
				pxReturn = pxNewSocket;
 800731e:	4634      	mov	r4, r6
	if( pxReturn != NULL )
 8007320:	2e00      	cmp	r6, #0
 8007322:	f47f af72 	bne.w	800720a <xProcessReceivedTCPPacket+0x266>
 8007326:	e00c      	b.n	8007342 <xProcessReceivedTCPPacket+0x39e>
			FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
 8007328:	8c81      	ldrh	r1, [r0, #36]	; 0x24
 800732a:	4c80      	ldr	r4, [pc, #512]	; (800752c <xProcessReceivedTCPPacket+0x588>)
 800732c:	4880      	ldr	r0, [pc, #512]	; (8007530 <xProcessReceivedTCPPacket+0x58c>)
 800732e:	2a01      	cmp	r2, #1
 8007330:	bf18      	it	ne
 8007332:	4620      	movne	r0, r4
 8007334:	9000      	str	r0, [sp, #0]
 8007336:	487f      	ldr	r0, [pc, #508]	; (8007534 <xProcessReceivedTCPPacket+0x590>)
 8007338:	f004 fb86 	bl	800ba48 <lUDPLoggingPrintf>
			prvTCPSendReset( pxNetworkBuffer );
 800733c:	4628      	mov	r0, r5
 800733e:	f7ff f95d 	bl	80065fc <prvTCPSendReset>
		xResult = pdPASS;
 8007342:	2000      	movs	r0, #0
 8007344:	e674      	b.n	8007030 <xProcessReceivedTCPPacket+0x8c>
				prvTCPSendReset( pxNetworkBuffer );
 8007346:	4628      	mov	r0, r5
 8007348:	f7ff f958 	bl	80065fc <prvTCPSendReset>
 800734c:	e7f9      	b.n	8007342 <xProcessReceivedTCPPacket+0x39e>
	{
		FreeRTOS_debug_printf( ( "TCP: Listen: new socket bind error\n" ) );
		vSocketClose( pxNewSocket );
 800734e:	4630      	mov	r0, r6
 8007350:	f7fd ff7e 	bl	8005250 <vSocketClose>
 8007354:	2400      	movs	r4, #0
 8007356:	e792      	b.n	800727e <xProcessReceivedTCPPacket+0x2da>
				vTCPStateChange( pxSocket, eCLOSED );
 8007358:	2100      	movs	r1, #0
 800735a:	f7ff f9d3 	bl	8006704 <vTCPStateChange>
 800735e:	e666      	b.n	800702e <xProcessReceivedTCPPacket+0x8a>
			else if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) )
 8007360:	2b04      	cmp	r3, #4
 8007362:	f63f ae64 	bhi.w	800702e <xProcessReceivedTCPPacket+0x8a>
 8007366:	e679      	b.n	800705c <xProcessReceivedTCPPacket+0xb8>
	pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8007368:	9b05      	ldr	r3, [sp, #20]
 800736a:	6999      	ldr	r1, [r3, #24]
	pucPtr = pxTCPHeader->ucOptdata;
 800736c:	f101 0336 	add.w	r3, r1, #54	; 0x36
	pucLast = pucPtr + (((pxTCPHeader->ucTCPOffset >> 4) - 5) << 2);
 8007370:	f891 202e 	ldrb.w	r2, [r1, #46]	; 0x2e
 8007374:	0912      	lsrs	r2, r2, #4
 8007376:	3a05      	subs	r2, #5
 8007378:	eb03 0782 	add.w	r7, r3, r2, lsl #2
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800737c:	f104 02dc 	add.w	r2, r4, #220	; 0xdc
 8007380:	9202      	str	r2, [sp, #8]
	while( pucPtr < pucLast )
 8007382:	42bb      	cmp	r3, r7
 8007384:	f4bf ae94 	bcs.w	80070b0 <xProcessReceivedTCPPacket+0x10c>
		if( pucPtr[ 0 ] == TCP_OPT_END )
 8007388:	f891 2036 	ldrb.w	r2, [r1, #54]	; 0x36
 800738c:	2a00      	cmp	r2, #0
 800738e:	f43f ae8f 	beq.w	80070b0 <xProcessReceivedTCPPacket+0x10c>
							uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 8007392:	f04f 0b00 	mov.w	fp, #0
 8007396:	f8cd 8010 	str.w	r8, [sp, #16]
 800739a:	46b9      	mov	r9, r7
 800739c:	e088      	b.n	80074b0 <xProcessReceivedTCPPacket+0x50c>
			pucPtr++;
 800739e:	3301      	adds	r3, #1
 80073a0:	e082      	b.n	80074a8 <xProcessReceivedTCPPacket+0x504>
		else if( ( pucPtr[ 0 ] == TCP_OPT_WSOPT ) && ( pucPtr[ 1 ] == TCP_OPT_WSOPT_LEN ) )
 80073a2:	785a      	ldrb	r2, [r3, #1]
 80073a4:	2a03      	cmp	r2, #3
 80073a6:	d005      	beq.n	80073b4 <xProcessReceivedTCPPacket+0x410>
			int len = ( int )pucPtr[ 1 ];
 80073a8:	7859      	ldrb	r1, [r3, #1]
			if( len == 0 )
 80073aa:	2900      	cmp	r1, #0
 80073ac:	d17b      	bne.n	80074a6 <xProcessReceivedTCPPacket+0x502>
 80073ae:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80073b2:	e67d      	b.n	80070b0 <xProcessReceivedTCPPacket+0x10c>
			pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
 80073b4:	789a      	ldrb	r2, [r3, #2]
 80073b6:	f884 20ca 	strb.w	r2, [r4, #202]	; 0xca
			pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
 80073ba:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 80073be:	f042 0210 	orr.w	r2, r2, #16
 80073c2:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
			pucPtr += TCP_OPT_WSOPT_LEN;
 80073c6:	3303      	adds	r3, #3
 80073c8:	e06e      	b.n	80074a8 <xProcessReceivedTCPPacket+0x504>
		else if( ( pucPtr[ 0 ] == TCP_OPT_MSS ) && ( pucPtr[ 1 ] == TCP_OPT_MSS_LEN ) )
 80073ca:	785a      	ldrb	r2, [r3, #1]
 80073cc:	2a04      	cmp	r2, #4
 80073ce:	d005      	beq.n	80073dc <xProcessReceivedTCPPacket+0x438>
			int len = ( int )pucPtr[ 1 ];
 80073d0:	4611      	mov	r1, r2
			if( len == 0 )
 80073d2:	2a00      	cmp	r2, #0
 80073d4:	d167      	bne.n	80074a6 <xProcessReceivedTCPPacket+0x502>
 80073d6:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80073da:	e669      	b.n	80070b0 <xProcessReceivedTCPPacket+0x10c>
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 80073dc:	7899      	ldrb	r1, [r3, #2]
			  ( ( ( uint32_t )apChr[1] ) ) );
 80073de:	78da      	ldrb	r2, [r3, #3]
	return ( uint16_t )
 80073e0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
			if( pxSocket->u.xTCP.usInitMSS != uxNewMSS )
 80073e4:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
			if( pxSocket->u.xTCP.usInitMSS > uxNewMSS )
 80073e8:	428a      	cmp	r2, r1
 80073ea:	d215      	bcs.n	8007418 <xProcessReceivedTCPPacket+0x474>
				pxSocket->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
 80073ec:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
 80073f0:	f041 0101 	orr.w	r1, r1, #1
 80073f4:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
				pxTCPWindow->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( pxTCPWindow->xSize.ulRxWindowLength / ( ( uint32_t ) uxNewMSS ) );
 80073f8:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
 80073fc:	fbb1 f1f2 	udiv	r1, r1, r2
 8007400:	fb02 f101 	mul.w	r1, r2, r1
 8007404:	f8c4 10e0 	str.w	r1, [r4, #224]	; 0xe0
				pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
 8007408:	f8a4 219a 	strh.w	r2, [r4, #410]	; 0x19a
				pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
 800740c:	f8a4 2198 	strh.w	r2, [r4, #408]	; 0x198
				pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
 8007410:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
				pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
 8007414:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
				pucPtr += TCP_OPT_MSS_LEN;
 8007418:	3304      	adds	r3, #4
 800741a:	e045      	b.n	80074a8 <xProcessReceivedTCPPacket+0x504>
 800741c:	3508      	adds	r5, #8
					while( len >= 8 )
 800741e:	42b5      	cmp	r5, r6
 8007420:	d038      	beq.n	8007494 <xProcessReceivedTCPPacket+0x4f0>
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8007422:	f815 3c04 	ldrb.w	r3, [r5, #-4]
			( ( ( uint32_t )apChr[1] ) << 16) |
 8007426:	f815 2c03 	ldrb.w	r2, [r5, #-3]
 800742a:	0412      	lsls	r2, r2, #16
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 800742c:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
			( ( ( uint32_t )apChr[3] ) );
 8007430:	f815 3c01 	ldrb.w	r3, [r5, #-1]
			( ( ( uint32_t )apChr[2] ) << 8) |
 8007434:	431a      	orrs	r2, r3
 8007436:	f815 0c02 	ldrb.w	r0, [r5, #-2]
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 800743a:	f815 1c08 	ldrb.w	r1, [r5, #-8]
			( ( ( uint32_t )apChr[1] ) << 16) |
 800743e:	f815 3c07 	ldrb.w	r3, [r5, #-7]
 8007442:	041b      	lsls	r3, r3, #16
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 8007444:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
			( ( ( uint32_t )apChr[3] ) );
 8007448:	f815 1c05 	ldrb.w	r1, [r5, #-5]
			( ( ( uint32_t )apChr[2] ) << 8) |
 800744c:	430b      	orrs	r3, r1
 800744e:	f815 1c06 	ldrb.w	r1, [r5, #-6]
					uint32_t ulCount = ulTCPWindowTxSack( &pxSocket->u.xTCP.xTCPWindow, ulFirst, ulLast );
 8007452:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8007456:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 800745a:	9802      	ldr	r0, [sp, #8]
 800745c:	f000 fefa 	bl	8008254 <ulTCPWindowTxSack>
 8007460:	4603      	mov	r3, r0
						if( ( pxSocket->u.xTCP.txStream  != NULL ) && ( ulCount > 0 ) )
 8007462:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8007464:	2800      	cmp	r0, #0
 8007466:	d0d9      	beq.n	800741c <xProcessReceivedTCPPacket+0x478>
 8007468:	2b00      	cmp	r3, #0
 800746a:	d0d7      	beq.n	800741c <xProcessReceivedTCPPacket+0x478>
							uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 800746c:	f8cd b000 	str.w	fp, [sp]
 8007470:	465a      	mov	r2, fp
 8007472:	4659      	mov	r1, fp
 8007474:	f7fe ff35 	bl	80062e2 <uxStreamBufferGet>
							pxSocket->xEventBits |= eSOCKET_SEND;
 8007478:	6823      	ldr	r3, [r4, #0]
 800747a:	f043 0202 	orr.w	r2, r3, #2
 800747e:	6022      	str	r2, [r4, #0]
								if( pxSocket->xSelectBits & eSELECT_WRITE )
 8007480:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007482:	f012 0f02 	tst.w	r2, #2
 8007486:	d0c9      	beq.n	800741c <xProcessReceivedTCPPacket+0x478>
									pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 8007488:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800748c:	f043 0302 	orr.w	r3, r3, #2
 8007490:	6023      	str	r3, [r4, #0]
 8007492:	e7c3      	b.n	800741c <xProcessReceivedTCPPacket+0x478>
 8007494:	f10a 0608 	add.w	r6, sl, #8
 8007498:	9b03      	ldr	r3, [sp, #12]
 800749a:	4433      	add	r3, r6
 800749c:	3f0a      	subs	r7, #10
 800749e:	f028 0807 	bic.w	r8, r8, #7
 80074a2:	eba7 0108 	sub.w	r1, r7, r8
			pucPtr += len;
 80074a6:	440b      	add	r3, r1
	while( pucPtr < pucLast )
 80074a8:	4599      	cmp	r9, r3
 80074aa:	d91f      	bls.n	80074ec <xProcessReceivedTCPPacket+0x548>
		if( pucPtr[ 0 ] == TCP_OPT_END )
 80074ac:	781a      	ldrb	r2, [r3, #0]
 80074ae:	b302      	cbz	r2, 80074f2 <xProcessReceivedTCPPacket+0x54e>
		if( pucPtr[ 0 ] == TCP_OPT_NOOP)
 80074b0:	2a01      	cmp	r2, #1
 80074b2:	f43f af74 	beq.w	800739e <xProcessReceivedTCPPacket+0x3fa>
		else if( ( pucPtr[ 0 ] == TCP_OPT_WSOPT ) && ( pucPtr[ 1 ] == TCP_OPT_WSOPT_LEN ) )
 80074b6:	2a03      	cmp	r2, #3
 80074b8:	f43f af73 	beq.w	80073a2 <xProcessReceivedTCPPacket+0x3fe>
		else if( ( pucPtr[ 0 ] == TCP_OPT_MSS ) && ( pucPtr[ 1 ] == TCP_OPT_MSS_LEN ) )
 80074bc:	2a02      	cmp	r2, #2
 80074be:	d084      	beq.n	80073ca <xProcessReceivedTCPPacket+0x426>
			int len = ( int )pucPtr[ 1 ];
 80074c0:	785f      	ldrb	r7, [r3, #1]
 80074c2:	4639      	mov	r1, r7
			if( len == 0 )
 80074c4:	b1c7      	cbz	r7, 80074f8 <xProcessReceivedTCPPacket+0x554>
				if( pucPtr[0] == TCP_OPT_SACK_A )
 80074c6:	2a05      	cmp	r2, #5
 80074c8:	d1ed      	bne.n	80074a6 <xProcessReceivedTCPPacket+0x502>
					len -= 2;
 80074ca:	1eb9      	subs	r1, r7, #2
					pucPtr += 2;
 80074cc:	1c9a      	adds	r2, r3, #2
 80074ce:	9203      	str	r2, [sp, #12]
					while( len >= 8 )
 80074d0:	2907      	cmp	r1, #7
 80074d2:	dd09      	ble.n	80074e8 <xProcessReceivedTCPPacket+0x544>
 80074d4:	f103 050a 	add.w	r5, r3, #10
 80074d8:	f1a7 080a 	sub.w	r8, r7, #10
 80074dc:	f028 0a07 	bic.w	sl, r8, #7
 80074e0:	f10a 0612 	add.w	r6, sl, #18
 80074e4:	441e      	add	r6, r3
 80074e6:	e79c      	b.n	8007422 <xProcessReceivedTCPPacket+0x47e>
					pucPtr += 2;
 80074e8:	9b03      	ldr	r3, [sp, #12]
 80074ea:	e7dc      	b.n	80074a6 <xProcessReceivedTCPPacket+0x502>
 80074ec:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80074f0:	e5de      	b.n	80070b0 <xProcessReceivedTCPPacket+0x10c>
 80074f2:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80074f6:	e5db      	b.n	80070b0 <xProcessReceivedTCPPacket+0x10c>
 80074f8:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80074fc:	e5d8      	b.n	80070b0 <xProcessReceivedTCPPacket+0x10c>
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 80074fe:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007502:	f043 0301 	orr.w	r3, r3, #1
 8007506:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 800750a:	e622      	b.n	8007152 <xProcessReceivedTCPPacket+0x1ae>
			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
 800750c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800750e:	e642      	b.n	8007196 <xProcessReceivedTCPPacket+0x1f2>
				lTCPAddRxdata( pxSocket, 0ul, NULL, pxTCPWindow->ulUserDataLength );
 8007510:	2200      	movs	r2, #0
 8007512:	4611      	mov	r1, r2
 8007514:	4620      	mov	r0, r4
 8007516:	f7fe fa87 	bl	8005a28 <lTCPAddRxdata>
				pxTCPWindow->ulUserDataLength = 0;
 800751a:	2300      	movs	r3, #0
 800751c:	f8c4 310c 	str.w	r3, [r4, #268]	; 0x10c
 8007520:	e24d      	b.n	80079be <xProcessReceivedTCPPacket+0xa1a>
 8007522:	bf00      	nop
 8007524:	20000574 	.word	0x20000574
 8007528:	20000010 	.word	0x20000010
 800752c:	0800cd94 	.word	0x0800cd94
 8007530:	0800d53c 	.word	0x0800d53c
 8007534:	0800cd98 	.word	0x0800cd98
		pxTCPWindow->ucOptionLength = 0u;
 8007538:	2300      	movs	r3, #0
 800753a:	f884 3118 	strb.w	r3, [r4, #280]	; 0x118
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800753e:	9b05      	ldr	r3, [sp, #20]
 8007540:	699d      	ldr	r5, [r3, #24]
	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMssChange != pdFALSE_UNSIGNED ) )
 8007542:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007546:	2b04      	cmp	r3, #4
 8007548:	d94b      	bls.n	80075e2 <xProcessReceivedTCPPacket+0x63e>
 800754a:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800754e:	f013 0f01 	tst.w	r3, #1
 8007552:	f000 8087 	beq.w	8007664 <xProcessReceivedTCPPacket+0x6c0>
		pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
 8007556:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 800755a:	f36f 0300 	bfc	r3, #0, #1
 800755e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
		pxTCPHeader->ucOptdata[ 0 ] = TCP_OPT_MSS;
 8007562:	2302      	movs	r3, #2
 8007564:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
		pxTCPHeader->ucOptdata[ 1 ] = TCP_OPT_MSS_LEN;
 8007568:	f04f 0904 	mov.w	r9, #4
 800756c:	f885 9037 	strb.w	r9, [r5, #55]	; 0x37
		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
 8007570:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8007574:	0a1b      	lsrs	r3, r3, #8
 8007576:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffu );
 800757a:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 800757e:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8007582:	2360      	movs	r3, #96	; 0x60
 8007584:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
		if( ( pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) )
 8007588:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 800758c:	2b04      	cmp	r3, #4
 800758e:	d02b      	beq.n	80075e8 <xProcessReceivedTCPPacket+0x644>
		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 8007590:	f01b 0f01 	tst.w	fp, #1
 8007594:	d014      	beq.n	80075c0 <xProcessReceivedTCPPacket+0x61c>
 8007596:	f994 3041 	ldrsb.w	r3, [r4, #65]	; 0x41
 800759a:	2b00      	cmp	r3, #0
 800759c:	db10      	blt.n	80075c0 <xProcessReceivedTCPPacket+0x61c>
			pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
 800759e:	f8c4 a0f0 	str.w	sl, [r4, #240]	; 0xf0
			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
 80075a2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80075a6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80075aa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 80075ae:	f013 0f40 	tst.w	r3, #64	; 0x40
 80075b2:	d105      	bne.n	80075c0 <xProcessReceivedTCPPacket+0x61c>
				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
 80075b4:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 80075b8:	f043 0302 	orr.w	r3, r3, #2
 80075bc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		switch (pxSocket->u.xTCP.ucTCPState)
 80075c0:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 80075c4:	1e9a      	subs	r2, r3, #2
 80075c6:	2a08      	cmp	r2, #8
 80075c8:	f200 817f 	bhi.w	80078ca <xProcessReceivedTCPPacket+0x926>
 80075cc:	e8df f012 	tbh	[pc, r2, lsl #1]
 80075d0:	004d0230 	.word	0x004d0230
 80075d4:	00d80230 	.word	0x00d80230
 80075d8:	01770177 	.word	0x01770177
 80075dc:	017d017d 	.word	0x017d017d
 80075e0:	0177      	.short	0x0177
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 80075e2:	f04f 0900 	mov.w	r9, #0
 80075e6:	e7cf      	b.n	8007588 <xProcessReceivedTCPPacket+0x5e4>
		if( ( pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) )
 80075e8:	f00b 021f 	and.w	r2, fp, #31
 80075ec:	2a02      	cmp	r2, #2
 80075ee:	d034      	beq.n	800765a <xProcessReceivedTCPPacket+0x6b6>
		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 80075f0:	f01b 0f01 	tst.w	fp, #1
 80075f4:	f040 8215 	bne.w	8007a22 <xProcessReceivedTCPPacket+0xa7e>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 80075f8:	9a05      	ldr	r2, [sp, #20]
 80075fa:	6996      	ldr	r6, [r2, #24]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 80075fc:	f896 202f 	ldrb.w	r2, [r6, #47]	; 0x2f
	uint16_t usExpect = ( uint16_t ) ipTCP_FLAG_ACK;
 8007600:	2110      	movs	r1, #16
	if( ( ucTCPFlags & 0x17u ) != usExpect )
 8007602:	f002 0217 	and.w	r2, r2, #23
 8007606:	428a      	cmp	r2, r1
 8007608:	d17e      	bne.n	8007708 <xProcessReceivedTCPPacket+0x764>
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800760a:	f8d6 2026 	ldr.w	r2, [r6, #38]	; 0x26
 800760e:	0e11      	lsrs	r1, r2, #24
 8007610:	ea41 6102 	orr.w	r1, r1, r2, lsl #24
 8007614:	0210      	lsls	r0, r2, #8
 8007616:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 800761a:	4301      	orrs	r1, r0
 800761c:	0a12      	lsrs	r2, r2, #8
 800761e:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8007622:	ea41 0502 	orr.w	r5, r1, r2
		pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
 8007626:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8007628:	f8a4 2196 	strh.w	r2, [r4, #406]	; 0x196
		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
 800762c:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 800762e:	f8a4 2194 	strh.w	r2, [r4, #404]	; 0x194
		if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 8007632:	2b02      	cmp	r3, #2
 8007634:	d07a      	beq.n	800772c <xProcessReceivedTCPPacket+0x788>
		else if( ulReceiveLength == 0u )
 8007636:	9b02      	ldr	r3, [sp, #8]
 8007638:	2b00      	cmp	r3, #0
 800763a:	f040 81d4 	bne.w	80079e6 <xProcessReceivedTCPPacket+0xa42>
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 800763e:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 8007642:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007646:	3301      	adds	r3, #1
 8007648:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		if( ( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0u ) )
 800764c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007650:	2b02      	cmp	r3, #2
 8007652:	f000 81cd 	beq.w	80079f0 <xProcessReceivedTCPPacket+0xa4c>
BaseType_t xSendLength = 0;
 8007656:	2500      	movs	r5, #0
 8007658:	e1d4      	b.n	8007a04 <xProcessReceivedTCPPacket+0xa60>
			vTCPStateChange( pxSocket, eSYN_FIRST );
 800765a:	2103      	movs	r1, #3
 800765c:	4620      	mov	r0, r4
 800765e:	f7ff f851 	bl	8006704 <vTCPStateChange>
 8007662:	e795      	b.n	8007590 <xProcessReceivedTCPPacket+0x5ec>
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 8007664:	f04f 0900 	mov.w	r9, #0
 8007668:	e792      	b.n	8007590 <xProcessReceivedTCPPacket+0x5ec>
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 800766a:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) TCP_OPT_MSS;
 800766e:	2202      	movs	r2, #2
 8007670:	f886 2036 	strb.w	r2, [r6, #54]	; 0x36
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) TCP_OPT_MSS_LEN;
 8007674:	2204      	movs	r2, #4
 8007676:	f886 2037 	strb.w	r2, [r6, #55]	; 0x37
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 800767a:	0a1a      	lsrs	r2, r3, #8
 800767c:	f886 2038 	strb.w	r2, [r6, #56]	; 0x38
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffu );
 8007680:	f886 3039 	strb.w	r3, [r6, #57]	; 0x39
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 8007684:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8007688:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 800768c:	fb02 f203 	mul.w	r2, r2, r3
		while( uxWinSize > 0xfffful )
 8007690:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8007694:	d336      	bcc.n	8007704 <xProcessReceivedTCPPacket+0x760>
 8007696:	2300      	movs	r3, #0
			uxWinSize >>= 1;
 8007698:	0852      	lsrs	r2, r2, #1
			ucFactor++;
 800769a:	3301      	adds	r3, #1
 800769c:	b2db      	uxtb	r3, r3
		while( uxWinSize > 0xfffful )
 800769e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80076a2:	d2f9      	bcs.n	8007698 <xProcessReceivedTCPPacket+0x6f4>
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 80076a4:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
		pxTCPHeader->ucOptdata[ 4 ] = TCP_OPT_NOOP;
 80076a8:	2301      	movs	r3, #1
 80076aa:	f886 303a 	strb.w	r3, [r6, #58]	; 0x3a
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( TCP_OPT_WSOPT );
 80076ae:	2203      	movs	r2, #3
 80076b0:	f886 203b 	strb.w	r2, [r6, #59]	; 0x3b
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( TCP_OPT_WSOPT_LEN );
 80076b4:	f886 203c 	strb.w	r2, [r6, #60]	; 0x3c
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 80076b8:	f894 20c9 	ldrb.w	r2, [r4, #201]	; 0xc9
 80076bc:	f886 203d 	strb.w	r2, [r6, #61]	; 0x3d
			pxTCPHeader->ucOptdata[ uxOptionsLength + 0 ] = TCP_OPT_NOOP;
 80076c0:	f886 303e 	strb.w	r3, [r6, #62]	; 0x3e
			pxTCPHeader->ucOptdata[ uxOptionsLength + 1 ] = TCP_OPT_NOOP;
 80076c4:	f886 303f 	strb.w	r3, [r6, #63]	; 0x3f
			pxTCPHeader->ucOptdata[ uxOptionsLength + 2 ] = TCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 80076c8:	2104      	movs	r1, #4
 80076ca:	f886 1040 	strb.w	r1, [r6, #64]	; 0x40
			pxTCPHeader->ucOptdata[ uxOptionsLength + 3 ] = 2;	/* 2: length of this option. */
 80076ce:	2302      	movs	r3, #2
 80076d0:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_SYN | ipTCP_FLAG_ACK;
 80076d4:	2312      	movs	r3, #18
 80076d6:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
				pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80076da:	2380      	movs	r3, #128	; 0x80
 80076dc:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
				vTCPStateChange( pxSocket, eSYN_RECEIVED );
 80076e0:	4620      	mov	r0, r4
 80076e2:	f7ff f80f 	bl	8006704 <vTCPStateChange>
				pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
 80076e6:	f108 0301 	add.w	r3, r8, #1
 80076ea:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
 80076ee:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u; /* because we send a TCP_SYN. */
 80076f2:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 80076f6:	3301      	adds	r3, #1
 80076f8:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
 80076fc:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
				xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 8007700:	2534      	movs	r5, #52	; 0x34
 8007702:	e0e5      	b.n	80078d0 <xProcessReceivedTCPPacket+0x92c>
		ucFactor = 0u;
 8007704:	2300      	movs	r3, #0
 8007706:	e7cd      	b.n	80076a4 <xProcessReceivedTCPPacket+0x700>
		vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8007708:	2108      	movs	r1, #8
 800770a:	4620      	mov	r0, r4
 800770c:	f7fe fffa 	bl	8006704 <vTCPStateChange>
		pxTCPHeader->ucTCPFlags |= ipTCP_FLAG_RST;
 8007710:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
 8007714:	f043 0304 	orr.w	r3, r3, #4
 8007718:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800771c:	f109 0528 	add.w	r5, r9, #40	; 0x28
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8007720:	f109 0314 	add.w	r3, r9, #20
 8007724:	009b      	lsls	r3, r3, #2
 8007726:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
 800772a:	e0cf      	b.n	80078cc <xProcessReceivedTCPPacket+0x928>
			pxLastTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK;
 800772c:	2310      	movs	r3, #16
 800772e:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
 8007732:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8007736:	f8d4 2108 	ldr.w	r2, [r4, #264]	; 0x108
 800773a:	4629      	mov	r1, r5
 800773c:	9803      	ldr	r0, [sp, #12]
 800773e:	f000 fb26 	bl	8007d8e <vTCPWindowInit>
			pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
 8007742:	3501      	adds	r5, #1
 8007744:	f8c4 50f4 	str.w	r5, [r4, #244]	; 0xf4
 8007748:	f8c4 50ec 	str.w	r5, [r4, #236]	; 0xec
			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
 800774c:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8007750:	3301      	adds	r3, #1
 8007752:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
			pxTCPWindow->ulNextTxSequenceNumber++;
 8007756:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 800775a:	3301      	adds	r3, #1
 800775c:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 8007760:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8007764:	3301      	adds	r3, #1
 8007766:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
		if( ( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0u ) )
 800776a:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 800776e:	2b02      	cmp	r3, #2
 8007770:	f000 813e 	beq.w	80079f0 <xProcessReceivedTCPPacket+0xa4c>
 8007774:	9b02      	ldr	r3, [sp, #8]
 8007776:	2b00      	cmp	r3, #0
 8007778:	f040 813a 	bne.w	80079f0 <xProcessReceivedTCPPacket+0xa4c>
BaseType_t xSendLength = 0;
 800777c:	2500      	movs	r5, #0
 800777e:	e141      	b.n	8007a04 <xProcessReceivedTCPPacket+0xa60>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 8007780:	9b05      	ldr	r3, [sp, #20]
 8007782:	699e      	ldr	r6, [r3, #24]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8007784:	f896 502f 	ldrb.w	r5, [r6, #47]	; 0x2f
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount;
 8007788:	f8d6 7026 	ldr.w	r7, [r6, #38]	; 0x26
	pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPHeader->usWindow );
 800778c:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 800778e:	0a13      	lsrs	r3, r2, #8
 8007790:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007794:	b29b      	uxth	r3, r3
		( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 8007796:	f894 20ca 	ldrb.w	r2, [r4, #202]	; 0xca
 800779a:	4093      	lsls	r3, r2
	pxSocket->u.xTCP.ulWindowSize =
 800779c:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
	if( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_ACK ) != 0u )
 80077a0:	f015 0f10 	tst.w	r5, #16
 80077a4:	d11f      	bne.n	80077e6 <xProcessReceivedTCPPacket+0x842>
	if( pxSocket->u.xTCP.txStream != NULL )
 80077a6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80077a8:	b113      	cbz	r3, 80077b0 <xProcessReceivedTCPPacket+0x80c>
		prvTCPAddTxData( pxSocket );
 80077aa:	4620      	mov	r0, r4
 80077ac:	f7fe fdfc 	bl	80063a8 <prvTCPAddTxData>
	pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 80077b0:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 80077b4:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
	if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u ) )
 80077b8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80077bc:	f013 0f20 	tst.w	r3, #32
 80077c0:	d102      	bne.n	80077c8 <xProcessReceivedTCPPacket+0x824>
 80077c2:	f015 0f01 	tst.w	r5, #1
 80077c6:	d056      	beq.n	8007876 <xProcessReceivedTCPPacket+0x8d2>
		if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 80077c8:	f013 0f40 	tst.w	r3, #64	; 0x40
 80077cc:	d036      	beq.n	800783c <xProcessReceivedTCPPacket+0x898>
			pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
 80077ce:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80077d2:	f043 0320 	orr.w	r3, r3, #32
 80077d6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 80077da:	9905      	ldr	r1, [sp, #20]
 80077dc:	4620      	mov	r0, r4
 80077de:	f7ff fb71 	bl	8006ec4 <prvTCPHandleFin>
 80077e2:	4605      	mov	r5, r0
 80077e4:	e072      	b.n	80078cc <xProcessReceivedTCPPacket+0x928>
		ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulAckNr ) );
 80077e6:	f8d6 302a 	ldr.w	r3, [r6, #42]	; 0x2a
 80077ea:	0e19      	lsrs	r1, r3, #24
 80077ec:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 80077f0:	021a      	lsls	r2, r3, #8
 80077f2:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 80077f6:	4311      	orrs	r1, r2
 80077f8:	0a1b      	lsrs	r3, r3, #8
 80077fa:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80077fe:	4319      	orrs	r1, r3
 8007800:	9803      	ldr	r0, [sp, #12]
 8007802:	f000 fd1b 	bl	800823c <ulTCPWindowTxAck>
 8007806:	4603      	mov	r3, r0
		if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0u ) )
 8007808:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800780a:	2800      	cmp	r0, #0
 800780c:	d0d0      	beq.n	80077b0 <xProcessReceivedTCPPacket+0x80c>
 800780e:	2b00      	cmp	r3, #0
 8007810:	d0cb      	beq.n	80077aa <xProcessReceivedTCPPacket+0x806>
			if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0u, NULL, ( size_t ) ulCount, pdFALSE ) != 0u )
 8007812:	2100      	movs	r1, #0
 8007814:	9100      	str	r1, [sp, #0]
 8007816:	460a      	mov	r2, r1
 8007818:	f7fe fd63 	bl	80062e2 <uxStreamBufferGet>
 800781c:	2800      	cmp	r0, #0
 800781e:	d0c2      	beq.n	80077a6 <xProcessReceivedTCPPacket+0x802>
				pxSocket->xEventBits |= eSOCKET_SEND;
 8007820:	6823      	ldr	r3, [r4, #0]
 8007822:	f043 0202 	orr.w	r2, r3, #2
 8007826:	6022      	str	r2, [r4, #0]
					if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
 8007828:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800782a:	f012 0f02 	tst.w	r2, #2
 800782e:	d0ba      	beq.n	80077a6 <xProcessReceivedTCPPacket+0x802>
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 8007830:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007834:	f043 0302 	orr.w	r3, r3, #2
 8007838:	6023      	str	r3, [r4, #0]
 800783a:	e7b4      	b.n	80077a6 <xProcessReceivedTCPPacket+0x802>
			bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
 800783c:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8007840:	4640      	mov	r0, r8
 8007842:	f000 fa71 	bl	8007d28 <xTCPWindowRxEmpty>
 8007846:	4605      	mov	r5, r0
			bTxDone     = xTCPWindowTxDone( pxTCPWindow );
 8007848:	4640      	mov	r0, r8
 800784a:	f000 fc39 	bl	80080c0 <xTCPWindowTxDone>
			if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
 800784e:	b195      	cbz	r5, 8007876 <xProcessReceivedTCPPacket+0x8d2>
 8007850:	b188      	cbz	r0, 8007876 <xProcessReceivedTCPPacket+0x8d2>
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount;
 8007852:	0e3b      	lsrs	r3, r7, #24
 8007854:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 8007858:	023a      	lsls	r2, r7, #8
 800785a:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800785e:	431a      	orrs	r2, r3
 8007860:	0a3b      	lsrs	r3, r7, #8
 8007862:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8007866:	4313      	orrs	r3, r2
				lDistance = ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNumber );
 8007868:	f8d4 20ec 	ldr.w	r2, [r4, #236]	; 0xec
 800786c:	1a9b      	subs	r3, r3, r2
 800786e:	9a02      	ldr	r2, [sp, #8]
 8007870:	4413      	add	r3, r2
		if( xMayClose != pdFALSE )
 8007872:	2b01      	cmp	r3, #1
 8007874:	ddab      	ble.n	80077ce <xProcessReceivedTCPPacket+0x82a>
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 8007876:	2310      	movs	r3, #16
 8007878:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
		if( ulReceiveLength != 0u )
 800787c:	9b02      	ldr	r3, [sp, #8]
 800787e:	2b00      	cmp	r3, #0
 8007880:	f000 80df 	beq.w	8007a42 <xProcessReceivedTCPPacket+0xa9e>
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 8007884:	f109 0528 	add.w	r5, r9, #40	; 0x28
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 8007888:	f109 0314 	add.w	r3, r9, #20
 800788c:	009b      	lsls	r3, r3, #2
 800788e:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
			if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 8007892:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007896:	f013 0f40 	tst.w	r3, #64	; 0x40
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800789a:	bf1c      	itt	ne
 800789c:	f8d4 3100 	ldrne.w	r3, [r4, #256]	; 0x100
 80078a0:	f8c4 30fc 	strne.w	r3, [r4, #252]	; 0xfc
		if( uxOptionsLength == 0u )
 80078a4:	f1b9 0f00 	cmp.w	r9, #0
 80078a8:	d110      	bne.n	80078cc <xProcessReceivedTCPPacket+0x928>
 80078aa:	462e      	mov	r6, r5
			lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 80078ac:	2200      	movs	r2, #0
 80078ae:	a905      	add	r1, sp, #20
 80078b0:	4620      	mov	r0, r4
 80078b2:	f7ff f807 	bl	80068c4 <prvTCPPrepareSend>
			if( lSendResult > 0 )
 80078b6:	1e05      	subs	r5, r0, #0
 80078b8:	dc0a      	bgt.n	80078d0 <xProcessReceivedTCPPacket+0x92c>
 80078ba:	4635      	mov	r5, r6
 80078bc:	e006      	b.n	80078cc <xProcessReceivedTCPPacket+0x928>
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 80078be:	9905      	ldr	r1, [sp, #20]
 80078c0:	4620      	mov	r0, r4
 80078c2:	f7ff faff 	bl	8006ec4 <prvTCPHandleFin>
 80078c6:	4605      	mov	r5, r0
 80078c8:	e000      	b.n	80078cc <xProcessReceivedTCPPacket+0x928>
BaseType_t xSendLength = 0;
 80078ca:	2500      	movs	r5, #0
	if( xSendLength > 0 )
 80078cc:	2d00      	cmp	r5, #0
 80078ce:	dd41      	ble.n	8007954 <xProcessReceivedTCPPacket+0x9b0>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 80078d0:	9e05      	ldr	r6, [sp, #20]
 80078d2:	f8d6 e018 	ldr.w	lr, [r6, #24]
									 ( pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulCurrentSequenceNumber );
 80078d6:	f8d4 70ec 	ldr.w	r7, [r4, #236]	; 0xec
	pxSocket->u.xTCP.ulRxCurWinSize = pxTCPWindow->xSize.ulRxWindowLength -
 80078da:	f8d4 10e0 	ldr.w	r1, [r4, #224]	; 0xe0
 80078de:	4439      	add	r1, r7
 80078e0:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 80078e4:	1ac9      	subs	r1, r1, r3
 80078e6:	f8c4 10d0 	str.w	r1, [r4, #208]	; 0xd0
	if( pxSocket->u.xTCP.rxStream != NULL )
 80078ea:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80078ec:	2800      	cmp	r0, #0
 80078ee:	d03d      	beq.n	800796c <xProcessReceivedTCPPacket+0x9c8>
size_t uxFront = pxBuffer->uxFront;
 80078f0:	68c3      	ldr	r3, [r0, #12]
size_t uxTail = pxBuffer->uxTail;
 80078f2:	6802      	ldr	r2, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 80078f4:	6900      	ldr	r0, [r0, #16]
 80078f6:	4402      	add	r2, r0
 80078f8:	3a01      	subs	r2, #1
 80078fa:	1ad3      	subs	r3, r2, r3
	if( uxCount >= pxBuffer->LENGTH )
 80078fc:	4298      	cmp	r0, r3
 80078fe:	d800      	bhi.n	8007902 <xProcessReceivedTCPPacket+0x95e>
		uxCount -= pxBuffer->LENGTH;
 8007900:	1a1b      	subs	r3, r3, r0
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 8007902:	428b      	cmp	r3, r1
 8007904:	bf28      	it	cs
 8007906:	460b      	movcs	r3, r1
	pxSocket->u.xTCP.ulRxCurWinSize = FreeRTOS_min_uint32( ulFrontSpace, pxSocket->u.xTCP.ulRxCurWinSize );
 8007908:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
 800790c:	9b02      	ldr	r3, [sp, #8]
 800790e:	b16b      	cbz	r3, 800792c <xProcessReceivedTCPPacket+0x988>
	lRxSpace = (int32_t)( pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber );
 8007910:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007912:	1bdf      	subs	r7, r3, r7
			lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usCurMSS );
 8007914:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
 8007918:	ebb7 0f43 	cmp.w	r7, r3, lsl #1
 800791c:	db06      	blt.n	800792c <xProcessReceivedTCPPacket+0x988>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 800791e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
 8007922:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007926:	d101      	bne.n	800792c <xProcessReceivedTCPPacket+0x988>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 8007928:	2d28      	cmp	r5, #40	; 0x28
 800792a:	d021      	beq.n	8007970 <xProcessReceivedTCPPacket+0x9cc>
		else if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800792c:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800792e:	b128      	cbz	r0, 800793c <xProcessReceivedTCPPacket+0x998>
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 8007930:	4286      	cmp	r6, r0
 8007932:	d001      	beq.n	8007938 <xProcessReceivedTCPPacket+0x994>
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8007934:	f000 fdce 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
			pxSocket->u.xTCP.pxAckMessage = NULL;
 8007938:	2300      	movs	r3, #0
 800793a:	67e3      	str	r3, [r4, #124]	; 0x7c
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 800793c:	2300      	movs	r3, #0
 800793e:	462a      	mov	r2, r5
 8007940:	9905      	ldr	r1, [sp, #20]
 8007942:	4620      	mov	r0, r4
 8007944:	f7fe fd5a 	bl	80063fc <prvTCPReturnPacket>
		if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
 8007948:	2d00      	cmp	r5, #0
 800794a:	dd03      	ble.n	8007954 <xProcessReceivedTCPPacket+0x9b0>
				prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 800794c:	a905      	add	r1, sp, #20
 800794e:	4620      	mov	r0, r4
 8007950:	f7ff f930 	bl	8006bb4 <prvTCPSendRepeated>
		if( pxNetworkBuffer != NULL )
 8007954:	9805      	ldr	r0, [sp, #20]
 8007956:	b118      	cbz	r0, 8007960 <xProcessReceivedTCPPacket+0x9bc>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8007958:	f000 fdbc 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
			pxNetworkBuffer = NULL;
 800795c:	2300      	movs	r3, #0
 800795e:	9305      	str	r3, [sp, #20]
		prvTCPNextTimeout ( pxSocket );
 8007960:	4620      	mov	r0, r4
 8007962:	f7fe fe75 	bl	8006650 <prvTCPNextTimeout>
		xResult = pdPASS;
 8007966:	2001      	movs	r0, #1
	return xResult;
 8007968:	f7ff bb62 	b.w	8007030 <xProcessReceivedTCPPacket+0x8c>
		ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 800796c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800796e:	e7c8      	b.n	8007902 <xProcessReceivedTCPPacket+0x95e>
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
 8007970:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
 8007974:	2b05      	cmp	r3, #5
 8007976:	d1d9      	bne.n	800792c <xProcessReceivedTCPPacket+0x988>
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
 8007978:	f89e 302f 	ldrb.w	r3, [lr, #47]	; 0x2f
 800797c:	2b10      	cmp	r3, #16
 800797e:	d1d5      	bne.n	800792c <xProcessReceivedTCPPacket+0x988>
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 8007980:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8007982:	4286      	cmp	r6, r0
 8007984:	d004      	beq.n	8007990 <xProcessReceivedTCPPacket+0x9ec>
				if( pxSocket->u.xTCP.pxAckMessage != 0 )
 8007986:	b108      	cbz	r0, 800798c <xProcessReceivedTCPPacket+0x9e8>
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 8007988:	f000 fda4 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
 800798c:	9b05      	ldr	r3, [sp, #20]
 800798e:	67e3      	str	r3, [r4, #124]	; 0x7c
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
 8007990:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 8007994:	9a02      	ldr	r2, [sp, #8]
 8007996:	429a      	cmp	r2, r3
 8007998:	d302      	bcc.n	80079a0 <xProcessReceivedTCPPacket+0x9fc>
 800799a:	ebb7 0f43 	cmp.w	r7, r3, lsl #1
 800799e:	da05      	bge.n	80079ac <xProcessReceivedTCPPacket+0xa08>
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_SHORT_DELAY_MS );
 80079a0:	2302      	movs	r3, #2
 80079a2:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
			*ppxNetworkBuffer = NULL;
 80079a6:	2300      	movs	r3, #0
 80079a8:	9305      	str	r3, [sp, #20]
 80079aa:	e7d3      	b.n	8007954 <xProcessReceivedTCPPacket+0x9b0>
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_LONGER_DELAY_MS );
 80079ac:	2314      	movs	r3, #20
 80079ae:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 80079b2:	e7f8      	b.n	80079a6 <xProcessReceivedTCPPacket+0xa02>
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
 80079b4:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 80079b8:	2b00      	cmp	r3, #0
 80079ba:	f47f ada9 	bne.w	8007510 <xProcessReceivedTCPPacket+0x56c>
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80079be:	9b05      	ldr	r3, [sp, #20]
 80079c0:	699d      	ldr	r5, [r3, #24]
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 80079c2:	f894 7118 	ldrb.w	r7, [r4, #280]	; 0x118
 80079c6:	46b9      	mov	r9, r7
		if( uxOptionsLength != 0u )
 80079c8:	2f00      	cmp	r7, #0
 80079ca:	f43f adba 	beq.w	8007542 <xProcessReceivedTCPPacket+0x59e>
			memcpy( pxTCPHeader->ucOptdata, pxTCPWindow->ulOptionsData, ( size_t ) uxOptionsLength );
 80079ce:	463a      	mov	r2, r7
 80079d0:	f504 71ae 	add.w	r1, r4, #348	; 0x15c
 80079d4:	f105 0036 	add.w	r0, r5, #54	; 0x36
 80079d8:	f004 fe7d 	bl	800c6d6 <memcpy>
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80079dc:	3714      	adds	r7, #20
 80079de:	00bf      	lsls	r7, r7, #2
 80079e0:	f885 702e 	strb.w	r7, [r5, #46]	; 0x2e
 80079e4:	e5d0      	b.n	8007588 <xProcessReceivedTCPPacket+0x5e4>
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 80079e6:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 80079ea:	3301      	adds	r3, #1
 80079ec:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
			pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 80079f0:	2310      	movs	r3, #16
 80079f2:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 80079f6:	f109 0528 	add.w	r5, r9, #40	; 0x28
			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 80079fa:	f109 0314 	add.w	r3, r9, #20
 80079fe:	009b      	lsls	r3, r3, #2
 8007a00:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
		if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
 8007a04:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8007a08:	f013 0f10 	tst.w	r3, #16
 8007a0c:	d104      	bne.n	8007a18 <xProcessReceivedTCPPacket+0xa74>
			pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
 8007a0e:	2300      	movs	r3, #0
 8007a10:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
			pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
 8007a14:	f884 30ca 	strb.w	r3, [r4, #202]	; 0xca
		vTCPStateChange( pxSocket, eESTABLISHED );
 8007a18:	2105      	movs	r1, #5
 8007a1a:	4620      	mov	r0, r4
 8007a1c:	f7fe fe72 	bl	8006704 <vTCPStateChange>
 8007a20:	e754      	b.n	80078cc <xProcessReceivedTCPPacket+0x928>
		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 8007a22:	f994 3041 	ldrsb.w	r3, [r4, #65]	; 0x41
 8007a26:	2b00      	cmp	r3, #0
 8007a28:	f6bf adb9 	bge.w	800759e <xProcessReceivedTCPPacket+0x5fa>
		switch (pxSocket->u.xTCP.ucTCPState)
 8007a2c:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 8007a30:	9a05      	ldr	r2, [sp, #20]
 8007a32:	6996      	ldr	r6, [r2, #24]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 8007a34:	f896 202f 	ldrb.w	r2, [r6, #47]	; 0x2f
		usExpect |= ( uint16_t ) ipTCP_FLAG_SYN;
 8007a38:	2b02      	cmp	r3, #2
 8007a3a:	bf14      	ite	ne
 8007a3c:	2110      	movne	r1, #16
 8007a3e:	2112      	moveq	r1, #18
 8007a40:	e5df      	b.n	8007602 <xProcessReceivedTCPPacket+0x65e>
		if( uxOptionsLength == 0u )
 8007a42:	f1b9 0f00 	cmp.w	r9, #0
 8007a46:	d185      	bne.n	8007954 <xProcessReceivedTCPPacket+0x9b0>
 8007a48:	2600      	movs	r6, #0
 8007a4a:	e72f      	b.n	80078ac <xProcessReceivedTCPPacket+0x908>

08007a4c <FreeRTOS_GetTCPStateName>:
	{
		if( ulState >= ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) )
		{
			ulState = ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) - 1u;
		}
		return pcStateNames[ ulState ];
 8007a4c:	280c      	cmp	r0, #12
 8007a4e:	bf28      	it	cs
 8007a50:	200c      	movcs	r0, #12
	}
 8007a52:	4b02      	ldr	r3, [pc, #8]	; (8007a5c <FreeRTOS_GetTCPStateName+0x10>)
 8007a54:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8007a58:	4770      	bx	lr
 8007a5a:	bf00      	nop
 8007a5c:	0800cc88 	.word	0x0800cc88

08007a60 <xTCPCheckNewClient>:
 * In the API accept(), the user asks is there is a new client?  As API's can
 * not walk through the xBoundTCPSocketsList the IP-task will do this.
 */
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
TickType_t xLocalPort = FreeRTOS_htons( pxSocket->usLocalPort );
 8007a60:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 8007a62:	0a19      	lsrs	r1, r3, #8
 8007a64:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
FreeRTOS_Socket_t *pxFound;
BaseType_t xResult = pdFALSE;

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8007a68:	4a10      	ldr	r2, [pc, #64]	; (8007aac <xTCPCheckNewClient+0x4c>)
 8007a6a:	68d3      	ldr	r3, [r2, #12]
 8007a6c:	3208      	adds	r2, #8
 8007a6e:	4293      	cmp	r3, r2
 8007a70:	d019      	beq.n	8007aa6 <xTCPCheckNewClient+0x46>
{
 8007a72:	b430      	push	{r4, r5}
 8007a74:	b289      	uxth	r1, r1
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8007a76:	4614      	mov	r4, r2
 8007a78:	e002      	b.n	8007a80 <xTCPCheckNewClient+0x20>
		pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
		pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8007a7a:	685b      	ldr	r3, [r3, #4]
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8007a7c:	42a3      	cmp	r3, r4
 8007a7e:	d00f      	beq.n	8007aa0 <xTCPCheckNewClient+0x40>
	{
		if( listGET_LIST_ITEM_VALUE( pxIterator ) == xLocalPort )
 8007a80:	681a      	ldr	r2, [r3, #0]
 8007a82:	4291      	cmp	r1, r2
 8007a84:	d1f9      	bne.n	8007a7a <xTCPCheckNewClient+0x1a>
		{
			pxFound = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007a86:	68da      	ldr	r2, [r3, #12]
			if( ( pxFound->ucProtocol == FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 8007a88:	f892 5027 	ldrb.w	r5, [r2, #39]	; 0x27
 8007a8c:	2d06      	cmp	r5, #6
 8007a8e:	d1f4      	bne.n	8007a7a <xTCPCheckNewClient+0x1a>
 8007a90:	f892 5040 	ldrb.w	r5, [r2, #64]	; 0x40
 8007a94:	f015 0f02 	tst.w	r5, #2
 8007a98:	d0ef      	beq.n	8007a7a <xTCPCheckNewClient+0x1a>
			{
				pxSocket->u.xTCP.pxPeerSocket = pxFound;
 8007a9a:	6542      	str	r2, [r0, #84]	; 0x54
				FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) );
				xResult = pdTRUE;
 8007a9c:	2001      	movs	r0, #1
				break;
 8007a9e:	e000      	b.n	8007aa2 <xTCPCheckNewClient+0x42>
BaseType_t xResult = pdFALSE;
 8007aa0:	2000      	movs	r0, #0
			}
		}
	}
	return xResult;
}
 8007aa2:	bc30      	pop	{r4, r5}
 8007aa4:	4770      	bx	lr
BaseType_t xResult = pdFALSE;
 8007aa6:	2000      	movs	r0, #0
	return xResult;
 8007aa8:	4770      	bx	lr
 8007aaa:	bf00      	nop
 8007aac:	2000283c 	.word	0x2000283c

08007ab0 <xTCPWindowRxFind>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxFind( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 8007ab0:	b410      	push	{r4}
	TCPSegment_t *pxSegment, *pxReturn = NULL;

		/* Find a segment with a given sequence number in the list of received
		segments. */

		pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xRxSegments );
 8007ab2:	f100 04ac 	add.w	r4, r0, #172	; 0xac

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007ab6:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8007aba:	429c      	cmp	r4, r3
 8007abc:	d00f      	beq.n	8007ade <xTCPWindowRxFind+0x2e>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007abe:	68d8      	ldr	r0, [r3, #12]

			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 8007ac0:	6802      	ldr	r2, [r0, #0]
 8007ac2:	4291      	cmp	r1, r2
 8007ac4:	d008      	beq.n	8007ad8 <xTCPWindowRxFind+0x28>
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8007ac6:	685b      	ldr	r3, [r3, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007ac8:	429c      	cmp	r4, r3
 8007aca:	d004      	beq.n	8007ad6 <xTCPWindowRxFind+0x26>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007acc:	68d8      	ldr	r0, [r3, #12]
			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 8007ace:	6802      	ldr	r2, [r0, #0]
 8007ad0:	428a      	cmp	r2, r1
 8007ad2:	d1f8      	bne.n	8007ac6 <xTCPWindowRxFind+0x16>
 8007ad4:	e000      	b.n	8007ad8 <xTCPWindowRxFind+0x28>
	TCPSegment_t *pxSegment, *pxReturn = NULL;
 8007ad6:	2000      	movs	r0, #0
				break;
			}
		}

		return pxReturn;
	}
 8007ad8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007adc:	4770      	bx	lr
	TCPSegment_t *pxSegment, *pxReturn = NULL;
 8007ade:	2000      	movs	r0, #0
		return pxReturn;
 8007ae0:	e7fa      	b.n	8007ad8 <xTCPWindowRxFind+0x28>

08007ae2 <xTCPWindowPeekHead>:
	{
	ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8007ae2:	6803      	ldr	r3, [r0, #0]
 8007ae4:	b113      	cbz	r3, 8007aec <xTCPWindowPeekHead+0xa>
			pxReturn = NULL;
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
			pxReturn = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 8007ae6:	68c3      	ldr	r3, [r0, #12]
 8007ae8:	68d8      	ldr	r0, [r3, #12]
 8007aea:	4770      	bx	lr
			pxReturn = NULL;
 8007aec:	2000      	movs	r0, #0
		}

		return pxReturn;
	}
 8007aee:	4770      	bx	lr

08007af0 <prvTCPWindowTxHasSpace>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t *pxWindow, uint32_t ulWindowSize )
	{
 8007af0:	b538      	push	{r3, r4, r5, lr}
 8007af2:	4605      	mov	r5, r0
 8007af4:	460c      	mov	r4, r1
	TCPSegment_t *pxSegment;

		/* This function will look if there is new transmission data.  It will
		return true if there is data to be sent. */

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 8007af6:	3054      	adds	r0, #84	; 0x54
 8007af8:	f7ff fff3 	bl	8007ae2 <xTCPWindowPeekHead>

		if( pxSegment == NULL )
 8007afc:	b1a0      	cbz	r0, 8007b28 <prvTCPWindowTxHasSpace+0x38>
		}
		else
		{
			/* How much data is outstanding, i.e. how much data has been sent
			but not yet acknowledged ? */
			if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
 8007afe:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007b00:	6a2a      	ldr	r2, [r5, #32]
 8007b02:	4293      	cmp	r3, r2
 8007b04:	d312      	bcc.n	8007b2c <prvTCPWindowTxHasSpace+0x3c>
			{
				ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
 8007b06:	1a9b      	subs	r3, r3, r2

			/* Subtract this from the peer's space. */
			ulWindowSize -= FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );

			/* See if the next segment may be sent. */
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 8007b08:	6882      	ldr	r2, [r0, #8]
			ulWindowSize -= FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
 8007b0a:	42a3      	cmp	r3, r4
 8007b0c:	bf94      	ite	ls
 8007b0e:	1ae0      	subls	r0, r4, r3
 8007b10:	1b20      	subhi	r0, r4, r4
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 8007b12:	4290      	cmp	r0, r2
 8007b14:	bf34      	ite	cc
 8007b16:	2000      	movcc	r0, #0
 8007b18:	2001      	movcs	r0, #1

			/* If 'xHasSpace', it looks like the peer has at least space for 1
			more new segment of size MSS.  xSize.ulTxWindowLength is the self-imposed
			limitation of the transmission window (in case of many resends it
			may be decreased). */
			if( ( ulTxOutstanding != 0UL ) && ( pxWindow->xSize.ulTxWindowLength < ulTxOutstanding + ( ( uint32_t ) pxSegment->lDataLength ) ) )
 8007b1a:	b163      	cbz	r3, 8007b36 <prvTCPWindowTxHasSpace+0x46>
 8007b1c:	4413      	add	r3, r2
 8007b1e:	68aa      	ldr	r2, [r5, #8]
			{
				xHasSpace = pdFALSE;
 8007b20:	429a      	cmp	r2, r3
 8007b22:	bf38      	it	cc
 8007b24:	2000      	movcc	r0, #0
 8007b26:	bd38      	pop	{r3, r4, r5, pc}
			xHasSpace = pdFALSE;
 8007b28:	2000      	movs	r0, #0
			}
		}

		return xHasSpace;
 8007b2a:	bd38      	pop	{r3, r4, r5, pc}
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 8007b2c:	6880      	ldr	r0, [r0, #8]
 8007b2e:	4284      	cmp	r4, r0
 8007b30:	bf34      	ite	cc
 8007b32:	2000      	movcc	r0, #0
 8007b34:	2001      	movcs	r0, #1
	}
 8007b36:	bd38      	pop	{r3, r4, r5, pc}

08007b38 <xTCPWindowGetHead>:
	{
 8007b38:	b510      	push	{r4, lr}
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 8007b3a:	6803      	ldr	r3, [r0, #0]
 8007b3c:	b12b      	cbz	r3, 8007b4a <xTCPWindowGetHead+0x12>
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 8007b3e:	68c0      	ldr	r0, [r0, #12]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 8007b40:	68c4      	ldr	r4, [r0, #12]
			uxListRemove( pxItem );
 8007b42:	f001 f9b7 	bl	8008eb4 <uxListRemove>
	}
 8007b46:	4620      	mov	r0, r4
 8007b48:	bd10      	pop	{r4, pc}
			pxSegment = NULL;
 8007b4a:	2400      	movs	r4, #0
		return pxSegment;
 8007b4c:	e7fb      	b.n	8007b46 <xTCPWindowGetHead+0xe>

08007b4e <vListInsertGeneric>:
	pxNewListItem->pxNext = (struct xLIST_ITEM * configLIST_VOLATILE)pxWhere;
 8007b4e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxWhere->pxPrevious;
 8007b50:	6893      	ldr	r3, [r2, #8]
 8007b52:	608b      	str	r3, [r1, #8]
	pxWhere->pxPrevious->pxNext = pxNewListItem;
 8007b54:	6893      	ldr	r3, [r2, #8]
 8007b56:	6059      	str	r1, [r3, #4]
	pxWhere->pxPrevious = pxNewListItem;
 8007b58:	6091      	str	r1, [r2, #8]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8007b5a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8007b5c:	6803      	ldr	r3, [r0, #0]
 8007b5e:	3301      	adds	r3, #1
 8007b60:	6003      	str	r3, [r0, #0]
 8007b62:	4770      	bx	lr

08007b64 <vTCPWindowFree>:
	{
 8007b64:	b510      	push	{r4, lr}
 8007b66:	4604      	mov	r4, r0
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
 8007b68:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8007b6a:	b113      	cbz	r3, 8007b72 <vTCPWindowFree+0xe>
			uxListRemove( &( pxSegment->xQueueItem ) );
 8007b6c:	3018      	adds	r0, #24
 8007b6e:	f001 f9a1 	bl	8008eb4 <uxListRemove>
		pxSegment->ulSequenceNumber = 0u;
 8007b72:	2300      	movs	r3, #0
 8007b74:	6023      	str	r3, [r4, #0]
		pxSegment->lDataLength = 0l;
 8007b76:	60a3      	str	r3, [r4, #8]
		pxSegment->u.ulFlags = 0u;
 8007b78:	6163      	str	r3, [r4, #20]
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xListItem ) ) != NULL )
 8007b7a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8007b7c:	b11b      	cbz	r3, 8007b86 <vTCPWindowFree+0x22>
			uxListRemove( &( pxSegment->xListItem ) );
 8007b7e:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8007b82:	f001 f997 	bl	8008eb4 <uxListRemove>
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007b86:	4804      	ldr	r0, [pc, #16]	; (8007b98 <vTCPWindowFree+0x34>)
 8007b88:	f100 0208 	add.w	r2, r0, #8
 8007b8c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 8007b90:	f7ff ffdd 	bl	8007b4e <vListInsertGeneric>
 8007b94:	bd10      	pop	{r4, pc}
 8007b96:	bf00      	nop
 8007b98:	20000578 	.word	0x20000578

08007b9c <prvTCPWindowTxCheckAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 8007b9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007ba0:	b083      	sub	sp, #12
 8007ba2:	9201      	str	r2, [sp, #4]
	uint32_t ulBytesConfirmed = 0u;
	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xTxSegments );
 8007ba4:	f100 0798 	add.w	r7, r0, #152	; 0x98

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		for(
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007ba8:	f8d0 409c 	ldr.w	r4, [r0, #156]	; 0x9c
		for(
 8007bac:	42a7      	cmp	r7, r4
 8007bae:	d03c      	beq.n	8007c2a <prvTCPWindowTxCheckAck+0x8e>
 8007bb0:	4682      	mov	sl, r0
 8007bb2:	460d      	mov	r5, r1
 8007bb4:	f102 38ff 	add.w	r8, r2, #4294967295	; 0xffffffff
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007bb8:	eba8 0301 	sub.w	r3, r8, r1
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
 8007bbc:	2b00      	cmp	r3, #0
 8007bbe:	db3a      	blt.n	8007c36 <prvTCPWindowTxCheckAck+0x9a>
 8007bc0:	2300      	movs	r3, #0
 8007bc2:	9300      	str	r3, [sp, #0]
		return ( ( a - b - 1UL ) & 0x80000000UL ) == 0UL;
 8007bc4:	ea6f 0b02 	mvn.w	fp, r2
 8007bc8:	e043      	b.n	8007c52 <prvTCPWindowTxCheckAck+0xb6>
				/* This segment is fully ACK'd, set the flag. */
				pxSegment->u.bits.bAcked = pdTRUE_UNSIGNED;

				/* Calculate the RTT only if the segment was sent-out for the
				first time and if this is the last ACK'd segment in a range. */
				if( ( pxSegment->u.bits.ucTransmitCount == 1 ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
 8007bca:	9b01      	ldr	r3, [sp, #4]
 8007bcc:	4293      	cmp	r3, r2
 8007bce:	d159      	bne.n	8007c84 <prvTCPWindowTxCheckAck+0xe8>
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 8007bd0:	f002 fa2e 	bl	800a030 <xTaskGetTickCount>
 8007bd4:	6933      	ldr	r3, [r6, #16]
 8007bd6:	1ac0      	subs	r0, r0, r3
				{
					int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );

					if( pxWindow->lSRTT >= mS )
 8007bd8:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8007bdc:	4298      	cmp	r0, r3
 8007bde:	dc0f      	bgt.n	8007c00 <prvTCPWindowTxCheckAck+0x64>
					{
						/* RTT becomes smaller: adapt slowly. */
						pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
 8007be0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8007be4:	181b      	adds	r3, r3, r0
 8007be6:	bf48      	it	mi
 8007be8:	3307      	addmi	r3, #7
 8007bea:	10db      	asrs	r3, r3, #3
 8007bec:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
						/* RTT becomes larger: adapt quicker */
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
					}

					/* Cap to the minimum of 50ms. */
					if( pxWindow->lSRTT < winSRTT_CAP_mS )
 8007bf0:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8007bf4:	2b31      	cmp	r3, #49	; 0x31
 8007bf6:	dc45      	bgt.n	8007c84 <prvTCPWindowTxCheckAck+0xe8>
					{
						pxWindow->lSRTT = winSRTT_CAP_mS;
 8007bf8:	2332      	movs	r3, #50	; 0x32
 8007bfa:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
 8007bfe:	e041      	b.n	8007c84 <prvTCPWindowTxCheckAck+0xe8>
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
 8007c00:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8007c04:	4403      	add	r3, r0
 8007c06:	005b      	lsls	r3, r3, #1
 8007c08:	bf48      	it	mi
 8007c0a:	3307      	addmi	r3, #7
 8007c0c:	10db      	asrs	r3, r3, #3
 8007c0e:	f8ca 3038 	str.w	r3, [sl, #56]	; 0x38
 8007c12:	e7ed      	b.n	8007bf0 <prvTCPWindowTxCheckAck+0x54>
						ulLast - pxWindow->tx.ulFirstSequenceNumber,
						pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
				}

				/* Increase the left-hand value of the transmission window. */
				pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
 8007c14:	eb09 0305 	add.w	r3, r9, r5
 8007c18:	f8ca 3020 	str.w	r3, [sl, #32]

				/* This function will return the number of bytes that the tail
				of txStream may be advanced. */
				ulBytesConfirmed += ulDataLength;
 8007c1c:	9b00      	ldr	r3, [sp, #0]
 8007c1e:	444b      	add	r3, r9
 8007c20:	9300      	str	r3, [sp, #0]

				/* All segments below tx.ulCurrentSequenceNumber may be freed. */
				vTCPWindowFree( pxSegment );
 8007c22:	4630      	mov	r0, r6
 8007c24:	f7ff ff9e 	bl	8007b64 <vTCPWindowFree>
 8007c28:	e00c      	b.n	8007c44 <prvTCPWindowTxCheckAck+0xa8>
	uint32_t ulBytesConfirmed = 0u;
 8007c2a:	2300      	movs	r3, #0
 8007c2c:	9300      	str	r3, [sp, #0]

			ulSequenceNumber += ulDataLength;
		}

		return ulBytesConfirmed;
	}
 8007c2e:	9800      	ldr	r0, [sp, #0]
 8007c30:	b003      	add	sp, #12
 8007c32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t ulBytesConfirmed = 0u;
 8007c36:	2300      	movs	r3, #0
 8007c38:	9300      	str	r3, [sp, #0]
		return ulBytesConfirmed;
 8007c3a:	e7f8      	b.n	8007c2e <prvTCPWindowTxCheckAck+0x92>
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 8007c3c:	f8da 3020 	ldr.w	r3, [sl, #32]
 8007c40:	429d      	cmp	r5, r3
 8007c42:	d0e7      	beq.n	8007c14 <prvTCPWindowTxCheckAck+0x78>
			ulSequenceNumber += ulDataLength;
 8007c44:	444d      	add	r5, r9
		for(
 8007c46:	42a7      	cmp	r7, r4
 8007c48:	d0f1      	beq.n	8007c2e <prvTCPWindowTxCheckAck+0x92>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007c4a:	eba8 0305 	sub.w	r3, r8, r5
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
 8007c4e:	2b00      	cmp	r3, #0
 8007c50:	dbed      	blt.n	8007c2e <prvTCPWindowTxCheckAck+0x92>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007c52:	68e6      	ldr	r6, [r4, #12]
			pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 8007c54:	6864      	ldr	r4, [r4, #4]
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 8007c56:	6833      	ldr	r3, [r6, #0]
		return ( ( a - b - 1UL ) & 0x80000000UL ) == 0UL;
 8007c58:	43da      	mvns	r2, r3
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 8007c5a:	42ea      	cmn	r2, r5
 8007c5c:	d5f3      	bpl.n	8007c46 <prvTCPWindowTxCheckAck+0xaa>
			if( ulSequenceNumber != pxSegment->ulSequenceNumber )
 8007c5e:	42ab      	cmp	r3, r5
 8007c60:	d1e5      	bne.n	8007c2e <prvTCPWindowTxCheckAck+0x92>
			ulDataLength = ( uint32_t ) pxSegment->lDataLength;
 8007c62:	f8d6 9008 	ldr.w	r9, [r6, #8]
			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 8007c66:	7db3      	ldrb	r3, [r6, #22]
 8007c68:	f013 0f02 	tst.w	r3, #2
 8007c6c:	d1e6      	bne.n	8007c3c <prvTCPWindowTxCheckAck+0xa0>
				if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t )ulDataLength, ulLast ) != pdFALSE )
 8007c6e:	eb09 0205 	add.w	r2, r9, r5
 8007c72:	eb1b 0f02 	cmn.w	fp, r2
 8007c76:	d5da      	bpl.n	8007c2e <prvTCPWindowTxCheckAck+0x92>
				pxSegment->u.bits.bAcked = pdTRUE_UNSIGNED;
 8007c78:	f043 0302 	orr.w	r3, r3, #2
 8007c7c:	75b3      	strb	r3, [r6, #22]
				if( ( pxSegment->u.bits.ucTransmitCount == 1 ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
 8007c7e:	7d33      	ldrb	r3, [r6, #20]
 8007c80:	2b01      	cmp	r3, #1
 8007c82:	d0a2      	beq.n	8007bca <prvTCPWindowTxCheckAck+0x2e>
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 8007c84:	f8da 3020 	ldr.w	r3, [sl, #32]
 8007c88:	429d      	cmp	r5, r3
 8007c8a:	d0c3      	beq.n	8007c14 <prvTCPWindowTxCheckAck+0x78>
			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
 8007c8c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8007c8e:	2b00      	cmp	r3, #0
 8007c90:	d0d8      	beq.n	8007c44 <prvTCPWindowTxCheckAck+0xa8>
				uxListRemove( &pxSegment->xQueueItem );
 8007c92:	f106 0018 	add.w	r0, r6, #24
 8007c96:	f001 f90d 	bl	8008eb4 <uxListRemove>
 8007c9a:	e7d3      	b.n	8007c44 <prvTCPWindowTxCheckAck+0xa8>

08007c9c <xTCPWindowNew>:
	{
 8007c9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
 8007ca0:	4c1f      	ldr	r4, [pc, #124]	; (8007d20 <xTCPWindowNew+0x84>)
 8007ca2:	6824      	ldr	r4, [r4, #0]
 8007ca4:	2c00      	cmp	r4, #0
 8007ca6:	d038      	beq.n	8007d1a <xTCPWindowNew+0x7e>
 8007ca8:	461d      	mov	r5, r3
 8007caa:	4617      	mov	r7, r2
 8007cac:	4688      	mov	r8, r1
 8007cae:	4606      	mov	r6, r0
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
 8007cb0:	4b1b      	ldr	r3, [pc, #108]	; (8007d20 <xTCPWindowNew+0x84>)
 8007cb2:	f8d3 900c 	ldr.w	r9, [r3, #12]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 8007cb6:	f8d9 400c 	ldr.w	r4, [r9, #12]
			configASSERT( pxItem != NULL );
 8007cba:	f1b9 0f00 	cmp.w	r9, #0
 8007cbe:	d01d      	beq.n	8007cfc <xTCPWindowNew+0x60>
			configASSERT( pxSegment != NULL );
 8007cc0:	b314      	cbz	r4, 8007d08 <xTCPWindowNew+0x6c>
			uxListRemove( pxItem );
 8007cc2:	4648      	mov	r0, r9
 8007cc4:	f001 f8f6 	bl	8008eb4 <uxListRemove>
			vListInsertFifo( xIsForRx ? &pxWindow->xRxSegments : &pxWindow->xTxSegments, pxItem );
 8007cc8:	b325      	cbz	r5, 8007d14 <xTCPWindowNew+0x78>
 8007cca:	f106 00a4 	add.w	r0, r6, #164	; 0xa4
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007cce:	f100 0208 	add.w	r2, r0, #8
 8007cd2:	4649      	mov	r1, r9
 8007cd4:	f7ff ff3b 	bl	8007b4e <vListInsertGeneric>
	pxTimer->ulBorn = xTaskGetTickCount ( );
 8007cd8:	f002 f9aa 	bl	800a030 <xTaskGetTickCount>
 8007cdc:	6120      	str	r0, [r4, #16]
			pxSegment->u.ulFlags = 0;
 8007cde:	2300      	movs	r3, #0
 8007ce0:	6163      	str	r3, [r4, #20]
			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 );
 8007ce2:	1aed      	subs	r5, r5, r3
 8007ce4:	bf18      	it	ne
 8007ce6:	2501      	movne	r5, #1
 8007ce8:	f365 0382 	bfi	r3, r5, #2, #1
 8007cec:	75a3      	strb	r3, [r4, #22]
			pxSegment->lMaxLength = lCount;
 8007cee:	6067      	str	r7, [r4, #4]
			pxSegment->lDataLength = lCount;
 8007cf0:	60a7      	str	r7, [r4, #8]
			pxSegment->ulSequenceNumber = ulSequenceNumber;
 8007cf2:	f8c4 8000 	str.w	r8, [r4]
	}
 8007cf6:	4620      	mov	r0, r4
 8007cf8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			configASSERT( pxItem != NULL );
 8007cfc:	f240 11af 	movw	r1, #431	; 0x1af
 8007d00:	4808      	ldr	r0, [pc, #32]	; (8007d24 <xTCPWindowNew+0x88>)
 8007d02:	f004 fb2d 	bl	800c360 <vAssertCalled>
 8007d06:	e7db      	b.n	8007cc0 <xTCPWindowNew+0x24>
			configASSERT( pxSegment != NULL );
 8007d08:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8007d0c:	4805      	ldr	r0, [pc, #20]	; (8007d24 <xTCPWindowNew+0x88>)
 8007d0e:	f004 fb27 	bl	800c360 <vAssertCalled>
 8007d12:	e7d6      	b.n	8007cc2 <xTCPWindowNew+0x26>
			vListInsertFifo( xIsForRx ? &pxWindow->xRxSegments : &pxWindow->xTxSegments, pxItem );
 8007d14:	f106 0090 	add.w	r0, r6, #144	; 0x90
 8007d18:	e7d9      	b.n	8007cce <xTCPWindowNew+0x32>
			pxSegment = NULL;
 8007d1a:	2400      	movs	r4, #0
		return pxSegment;
 8007d1c:	e7eb      	b.n	8007cf6 <xTCPWindowNew+0x5a>
 8007d1e:	bf00      	nop
 8007d20:	20000578 	.word	0x20000578
 8007d24:	0800cdc8 	.word	0x0800cdc8

08007d28 <xTCPWindowRxEmpty>:
		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
 8007d28:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8007d2c:	b92b      	cbnz	r3, 8007d3a <xTCPWindowRxEmpty+0x12>
	return ( ( a - b ) & 0x80000000UL ) == 0UL;
 8007d2e:	6903      	ldr	r3, [r0, #16]
 8007d30:	6980      	ldr	r0, [r0, #24]
 8007d32:	1a18      	subs	r0, r3, r0
		else if( xSequenceGreaterThanOrEqual( pxWindow->rx.ulCurrentSequenceNumber, pxWindow->rx.ulHighestSequenceNumber ) != pdFALSE )
 8007d34:	43c0      	mvns	r0, r0
 8007d36:	0fc0      	lsrs	r0, r0, #31
 8007d38:	4770      	bx	lr
 8007d3a:	2000      	movs	r0, #0
	}
 8007d3c:	4770      	bx	lr

08007d3e <vTCPWindowDestroy>:
	{
 8007d3e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007d42:	4606      	mov	r6, r0
 8007d44:	2501      	movs	r5, #1
				pxSegments = &( pxWindow->xTxSegments );
 8007d46:	f100 0890 	add.w	r8, r0, #144	; 0x90
				pxSegments = &( pxWindow->xRxSegments );
 8007d4a:	f100 07a4 	add.w	r7, r0, #164	; 0xa4
 8007d4e:	e009      	b.n	8007d64 <vTCPWindowDestroy+0x26>
			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
 8007d50:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 8007d54:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8007d58:	d103      	bne.n	8007d62 <vTCPWindowDestroy+0x24>
				pxSegments = &( pxWindow->xTxSegments );
 8007d5a:	4644      	mov	r4, r8
 8007d5c:	e00a      	b.n	8007d74 <vTCPWindowDestroy+0x36>
		for( xRound = 0; xRound < 2; xRound++ )
 8007d5e:	2d01      	cmp	r5, #1
 8007d60:	dc13      	bgt.n	8007d8a <vTCPWindowDestroy+0x4c>
 8007d62:	3501      	adds	r5, #1
			if( xRound != 0 )
 8007d64:	2d01      	cmp	r5, #1
 8007d66:	d0f3      	beq.n	8007d50 <vTCPWindowDestroy+0x12>
			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
 8007d68:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8007d6c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8007d70:	d1f5      	bne.n	8007d5e <vTCPWindowDestroy+0x20>
				pxSegments = &( pxWindow->xRxSegments );
 8007d72:	463c      	mov	r4, r7
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 8007d74:	6823      	ldr	r3, [r4, #0]
 8007d76:	2b00      	cmp	r3, #0
 8007d78:	d0f1      	beq.n	8007d5e <vTCPWindowDestroy+0x20>
					pxSegment = ( TCPSegment_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxSegments );
 8007d7a:	68e3      	ldr	r3, [r4, #12]
					vTCPWindowFree( pxSegment );
 8007d7c:	68d8      	ldr	r0, [r3, #12]
 8007d7e:	f7ff fef1 	bl	8007b64 <vTCPWindowFree>
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 8007d82:	6823      	ldr	r3, [r4, #0]
 8007d84:	2b00      	cmp	r3, #0
 8007d86:	d1f8      	bne.n	8007d7a <vTCPWindowDestroy+0x3c>
 8007d88:	e7e9      	b.n	8007d5e <vTCPWindowDestroy+0x20>
	}
 8007d8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08007d8e <vTCPWindowInit>:
{
 8007d8e:	b410      	push	{r4}
	pxWindow->u.ulFlags = 0ul;
 8007d90:	2400      	movs	r4, #0
 8007d92:	6004      	str	r4, [r0, #0]
	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 8007d94:	2401      	movs	r4, #1
 8007d96:	7004      	strb	r4, [r0, #0]
	if( ulMSS != 0ul )
 8007d98:	b193      	cbz	r3, 8007dc0 <vTCPWindowInit+0x32>
 8007d9a:	461c      	mov	r4, r3
		if( pxWindow->usMSSInit != 0u )
 8007d9c:	f8b0 30be 	ldrh.w	r3, [r0, #190]	; 0xbe
 8007da0:	b10b      	cbz	r3, 8007da6 <vTCPWindowInit+0x18>
			pxWindow->usMSSInit = ( uint16_t ) ulMSS;
 8007da2:	f8a0 40be 	strh.w	r4, [r0, #190]	; 0xbe
		if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0u ) )
 8007da6:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	; 0xbc
 8007daa:	429c      	cmp	r4, r3
 8007dac:	d300      	bcc.n	8007db0 <vTCPWindowInit+0x22>
 8007dae:	b93b      	cbnz	r3, 8007dc0 <vTCPWindowInit+0x32>
			pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
 8007db0:	6843      	ldr	r3, [r0, #4]
 8007db2:	fbb3 f3f4 	udiv	r3, r3, r4
 8007db6:	fb04 f303 	mul.w	r3, r4, r3
 8007dba:	6043      	str	r3, [r0, #4]
			pxWindow->usMSS = ( uint16_t ) ulMSS;
 8007dbc:	f8a0 40bc 	strh.w	r4, [r0, #188]	; 0xbc
	pxWindow->lSRTT = l500ms;
 8007dc0:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8007dc4:	6383      	str	r3, [r0, #56]	; 0x38
	pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
 8007dc6:	60c1      	str	r1, [r0, #12]
	pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
 8007dc8:	6101      	str	r1, [r0, #16]
	pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
 8007dca:	6181      	str	r1, [r0, #24]
	pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
 8007dcc:	61c2      	str	r2, [r0, #28]
	pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
 8007dce:	6202      	str	r2, [r0, #32]
	pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
 8007dd0:	6342      	str	r2, [r0, #52]	; 0x34
	pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
 8007dd2:	6282      	str	r2, [r0, #40]	; 0x28
	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 8007dd4:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 8007dd6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007dda:	4770      	bx	lr

08007ddc <vTCPWindowCreate>:
{
 8007ddc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007de0:	4605      	mov	r5, r0
 8007de2:	468a      	mov	sl, r1
 8007de4:	4691      	mov	r9, r2
 8007de6:	4698      	mov	r8, r3
		if( xTCPSegments == NULL )
 8007de8:	4b22      	ldr	r3, [pc, #136]	; (8007e74 <vTCPWindowCreate+0x98>)
 8007dea:	681b      	ldr	r3, [r3, #0]
 8007dec:	b1fb      	cbz	r3, 8007e2e <vTCPWindowCreate+0x52>
		vListInitialise( &pxWindow->xTxSegments );
 8007dee:	f105 0090 	add.w	r0, r5, #144	; 0x90
 8007df2:	f001 f82b 	bl	8008e4c <vListInitialise>
		vListInitialise( &pxWindow->xRxSegments );
 8007df6:	f105 00a4 	add.w	r0, r5, #164	; 0xa4
 8007dfa:	f001 f827 	bl	8008e4c <vListInitialise>
		vListInitialise( &pxWindow->xPriorityQueue );			/* Priority queue: segments which must be sent immediately */
 8007dfe:	f105 0040 	add.w	r0, r5, #64	; 0x40
 8007e02:	f001 f823 	bl	8008e4c <vListInitialise>
		vListInitialise( &pxWindow->xTxQueue   );			/* Transmit queue: segments queued for transmission */
 8007e06:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8007e0a:	f001 f81f 	bl	8008e4c <vListInitialise>
		vListInitialise( &pxWindow->xWaitQueue );			/* Waiting queue:  outstanding segments */
 8007e0e:	f105 0068 	add.w	r0, r5, #104	; 0x68
 8007e12:	f001 f81b 	bl	8008e4c <vListInitialise>
	pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
 8007e16:	f8c5 a004 	str.w	sl, [r5, #4]
	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 8007e1a:	f8c5 9008 	str.w	r9, [r5, #8]
	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
 8007e1e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007e20:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007e22:	4641      	mov	r1, r8
 8007e24:	4628      	mov	r0, r5
 8007e26:	f7ff ffb2 	bl	8007d8e <vTCPWindowInit>
 8007e2a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		vListInitialise( &xSegmentList );
 8007e2e:	4812      	ldr	r0, [pc, #72]	; (8007e78 <vTCPWindowCreate+0x9c>)
 8007e30:	f001 f80c 	bl	8008e4c <vListInitialise>
		xTCPSegments = ( TCPSegment_t * ) pvPortMallocLarge( ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 8007e34:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8007e38:	f001 fa1e 	bl	8009278 <pvPortMalloc>
 8007e3c:	4606      	mov	r6, r0
 8007e3e:	4b0d      	ldr	r3, [pc, #52]	; (8007e74 <vTCPWindowCreate+0x98>)
 8007e40:	6018      	str	r0, [r3, #0]
		if( xTCPSegments == NULL )
 8007e42:	2800      	cmp	r0, #0
 8007e44:	d0d3      	beq.n	8007dee <vTCPWindowCreate+0x12>
			memset( xTCPSegments, '\0', ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 8007e46:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8007e4a:	2100      	movs	r1, #0
 8007e4c:	f004 fc68 	bl	800c720 <memset>
 8007e50:	4634      	mov	r4, r6
 8007e52:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007e56:	4f08      	ldr	r7, [pc, #32]	; (8007e78 <vTCPWindowCreate+0x9c>)
 8007e58:	f107 0b08 	add.w	fp, r7, #8
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xListItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
 8007e5c:	63a4      	str	r4, [r4, #56]	; 0x38
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
 8007e5e:	6264      	str	r4, [r4, #36]	; 0x24
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8007e60:	465a      	mov	r2, fp
 8007e62:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 8007e66:	4638      	mov	r0, r7
 8007e68:	f7ff fe71 	bl	8007b4e <vListInsertGeneric>
 8007e6c:	3440      	adds	r4, #64	; 0x40
			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 8007e6e:	42b4      	cmp	r4, r6
 8007e70:	d1f4      	bne.n	8007e5c <vTCPWindowCreate+0x80>
 8007e72:	e7bc      	b.n	8007dee <vTCPWindowCreate+0x12>
 8007e74:	2000058c 	.word	0x2000058c
 8007e78:	20000578 	.word	0x20000578

08007e7c <lTCPWindowRxCheck>:
	{
 8007e7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007e80:	4605      	mov	r5, r0
 8007e82:	460e      	mov	r6, r1
 8007e84:	4690      	mov	r8, r2
		ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 8007e86:	6907      	ldr	r7, [r0, #16]
		pxWindow->ucOptionLength = 0u;
 8007e88:	2200      	movs	r2, #0
 8007e8a:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
		pxWindow->ulUserDataLength = 0ul;
 8007e8e:	6302      	str	r2, [r0, #48]	; 0x30
		if( ulCurrentSequenceNumber == ulSequenceNumber )
 8007e90:	428f      	cmp	r7, r1
 8007e92:	d00f      	beq.n	8007eb4 <lTCPWindowRxCheck+0x38>
		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
 8007e94:	1c4a      	adds	r2, r1, #1
 8007e96:	4297      	cmp	r7, r2
 8007e98:	f000 809a 	beq.w	8007fd0 <lTCPWindowRxCheck+0x154>
			ulLast = ulSequenceNumber + ulLength;
 8007e9c:	eb01 0408 	add.w	r4, r1, r8
			lDistance = ( int32_t ) ( ulLast - ulCurrentSequenceNumber );
 8007ea0:	1be2      	subs	r2, r4, r7
			if( lDistance <= 0 )
 8007ea2:	2a00      	cmp	r2, #0
 8007ea4:	f340 8098 	ble.w	8007fd8 <lTCPWindowRxCheck+0x15c>
			else if( lDistance > ( int32_t ) ulSpace )
 8007ea8:	429a      	cmp	r2, r3
 8007eaa:	dd50      	ble.n	8007f4e <lTCPWindowRxCheck+0xd2>
				lReturn = -1;
 8007eac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007eb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( ulLength > ulSpace )
 8007eb4:	4598      	cmp	r8, r3
 8007eb6:	f200 8087 	bhi.w	8007fc8 <lTCPWindowRxCheck+0x14c>
				ulCurrentSequenceNumber += ulLength;
 8007eba:	4447      	add	r7, r8
				if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0 )
 8007ebc:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8007ec0:	b91b      	cbnz	r3, 8007eca <lTCPWindowRxCheck+0x4e>
				pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
 8007ec2:	612f      	str	r7, [r5, #16]
				lReturn = 0;
 8007ec4:	2000      	movs	r0, #0
 8007ec6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
 8007eca:	eb01 0c08 	add.w	ip, r1, r8
	const MiniListItem_t* pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &pxWindow->xRxSegments );
 8007ece:	f100 0eac 	add.w	lr, r0, #172	; 0xac
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007ed2:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8007ed6:	459e      	cmp	lr, r3
 8007ed8:	d021      	beq.n	8007f1e <lTCPWindowRxCheck+0xa2>
 8007eda:	4610      	mov	r0, r2
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007edc:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 8007ee0:	e003      	b.n	8007eea <lTCPWindowRxCheck+0x6e>
					pxBest = pxSegment;
 8007ee2:	4620      	mov	r0, r4
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8007ee4:	685b      	ldr	r3, [r3, #4]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8007ee6:	459e      	cmp	lr, r3
 8007ee8:	d012      	beq.n	8007f10 <lTCPWindowRxCheck+0x94>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8007eea:	68dc      	ldr	r4, [r3, #12]
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8007eec:	6822      	ldr	r2, [r4, #0]
	return ( ( a - b ) & 0x80000000UL ) == 0UL;
 8007eee:	1b91      	subs	r1, r2, r6
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8007ef0:	2900      	cmp	r1, #0
 8007ef2:	dbf7      	blt.n	8007ee4 <lTCPWindowRxCheck+0x68>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007ef4:	ebac 0102 	sub.w	r1, ip, r2
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 8007ef8:	2900      	cmp	r1, #0
 8007efa:	dbf3      	blt.n	8007ee4 <lTCPWindowRxCheck+0x68>
				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
 8007efc:	2800      	cmp	r0, #0
 8007efe:	d0f0      	beq.n	8007ee2 <lTCPWindowRxCheck+0x66>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8007f00:	6801      	ldr	r1, [r0, #0]
 8007f02:	3901      	subs	r1, #1
 8007f04:	1a8a      	subs	r2, r1, r2
					pxBest = pxSegment;
 8007f06:	ea10 0022 	ands.w	r0, r0, r2, asr #32
 8007f0a:	bf38      	it	cc
 8007f0c:	4620      	movcc	r0, r4
 8007f0e:	e7e9      	b.n	8007ee4 <lTCPWindowRxCheck+0x68>
					if( pxFound != NULL )
 8007f10:	b138      	cbz	r0, 8007f22 <lTCPWindowRxCheck+0xa6>
						ulCurrentSequenceNumber = pxFound->ulSequenceNumber + ( ( uint32_t ) pxFound->lDataLength );
 8007f12:	6804      	ldr	r4, [r0, #0]
 8007f14:	6883      	ldr	r3, [r0, #8]
 8007f16:	441c      	add	r4, r3
						vTCPWindowFree( pxFound );
 8007f18:	f7ff fe24 	bl	8007b64 <vTCPWindowFree>
 8007f1c:	e008      	b.n	8007f30 <lTCPWindowRxCheck+0xb4>
				ulCurrentSequenceNumber += ulLength;
 8007f1e:	463c      	mov	r4, r7
 8007f20:	e006      	b.n	8007f30 <lTCPWindowRxCheck+0xb4>
 8007f22:	463c      	mov	r4, r7
 8007f24:	e004      	b.n	8007f30 <lTCPWindowRxCheck+0xb4>
						ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
 8007f26:	689a      	ldr	r2, [r3, #8]
 8007f28:	4414      	add	r4, r2
						vTCPWindowFree( pxFound );
 8007f2a:	4618      	mov	r0, r3
 8007f2c:	f7ff fe1a 	bl	8007b64 <vTCPWindowFree>
					while( ( pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber ) ) != NULL )
 8007f30:	4621      	mov	r1, r4
 8007f32:	4628      	mov	r0, r5
 8007f34:	f7ff fdbc 	bl	8007ab0 <xTCPWindowRxFind>
 8007f38:	4603      	mov	r3, r0
 8007f3a:	2800      	cmp	r0, #0
 8007f3c:	d1f3      	bne.n	8007f26 <lTCPWindowRxCheck+0xaa>
					if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
 8007f3e:	42bc      	cmp	r4, r7
						pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
 8007f40:	bf1c      	itt	ne
 8007f42:	1be7      	subne	r7, r4, r7
 8007f44:	632f      	strne	r7, [r5, #48]	; 0x30
 8007f46:	4627      	mov	r7, r4
 8007f48:	e7bb      	b.n	8007ec2 <lTCPWindowRxCheck+0x46>
					ulLast += ( uint32_t ) pxFound->lDataLength;
 8007f4a:	689b      	ldr	r3, [r3, #8]
 8007f4c:	441c      	add	r4, r3
				while( ( pxFound = xTCPWindowRxFind( pxWindow, ulLast ) ) != NULL )
 8007f4e:	4621      	mov	r1, r4
 8007f50:	4628      	mov	r0, r5
 8007f52:	f7ff fdad 	bl	8007ab0 <xTCPWindowRxFind>
 8007f56:	4603      	mov	r3, r0
 8007f58:	2800      	cmp	r0, #0
 8007f5a:	d1f6      	bne.n	8007f4a <lTCPWindowRxCheck+0xce>
				pxWindow->ulOptionsData[0] = OPTION_CODE_SINGLE_SACK;
 8007f5c:	4b22      	ldr	r3, [pc, #136]	; (8007fe8 <lTCPWindowRxCheck+0x16c>)
 8007f5e:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
				pxWindow->ulOptionsData[1] = FreeRTOS_htonl( ulSequenceNumber );
 8007f62:	0e33      	lsrs	r3, r6, #24
 8007f64:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 8007f68:	0232      	lsls	r2, r6, #8
 8007f6a:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8007f6e:	4313      	orrs	r3, r2
 8007f70:	0a32      	lsrs	r2, r6, #8
 8007f72:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8007f76:	4313      	orrs	r3, r2
 8007f78:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
				pxWindow->ulOptionsData[2] = FreeRTOS_htonl( ulLast );
 8007f7c:	0e23      	lsrs	r3, r4, #24
 8007f7e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 8007f82:	0222      	lsls	r2, r4, #8
 8007f84:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 8007f88:	4313      	orrs	r3, r2
 8007f8a:	0a24      	lsrs	r4, r4, #8
 8007f8c:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
 8007f90:	431c      	orrs	r4, r3
 8007f92:	f8c5 4088 	str.w	r4, [r5, #136]	; 0x88
				pxWindow->ucOptionLength = 3 * sizeof( pxWindow->ulOptionsData[ 0 ] );
 8007f96:	230c      	movs	r3, #12
 8007f98:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
				pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
 8007f9c:	4631      	mov	r1, r6
 8007f9e:	4628      	mov	r0, r5
 8007fa0:	f7ff fd86 	bl	8007ab0 <xTCPWindowRxFind>
				if( pxFound != NULL )
 8007fa4:	b9e0      	cbnz	r0, 8007fe0 <lTCPWindowRxCheck+0x164>
					pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
 8007fa6:	2301      	movs	r3, #1
 8007fa8:	4642      	mov	r2, r8
 8007faa:	4631      	mov	r1, r6
 8007fac:	4628      	mov	r0, r5
 8007fae:	f7ff fe75 	bl	8007c9c <xTCPWindowNew>
					if( pxFound == NULL )
 8007fb2:	b110      	cbz	r0, 8007fba <lTCPWindowRxCheck+0x13e>
						lReturn = ( int32_t ) ( ulSequenceNumber - ulCurrentSequenceNumber );
 8007fb4:	1bf0      	subs	r0, r6, r7
 8007fb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxWindow->ucOptionLength = 0u;
 8007fba:	2300      	movs	r3, #0
 8007fbc:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
						lReturn = -1;
 8007fc0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007fc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				lReturn = -1;
 8007fc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007fcc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			lReturn = -1;
 8007fd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007fd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				lReturn = -1;
 8007fd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007fdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					lReturn = -1;
 8007fe0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
 8007fe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007fe8:	0a050101 	.word	0x0a050101

08007fec <lTCPWindowTxAdd>:
	{
 8007fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007ff0:	b083      	sub	sp, #12
 8007ff2:	4605      	mov	r5, r0
 8007ff4:	4616      	mov	r6, r2
 8007ff6:	469a      	mov	sl, r3
	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
 8007ff8:	460f      	mov	r7, r1
	TCPSegment_t *pxSegment = pxWindow->pxHeadSegment;
 8007ffa:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
		if( pxSegment != NULL )
 8007ffc:	b313      	cbz	r3, 8008044 <lTCPWindowTxAdd+0x58>
			if( pxSegment->lDataLength < pxSegment->lMaxLength )
 8007ffe:	f8d3 8008 	ldr.w	r8, [r3, #8]
 8008002:	685a      	ldr	r2, [r3, #4]
 8008004:	4590      	cmp	r8, r2
 8008006:	da20      	bge.n	800804a <lTCPWindowTxAdd+0x5e>
				if( ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength != 0 ) )
 8008008:	7d98      	ldrb	r0, [r3, #22]
 800800a:	f010 0f01 	tst.w	r0, #1
 800800e:	d152      	bne.n	80080b6 <lTCPWindowTxAdd+0xca>
 8008010:	f1b8 0f00 	cmp.w	r8, #0
 8008014:	d01b      	beq.n	800804e <lTCPWindowTxAdd+0x62>
					lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
 8008016:	eba2 0008 	sub.w	r0, r2, r8
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
 800801a:	4288      	cmp	r0, r1
 800801c:	bfa8      	it	ge
 800801e:	4608      	movge	r0, r1
					pxSegment->lDataLength += lToWrite;
 8008020:	eb08 0400 	add.w	r4, r8, r0
 8008024:	609c      	str	r4, [r3, #8]
					if( pxSegment->lDataLength >= pxSegment->lMaxLength )
 8008026:	42a2      	cmp	r2, r4
						pxWindow->pxHeadSegment = NULL;
 8008028:	bfdc      	itt	le
 800802a:	2300      	movle	r3, #0
 800802c:	67eb      	strle	r3, [r5, #124]	; 0x7c
					lBytesLeft -= lToWrite;
 800802e:	1a0f      	subs	r7, r1, r0
					pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 8008030:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8008032:	4403      	add	r3, r0
 8008034:	636b      	str	r3, [r5, #52]	; 0x34
		lPosition += lCount;
 8008036:	4406      	add	r6, r0
		if( lPosition >= lMax )
 8008038:	45b2      	cmp	sl, r6
 800803a:	dc3f      	bgt.n	80080bc <lTCPWindowTxAdd+0xd0>
			lPosition -= lMax;
 800803c:	eba6 060a 	sub.w	r6, r6, sl
					lDone += lToWrite;
 8008040:	4680      	mov	r8, r0
 8008042:	e004      	b.n	800804e <lTCPWindowTxAdd+0x62>
	int32_t lDone = 0;
 8008044:	f04f 0800 	mov.w	r8, #0
 8008048:	e001      	b.n	800804e <lTCPWindowTxAdd+0x62>
 800804a:	f04f 0800 	mov.w	r8, #0
		while( lBytesLeft > 0 )
 800804e:	2f00      	cmp	r7, #0
 8008050:	dd2d      	ble.n	80080ae <lTCPWindowTxAdd+0xc2>
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, pxWindow->usMSS );
 8008052:	f04f 0900 	mov.w	r9, #0
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008056:	f105 0b54 	add.w	fp, r5, #84	; 0x54
 800805a:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 800805e:	9301      	str	r3, [sp, #4]
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, pxWindow->usMSS );
 8008060:	464b      	mov	r3, r9
 8008062:	f8b5 20bc 	ldrh.w	r2, [r5, #188]	; 0xbc
 8008066:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8008068:	4628      	mov	r0, r5
 800806a:	f7ff fe17 	bl	8007c9c <xTCPWindowNew>
			if( pxSegment != NULL )
 800806e:	4604      	mov	r4, r0
 8008070:	b1e8      	cbz	r0, 80080ae <lTCPWindowTxAdd+0xc2>
 8008072:	6843      	ldr	r3, [r0, #4]
 8008074:	42bb      	cmp	r3, r7
 8008076:	bfa8      	it	ge
 8008078:	463b      	movge	r3, r7
				pxSegment->lDataLength = lToWrite;
 800807a:	6083      	str	r3, [r0, #8]
				pxSegment->lStreamPos = lPosition;
 800807c:	60c6      	str	r6, [r0, #12]
				lBytesLeft -= lToWrite;
 800807e:	1aff      	subs	r7, r7, r3
		lPosition += lCount;
 8008080:	441e      	add	r6, r3
		if( lPosition >= lMax )
 8008082:	45b2      	cmp	sl, r6
			lPosition -= lMax;
 8008084:	bfd8      	it	le
 8008086:	eba6 060a 	suble.w	r6, r6, sl
				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 800808a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800808c:	441a      	add	r2, r3
 800808e:	636a      	str	r2, [r5, #52]	; 0x34
				lDone += lToWrite;
 8008090:	4498      	add	r8, r3
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008092:	9a01      	ldr	r2, [sp, #4]
 8008094:	f100 0118 	add.w	r1, r0, #24
 8008098:	4658      	mov	r0, fp
 800809a:	f7ff fd58 	bl	8007b4e <vListInsertGeneric>
				if( pxSegment->lDataLength < pxSegment->lMaxLength )
 800809e:	68a2      	ldr	r2, [r4, #8]
 80080a0:	6863      	ldr	r3, [r4, #4]
 80080a2:	429a      	cmp	r2, r3
					pxWindow->pxHeadSegment = pxSegment;
 80080a4:	bfa8      	it	ge
 80080a6:	464c      	movge	r4, r9
 80080a8:	67ec      	str	r4, [r5, #124]	; 0x7c
		while( lBytesLeft > 0 )
 80080aa:	2f00      	cmp	r7, #0
 80080ac:	dcd8      	bgt.n	8008060 <lTCPWindowTxAdd+0x74>
	}
 80080ae:	4640      	mov	r0, r8
 80080b0:	b003      	add	sp, #12
 80080b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int32_t lDone = 0;
 80080b6:	f04f 0800 	mov.w	r8, #0
 80080ba:	e7c8      	b.n	800804e <lTCPWindowTxAdd+0x62>
					lDone += lToWrite;
 80080bc:	4680      	mov	r8, r0
 80080be:	e7c6      	b.n	800804e <lTCPWindowTxAdd+0x62>

080080c0 <xTCPWindowTxDone>:
		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
 80080c0:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
	}
 80080c4:	fab0 f080 	clz	r0, r0
 80080c8:	0940      	lsrs	r0, r0, #5
 80080ca:	4770      	bx	lr

080080cc <xTCPWindowTxHasData>:
	{
 80080cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		*pulDelay = 0u;
 80080ce:	2300      	movs	r3, #0
 80080d0:	6013      	str	r3, [r2, #0]
		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
 80080d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80080d4:	bb53      	cbnz	r3, 800812c <xTCPWindowTxHasData+0x60>
 80080d6:	4615      	mov	r5, r2
 80080d8:	460e      	mov	r6, r1
 80080da:	4604      	mov	r4, r0
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 80080dc:	3068      	adds	r0, #104	; 0x68
 80080de:	f7ff fd00 	bl	8007ae2 <xTCPWindowPeekHead>
			if( pxSegment != NULL )
 80080e2:	4607      	mov	r7, r0
 80080e4:	b160      	cbz	r0, 8008100 <xTCPWindowTxHasData+0x34>
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 80080e6:	f001 ffa3 	bl	800a030 <xTaskGetTickCount>
 80080ea:	693b      	ldr	r3, [r7, #16]
 80080ec:	1ac0      	subs	r0, r0, r3
				ulMaxAge = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 80080ee:	7d3a      	ldrb	r2, [r7, #20]
 80080f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80080f2:	4093      	lsls	r3, r2
				if( ulMaxAge > ulAge )
 80080f4:	4298      	cmp	r0, r3
 80080f6:	d21b      	bcs.n	8008130 <xTCPWindowTxHasData+0x64>
					*pulDelay = ulMaxAge - ulAge;
 80080f8:	1a1b      	subs	r3, r3, r0
 80080fa:	602b      	str	r3, [r5, #0]
				xReturn = pdTRUE;
 80080fc:	2001      	movs	r0, #1
 80080fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );
 8008100:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8008104:	f7ff fced 	bl	8007ae2 <xTCPWindowPeekHead>
				if( pxSegment == NULL )
 8008108:	4605      	mov	r5, r0
 800810a:	b198      	cbz	r0, 8008134 <xTCPWindowTxHasData+0x68>
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 800810c:	4631      	mov	r1, r6
 800810e:	4620      	mov	r0, r4
 8008110:	f7ff fcee 	bl	8007af0 <prvTCPWindowTxHasSpace>
 8008114:	b180      	cbz	r0, 8008138 <xTCPWindowTxHasData+0x6c>
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 8008116:	7823      	ldrb	r3, [r4, #0]
 8008118:	f013 0f02 	tst.w	r3, #2
 800811c:	d00e      	beq.n	800813c <xTCPWindowTxHasData+0x70>
 800811e:	68a8      	ldr	r0, [r5, #8]
 8008120:	686b      	ldr	r3, [r5, #4]
 8008122:	4298      	cmp	r0, r3
 8008124:	bfb4      	ite	lt
 8008126:	2000      	movlt	r0, #0
 8008128:	2001      	movge	r0, #1
 800812a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 800812c:	2001      	movs	r0, #1
 800812e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				xReturn = pdTRUE;
 8008130:	2001      	movs	r0, #1
 8008132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xReturn = pdFALSE;
 8008134:	2000      	movs	r0, #0
 8008136:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xReturn = pdFALSE;
 8008138:	2000      	movs	r0, #0
 800813a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xReturn = pdTRUE;
 800813c:	2001      	movs	r0, #1
	}
 800813e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08008140 <ulTCPWindowTxGet>:
	{
 8008140:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008144:	4605      	mov	r5, r0
 8008146:	460f      	mov	r7, r1
 8008148:	4616      	mov	r6, r2
		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
 800814a:	3040      	adds	r0, #64	; 0x40
 800814c:	f7ff fcf4 	bl	8007b38 <xTCPWindowGetHead>
		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
 8008150:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008152:	62eb      	str	r3, [r5, #44]	; 0x2c
		if( pxSegment == NULL )
 8008154:	4604      	mov	r4, r0
 8008156:	b310      	cbz	r0, 800819e <ulTCPWindowTxGet+0x5e>
			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
 8008158:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800815a:	b123      	cbz	r3, 8008166 <ulTCPWindowTxGet+0x26>
 800815c:	f240 5181 	movw	r1, #1409	; 0x581
 8008160:	4835      	ldr	r0, [pc, #212]	; (8008238 <ulTCPWindowTxGet+0xf8>)
 8008162:	f004 f8fd 	bl	800c360 <vAssertCalled>
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008166:	f105 0270 	add.w	r2, r5, #112	; 0x70
 800816a:	f104 0118 	add.w	r1, r4, #24
 800816e:	f105 0068 	add.w	r0, r5, #104	; 0x68
 8008172:	f7ff fcec 	bl	8007b4e <vListInsertGeneric>
			pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
 8008176:	7da3      	ldrb	r3, [r4, #22]
 8008178:	f043 0301 	orr.w	r3, r3, #1
 800817c:	75a3      	strb	r3, [r4, #22]
			( pxSegment->u.bits.ucTransmitCount )++;
 800817e:	7d23      	ldrb	r3, [r4, #20]
 8008180:	3301      	adds	r3, #1
 8008182:	b2db      	uxtb	r3, r3
 8008184:	7523      	strb	r3, [r4, #20]
			if( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW )
 8008186:	2b04      	cmp	r3, #4
 8008188:	d047      	beq.n	800821a <ulTCPWindowTxGet+0xda>
	pxTimer->ulBorn = xTaskGetTickCount ( );
 800818a:	f001 ff51 	bl	800a030 <xTaskGetTickCount>
 800818e:	6120      	str	r0, [r4, #16]
			pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
 8008190:	6823      	ldr	r3, [r4, #0]
 8008192:	62eb      	str	r3, [r5, #44]	; 0x2c
			*plPosition = pxSegment->lStreamPos;
 8008194:	68e3      	ldr	r3, [r4, #12]
 8008196:	6033      	str	r3, [r6, #0]
			ulReturn = ( uint32_t ) pxSegment->lDataLength;
 8008198:	68a0      	ldr	r0, [r4, #8]
 800819a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 800819e:	f105 0868 	add.w	r8, r5, #104	; 0x68
 80081a2:	4640      	mov	r0, r8
 80081a4:	f7ff fc9d 	bl	8007ae2 <xTCPWindowPeekHead>
			if( pxSegment != NULL )
 80081a8:	4681      	mov	r9, r0
 80081aa:	b148      	cbz	r0, 80081c0 <ulTCPWindowTxGet+0x80>
				ulMaxTime = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 80081ac:	7d03      	ldrb	r3, [r0, #20]
 80081ae:	6bac      	ldr	r4, [r5, #56]	; 0x38
 80081b0:	409c      	lsls	r4, r3
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 80081b2:	f001 ff3d 	bl	800a030 <xTaskGetTickCount>
 80081b6:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80081ba:	1ac0      	subs	r0, r0, r3
				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
 80081bc:	42a0      	cmp	r0, r4
 80081be:	d815      	bhi.n	80081ec <ulTCPWindowTxGet+0xac>
				pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 80081c0:	f105 0454 	add.w	r4, r5, #84	; 0x54
 80081c4:	4620      	mov	r0, r4
 80081c6:	f7ff fc8c 	bl	8007ae2 <xTCPWindowPeekHead>
				if( pxSegment == NULL )
 80081ca:	b370      	cbz	r0, 800822a <ulTCPWindowTxGet+0xea>
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 80081cc:	782a      	ldrb	r2, [r5, #0]
 80081ce:	f012 0f02 	tst.w	r2, #2
 80081d2:	d003      	beq.n	80081dc <ulTCPWindowTxGet+0x9c>
 80081d4:	6882      	ldr	r2, [r0, #8]
 80081d6:	6843      	ldr	r3, [r0, #4]
 80081d8:	429a      	cmp	r2, r3
 80081da:	db29      	blt.n	8008230 <ulTCPWindowTxGet+0xf0>
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 80081dc:	4639      	mov	r1, r7
 80081de:	4628      	mov	r0, r5
 80081e0:	f7ff fc86 	bl	8007af0 <prvTCPWindowTxHasSpace>
 80081e4:	b958      	cbnz	r0, 80081fe <ulTCPWindowTxGet+0xbe>
 80081e6:	2000      	movs	r0, #0
		return ulReturn;
 80081e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
 80081ec:	4640      	mov	r0, r8
 80081ee:	f7ff fca3 	bl	8007b38 <xTCPWindowGetHead>
 80081f2:	4604      	mov	r4, r0
					pxSegment->u.bits.ucDupAckCount = pdFALSE_UNSIGNED;
 80081f4:	2300      	movs	r3, #0
 80081f6:	7543      	strb	r3, [r0, #21]
			if( pxSegment == NULL )
 80081f8:	2800      	cmp	r0, #0
 80081fa:	d1ad      	bne.n	8008158 <ulTCPWindowTxGet+0x18>
 80081fc:	e7e0      	b.n	80081c0 <ulTCPWindowTxGet+0x80>
					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );
 80081fe:	4620      	mov	r0, r4
 8008200:	f7ff fc9a 	bl	8007b38 <xTCPWindowGetHead>
 8008204:	4604      	mov	r4, r0
					if( pxWindow->pxHeadSegment == pxSegment )
 8008206:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8008208:	4298      	cmp	r0, r3
						pxWindow->pxHeadSegment = NULL;
 800820a:	bf04      	itt	eq
 800820c:	2300      	moveq	r3, #0
 800820e:	67eb      	streq	r3, [r5, #124]	; 0x7c
					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
 8008210:	6803      	ldr	r3, [r0, #0]
 8008212:	6882      	ldr	r2, [r0, #8]
 8008214:	4413      	add	r3, r2
 8008216:	62ab      	str	r3, [r5, #40]	; 0x28
 8008218:	e79e      	b.n	8008158 <ulTCPWindowTxGet+0x18>
				if( pxWindow->xSize.ulTxWindowLength > ( 2U * pxWindow->usMSS ) )
 800821a:	f8b5 30bc 	ldrh.w	r3, [r5, #188]	; 0xbc
 800821e:	005b      	lsls	r3, r3, #1
 8008220:	68aa      	ldr	r2, [r5, #8]
 8008222:	429a      	cmp	r2, r3
					pxWindow->xSize.ulTxWindowLength = ( 2UL * pxWindow->usMSS );
 8008224:	bf88      	it	hi
 8008226:	60ab      	strhi	r3, [r5, #8]
 8008228:	e7af      	b.n	800818a <ulTCPWindowTxGet+0x4a>
 800822a:	2000      	movs	r0, #0
 800822c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008230:	2000      	movs	r0, #0
 8008232:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008236:	bf00      	nop
 8008238:	0800cdc8 	.word	0x0800cdc8

0800823c <ulTCPWindowTxAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxAck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 800823c:	b508      	push	{r3, lr}
	uint32_t ulFirstSequence, ulReturn;

		/* Receive a normal ACK. */

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
 800823e:	6a03      	ldr	r3, [r0, #32]
		return ( ( b - a ) & 0x80000000UL ) == 0UL;
 8008240:	1a5a      	subs	r2, r3, r1

		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
 8008242:	2a00      	cmp	r2, #0
 8008244:	db01      	blt.n	800824a <ulTCPWindowTxAck+0xe>
		{
			ulReturn = 0UL;
 8008246:	2000      	movs	r0, #0
		{
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
		}

		return ulReturn;
	}
 8008248:	bd08      	pop	{r3, pc}
 800824a:	460a      	mov	r2, r1
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
 800824c:	4619      	mov	r1, r3
 800824e:	f7ff fca5 	bl	8007b9c <prvTCPWindowTxCheckAck>
 8008252:	bd08      	pop	{r3, pc}

08008254 <ulTCPWindowTxSack>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxSack( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 8008254:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008258:	4607      	mov	r7, r0
 800825a:	460e      	mov	r6, r1
	uint32_t ulAckCount = 0UL;
	uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;

		/* Receive a SACK option. */
		ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
 800825c:	f7ff fc9e 	bl	8007b9c <prvTCPWindowTxCheckAck>
 8008260:	4680      	mov	r8, r0
		pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &( pxWindow->xWaitQueue ) );
 8008262:	f107 0570 	add.w	r5, r7, #112	; 0x70
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8008266:	6f7c      	ldr	r4, [r7, #116]	; 0x74
 8008268:	42a5      	cmp	r5, r4
 800826a:	d025      	beq.n	80082b8 <ulTCPWindowTxSack+0x64>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 800826c:	3e01      	subs	r6, #1
				pxSegment->u.bits.ucTransmitCount = pdFALSE_UNSIGNED;
 800826e:	f04f 0a00 	mov.w	sl, #0
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 8008272:	f107 0940 	add.w	r9, r7, #64	; 0x40
 8008276:	e001      	b.n	800827c <ulTCPWindowTxSack+0x28>
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8008278:	42a5      	cmp	r5, r4
 800827a:	d01d      	beq.n	80082b8 <ulTCPWindowTxSack+0x64>
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800827c:	68e3      	ldr	r3, [r4, #12]
			pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 800827e:	6864      	ldr	r4, [r4, #4]
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
 8008280:	7d9a      	ldrb	r2, [r3, #22]
 8008282:	f012 0f02 	tst.w	r2, #2
 8008286:	d1f7      	bne.n	8008278 <ulTCPWindowTxSack+0x24>
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 8008288:	681a      	ldr	r2, [r3, #0]
 800828a:	1ab2      	subs	r2, r6, r2
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
 800828c:	2a00      	cmp	r2, #0
 800828e:	dbf3      	blt.n	8008278 <ulTCPWindowTxSack+0x24>
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
 8008290:	7d5a      	ldrb	r2, [r3, #21]
 8008292:	3201      	adds	r2, #1
 8008294:	b2d2      	uxtb	r2, r2
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
 8008296:	755a      	strb	r2, [r3, #21]
 8008298:	2a03      	cmp	r2, #3
 800829a:	d1ed      	bne.n	8008278 <ulTCPWindowTxSack+0x24>
				pxSegment->u.bits.ucTransmitCount = pdFALSE_UNSIGNED;
 800829c:	f883 a014 	strb.w	sl, [r3, #20]
				uxListRemove( &pxSegment->xQueueItem );
 80082a0:	f103 0b18 	add.w	fp, r3, #24
 80082a4:	4658      	mov	r0, fp
 80082a6:	f000 fe05 	bl	8008eb4 <uxListRemove>
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 80082aa:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80082ae:	4659      	mov	r1, fp
 80082b0:	4648      	mov	r0, r9
 80082b2:	f7ff fc4c 	bl	8007b4e <vListInsertGeneric>
 80082b6:	e7df      	b.n	8008278 <ulTCPWindowTxSack+0x24>
				pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
			FreeRTOS_flush_logging( );
		}

		return ulAckCount;
	}
 80082b8:	4640      	mov	r0, r8
 80082ba:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080082c0 <vProcessGeneratedUDPPacket>:
	}
};
/*-----------------------------------------------------------*/

void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 80082c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80082c2:	b083      	sub	sp, #12
 80082c4:	4604      	mov	r4, r0
UDPPacket_t *pxUDPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
 80082c6:	6943      	ldr	r3, [r0, #20]
 80082c8:	a802      	add	r0, sp, #8
 80082ca:	f840 3d04 	str.w	r3, [r0, #-4]!

	/* Map the UDP packet onto the start of the frame. */
	pxUDPPacket = ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
 80082ce:	69a5      	ldr	r5, [r4, #24]

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ) );
 80082d0:	4629      	mov	r1, r5
 80082d2:	f7fb f8cd 	bl	8003470 <eARPGetCacheEntry>

	if( eReturned != eCantSendPacket )
 80082d6:	2802      	cmp	r0, #2
 80082d8:	d003      	beq.n	80082e2 <vProcessGeneratedUDPPacket+0x22>
	{
		if( eReturned == eARPCacheHit )
 80082da:	2801      	cmp	r0, #1
 80082dc:	d006      	beq.n	80082ec <vProcessGeneratedUDPPacket+0x2c>
					pxUDPPacket->xUDPHeader.usChecksum = 0u;
				}
			}
			#endif
		}
		else if( eReturned == eARPCacheMiss )
 80082de:	2800      	cmp	r0, #0
 80082e0:	d041      	beq.n	8008366 <vProcessGeneratedUDPPacket+0xa6>
	}
	else
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
		packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 80082e2:	4620      	mov	r0, r4
 80082e4:	f000 f8f6 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
	}
}
 80082e8:	b003      	add	sp, #12
 80082ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if( pxNetworkBuffer->usPort != ipPACKET_CONTAINS_ICMP_DATA )
 80082ec:	8c23      	ldrh	r3, [r4, #32]
 80082ee:	b173      	cbz	r3, 800830e <vProcessGeneratedUDPPacket+0x4e>
				pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 80082f0:	84ab      	strh	r3, [r5, #36]	; 0x24
				pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 80082f2:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 80082f4:	846b      	strh	r3, [r5, #34]	; 0x22
				pxUDPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( UDPHeader_t ) );
 80082f6:	69e3      	ldr	r3, [r4, #28]
 80082f8:	3308      	adds	r3, #8
 80082fa:	b29b      	uxth	r3, r3
				pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 80082fc:	0a1a      	lsrs	r2, r3, #8
 80082fe:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8008302:	84eb      	strh	r3, [r5, #38]	; 0x26
				pxUDPHeader->usChecksum = 0u;
 8008304:	2300      	movs	r3, #0
 8008306:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 800830a:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
			memcpy( ( void *) &( pxUDPPacket->xEthernetHeader.xSourceAddress ), ( void * ) xDefaultPartUDPPacketHeader.ucBytes, sizeof( xDefaultPartUDPPacketHeader ) );
 800830e:	4e1e      	ldr	r6, [pc, #120]	; (8008388 <vProcessGeneratedUDPPacket+0xc8>)
 8008310:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8008312:	f8c5 0006 	str.w	r0, [r5, #6]
 8008316:	f8c5 100a 	str.w	r1, [r5, #10]
 800831a:	f8c5 200e 	str.w	r2, [r5, #14]
 800831e:	f8c5 3012 	str.w	r3, [r5, #18]
 8008322:	ce03      	ldmia	r6!, {r0, r1}
 8008324:	f8c5 0016 	str.w	r0, [r5, #22]
 8008328:	f8c5 101a 	str.w	r1, [r5, #26]
			if( pxNetworkBuffer->usPort == ipPACKET_CONTAINS_ICMP_DATA )
 800832c:	8c23      	ldrh	r3, [r4, #32]
 800832e:	b9b3      	cbnz	r3, 800835e <vProcessGeneratedUDPPacket+0x9e>
				pxIPHeader->ucProtocol = ipPROTOCOL_ICMP;
 8008330:	2301      	movs	r3, #1
 8008332:	75eb      	strb	r3, [r5, #23]
				pxIPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( IPHeader_t ) );
 8008334:	69e3      	ldr	r3, [r4, #28]
 8008336:	3314      	adds	r3, #20
 8008338:	822b      	strh	r3, [r5, #16]
			pxNetworkBuffer->xDataLength = pxIPHeader->usLength + sizeof( EthernetHeader_t );
 800833a:	8a2b      	ldrh	r3, [r5, #16]
 800833c:	330e      	adds	r3, #14
 800833e:	61e3      	str	r3, [r4, #28]
			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 8008340:	8a2a      	ldrh	r2, [r5, #16]
 8008342:	0a13      	lsrs	r3, r2, #8
 8008344:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008348:	822b      	strh	r3, [r5, #16]
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
 800834a:	6963      	ldr	r3, [r4, #20]
 800834c:	f8c5 301e 	str.w	r3, [r5, #30]
				if( pxNetworkBuffer->ulIPAddress == ipLLMNR_IP_ADDR )
 8008350:	6962      	ldr	r2, [r4, #20]
 8008352:	4b0e      	ldr	r3, [pc, #56]	; (800838c <vProcessGeneratedUDPPacket+0xcc>)
 8008354:	429a      	cmp	r2, r3
 8008356:	d112      	bne.n	800837e <vProcessGeneratedUDPPacket+0xbe>
					pxIPHeader->ucTimeToLive = 0x01;
 8008358:	2301      	movs	r3, #1
 800835a:	75ab      	strb	r3, [r5, #22]
 800835c:	e00f      	b.n	800837e <vProcessGeneratedUDPPacket+0xbe>
				pxIPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
 800835e:	69e3      	ldr	r3, [r4, #28]
 8008360:	331c      	adds	r3, #28
 8008362:	822b      	strh	r3, [r5, #16]
 8008364:	e7e9      	b.n	800833a <vProcessGeneratedUDPPacket+0x7a>
			vARPRefreshCacheEntry( NULL, ulIPAddress );
 8008366:	9901      	ldr	r1, [sp, #4]
 8008368:	f7fa ff98 	bl	800329c <vARPRefreshCacheEntry>
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
 800836c:	2100      	movs	r1, #0
 800836e:	2002      	movs	r0, #2
 8008370:	f003 fa6e 	bl	800b850 <vExampleDebugStatUpdate>
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8008374:	9b01      	ldr	r3, [sp, #4]
 8008376:	6163      	str	r3, [r4, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
 8008378:	4620      	mov	r0, r4
 800837a:	f7fb f8df 	bl	800353c <vARPGenerateRequestPacket>
		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 800837e:	2101      	movs	r1, #1
 8008380:	4620      	mov	r0, r4
 8008382:	f000 fb69 	bl	8008a58 <xNetworkInterfaceOutput>
 8008386:	e7af      	b.n	80082e8 <vProcessGeneratedUDPPacket+0x28>
 8008388:	20000010 	.word	0x20000010
 800838c:	fc0000e0 	.word	0xfc0000e0

08008390 <xProcessReceivedUDPPacket>:
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
 8008390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008392:	4606      	mov	r6, r0
 8008394:	460f      	mov	r7, r1
BaseType_t xReturn = pdPASS;
FreeRTOS_Socket_t *pxSocket;

UDPPacket_t *pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
 8008396:	6985      	ldr	r5, [r0, #24]

	pxSocket = pxUDPSocketLookup( usPort );
 8008398:	4608      	mov	r0, r1
 800839a:	f7fc ffb1 	bl	8005300 <pxUDPSocketLookup>

	if( pxSocket )
 800839e:	b368      	cbz	r0, 80083fc <xProcessReceivedUDPPacket+0x6c>
 80083a0:	4604      	mov	r4, r0
	{

		/* When refreshing the ARP cache with received UDP packets we must be
		careful;  hundreds of broadcast messages may pass and if we're not
		handling them, no use to fill the ARP cache with those IP addresses. */
		vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 80083a2:	f8d5 101a 	ldr.w	r1, [r5, #26]
 80083a6:	1da8      	adds	r0, r5, #6
 80083a8:	f7fa ff78 	bl	800329c <vARPRefreshCacheEntry>
		}
		#endif

		if( xReturn == pdPASS )
		{
			vTaskSuspendAll();
 80083ac:	f001 fe38 	bl	800a020 <vTaskSuspendAll>
			{
				if( xReturn == pdPASS )
				{
					taskENTER_CRITICAL();
 80083b0:	f000 fdd8 	bl	8008f64 <vPortEnterCritical>
					{
						/* Add the network packet to the list of packets to be
						processed by the socket. */
						vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
 80083b4:	4631      	mov	r1, r6
 80083b6:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80083ba:	f000 fd55 	bl	8008e68 <vListInsertEnd>
					}
					taskEXIT_CRITICAL();
 80083be:	f000 fdf3 	bl	8008fa8 <vPortExitCritical>
				}
			}
			xTaskResumeAll();
 80083c2:	f001 ff07 	bl	800a1d4 <xTaskResumeAll>

			/* Set the socket's receive event */
			if( pxSocket->xEventGroup != NULL )
 80083c6:	6860      	ldr	r0, [r4, #4]
 80083c8:	b110      	cbz	r0, 80083d0 <xProcessReceivedUDPPacket+0x40>
			{
				xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_RECEIVE );
 80083ca:	2101      	movs	r1, #1
 80083cc:	f000 fcce 	bl	8008d6c <xEventGroupSetBits>
			}

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) )
 80083d0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80083d2:	b11b      	cbz	r3, 80083dc <xProcessReceivedUDPPacket+0x4c>
 80083d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80083d6:	f012 0f01 	tst.w	r2, #1
 80083da:	d105      	bne.n	80083e8 <xProcessReceivedUDPPacket+0x58>
			}
			#endif

			#if( ipconfigUSE_DHCP == 1 )
			{
				if( xIsDHCPSocket( pxSocket ) )
 80083dc:	4620      	mov	r0, r4
 80083de:	f7fb fb5f 	bl	8003aa0 <xIsDHCPSocket>
 80083e2:	b930      	cbnz	r0, 80083f2 <xProcessReceivedUDPPacket+0x62>
BaseType_t xReturn = pdPASS;
 80083e4:	2001      	movs	r0, #1
 80083e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_READ );
 80083e8:	2101      	movs	r1, #1
 80083ea:	6818      	ldr	r0, [r3, #0]
 80083ec:	f000 fcbe 	bl	8008d6c <xEventGroupSetBits>
 80083f0:	e7f4      	b.n	80083dc <xProcessReceivedUDPPacket+0x4c>
				{
					xSendEventToIPTask( eDHCPEvent );
 80083f2:	2004      	movs	r0, #4
 80083f4:	f7fc f98e 	bl	8004714 <xSendEventToIPTask>
BaseType_t xReturn = pdPASS;
 80083f8:	2001      	movs	r0, #1
 80083fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		#if( ipconfigUSE_DNS == 1 )
			/* a DNS reply, check for the source port.  Although the DNS client
			does open a UDP socket to send a messages, this socket will be
			closed after a short timeout.  Messages that come late (after the
			socket is closed) will be treated here. */
			if( FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usSourcePort ) == ipDNS_PORT )
 80083fc:	8c6a      	ldrh	r2, [r5, #34]	; 0x22
 80083fe:	0a13      	lsrs	r3, r2, #8
 8008400:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008404:	b21b      	sxth	r3, r3
 8008406:	2b35      	cmp	r3, #53	; 0x35
 8008408:	d007      	beq.n	800841a <xProcessReceivedUDPPacket+0x8a>
			else
		#endif

		#if( ipconfigUSE_LLMNR == 1 )
			/* a LLMNR request, check for the destination port. */
			if( ( usPort == FreeRTOS_ntohs( ipLLMNR_PORT ) ) ||
 800840a:	f64e 3314 	movw	r3, #60180	; 0xeb14
 800840e:	429f      	cmp	r7, r3
 8008410:	d00c      	beq.n	800842c <xProcessReceivedUDPPacket+0x9c>
 8008412:	429a      	cmp	r2, r3
 8008414:	d00a      	beq.n	800842c <xProcessReceivedUDPPacket+0x9c>
				xReturn = ( BaseType_t )ulNBNSHandlePacket( pxNetworkBuffer );
			}
			else
		#endif /* ipconfigUSE_NBNS */
		{
			xReturn = pdFAIL;
 8008416:	2000      	movs	r0, #0
		}
	}

	return xReturn;
}
 8008418:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 800841a:	f8d5 101a 	ldr.w	r1, [r5, #26]
 800841e:	1da8      	adds	r0, r5, #6
 8008420:	f7fa ff3c 	bl	800329c <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 8008424:	4630      	mov	r0, r6
 8008426:	f7fb ff9e 	bl	8004366 <ulDNSHandlePacket>
 800842a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 800842c:	f8d5 101a 	ldr.w	r1, [r5, #26]
 8008430:	1da8      	adds	r0, r5, #6
 8008432:	f7fa ff33 	bl	800329c <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 8008436:	4630      	mov	r0, r6
 8008438:	f7fb ff95 	bl	8004366 <ulDNSHandlePacket>
 800843c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08008440 <xNetworkBuffersInitialise>:
static SemaphoreHandle_t xNetworkBufferSemaphore = NULL;

/*-----------------------------------------------------------*/

BaseType_t xNetworkBuffersInitialise( void )
{
 8008440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
BaseType_t xReturn, x;

	/* Only initialise the buffers and their associated kernel objects if they
	have not been initialised before. */
	if( xNetworkBufferSemaphore == NULL )
 8008442:	4b1a      	ldr	r3, [pc, #104]	; (80084ac <xNetworkBuffersInitialise+0x6c>)
 8008444:	681b      	ldr	r3, [r3, #0]
 8008446:	b12b      	cbz	r3, 8008454 <xNetworkBuffersInitialise+0x14>

			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
		}
	}

	if( xNetworkBufferSemaphore == NULL )
 8008448:	4b18      	ldr	r3, [pc, #96]	; (80084ac <xNetworkBuffersInitialise+0x6c>)
 800844a:	6818      	ldr	r0, [r3, #0]
	{
		xReturn = pdPASS;
	}

	return xReturn;
}
 800844c:	3000      	adds	r0, #0
 800844e:	bf18      	it	ne
 8008450:	2001      	movne	r0, #1
 8008452:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		xNetworkBufferSemaphore = xSemaphoreCreateCounting( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS );
 8008454:	2119      	movs	r1, #25
 8008456:	4608      	mov	r0, r1
 8008458:	f001 f93c 	bl	80096d4 <xQueueCreateCountingSemaphore>
 800845c:	4b13      	ldr	r3, [pc, #76]	; (80084ac <xNetworkBuffersInitialise+0x6c>)
 800845e:	6018      	str	r0, [r3, #0]
		configASSERT( xNetworkBufferSemaphore );
 8008460:	b1f8      	cbz	r0, 80084a2 <xNetworkBuffersInitialise+0x62>
			vQueueAddToRegistry( xNetworkBufferSemaphore, "NetBufSem" );
 8008462:	4c12      	ldr	r4, [pc, #72]	; (80084ac <xNetworkBuffersInitialise+0x6c>)
 8008464:	4912      	ldr	r1, [pc, #72]	; (80084b0 <xNetworkBuffersInitialise+0x70>)
 8008466:	6820      	ldr	r0, [r4, #0]
 8008468:	f001 fb46 	bl	8009af8 <vQueueAddToRegistry>
		if( xNetworkBufferSemaphore != NULL )
 800846c:	6823      	ldr	r3, [r4, #0]
 800846e:	2b00      	cmp	r3, #0
 8008470:	d0ea      	beq.n	8008448 <xNetworkBuffersInitialise+0x8>
			vListInitialise( &xFreeBuffersList );
 8008472:	4810      	ldr	r0, [pc, #64]	; (80084b4 <xNetworkBuffersInitialise+0x74>)
 8008474:	f000 fcea 	bl	8008e4c <vListInitialise>
 8008478:	4c0f      	ldr	r4, [pc, #60]	; (80084b8 <xNetworkBuffersInitialise+0x78>)
 800847a:	f504 7761 	add.w	r7, r4, #900	; 0x384
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 800847e:	2600      	movs	r6, #0
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8008480:	4d0c      	ldr	r5, [pc, #48]	; (80084b4 <xNetworkBuffersInitialise+0x74>)
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 8008482:	61a6      	str	r6, [r4, #24]
				vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8008484:	4620      	mov	r0, r4
 8008486:	f000 fcec 	bl	8008e62 <vListInitialiseItem>
				listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );
 800848a:	60e4      	str	r4, [r4, #12]
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 800848c:	4621      	mov	r1, r4
 800848e:	4628      	mov	r0, r5
 8008490:	f000 fcf6 	bl	8008e80 <vListInsert>
 8008494:	3424      	adds	r4, #36	; 0x24
			for( x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 8008496:	42bc      	cmp	r4, r7
 8008498:	d1f3      	bne.n	8008482 <xNetworkBuffersInitialise+0x42>
			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
 800849a:	2219      	movs	r2, #25
 800849c:	4b07      	ldr	r3, [pc, #28]	; (80084bc <xNetworkBuffersInitialise+0x7c>)
 800849e:	601a      	str	r2, [r3, #0]
 80084a0:	e7d2      	b.n	8008448 <xNetworkBuffersInitialise+0x8>
		configASSERT( xNetworkBufferSemaphore );
 80084a2:	2187      	movs	r1, #135	; 0x87
 80084a4:	4806      	ldr	r0, [pc, #24]	; (80084c0 <xNetworkBuffersInitialise+0x80>)
 80084a6:	f003 ff5b 	bl	800c360 <vAssertCalled>
 80084aa:	e7da      	b.n	8008462 <xNetworkBuffersInitialise+0x22>
 80084ac:	2000092c 	.word	0x2000092c
 80084b0:	0800ce58 	.word	0x0800ce58
 80084b4:	20000594 	.word	0x20000594
 80084b8:	200005a8 	.word	0x200005a8
 80084bc:	20000590 	.word	0x20000590
 80084c0:	0800ce04 	.word	0x0800ce04

080084c4 <vReleaseNetworkBuffer>:
void vReleaseNetworkBuffer( uint8_t *pucEthernetBuffer )
{
	/* There is space before the Ethernet buffer in which a pointer to the
	network buffer that references this Ethernet buffer is stored.  Remove the
	space before freeing the buffer. */
	if( pucEthernetBuffer != NULL )
 80084c4:	b120      	cbz	r0, 80084d0 <vReleaseNetworkBuffer+0xc>
{
 80084c6:	b508      	push	{r3, lr}
	{
		pucEthernetBuffer -= ipBUFFER_PADDING;
		vPortFree( ( void * ) pucEthernetBuffer );
 80084c8:	380a      	subs	r0, #10
 80084ca:	f000 ff3b 	bl	8009344 <vPortFree>
 80084ce:	bd08      	pop	{r3, pc}
 80084d0:	4770      	bx	lr
	...

080084d4 <vReleaseNetworkBufferAndDescriptor>:
	return pxReturn;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBufferAndDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 80084d4:	b510      	push	{r4, lr}
 80084d6:	4604      	mov	r4, r0
	/* Ensure the buffer is returned to the list of free buffers before the
	counting semaphore is 'given' to say a buffer is available.  Release the
	storage allocated to the buffer payload.  THIS FILE SHOULD NOT BE USED
	IF THE PROJECT INCLUDES A MEMORY ALLOCATOR THAT WILL FRAGMENT THE HEAP
	MEMORY.  For example, heap_2 must not be used, heap_4 can be used. */
	vReleaseNetworkBuffer( pxNetworkBuffer->pucEthernetBuffer );
 80084d8:	6980      	ldr	r0, [r0, #24]
 80084da:	f7ff fff3 	bl	80084c4 <vReleaseNetworkBuffer>
	pxNetworkBuffer->pucEthernetBuffer = NULL;
 80084de:	2300      	movs	r3, #0
 80084e0:	61a3      	str	r3, [r4, #24]

	taskENTER_CRITICAL();
 80084e2:	f000 fd3f 	bl	8008f64 <vPortEnterCritical>
	{
		xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );

		if( xListItemAlreadyInFreeList == pdFALSE )
 80084e6:	6922      	ldr	r2, [r4, #16]
 80084e8:	4b0b      	ldr	r3, [pc, #44]	; (8008518 <vReleaseNetworkBufferAndDescriptor+0x44>)
 80084ea:	429a      	cmp	r2, r3
 80084ec:	d011      	beq.n	8008512 <vReleaseNetworkBufferAndDescriptor+0x3e>
		{
			vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 80084ee:	4621      	mov	r1, r4
 80084f0:	4618      	mov	r0, r3
 80084f2:	f000 fcb9 	bl	8008e68 <vListInsertEnd>
		}
	}
	taskEXIT_CRITICAL();
 80084f6:	f000 fd57 	bl	8008fa8 <vPortExitCritical>

	if( xListItemAlreadyInFreeList == pdFALSE )
	{
		xSemaphoreGive( xNetworkBufferSemaphore );
 80084fa:	2300      	movs	r3, #0
 80084fc:	461a      	mov	r2, r3
 80084fe:	4619      	mov	r1, r3
 8008500:	4806      	ldr	r0, [pc, #24]	; (800851c <vReleaseNetworkBufferAndDescriptor+0x48>)
 8008502:	6800      	ldr	r0, [r0, #0]
 8008504:	f001 f904 	bl	8009710 <xQueueGenericSend>
	}

	iptraceNETWORK_BUFFER_RELEASED( pxNetworkBuffer );
 8008508:	2100      	movs	r1, #0
 800850a:	2014      	movs	r0, #20
 800850c:	f003 f9a0 	bl	800b850 <vExampleDebugStatUpdate>
}
 8008510:	bd10      	pop	{r4, pc}
	taskEXIT_CRITICAL();
 8008512:	f000 fd49 	bl	8008fa8 <vPortExitCritical>
 8008516:	e7f7      	b.n	8008508 <vReleaseNetworkBufferAndDescriptor+0x34>
 8008518:	20000594 	.word	0x20000594
 800851c:	2000092c 	.word	0x2000092c

08008520 <pxGetNetworkBufferWithDescriptor>:
{
 8008520:	b570      	push	{r4, r5, r6, lr}
 8008522:	460a      	mov	r2, r1
	if( ( xRequestedSizeBytes != 0u ) && ( xRequestedSizeBytes < ( size_t ) baMINIMAL_BUFFER_SIZE ) )
 8008524:	1e43      	subs	r3, r0, #1
 8008526:	2b44      	cmp	r3, #68	; 0x44
 8008528:	d936      	bls.n	8008598 <pxGetNetworkBufferWithDescriptor+0x78>
	xRequestedSizeBytes += 2u;
 800852a:	1c84      	adds	r4, r0, #2
	if( ( xRequestedSizeBytes & ( sizeof( size_t ) - 1u ) ) != 0u )
 800852c:	f014 0f03 	tst.w	r4, #3
 8008530:	d002      	beq.n	8008538 <pxGetNetworkBufferWithDescriptor+0x18>
		xRequestedSizeBytes = ( xRequestedSizeBytes | ( sizeof( size_t ) - 1u ) ) + 1u;
 8008532:	f044 0403 	orr.w	r4, r4, #3
 8008536:	3401      	adds	r4, #1
	if( xSemaphoreTake( xNetworkBufferSemaphore, xBlockTimeTicks ) == pdPASS )
 8008538:	2300      	movs	r3, #0
 800853a:	4619      	mov	r1, r3
 800853c:	4822      	ldr	r0, [pc, #136]	; (80085c8 <pxGetNetworkBufferWithDescriptor+0xa8>)
 800853e:	6800      	ldr	r0, [r0, #0]
 8008540:	f001 f9f4 	bl	800992c <xQueueGenericReceive>
 8008544:	2801      	cmp	r0, #1
 8008546:	d138      	bne.n	80085ba <pxGetNetworkBufferWithDescriptor+0x9a>
		taskENTER_CRITICAL();
 8008548:	f000 fd0c 	bl	8008f64 <vPortEnterCritical>
			pxReturn = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &xFreeBuffersList );
 800854c:	4e1f      	ldr	r6, [pc, #124]	; (80085cc <pxGetNetworkBufferWithDescriptor+0xac>)
 800854e:	68f3      	ldr	r3, [r6, #12]
 8008550:	68dd      	ldr	r5, [r3, #12]
			uxListRemove( &( pxReturn->xBufferListItem ) );
 8008552:	4628      	mov	r0, r5
 8008554:	f000 fcae 	bl	8008eb4 <uxListRemove>
		taskEXIT_CRITICAL();
 8008558:	f000 fd26 	bl	8008fa8 <vPortExitCritical>
		uxCount = listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 800855c:	6833      	ldr	r3, [r6, #0]
		if( uxMinimumFreeNetworkBuffers > uxCount )
 800855e:	4a1c      	ldr	r2, [pc, #112]	; (80085d0 <pxGetNetworkBufferWithDescriptor+0xb0>)
 8008560:	6812      	ldr	r2, [r2, #0]
 8008562:	4293      	cmp	r3, r2
			uxMinimumFreeNetworkBuffers = uxCount;
 8008564:	bf3c      	itt	cc
 8008566:	4a1a      	ldrcc	r2, [pc, #104]	; (80085d0 <pxGetNetworkBufferWithDescriptor+0xb0>)
 8008568:	6013      	strcc	r3, [r2, #0]
		configASSERT( pxReturn->pucEthernetBuffer == NULL );
 800856a:	69ab      	ldr	r3, [r5, #24]
 800856c:	b123      	cbz	r3, 8008578 <pxGetNetworkBufferWithDescriptor+0x58>
 800856e:	f44f 7189 	mov.w	r1, #274	; 0x112
 8008572:	4818      	ldr	r0, [pc, #96]	; (80085d4 <pxGetNetworkBufferWithDescriptor+0xb4>)
 8008574:	f003 fef4 	bl	800c360 <vAssertCalled>
		if( xRequestedSizeBytes > 0 )
 8008578:	b984      	cbnz	r4, 800859c <pxGetNetworkBufferWithDescriptor+0x7c>
	if( pxReturn == NULL )
 800857a:	b1f5      	cbz	r5, 80085ba <pxGetNetworkBufferWithDescriptor+0x9a>
		iptraceNETWORK_BUFFER_OBTAINED( pxReturn );
 800857c:	4b12      	ldr	r3, [pc, #72]	; (80085c8 <pxGetNetworkBufferWithDescriptor+0xa8>)
 800857e:	6818      	ldr	r0, [r3, #0]
 8008580:	f001 faa8 	bl	8009ad4 <uxQueueMessagesWaiting>
 8008584:	4601      	mov	r1, r0
 8008586:	2003      	movs	r0, #3
 8008588:	f003 f962 	bl	800b850 <vExampleDebugStatUpdate>
 800858c:	2100      	movs	r1, #0
 800858e:	2013      	movs	r0, #19
 8008590:	f003 f95e 	bl	800b850 <vExampleDebugStatUpdate>
}
 8008594:	4628      	mov	r0, r5
 8008596:	bd70      	pop	{r4, r5, r6, pc}
	xRequestedSizeBytes += 2u;
 8008598:	2448      	movs	r4, #72	; 0x48
 800859a:	e7cd      	b.n	8008538 <pxGetNetworkBufferWithDescriptor+0x18>
			pxReturn->pucEthernetBuffer = ( uint8_t * ) pvPortMalloc( xRequestedSizeBytes + ipBUFFER_PADDING );
 800859c:	f104 000a 	add.w	r0, r4, #10
 80085a0:	f000 fe6a 	bl	8009278 <pvPortMalloc>
 80085a4:	61a8      	str	r0, [r5, #24]
			if( pxReturn->pucEthernetBuffer == NULL )
 80085a6:	b128      	cbz	r0, 80085b4 <pxGetNetworkBufferWithDescriptor+0x94>
				*( ( NetworkBufferDescriptor_t ** ) ( pxReturn->pucEthernetBuffer ) ) = pxReturn;
 80085a8:	6005      	str	r5, [r0, #0]
				pxReturn->pucEthernetBuffer += ipBUFFER_PADDING;
 80085aa:	69ab      	ldr	r3, [r5, #24]
 80085ac:	330a      	adds	r3, #10
 80085ae:	61ab      	str	r3, [r5, #24]
				pxReturn->xDataLength = xRequestedSizeBytes;
 80085b0:	61ec      	str	r4, [r5, #28]
 80085b2:	e7e2      	b.n	800857a <pxGetNetworkBufferWithDescriptor+0x5a>
				vReleaseNetworkBufferAndDescriptor( pxReturn );
 80085b4:	4628      	mov	r0, r5
 80085b6:	f7ff ff8d 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
		iptraceFAILED_TO_OBTAIN_NETWORK_BUFFER();
 80085ba:	2100      	movs	r1, #0
 80085bc:	2006      	movs	r0, #6
 80085be:	f003 f947 	bl	800b850 <vExampleDebugStatUpdate>
 80085c2:	2500      	movs	r5, #0
 80085c4:	e7e6      	b.n	8008594 <pxGetNetworkBufferWithDescriptor+0x74>
 80085c6:	bf00      	nop
 80085c8:	2000092c 	.word	0x2000092c
 80085cc:	20000594 	.word	0x20000594
 80085d0:	20000590 	.word	0x20000590
 80085d4:	0800ce04 	.word	0x0800ce04

080085d8 <uxGetNumberOfFreeNetworkBuffers>:
 * Returns the number of free network buffers
 */
UBaseType_t uxGetNumberOfFreeNetworkBuffers( void )
{
	return listCURRENT_LIST_LENGTH( &xFreeBuffersList );
}
 80085d8:	4b01      	ldr	r3, [pc, #4]	; (80085e0 <uxGetNumberOfFreeNetworkBuffers+0x8>)
 80085da:	6818      	ldr	r0, [r3, #0]
 80085dc:	4770      	bx	lr
 80085de:	bf00      	nop
 80085e0:	20000594 	.word	0x20000594

080085e4 <uxGetMinimumFreeNetworkBuffers>:
/*-----------------------------------------------------------*/

UBaseType_t uxGetMinimumFreeNetworkBuffers( void )
{
	return uxMinimumFreeNetworkBuffers;
}
 80085e4:	4b01      	ldr	r3, [pc, #4]	; (80085ec <uxGetMinimumFreeNetworkBuffers+0x8>)
 80085e6:	6818      	ldr	r0, [r3, #0]
 80085e8:	4770      	bx	lr
 80085ea:	bf00      	nop
 80085ec:	20000590 	.word	0x20000590

080085f0 <prvNetworkInterfaceInput>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvNetworkInterfaceInput( void )
{
 80085f0:	b570      	push	{r4, r5, r6, lr}
 80085f2:	b082      	sub	sp, #8
xNetworkBufferDescriptor_t *pxDescriptor;
uint16_t usReceivedLength;
__IO ETH_DMADescTypeDef *xDMARxDescriptor;
uint32_t ulSegCount;
xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };
 80085f4:	2301      	movs	r3, #1
 80085f6:	f88d 3000 	strb.w	r3, [sp]
 80085fa:	2300      	movs	r3, #0
 80085fc:	9301      	str	r3, [sp, #4]
const TickType_t xDescriptorWaitTime = pdMS_TO_TICKS( 250 );

	/* get received frame */
	if( HAL_ETH_GetReceivedFrame( &xETH ) != HAL_OK )
 80085fe:	482d      	ldr	r0, [pc, #180]	; (80086b4 <prvNetworkInterfaceInput+0xc4>)
 8008600:	f7f9 fc6e 	bl	8001ee0 <HAL_ETH_GetReceivedFrame>
 8008604:	2800      	cmp	r0, #0
 8008606:	d14e      	bne.n	80086a6 <prvNetworkInterfaceInput+0xb6>
		usReceivedLength = 0;
	}
	else
	{
		/* Obtain the size of the packet and put it into the "usReceivedLength" variable. */
		usReceivedLength = xETH.RxFrameInfos.length;
 8008608:	4b2a      	ldr	r3, [pc, #168]	; (80086b4 <prvNetworkInterfaceInput+0xc4>)
 800860a:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 800860c:	b2ac      	uxth	r4, r5

		if( usReceivedLength > 0 )
 800860e:	2c00      	cmp	r4, #0
 8008610:	d035      	beq.n	800867e <prvNetworkInterfaceInput+0x8e>
		{
			/* Create a buffer of the required length. */
			pxDescriptor = pxGetNetworkBufferWithDescriptor( usReceivedLength, xDescriptorWaitTime );
 8008612:	21fa      	movs	r1, #250	; 0xfa
 8008614:	4620      	mov	r0, r4
 8008616:	f7ff ff83 	bl	8008520 <pxGetNetworkBufferWithDescriptor>

			if( pxDescriptor != NULL )
 800861a:	4606      	mov	r6, r0
 800861c:	b350      	cbz	r0, 8008674 <prvNetworkInterfaceInput+0x84>
			{
				xDMARxDescriptor = xETH.RxFrameInfos.FSRxDesc;

				/* Copy remaining data. */
				if( usReceivedLength > pxDescriptor->xDataLength )
 800861e:	69c3      	ldr	r3, [r0, #28]
 8008620:	429c      	cmp	r4, r3
				{
					usReceivedLength = pxDescriptor->xDataLength;
 8008622:	bf88      	it	hi
 8008624:	b29c      	uxthhi	r4, r3
				}

				memcpy( pxDescriptor->pucEthernetBuffer, ( uint8_t * ) xETH.RxFrameInfos.buffer, usReceivedLength);
 8008626:	4622      	mov	r2, r4
 8008628:	4b22      	ldr	r3, [pc, #136]	; (80086b4 <prvNetworkInterfaceInput+0xc4>)
 800862a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800862c:	6980      	ldr	r0, [r0, #24]
 800862e:	f004 f852 	bl	800c6d6 <memcpy>

				xRxEvent.pvData = ( void * ) pxDescriptor;
 8008632:	9601      	str	r6, [sp, #4]

				/* Pass the data to the TCP/IP task for processing. */
				if( xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE )
 8008634:	21fa      	movs	r1, #250	; 0xfa
 8008636:	4668      	mov	r0, sp
 8008638:	f7fb ffd6 	bl	80045e8 <xSendEventStructToIPTask>
 800863c:	b9a8      	cbnz	r0, 800866a <prvNetworkInterfaceInput+0x7a>
				{
					/* Could not send the descriptor into the TCP/IP stack, it
					must be released. */
					vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 800863e:	4630      	mov	r0, r6
 8008640:	f7ff ff48 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
					iptraceETHERNET_RX_EVENT_LOST();
 8008644:	2100      	movs	r1, #0
 8008646:	200a      	movs	r0, #10
 8008648:	f003 f902 	bl	800b850 <vExampleDebugStatUpdate>
				{
					iptraceNETWORK_INTERFACE_RECEIVE();
				}

				/* Release descriptors to DMA.  Point to first descriptor. */
				xDMARxDescriptor = xETH.RxFrameInfos.FSRxDesc;
 800864c:	4a19      	ldr	r2, [pc, #100]	; (80086b4 <prvNetworkInterfaceInput+0xc4>)
 800864e:	6b13      	ldr	r3, [r2, #48]	; 0x30
				ulSegCount = xETH.RxFrameInfos.SegCount;
 8008650:	6b91      	ldr	r1, [r2, #56]	; 0x38

				/* Set Own bit in RX descriptors: gives the buffers back to
				DMA. */
				while( ulSegCount != 0 )
 8008652:	b131      	cbz	r1, 8008662 <prvNetworkInterfaceInput+0x72>
				{
					xDMARxDescriptor->Status |= ETH_DMARXDESC_OWN;
 8008654:	681a      	ldr	r2, [r3, #0]
 8008656:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800865a:	601a      	str	r2, [r3, #0]
					xDMARxDescriptor = ( ETH_DMADescTypeDef * ) xDMARxDescriptor->Buffer2NextDescAddr;
 800865c:	68db      	ldr	r3, [r3, #12]
				while( ulSegCount != 0 )
 800865e:	3901      	subs	r1, #1
 8008660:	d1f8      	bne.n	8008654 <prvNetworkInterfaceInput+0x64>
					ulSegCount--;
				}

				/* Clear Segment_Count */
				xETH.RxFrameInfos.SegCount = 0;
 8008662:	2200      	movs	r2, #0
 8008664:	4b13      	ldr	r3, [pc, #76]	; (80086b4 <prvNetworkInterfaceInput+0xc4>)
 8008666:	639a      	str	r2, [r3, #56]	; 0x38
 8008668:	e00c      	b.n	8008684 <prvNetworkInterfaceInput+0x94>
					iptraceNETWORK_INTERFACE_RECEIVE();
 800866a:	2100      	movs	r1, #0
 800866c:	4608      	mov	r0, r1
 800866e:	f003 f8ef 	bl	800b850 <vExampleDebugStatUpdate>
 8008672:	e7eb      	b.n	800864c <prvNetworkInterfaceInput+0x5c>
			}
			else
			{
				FreeRTOS_printf( ( "prvNetworkInterfaceInput: pxGetNetworkBuffer failed length %u\n", usReceivedLength ) );
 8008674:	4621      	mov	r1, r4
 8008676:	4810      	ldr	r0, [pc, #64]	; (80086b8 <prvNetworkInterfaceInput+0xc8>)
 8008678:	f003 f9e6 	bl	800ba48 <lUDPLoggingPrintf>
 800867c:	e002      	b.n	8008684 <prvNetworkInterfaceInput+0x94>
			}
		}
		else
		{
			FreeRTOS_printf( ( "prvNetworkInterfaceInput: zero-sized packet?\n" ) );
 800867e:	480f      	ldr	r0, [pc, #60]	; (80086bc <prvNetworkInterfaceInput+0xcc>)
 8008680:	f003 f9e2 	bl	800ba48 <lUDPLoggingPrintf>
			pxDescriptor = NULL;
		}

		/* When Rx Buffer unavailable flag is set clear it and resume
		reception. */
		if( ( xETH.Instance->DMASR & ETH_DMASR_RBUS ) != 0 )
 8008684:	4b0b      	ldr	r3, [pc, #44]	; (80086b4 <prvNetworkInterfaceInput+0xc4>)
 8008686:	681b      	ldr	r3, [r3, #0]
 8008688:	f241 0214 	movw	r2, #4116	; 0x1014
 800868c:	589a      	ldr	r2, [r3, r2]
 800868e:	f012 0f80 	tst.w	r2, #128	; 0x80
 8008692:	d009      	beq.n	80086a8 <prvNetworkInterfaceInput+0xb8>
		{
			/* Clear RBUS ETHERNET DMA flag. */
			xETH.Instance->DMASR = ETH_DMASR_RBUS;
 8008694:	2180      	movs	r1, #128	; 0x80
 8008696:	f241 0214 	movw	r2, #4116	; 0x1014
 800869a:	5099      	str	r1, [r3, r2]

			/* Resume DMA reception. */
			xETH.Instance->DMARPDR = 0;
 800869c:	2100      	movs	r1, #0
 800869e:	f241 0208 	movw	r2, #4104	; 0x1008
 80086a2:	5099      	str	r1, [r3, r2]
 80086a4:	e000      	b.n	80086a8 <prvNetworkInterfaceInput+0xb8>
		usReceivedLength = 0;
 80086a6:	2400      	movs	r4, #0
		}
	}

	return ( usReceivedLength > 0 );
}
 80086a8:	1c20      	adds	r0, r4, #0
 80086aa:	bf18      	it	ne
 80086ac:	2001      	movne	r0, #1
 80086ae:	b002      	add	sp, #8
 80086b0:	bd70      	pop	{r4, r5, r6, pc}
 80086b2:	bf00      	nop
 80086b4:	20000944 	.word	0x20000944
 80086b8:	0800cf48 	.word	0x0800cf48
 80086bc:	0800cf88 	.word	0x0800cf88

080086c0 <prvEthernetUpdateConfig>:
	ulACRValue = ulAdvertise;
}
/*-----------------------------------------------------------*/

static void prvEthernetUpdateConfig( BaseType_t xForce )
{
 80086c0:	b530      	push	{r4, r5, lr}
 80086c2:	b085      	sub	sp, #20
 80086c4:	4604      	mov	r4, r0
__IO uint32_t ulTimeout = 0;
 80086c6:	2300      	movs	r3, #0
 80086c8:	9303      	str	r3, [sp, #12]
uint32_t ulRegValue = 0;
 80086ca:	9302      	str	r3, [sp, #8]

	FreeRTOS_printf( ( "prvEthernetUpdateConfig: LS %d Force %d\n",
 80086cc:	4b4b      	ldr	r3, [pc, #300]	; (80087fc <prvEthernetUpdateConfig+0x13c>)
 80086ce:	6819      	ldr	r1, [r3, #0]
 80086d0:	4602      	mov	r2, r0
 80086d2:	f3c1 0180 	ubfx	r1, r1, #2, #1
 80086d6:	484a      	ldr	r0, [pc, #296]	; (8008800 <prvEthernetUpdateConfig+0x140>)
 80086d8:	f003 f9b6 	bl	800ba48 <lUDPLoggingPrintf>
		( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ,
		xForce ) );

	if( ( xForce != pdFALSE ) || ( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) )
 80086dc:	b92c      	cbnz	r4, 80086ea <prvEthernetUpdateConfig+0x2a>
 80086de:	4b47      	ldr	r3, [pc, #284]	; (80087fc <prvEthernetUpdateConfig+0x13c>)
 80086e0:	681b      	ldr	r3, [r3, #0]
 80086e2:	f013 0f04 	tst.w	r3, #4
 80086e6:	f000 8085 	beq.w	80087f4 <prvEthernetUpdateConfig+0x134>
	{
		/* Restart the auto-negotiation. */
		if( xETH.Init.AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE )
 80086ea:	4b46      	ldr	r3, [pc, #280]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80086ec:	685b      	ldr	r3, [r3, #4]
 80086ee:	2b00      	cmp	r3, #0
 80086f0:	d064      	beq.n	80087bc <prvEthernetUpdateConfig+0xfc>
		{
			/* Enable Auto-Negotiation. */
			HAL_ETH_WritePHYRegister( &xETH, PHY_BCR, ulBCRvalue | BMCR_ANRESTART );
 80086f2:	4b45      	ldr	r3, [pc, #276]	; (8008808 <prvEthernetUpdateConfig+0x148>)
 80086f4:	681a      	ldr	r2, [r3, #0]
 80086f6:	4c43      	ldr	r4, [pc, #268]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80086f8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80086fc:	2100      	movs	r1, #0
 80086fe:	4620      	mov	r0, r4
 8008700:	f7f9 fca4 	bl	800204c <HAL_ETH_WritePHYRegister>
			HAL_ETH_WritePHYRegister( &xETH, PHY_REG_04_ADVERTISE, ulACRValue);
 8008704:	4b41      	ldr	r3, [pc, #260]	; (800880c <prvEthernetUpdateConfig+0x14c>)
 8008706:	681a      	ldr	r2, [r3, #0]
 8008708:	2104      	movs	r1, #4
 800870a:	4620      	mov	r0, r4
 800870c:	f7f9 fc9e 	bl	800204c <HAL_ETH_WritePHYRegister>
			/* Wait until the auto-negotiation will be completed */
			do
			{
				ulTimeout++;
				HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &ulRegValue );
			} while( ( ( ulRegValue & PHY_AUTONEGO_COMPLETE) == 0 ) && ( ulTimeout < PHY_READ_TO ) );
 8008710:	4d3f      	ldr	r5, [pc, #252]	; (8008810 <prvEthernetUpdateConfig+0x150>)
				ulTimeout++;
 8008712:	9b03      	ldr	r3, [sp, #12]
 8008714:	3301      	adds	r3, #1
 8008716:	9303      	str	r3, [sp, #12]
				HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &ulRegValue );
 8008718:	aa02      	add	r2, sp, #8
 800871a:	2101      	movs	r1, #1
 800871c:	4620      	mov	r0, r4
 800871e:	f7f9 fc47 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
			} while( ( ( ulRegValue & PHY_AUTONEGO_COMPLETE) == 0 ) && ( ulTimeout < PHY_READ_TO ) );
 8008722:	9b02      	ldr	r3, [sp, #8]
 8008724:	f013 0f20 	tst.w	r3, #32
 8008728:	d102      	bne.n	8008730 <prvEthernetUpdateConfig+0x70>
 800872a:	9b03      	ldr	r3, [sp, #12]
 800872c:	42ab      	cmp	r3, r5
 800872e:	d9f0      	bls.n	8008712 <prvEthernetUpdateConfig+0x52>

			HAL_ETH_WritePHYRegister( &xETH, PHY_BCR, ulBCRvalue & ~BMCR_ANRESTART );
 8008730:	4b35      	ldr	r3, [pc, #212]	; (8008808 <prvEthernetUpdateConfig+0x148>)
 8008732:	681a      	ldr	r2, [r3, #0]
 8008734:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8008738:	2100      	movs	r1, #0
 800873a:	4832      	ldr	r0, [pc, #200]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 800873c:	f7f9 fc86 	bl	800204c <HAL_ETH_WritePHYRegister>

			if( ulTimeout < PHY_READ_TO )
 8008740:	9a03      	ldr	r2, [sp, #12]
 8008742:	4b33      	ldr	r3, [pc, #204]	; (8008810 <prvEthernetUpdateConfig+0x150>)
 8008744:	429a      	cmp	r2, r3
 8008746:	d843      	bhi.n	80087d0 <prvEthernetUpdateConfig+0x110>
			{
				/* Reset Timeout counter. */
				ulTimeout = 0;
 8008748:	2300      	movs	r3, #0
 800874a:	9303      	str	r3, [sp, #12]

				/* Read the result of the auto-negotiation. */
				HAL_ETH_ReadPHYRegister( &xETH, PHY_SR, &ulRegValue);
 800874c:	aa02      	add	r2, sp, #8
 800874e:	2110      	movs	r1, #16
 8008750:	482c      	ldr	r0, [pc, #176]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 8008752:	f7f9 fc2d 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
				if( ( ulRegValue & PHY_LINK_STATUS ) != 0 )
 8008756:	9902      	ldr	r1, [sp, #8]
 8008758:	f011 0501 	ands.w	r5, r1, #1
				{
					ulPHYLinkStatus |= BMSR_LINK_STATUS;
 800875c:	4a27      	ldr	r2, [pc, #156]	; (80087fc <prvEthernetUpdateConfig+0x13c>)
 800875e:	6813      	ldr	r3, [r2, #0]
 8008760:	bf14      	ite	ne
 8008762:	f043 0304 	orrne.w	r3, r3, #4
				}
				else
				{
					ulPHYLinkStatus &= ~( BMSR_LINK_STATUS );
 8008766:	f023 0304 	biceq.w	r3, r3, #4
 800876a:	6013      	str	r3, [r2, #0]
				}

				FreeRTOS_printf( ( ">> Autonego ready: %08x: %s duplex %u mbit %s status\n",
 800876c:	f001 0404 	and.w	r4, r1, #4
 8008770:	f001 0302 	and.w	r3, r1, #2
 8008774:	2b00      	cmp	r3, #0
 8008776:	bf14      	ite	ne
 8008778:	230a      	movne	r3, #10
 800877a:	2364      	moveq	r3, #100	; 0x64
 800877c:	4a25      	ldr	r2, [pc, #148]	; (8008814 <prvEthernetUpdateConfig+0x154>)
 800877e:	4826      	ldr	r0, [pc, #152]	; (8008818 <prvEthernetUpdateConfig+0x158>)
 8008780:	2d00      	cmp	r5, #0
 8008782:	bf08      	it	eq
 8008784:	4610      	moveq	r0, r2
 8008786:	9000      	str	r0, [sp, #0]
 8008788:	4824      	ldr	r0, [pc, #144]	; (800881c <prvEthernetUpdateConfig+0x15c>)
 800878a:	4a25      	ldr	r2, [pc, #148]	; (8008820 <prvEthernetUpdateConfig+0x160>)
 800878c:	2c00      	cmp	r4, #0
 800878e:	bf08      	it	eq
 8008790:	4602      	moveq	r2, r0
 8008792:	4824      	ldr	r0, [pc, #144]	; (8008824 <prvEthernetUpdateConfig+0x164>)
 8008794:	f003 f958 	bl	800ba48 <lUDPLoggingPrintf>
					(ulRegValue & PHY_SPEED_STATUS) ? 10 : 100,
					(ulRegValue & PHY_LINK_STATUS) ? "high" : "low" ) );

				/* Configure the MAC with the Duplex Mode fixed by the
				auto-negotiation process. */
				if( ( ulRegValue & PHY_DUPLEX_STATUS ) != ( uint32_t ) RESET )
 8008798:	9b02      	ldr	r3, [sp, #8]
 800879a:	f013 0f04 	tst.w	r3, #4
				{
					/* Set Ethernet duplex mode to Full-duplex following the
					auto-negotiation. */
					xETH.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 800879e:	bf14      	ite	ne
 80087a0:	f44f 6100 	movne.w	r1, #2048	; 0x800
				}
				else
				{
					/* Set Ethernet duplex mode to Half-duplex following the
					auto-negotiation. */
					xETH.Init.DuplexMode = ETH_MODE_HALFDUPLEX;
 80087a4:	2100      	moveq	r1, #0
 80087a6:	4a17      	ldr	r2, [pc, #92]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80087a8:	60d1      	str	r1, [r2, #12]
				}

				/* Configure the MAC with the speed fixed by the
				auto-negotiation process. */
				if( ( ulRegValue & PHY_SPEED_STATUS) != 0 )
 80087aa:	f013 0f02 	tst.w	r3, #2
				{
					/* Set Ethernet speed to 10M following the
					auto-negotiation. */
					xETH.Init.Speed = ETH_SPEED_10M;
 80087ae:	bf14      	ite	ne
 80087b0:	2200      	movne	r2, #0
				}
				else
				{
					/* Set Ethernet speed to 100M following the
					auto-negotiation. */
					xETH.Init.Speed = ETH_SPEED_100M;
 80087b2:	f44f 4280 	moveq.w	r2, #16384	; 0x4000
 80087b6:	4b13      	ldr	r3, [pc, #76]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80087b8:	609a      	str	r2, [r3, #8]
 80087ba:	e009      	b.n	80087d0 <prvEthernetUpdateConfig+0x110>
			/* Check parameters */
			assert_param( IS_ETH_SPEED( xETH.Init.Speed ) );
			assert_param( IS_ETH_DUPLEX_MODE( xETH.Init.DuplexMode ) );

			/* Set MAC Speed and Duplex Mode to PHY */
			usValue = ( uint16_t ) ( xETH.Init.DuplexMode >> 3 ) | ( uint16_t ) ( xETH.Init.Speed >> 1 );
 80087bc:	4811      	ldr	r0, [pc, #68]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80087be:	68c2      	ldr	r2, [r0, #12]
 80087c0:	6883      	ldr	r3, [r0, #8]
 80087c2:	085b      	lsrs	r3, r3, #1
 80087c4:	ea43 02d2 	orr.w	r2, r3, r2, lsr #3
			HAL_ETH_WritePHYRegister( &xETH, PHY_BCR, usValue );
 80087c8:	b292      	uxth	r2, r2
 80087ca:	2100      	movs	r1, #0
 80087cc:	f7f9 fc3e 	bl	800204c <HAL_ETH_WritePHYRegister>
		}

		/* ETHERNET MAC Re-Configuration */
		HAL_ETH_ConfigMAC( &xETH, (ETH_MACInitTypeDef *) NULL);
 80087d0:	4c0c      	ldr	r4, [pc, #48]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80087d2:	2100      	movs	r1, #0
 80087d4:	4620      	mov	r0, r4
 80087d6:	f7f9 fcff 	bl	80021d8 <HAL_ETH_ConfigMAC>

		/* Restart MAC interface */
		HAL_ETH_Start( &xETH);
 80087da:	4620      	mov	r0, r4
 80087dc:	f7f9 fc84 	bl	80020e8 <HAL_ETH_Start>

		FreeRTOS_printf( ( "MACCR = %08x DMABMR = %08x\n",
 80087e0:	6823      	ldr	r3, [r4, #0]
 80087e2:	6819      	ldr	r1, [r3, #0]
 80087e4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80087e8:	681a      	ldr	r2, [r3, #0]
 80087ea:	480f      	ldr	r0, [pc, #60]	; (8008828 <prvEthernetUpdateConfig+0x168>)
 80087ec:	f003 f92c 	bl	800ba48 <lUDPLoggingPrintf>
	else
	{
		/* Stop MAC interface */
		HAL_ETH_Stop( &xETH );
	}
}
 80087f0:	b005      	add	sp, #20
 80087f2:	bd30      	pop	{r4, r5, pc}
		HAL_ETH_Stop( &xETH );
 80087f4:	4803      	ldr	r0, [pc, #12]	; (8008804 <prvEthernetUpdateConfig+0x144>)
 80087f6:	f7f9 fcb3 	bl	8002160 <HAL_ETH_Stop>
}
 80087fa:	e7f9      	b.n	80087f0 <prvEthernetUpdateConfig+0x130>
 80087fc:	2000093c 	.word	0x2000093c
 8008800:	0800cec8 	.word	0x0800cec8
 8008804:	20000944 	.word	0x20000944
 8008808:	20000934 	.word	0x20000934
 800880c:	20000930 	.word	0x20000930
 8008810:	0004fffe 	.word	0x0004fffe
 8008814:	0800cec4 	.word	0x0800cec4
 8008818:	0800cebc 	.word	0x0800cebc
 800881c:	0800ceb4 	.word	0x0800ceb4
 8008820:	0800ceac 	.word	0x0800ceac
 8008824:	0800cef4 	.word	0x0800cef4
 8008828:	0800cf2c 	.word	0x0800cf2c

0800882c <prvEMACHandlerTask>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvEMACHandlerTask( void *pvParameters )
{
 800882c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008830:	b085      	sub	sp, #20
const TickType_t ulMaxBlockTime = pdMS_TO_TICKS( 100UL );

	/* Remove compiler warnings about unused parameters. */
	( void ) pvParameters;

	vTaskSetTimeOutState( &xPhyTime );
 8008832:	a802      	add	r0, sp, #8
 8008834:	f001 fef0 	bl	800a618 <vTaskSetTimeOutState>
	xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
 8008838:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800883c:	9301      	str	r3, [sp, #4]
BaseType_t xResult = 0;
 800883e:	2600      	movs	r6, #0
UBaseType_t uxLastMinBufferCount = 0;
 8008840:	4637      	mov	r7, r6
		if( uxLastMinBufferCount != uxCurrentCount )
		{
			/* The logging produced below may be helpful
			while tuning +TCP: see how many buffers are in use. */
			uxLastMinBufferCount = uxCurrentCount;
			FreeRTOS_printf( ( "Network buffers: %lu lowest %lu\n",
 8008842:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 8008930 <prvEMACHandlerTask+0x104>
				FreeRTOS_printf( ( "Queue space: lowest %lu\n", uxCurrentCount ) );
			}
		}
		#endif /* ipconfigCHECK_IP_QUEUE_SPACE */

		if( ( ulISREvents & EMAC_IF_ALL_EVENT ) == 0 )
 8008846:	4c37      	ldr	r4, [pc, #220]	; (8008924 <prvEMACHandlerTask+0xf8>)
			xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
			xResult = 0;
		}
		else if( xTaskCheckForTimeOut( &xPhyTime, &xPhyRemTime ) != pdFALSE )
		{
			HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &xStatus );
 8008848:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 8008934 <prvEMACHandlerTask+0x108>
 800884c:	e01e      	b.n	800888c <prvEMACHandlerTask+0x60>
			ulTaskNotifyTake( pdFALSE, ulMaxBlockTime );
 800884e:	2164      	movs	r1, #100	; 0x64
 8008850:	2000      	movs	r0, #0
 8008852:	f002 f9cb 	bl	800abec <ulTaskNotifyTake>
 8008856:	e029      	b.n	80088ac <prvEMACHandlerTask+0x80>
		if( ( ulISREvents & EMAC_IF_TX_EVENT ) != 0 )
 8008858:	6823      	ldr	r3, [r4, #0]
 800885a:	f013 0f02 	tst.w	r3, #2
 800885e:	d003      	beq.n	8008868 <prvEMACHandlerTask+0x3c>
			ulISREvents &= ~EMAC_IF_TX_EVENT;
 8008860:	6823      	ldr	r3, [r4, #0]
 8008862:	f023 0302 	bic.w	r3, r3, #2
 8008866:	6023      	str	r3, [r4, #0]
		if( ( ulISREvents & EMAC_IF_ERR_EVENT ) != 0 )
 8008868:	6823      	ldr	r3, [r4, #0]
 800886a:	f013 0f04 	tst.w	r3, #4
 800886e:	d003      	beq.n	8008878 <prvEMACHandlerTask+0x4c>
			ulISREvents &= ~EMAC_IF_ERR_EVENT;
 8008870:	6823      	ldr	r3, [r4, #0]
 8008872:	f023 0304 	bic.w	r3, r3, #4
 8008876:	6023      	str	r3, [r4, #0]
		if( xResult > 0 )
 8008878:	2e00      	cmp	r6, #0
 800887a:	dd28      	ble.n	80088ce <prvEMACHandlerTask+0xa2>
			vTaskSetTimeOutState( &xPhyTime );
 800887c:	a802      	add	r0, sp, #8
 800887e:	f001 fecb 	bl	800a618 <vTaskSetTimeOutState>
			xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
 8008882:	f643 2398 	movw	r3, #15000	; 0x3a98
 8008886:	9301      	str	r3, [sp, #4]
			xResult = 0;
 8008888:	2600      	movs	r6, #0
 800888a:	462f      	mov	r7, r5
		uxCurrentCount = uxGetMinimumFreeNetworkBuffers();
 800888c:	f7ff feaa 	bl	80085e4 <uxGetMinimumFreeNetworkBuffers>
 8008890:	4605      	mov	r5, r0
		if( uxLastMinBufferCount != uxCurrentCount )
 8008892:	4287      	cmp	r7, r0
 8008894:	d006      	beq.n	80088a4 <prvEMACHandlerTask+0x78>
			FreeRTOS_printf( ( "Network buffers: %lu lowest %lu\n",
 8008896:	f7ff fe9f 	bl	80085d8 <uxGetNumberOfFreeNetworkBuffers>
 800889a:	462a      	mov	r2, r5
 800889c:	4601      	mov	r1, r0
 800889e:	4640      	mov	r0, r8
 80088a0:	f003 f8d2 	bl	800ba48 <lUDPLoggingPrintf>
		if( ( ulISREvents & EMAC_IF_ALL_EVENT ) == 0 )
 80088a4:	6823      	ldr	r3, [r4, #0]
 80088a6:	f013 0f07 	tst.w	r3, #7
 80088aa:	d0d0      	beq.n	800884e <prvEMACHandlerTask+0x22>
		if( ( ulISREvents & EMAC_IF_RX_EVENT ) != 0 )
 80088ac:	6823      	ldr	r3, [r4, #0]
 80088ae:	f013 0f01 	tst.w	r3, #1
 80088b2:	d0d1      	beq.n	8008858 <prvEMACHandlerTask+0x2c>
			ulISREvents &= ~EMAC_IF_RX_EVENT;
 80088b4:	6823      	ldr	r3, [r4, #0]
 80088b6:	f023 0301 	bic.w	r3, r3, #1
 80088ba:	6023      	str	r3, [r4, #0]
			xResult = prvNetworkInterfaceInput();
 80088bc:	f7ff fe98 	bl	80085f0 <prvNetworkInterfaceInput>
			if( xResult > 0 )
 80088c0:	1e06      	subs	r6, r0, #0
 80088c2:	ddc9      	ble.n	8008858 <prvEMACHandlerTask+0x2c>
			  	while( prvNetworkInterfaceInput() > 0 )
 80088c4:	f7ff fe94 	bl	80085f0 <prvNetworkInterfaceInput>
 80088c8:	2800      	cmp	r0, #0
 80088ca:	dcfb      	bgt.n	80088c4 <prvEMACHandlerTask+0x98>
 80088cc:	e7c4      	b.n	8008858 <prvEMACHandlerTask+0x2c>
		else if( xTaskCheckForTimeOut( &xPhyTime, &xPhyRemTime ) != pdFALSE )
 80088ce:	a901      	add	r1, sp, #4
 80088d0:	a802      	add	r0, sp, #8
 80088d2:	f001 feb7 	bl	800a644 <xTaskCheckForTimeOut>
 80088d6:	2800      	cmp	r0, #0
 80088d8:	d0d7      	beq.n	800888a <prvEMACHandlerTask+0x5e>
			HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &xStatus );
 80088da:	466a      	mov	r2, sp
 80088dc:	2101      	movs	r1, #1
 80088de:	4648      	mov	r0, r9
 80088e0:	f7f9 fb66 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != ( xStatus & BMSR_LINK_STATUS ) )
 80088e4:	9900      	ldr	r1, [sp, #0]
 80088e6:	4b10      	ldr	r3, [pc, #64]	; (8008928 <prvEMACHandlerTask+0xfc>)
 80088e8:	681b      	ldr	r3, [r3, #0]
 80088ea:	404b      	eors	r3, r1
 80088ec:	f013 0f04 	tst.w	r3, #4
 80088f0:	d10d      	bne.n	800890e <prvEMACHandlerTask+0xe2>
				ulPHYLinkStatus = xStatus;
				FreeRTOS_printf( ( "prvEMACHandlerTask: PHY LS now %d\n", ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) );
				prvEthernetUpdateConfig( pdFALSE );
			}

			vTaskSetTimeOutState( &xPhyTime );
 80088f2:	a802      	add	r0, sp, #8
 80088f4:	f001 fe90 	bl	800a618 <vTaskSetTimeOutState>
			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 80088f8:	4b0b      	ldr	r3, [pc, #44]	; (8008928 <prvEMACHandlerTask+0xfc>)
 80088fa:	681b      	ldr	r3, [r3, #0]
 80088fc:	f013 0f04 	tst.w	r3, #4
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
 8008900:	bf14      	ite	ne
 8008902:	f643 2398 	movwne	r3, #15000	; 0x3a98
			}
			else
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
 8008906:	f44f 737a 	moveq.w	r3, #1000	; 0x3e8
 800890a:	9301      	str	r3, [sp, #4]
 800890c:	e7bd      	b.n	800888a <prvEMACHandlerTask+0x5e>
				ulPHYLinkStatus = xStatus;
 800890e:	4b06      	ldr	r3, [pc, #24]	; (8008928 <prvEMACHandlerTask+0xfc>)
 8008910:	6019      	str	r1, [r3, #0]
				FreeRTOS_printf( ( "prvEMACHandlerTask: PHY LS now %d\n", ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) );
 8008912:	f3c1 0180 	ubfx	r1, r1, #2, #1
 8008916:	4805      	ldr	r0, [pc, #20]	; (800892c <prvEMACHandlerTask+0x100>)
 8008918:	f003 f896 	bl	800ba48 <lUDPLoggingPrintf>
				prvEthernetUpdateConfig( pdFALSE );
 800891c:	2000      	movs	r0, #0
 800891e:	f7ff fecf 	bl	80086c0 <prvEthernetUpdateConfig>
 8008922:	e7e6      	b.n	80088f2 <prvEMACHandlerTask+0xc6>
 8008924:	20000938 	.word	0x20000938
 8008928:	2000093c 	.word	0x2000093c
 800892c:	0800ce88 	.word	0x0800ce88
 8008930:	0800ce64 	.word	0x0800ce64
 8008934:	20000944 	.word	0x20000944

08008938 <HAL_ETH_RxCpltCallback>:
{
 8008938:	b500      	push	{lr}
 800893a:	b083      	sub	sp, #12
BaseType_t xHigherPriorityTaskWoken = 0;
 800893c:	2300      	movs	r3, #0
 800893e:	9301      	str	r3, [sp, #4]
    ulISREvents |= EMAC_IF_RX_EVENT;
 8008940:	4a0b      	ldr	r2, [pc, #44]	; (8008970 <HAL_ETH_RxCpltCallback+0x38>)
 8008942:	6813      	ldr	r3, [r2, #0]
 8008944:	f043 0301 	orr.w	r3, r3, #1
 8008948:	6013      	str	r3, [r2, #0]
	if( xEMACTaskHandle != NULL )
 800894a:	4b0a      	ldr	r3, [pc, #40]	; (8008974 <HAL_ETH_RxCpltCallback+0x3c>)
 800894c:	6818      	ldr	r0, [r3, #0]
 800894e:	b160      	cbz	r0, 800896a <HAL_ETH_RxCpltCallback+0x32>
		vTaskNotifyGiveFromISR( xEMACTaskHandle, &xHigherPriorityTaskWoken );
 8008950:	a901      	add	r1, sp, #4
 8008952:	f002 f9f1 	bl	800ad38 <vTaskNotifyGiveFromISR>
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8008956:	9b01      	ldr	r3, [sp, #4]
 8008958:	b13b      	cbz	r3, 800896a <HAL_ETH_RxCpltCallback+0x32>
 800895a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800895e:	4b06      	ldr	r3, [pc, #24]	; (8008978 <HAL_ETH_RxCpltCallback+0x40>)
 8008960:	601a      	str	r2, [r3, #0]
 8008962:	f3bf 8f4f 	dsb	sy
 8008966:	f3bf 8f6f 	isb	sy
}
 800896a:	b003      	add	sp, #12
 800896c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008970:	20000938 	.word	0x20000938
 8008974:	20000940 	.word	0x20000940
 8008978:	e000ed04 	.word	0xe000ed04

0800897c <HAL_ETH_TxCpltCallback>:
{
 800897c:	4770      	bx	lr
	...

08008980 <xNetworkInterfaceInitialise>:
	if( xEMACTaskHandle == NULL )
 8008980:	4b26      	ldr	r3, [pc, #152]	; (8008a1c <xNetworkInterfaceInitialise+0x9c>)
 8008982:	681b      	ldr	r3, [r3, #0]
 8008984:	b123      	cbz	r3, 8008990 <xNetworkInterfaceInitialise+0x10>
	return ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0;
 8008986:	4b26      	ldr	r3, [pc, #152]	; (8008a20 <xNetworkInterfaceInitialise+0xa0>)
 8008988:	6818      	ldr	r0, [r3, #0]
}
 800898a:	f3c0 0080 	ubfx	r0, r0, #2, #1
 800898e:	4770      	bx	lr
{
 8008990:	b570      	push	{r4, r5, r6, lr}
 8008992:	b082      	sub	sp, #8
		xETH.Instance = ETH;
 8008994:	4c23      	ldr	r4, [pc, #140]	; (8008a24 <xNetworkInterfaceInitialise+0xa4>)
 8008996:	4b24      	ldr	r3, [pc, #144]	; (8008a28 <xNetworkInterfaceInitialise+0xa8>)
 8008998:	6023      	str	r3, [r4, #0]
		xETH.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 800899a:	2501      	movs	r5, #1
 800899c:	6065      	str	r5, [r4, #4]
		xETH.Init.Speed = ETH_SPEED_100M;
 800899e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80089a2:	60a3      	str	r3, [r4, #8]
		xETH.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 80089a4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80089a8:	60e3      	str	r3, [r4, #12]
		xETH.Init.PhyAddress = 1;
 80089aa:	8225      	strh	r5, [r4, #16]
		xETH.Init.MACAddr = ( uint8_t *) ucMACAddress;
 80089ac:	4b1f      	ldr	r3, [pc, #124]	; (8008a2c <xNetworkInterfaceInitialise+0xac>)
 80089ae:	6163      	str	r3, [r4, #20]
		xETH.Init.RxMode = ETH_RXINTERRUPT_MODE;
 80089b0:	61a5      	str	r5, [r4, #24]
		xETH.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 80089b2:	2600      	movs	r6, #0
 80089b4:	61e6      	str	r6, [r4, #28]
		xETH.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 80089b6:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 80089ba:	6223      	str	r3, [r4, #32]
		hal_eth_init_status = HAL_ETH_Init( &xETH ); //调用库函数
 80089bc:	4620      	mov	r0, r4
 80089be:	f7f9 f917 	bl	8001bf0 <HAL_ETH_Init>
		__HAL_ETH_DMA_ENABLE_IT( &xETH , ETH_DMA_ALL_INTS );
 80089c2:	6821      	ldr	r1, [r4, #0]
 80089c4:	f241 021c 	movw	r2, #4124	; 0x101c
 80089c8:	5888      	ldr	r0, [r1, r2]
 80089ca:	4b19      	ldr	r3, [pc, #100]	; (8008a30 <xNetworkInterfaceInitialise+0xb0>)
 80089cc:	4303      	orrs	r3, r0
 80089ce:	508b      	str	r3, [r1, r2]
		HAL_ETH_DMATxDescListInit( &xETH, DMATxDscrTab, Tx_Buff[ 0 ], ETH_TXBUFNB );
 80089d0:	2302      	movs	r3, #2
 80089d2:	4a18      	ldr	r2, [pc, #96]	; (8008a34 <xNetworkInterfaceInitialise+0xb4>)
 80089d4:	4918      	ldr	r1, [pc, #96]	; (8008a38 <xNetworkInterfaceInitialise+0xb8>)
 80089d6:	4620      	mov	r0, r4
 80089d8:	f7f9 f88d 	bl	8001af6 <HAL_ETH_DMATxDescListInit>
		HAL_ETH_DMARxDescListInit( &xETH, DMARxDscrTab, Rx_Buff[ 0 ], ETH_RXBUFNB );
 80089dc:	2304      	movs	r3, #4
 80089de:	4a17      	ldr	r2, [pc, #92]	; (8008a3c <xNetworkInterfaceInitialise+0xbc>)
 80089e0:	4917      	ldr	r1, [pc, #92]	; (8008a40 <xNetworkInterfaceInitialise+0xc0>)
 80089e2:	4620      	mov	r0, r4
 80089e4:	f7f9 f8ca 	bl	8001b7c <HAL_ETH_DMARxDescListInit>
	( *(__IO uint32_t *)( ( uint32_t ) ( ETH_MAC_ADDR_HBASE + ulIndex ) ) ) = ulTempReg;
 80089e8:	4a16      	ldr	r2, [pc, #88]	; (8008a44 <xNetworkInterfaceInitialise+0xc4>)
 80089ea:	4b17      	ldr	r3, [pc, #92]	; (8008a48 <xNetworkInterfaceInitialise+0xc8>)
 80089ec:	601a      	str	r2, [r3, #0]
	( *(__IO uint32_t *) ( ( uint32_t ) ( ETH_MAC_ADDR_LBASE + ulIndex ) ) ) = ulTempReg;
 80089ee:	4a17      	ldr	r2, [pc, #92]	; (8008a4c <xNetworkInterfaceInitialise+0xcc>)
 80089f0:	3304      	adds	r3, #4
 80089f2:	601a      	str	r2, [r3, #0]
		prvEthernetUpdateConfig( pdTRUE );
 80089f4:	4628      	mov	r0, r5
 80089f6:	f7ff fe63 	bl	80086c0 <prvEthernetUpdateConfig>
		xTaskCreate( prvEMACHandlerTask, "EMAC", configEMAC_TASK_STACK_SIZE, NULL, configMAX_PRIORITIES - 1, &xEMACTaskHandle );
 80089fa:	4b08      	ldr	r3, [pc, #32]	; (8008a1c <xNetworkInterfaceInitialise+0x9c>)
 80089fc:	9301      	str	r3, [sp, #4]
 80089fe:	2306      	movs	r3, #6
 8008a00:	9300      	str	r3, [sp, #0]
 8008a02:	4633      	mov	r3, r6
 8008a04:	f44f 7280 	mov.w	r2, #256	; 0x100
 8008a08:	4911      	ldr	r1, [pc, #68]	; (8008a50 <xNetworkInterfaceInitialise+0xd0>)
 8008a0a:	4812      	ldr	r0, [pc, #72]	; (8008a54 <xNetworkInterfaceInitialise+0xd4>)
 8008a0c:	f001 f932 	bl	8009c74 <xTaskCreate>
	return ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0;
 8008a10:	4b03      	ldr	r3, [pc, #12]	; (8008a20 <xNetworkInterfaceInitialise+0xa0>)
 8008a12:	6818      	ldr	r0, [r3, #0]
}
 8008a14:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8008a18:	b002      	add	sp, #8
 8008a1a:	bd70      	pop	{r4, r5, r6, pc}
 8008a1c:	20000940 	.word	0x20000940
 8008a20:	2000093c 	.word	0x2000093c
 8008a24:	20000944 	.word	0x20000944
 8008a28:	40028000 	.word	0x40028000
 8008a2c:	0800dcdc 	.word	0x0800dcdc
 8008a30:	3801e7fb 	.word	0x3801e7fb
 8008a34:	200040f4 	.word	0x200040f4
 8008a38:	20002864 	.word	0x20002864
 8008a3c:	200028a4 	.word	0x200028a4
 8008a40:	20004074 	.word	0x20004074
 8008a44:	8000fc00 	.word	0x8000fc00
 8008a48:	40028048 	.word	0x40028048
 8008a4c:	005e0001 	.word	0x005e0001
 8008a50:	0800d014 	.word	0x0800d014
 8008a54:	0800882d 	.word	0x0800882d

08008a58 <xNetworkInterfaceOutput>:
{
 8008a58:	b570      	push	{r4, r5, r6, lr}
 8008a5a:	4604      	mov	r4, r0
 8008a5c:	460e      	mov	r6, r1
		pxPacket = ( ProtocolPacket_t * ) ( pxDescriptor->pucEthernetBuffer );
 8008a5e:	6983      	ldr	r3, [r0, #24]
		if( pxPacket->xICMPPacket.xIPHeader.ucProtocol == ipPROTOCOL_ICMP )
 8008a60:	7dda      	ldrb	r2, [r3, #23]
 8008a62:	2a01      	cmp	r2, #1
 8008a64:	d01e      	beq.n	8008aa4 <xNetworkInterfaceOutput+0x4c>
	if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 8008a66:	4b17      	ldr	r3, [pc, #92]	; (8008ac4 <xNetworkInterfaceOutput+0x6c>)
 8008a68:	681b      	ldr	r3, [r3, #0]
 8008a6a:	f013 0f04 	tst.w	r3, #4
 8008a6e:	d01f      	beq.n	8008ab0 <xNetworkInterfaceOutput+0x58>
		pxDmaTxDesc = xETH.TxDesc;
 8008a70:	4b15      	ldr	r3, [pc, #84]	; (8008ac8 <xNetworkInterfaceOutput+0x70>)
 8008a72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		if( ( pxDmaTxDesc->Status & ETH_DMATXDESC_OWN ) != 0 )
 8008a74:	681a      	ldr	r2, [r3, #0]
 8008a76:	2a00      	cmp	r2, #0
 8008a78:	db1e      	blt.n	8008ab8 <xNetworkInterfaceOutput+0x60>
			ulTransmitSize = pxDescriptor->xDataLength;
 8008a7a:	69e5      	ldr	r5, [r4, #28]
 8008a7c:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8008a80:	4295      	cmp	r5, r2
 8008a82:	bf28      	it	cs
 8008a84:	4615      	movcs	r5, r2
			memcpy( ( void * ) pxDmaTxDesc->Buffer1Addr, pxDescriptor->pucEthernetBuffer, ulTransmitSize );
 8008a86:	6898      	ldr	r0, [r3, #8]
 8008a88:	462a      	mov	r2, r5
 8008a8a:	69a1      	ldr	r1, [r4, #24]
 8008a8c:	f003 fe23 	bl	800c6d6 <memcpy>
			HAL_ETH_TransmitFrame( &xETH, ulTransmitSize );
 8008a90:	4629      	mov	r1, r5
 8008a92:	480d      	ldr	r0, [pc, #52]	; (8008ac8 <xNetworkInterfaceOutput+0x70>)
 8008a94:	f7f9 f99c 	bl	8001dd0 <HAL_ETH_TransmitFrame>
			iptraceNETWORK_INTERFACE_TRANSMIT();
 8008a98:	2100      	movs	r1, #0
 8008a9a:	2001      	movs	r0, #1
 8008a9c:	f002 fed8 	bl	800b850 <vExampleDebugStatUpdate>
			xReturn = pdPASS;
 8008aa0:	2501      	movs	r5, #1
 8008aa2:	e006      	b.n	8008ab2 <xNetworkInterfaceOutput+0x5a>
			pxPacket->xICMPPacket.xICMPHeader.usChecksum = ( uint16_t )0u;
 8008aa4:	2200      	movs	r2, #0
 8008aa6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8008aaa:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8008aae:	e7da      	b.n	8008a66 <xNetworkInterfaceOutput+0xe>
		xReturn = pdFAIL;
 8008ab0:	2500      	movs	r5, #0
		if( bReleaseAfterSend != pdFALSE )
 8008ab2:	b91e      	cbnz	r6, 8008abc <xNetworkInterfaceOutput+0x64>
}
 8008ab4:	4628      	mov	r0, r5
 8008ab6:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdFAIL;
 8008ab8:	2500      	movs	r5, #0
 8008aba:	e7fa      	b.n	8008ab2 <xNetworkInterfaceOutput+0x5a>
			vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 8008abc:	4620      	mov	r0, r4
 8008abe:	f7ff fd09 	bl	80084d4 <vReleaseNetworkBufferAndDescriptor>
	return xReturn;
 8008ac2:	e7f7      	b.n	8008ab4 <xNetworkInterfaceOutput+0x5c>
 8008ac4:	2000093c 	.word	0x2000093c
 8008ac8:	20000944 	.word	0x20000944

08008acc <vMACBProbePhy>:
{
 8008acc:	b530      	push	{r4, r5, lr}
 8008ace:	b089      	sub	sp, #36	; 0x24
TickType_t xRemTime = 0;
 8008ad0:	2500      	movs	r5, #0
 8008ad2:	9500      	str	r5, [sp, #0]
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_03_PHYSID2, &ulLower);
 8008ad4:	4c3d      	ldr	r4, [pc, #244]	; (8008bcc <vMACBProbePhy+0x100>)
 8008ad6:	aa05      	add	r2, sp, #20
 8008ad8:	2103      	movs	r1, #3
 8008ada:	4620      	mov	r0, r4
 8008adc:	f7f9 fa68 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_02_PHYSID1, &ulUpper);
 8008ae0:	aa04      	add	r2, sp, #16
 8008ae2:	2102      	movs	r1, #2
 8008ae4:	4620      	mov	r0, r4
 8008ae6:	f7f9 fa63 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	ulMACPhyID = ( ( ulUpper << 16 ) & 0xFFFF0000 ) | ( ulLower & 0xFFF0 );
 8008aea:	9905      	ldr	r1, [sp, #20]
 8008aec:	f021 010f 	bic.w	r1, r1, #15
 8008af0:	0409      	lsls	r1, r1, #16
 8008af2:	0c09      	lsrs	r1, r1, #16
	FreeRTOS_printf( ( "PHY ID %X\n", ulMACPhyID ) );
 8008af4:	9b04      	ldr	r3, [sp, #16]
 8008af6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8008afa:	4835      	ldr	r0, [pc, #212]	; (8008bd0 <vMACBProbePhy+0x104>)
 8008afc:	f002 ffa4 	bl	800ba48 <lUDPLoggingPrintf>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_00_BMCR, &ulConfig);
 8008b00:	aa06      	add	r2, sp, #24
 8008b02:	4629      	mov	r1, r5
 8008b04:	4620      	mov	r0, r4
 8008b06:	f7f9 fa53 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulConfig | BMCR_RESET );
 8008b0a:	9a06      	ldr	r2, [sp, #24]
 8008b0c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8008b10:	4629      	mov	r1, r5
 8008b12:	4620      	mov	r0, r4
 8008b14:	f7f9 fa9a 	bl	800204c <HAL_ETH_WritePHYRegister>
	xRemTime = ( TickType_t ) pdMS_TO_TICKS( 1000UL );
 8008b18:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008b1c:	9300      	str	r3, [sp, #0]
	vTaskSetTimeOutState( &xPhyTime );
 8008b1e:	a801      	add	r0, sp, #4
 8008b20:	f001 fd7a 	bl	800a618 <vTaskSetTimeOutState>
		HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_00_BMCR, &ulValue);
 8008b24:	4625      	mov	r5, r4
 8008b26:	2400      	movs	r4, #0
 8008b28:	aa03      	add	r2, sp, #12
 8008b2a:	4621      	mov	r1, r4
 8008b2c:	4628      	mov	r0, r5
 8008b2e:	f7f9 fa3f 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
		if( ( ulValue & BMCR_RESET ) == 0 )
 8008b32:	9b03      	ldr	r3, [sp, #12]
 8008b34:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8008b38:	d009      	beq.n	8008b4e <vMACBProbePhy+0x82>
		if( xTaskCheckForTimeOut( &xPhyTime, &xRemTime ) != pdFALSE )
 8008b3a:	4669      	mov	r1, sp
 8008b3c:	a801      	add	r0, sp, #4
 8008b3e:	f001 fd81 	bl	800a644 <xTaskCheckForTimeOut>
 8008b42:	2800      	cmp	r0, #0
 8008b44:	d0f0      	beq.n	8008b28 <vMACBProbePhy+0x5c>
			FreeRTOS_printf( ( "BMCR_RESET timed out\n" ) );
 8008b46:	4823      	ldr	r0, [pc, #140]	; (8008bd4 <vMACBProbePhy+0x108>)
 8008b48:	f002 ff7e 	bl	800ba48 <lUDPLoggingPrintf>
			break;
 8008b4c:	e002      	b.n	8008b54 <vMACBProbePhy+0x88>
			FreeRTOS_printf( ( "BMCR_RESET ready\n" ) );
 8008b4e:	4822      	ldr	r0, [pc, #136]	; (8008bd8 <vMACBProbePhy+0x10c>)
 8008b50:	f002 ff7a 	bl	800ba48 <lUDPLoggingPrintf>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulConfig & ~BMCR_RESET);
 8008b54:	ad08      	add	r5, sp, #32
 8008b56:	f855 2d08 	ldr.w	r2, [r5, #-8]!
 8008b5a:	4c1c      	ldr	r4, [pc, #112]	; (8008bcc <vMACBProbePhy+0x100>)
 8008b5c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008b60:	2100      	movs	r1, #0
 8008b62:	4620      	mov	r0, r4
 8008b64:	f7f9 fa72 	bl	800204c <HAL_ETH_WritePHYRegister>
	vTaskDelay( pdMS_TO_TICKS( 50ul ) );
 8008b68:	2032      	movs	r0, #50	; 0x32
 8008b6a:	f001 fbb3 	bl	800a2d4 <vTaskDelay>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_04_ADVERTISE, ulAdvertise);
 8008b6e:	f240 12e1 	movw	r2, #481	; 0x1e1
 8008b72:	2104      	movs	r1, #4
 8008b74:	4620      	mov	r0, r4
 8008b76:	f7f9 fa69 	bl	800204c <HAL_ETH_WritePHYRegister>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_00_BMCR, &ulConfig);
 8008b7a:	462a      	mov	r2, r5
 8008b7c:	2100      	movs	r1, #0
 8008b7e:	4620      	mov	r0, r4
 8008b80:	f7f9 fa16 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	ulConfig &= ~( BMCR_ANRESTART | BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX );
 8008b84:	9b06      	ldr	r3, [sp, #24]
 8008b86:	f423 534c 	bic.w	r3, r3, #13056	; 0x3300
	ulConfig |= (BMCR_ANRESTART | BMCR_ANENABLE);
 8008b8a:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
 8008b8e:	9306      	str	r3, [sp, #24]
	HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_19_PHYCR, &ulPhyControl );
 8008b90:	aa07      	add	r2, sp, #28
 8008b92:	2119      	movs	r1, #25
 8008b94:	4620      	mov	r0, r4
 8008b96:	f7f9 fa0b 	bl	8001fb0 <HAL_ETH_ReadPHYRegister>
	ulPhyControl &= ~( PHYCR_MDIX_EN|PHYCR_MDIX_FORCE );
 8008b9a:	9a07      	ldr	r2, [sp, #28]
 8008b9c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
		ulPhyControl |= PHYCR_MDIX_EN;
 8008ba0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8008ba4:	9207      	str	r2, [sp, #28]
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_19_PHYCR, ulPhyControl );
 8008ba6:	2119      	movs	r1, #25
 8008ba8:	4620      	mov	r0, r4
 8008baa:	f7f9 fa4f 	bl	800204c <HAL_ETH_WritePHYRegister>
	FreeRTOS_printf( ( "+TCP: advertise: %lX config %lX\n", ulAdvertise, ulConfig ) );
 8008bae:	9a06      	ldr	r2, [sp, #24]
 8008bb0:	f240 11e1 	movw	r1, #481	; 0x1e1
 8008bb4:	4809      	ldr	r0, [pc, #36]	; (8008bdc <vMACBProbePhy+0x110>)
 8008bb6:	f002 ff47 	bl	800ba48 <lUDPLoggingPrintf>
	ulBCRvalue = ulConfig;
 8008bba:	9a06      	ldr	r2, [sp, #24]
 8008bbc:	4b08      	ldr	r3, [pc, #32]	; (8008be0 <vMACBProbePhy+0x114>)
 8008bbe:	601a      	str	r2, [r3, #0]
	ulACRValue = ulAdvertise;
 8008bc0:	f240 12e1 	movw	r2, #481	; 0x1e1
 8008bc4:	4b07      	ldr	r3, [pc, #28]	; (8008be4 <vMACBProbePhy+0x118>)
 8008bc6:	601a      	str	r2, [r3, #0]
}
 8008bc8:	b009      	add	sp, #36	; 0x24
 8008bca:	bd30      	pop	{r4, r5, pc}
 8008bcc:	20000944 	.word	0x20000944
 8008bd0:	0800cfb8 	.word	0x0800cfb8
 8008bd4:	0800cfd8 	.word	0x0800cfd8
 8008bd8:	0800cfc4 	.word	0x0800cfc4
 8008bdc:	0800cff0 	.word	0x0800cff0
 8008be0:	20000934 	.word	0x20000934
 8008be4:	20000930 	.word	0x20000930

08008be8 <xGetPhyLinkStatus>:
	if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 8008be8:	4b02      	ldr	r3, [pc, #8]	; (8008bf4 <xGetPhyLinkStatus+0xc>)
 8008bea:	6818      	ldr	r0, [r3, #0]
}
 8008bec:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8008bf0:	4770      	bx	lr
 8008bf2:	bf00      	nop
 8008bf4:	2000093c 	.word	0x2000093c

08008bf8 <ETH_IRQHandler>:
	}
}
/*-----------------------------------------------------------*/

void ETH_IRQHandler( void )
{
 8008bf8:	b508      	push	{r3, lr}
	HAL_ETH_IRQHandler( &xETH );
 8008bfa:	4802      	ldr	r0, [pc, #8]	; (8008c04 <ETH_IRQHandler+0xc>)
 8008bfc:	f7f9 f9b8 	bl	8001f70 <HAL_ETH_IRQHandler>
 8008c00:	bd08      	pop	{r3, pc}
 8008c02:	bf00      	nop
 8008c04:	20000944 	.word	0x20000944

08008c08 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
 8008c08:	b510      	push	{r4, lr}
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
 8008c0a:	201c      	movs	r0, #28
 8008c0c:	f000 fb34 	bl	8009278 <pvPortMalloc>

		if( pxEventBits != NULL )
 8008c10:	4604      	mov	r4, r0
 8008c12:	b120      	cbz	r0, 8008c1e <xEventGroupCreate+0x16>
		{
			pxEventBits->uxEventBits = 0;
 8008c14:	2300      	movs	r3, #0
 8008c16:	f840 3b04 	str.w	r3, [r0], #4
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 8008c1a:	f000 f917 	bl	8008e4c <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
 8008c1e:	4620      	mov	r0, r4
 8008c20:	bd10      	pop	{r4, pc}
	...

08008c24 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
 8008c24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008c28:	460d      	mov	r5, r1
 8008c2a:	4617      	mov	r7, r2
 8008c2c:	4698      	mov	r8, r3
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
 8008c2e:	4606      	mov	r6, r0
 8008c30:	b308      	cbz	r0, 8008c76 <xEventGroupWaitBits+0x52>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008c32:	f015 4f7f 	tst.w	r5, #4278190080	; 0xff000000
 8008c36:	d124      	bne.n	8008c82 <xEventGroupWaitBits+0x5e>
	configASSERT( uxBitsToWaitFor != 0 );
 8008c38:	b34d      	cbz	r5, 8008c8e <xEventGroupWaitBits+0x6a>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8008c3a:	f001 fe25 	bl	800a888 <xTaskGetSchedulerState>
 8008c3e:	b930      	cbnz	r0, 8008c4e <xEventGroupWaitBits+0x2a>
 8008c40:	9b06      	ldr	r3, [sp, #24]
 8008c42:	b123      	cbz	r3, 8008c4e <xEventGroupWaitBits+0x2a>
 8008c44:	f44f 71a9 	mov.w	r1, #338	; 0x152
 8008c48:	4836      	ldr	r0, [pc, #216]	; (8008d24 <xEventGroupWaitBits+0x100>)
 8008c4a:	f003 fb89 	bl	800c360 <vAssertCalled>
	}
	#endif

	vTaskSuspendAll();
 8008c4e:	f001 f9e7 	bl	800a020 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 8008c52:	6834      	ldr	r4, [r6, #0]

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
 8008c54:	f1b8 0f00 	cmp.w	r8, #0
 8008c58:	d11f      	bne.n	8008c9a <xEventGroupWaitBits+0x76>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 8008c5a:	4225      	tst	r5, r4
 8008c5c:	bf14      	ite	ne
 8008c5e:	2301      	movne	r3, #1
 8008c60:	2300      	moveq	r3, #0
		if( xWaitConditionMet != pdFALSE )
 8008c62:	b303      	cbz	r3, 8008ca6 <xEventGroupWaitBits+0x82>
			if( xClearOnExit != pdFALSE )
 8008c64:	b117      	cbz	r7, 8008c6c <xEventGroupWaitBits+0x48>
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8008c66:	ea24 0505 	bic.w	r5, r4, r5
 8008c6a:	6035      	str	r5, [r6, #0]
	xAlreadyYielded = xTaskResumeAll();
 8008c6c:	f001 fab2 	bl	800a1d4 <xTaskResumeAll>
 8008c70:	4620      	mov	r0, r4
}
 8008c72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT( xEventGroup );
 8008c76:	f240 114d 	movw	r1, #333	; 0x14d
 8008c7a:	482a      	ldr	r0, [pc, #168]	; (8008d24 <xEventGroupWaitBits+0x100>)
 8008c7c:	f003 fb70 	bl	800c360 <vAssertCalled>
 8008c80:	e7d7      	b.n	8008c32 <xEventGroupWaitBits+0xe>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008c82:	f44f 71a7 	mov.w	r1, #334	; 0x14e
 8008c86:	4827      	ldr	r0, [pc, #156]	; (8008d24 <xEventGroupWaitBits+0x100>)
 8008c88:	f003 fb6a 	bl	800c360 <vAssertCalled>
 8008c8c:	e7d4      	b.n	8008c38 <xEventGroupWaitBits+0x14>
	configASSERT( uxBitsToWaitFor != 0 );
 8008c8e:	f240 114f 	movw	r1, #335	; 0x14f
 8008c92:	4824      	ldr	r0, [pc, #144]	; (8008d24 <xEventGroupWaitBits+0x100>)
 8008c94:	f003 fb64 	bl	800c360 <vAssertCalled>
 8008c98:	e7cf      	b.n	8008c3a <xEventGroupWaitBits+0x16>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8008c9a:	ea35 0304 	bics.w	r3, r5, r4
 8008c9e:	bf0c      	ite	eq
 8008ca0:	2301      	moveq	r3, #1
 8008ca2:	2300      	movne	r3, #0
 8008ca4:	e7dd      	b.n	8008c62 <xEventGroupWaitBits+0x3e>
		else if( xTicksToWait == ( TickType_t ) 0 )
 8008ca6:	9b06      	ldr	r3, [sp, #24]
 8008ca8:	2b00      	cmp	r3, #0
 8008caa:	d0df      	beq.n	8008c6c <xEventGroupWaitBits+0x48>
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 8008cac:	2f00      	cmp	r7, #0
 8008cae:	bf0c      	ite	eq
 8008cb0:	2100      	moveq	r1, #0
 8008cb2:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
			if( xWaitForAllBits != pdFALSE )
 8008cb6:	f1b8 0f00 	cmp.w	r8, #0
 8008cba:	d001      	beq.n	8008cc0 <xEventGroupWaitBits+0x9c>
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 8008cbc:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 8008cc0:	9a06      	ldr	r2, [sp, #24]
 8008cc2:	4329      	orrs	r1, r5
 8008cc4:	1d30      	adds	r0, r6, #4
 8008cc6:	f001 fbf5 	bl	800a4b4 <vTaskPlaceOnUnorderedEventList>
	xAlreadyYielded = xTaskResumeAll();
 8008cca:	f001 fa83 	bl	800a1d4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8008cce:	b938      	cbnz	r0, 8008ce0 <xEventGroupWaitBits+0xbc>
			portYIELD_WITHIN_API();
 8008cd0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008cd4:	4b14      	ldr	r3, [pc, #80]	; (8008d28 <xEventGroupWaitBits+0x104>)
 8008cd6:	601a      	str	r2, [r3, #0]
 8008cd8:	f3bf 8f4f 	dsb	sy
 8008cdc:	f3bf 8f6f 	isb	sy
		uxReturn = uxTaskResetEventItemValue();
 8008ce0:	f001 ff6a 	bl	800abb8 <uxTaskResetEventItemValue>
 8008ce4:	4604      	mov	r4, r0
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8008ce6:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
 8008cea:	d003      	beq.n	8008cf4 <xEventGroupWaitBits+0xd0>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 8008cec:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
	return uxReturn;
 8008cf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			taskENTER_CRITICAL();
 8008cf4:	f000 f936 	bl	8008f64 <vPortEnterCritical>
				uxReturn = pxEventBits->uxEventBits;
 8008cf8:	6834      	ldr	r4, [r6, #0]
	if( xWaitForAllBits == pdFALSE )
 8008cfa:	f1b8 0f00 	cmp.w	r8, #0
 8008cfe:	d10b      	bne.n	8008d18 <xEventGroupWaitBits+0xf4>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 8008d00:	4225      	tst	r5, r4
 8008d02:	bf14      	ite	ne
 8008d04:	2301      	movne	r3, #1
 8008d06:	2300      	moveq	r3, #0
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 8008d08:	b11b      	cbz	r3, 8008d12 <xEventGroupWaitBits+0xee>
					if( xClearOnExit != pdFALSE )
 8008d0a:	b117      	cbz	r7, 8008d12 <xEventGroupWaitBits+0xee>
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8008d0c:	ea24 0505 	bic.w	r5, r4, r5
 8008d10:	6035      	str	r5, [r6, #0]
			taskEXIT_CRITICAL();
 8008d12:	f000 f949 	bl	8008fa8 <vPortExitCritical>
 8008d16:	e7e9      	b.n	8008cec <xEventGroupWaitBits+0xc8>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8008d18:	ea35 0304 	bics.w	r3, r5, r4
 8008d1c:	bf0c      	ite	eq
 8008d1e:	2301      	moveq	r3, #1
 8008d20:	2300      	movne	r3, #0
 8008d22:	e7f1      	b.n	8008d08 <xEventGroupWaitBits+0xe4>
 8008d24:	0800d01c 	.word	0x0800d01c
 8008d28:	e000ed04 	.word	0xe000ed04

08008d2c <xEventGroupClearBits>:
{
 8008d2c:	b570      	push	{r4, r5, r6, lr}
 8008d2e:	460c      	mov	r4, r1
	configASSERT( xEventGroup );
 8008d30:	4606      	mov	r6, r0
 8008d32:	b160      	cbz	r0, 8008d4e <xEventGroupClearBits+0x22>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008d34:	f014 4f7f 	tst.w	r4, #4278190080	; 0xff000000
 8008d38:	d10f      	bne.n	8008d5a <xEventGroupClearBits+0x2e>
	taskENTER_CRITICAL();
 8008d3a:	f000 f913 	bl	8008f64 <vPortEnterCritical>
		uxReturn = pxEventBits->uxEventBits;
 8008d3e:	6835      	ldr	r5, [r6, #0]
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 8008d40:	ea25 0404 	bic.w	r4, r5, r4
 8008d44:	6034      	str	r4, [r6, #0]
	taskEXIT_CRITICAL();
 8008d46:	f000 f92f 	bl	8008fa8 <vPortExitCritical>
}
 8008d4a:	4628      	mov	r0, r5
 8008d4c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( xEventGroup );
 8008d4e:	f240 11df 	movw	r1, #479	; 0x1df
 8008d52:	4805      	ldr	r0, [pc, #20]	; (8008d68 <xEventGroupClearBits+0x3c>)
 8008d54:	f003 fb04 	bl	800c360 <vAssertCalled>
 8008d58:	e7ec      	b.n	8008d34 <xEventGroupClearBits+0x8>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008d5a:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 8008d5e:	4802      	ldr	r0, [pc, #8]	; (8008d68 <xEventGroupClearBits+0x3c>)
 8008d60:	f003 fafe 	bl	800c360 <vAssertCalled>
 8008d64:	e7e9      	b.n	8008d3a <xEventGroupClearBits+0xe>
 8008d66:	bf00      	nop
 8008d68:	0800d01c 	.word	0x0800d01c

08008d6c <xEventGroupSetBits>:
{
 8008d6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008d6e:	460c      	mov	r4, r1
	configASSERT( xEventGroup );
 8008d70:	4605      	mov	r5, r0
 8008d72:	b170      	cbz	r0, 8008d92 <xEventGroupSetBits+0x26>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008d74:	f014 4f7f 	tst.w	r4, #4278190080	; 0xff000000
 8008d78:	d111      	bne.n	8008d9e <xEventGroupSetBits+0x32>
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008d7a:	f105 060c 	add.w	r6, r5, #12
	vTaskSuspendAll();
 8008d7e:	f001 f94f 	bl	800a020 <vTaskSuspendAll>
		pxListItem = listGET_HEAD_ENTRY( pxList );
 8008d82:	6928      	ldr	r0, [r5, #16]
		pxEventBits->uxEventBits |= uxBitsToSet;
 8008d84:	682b      	ldr	r3, [r5, #0]
 8008d86:	4323      	orrs	r3, r4
 8008d88:	602b      	str	r3, [r5, #0]
		while( pxListItem != pxListEnd )
 8008d8a:	4286      	cmp	r6, r0
 8008d8c:	d02f      	beq.n	8008dee <xEventGroupSetBits+0x82>
 8008d8e:	2700      	movs	r7, #0
 8008d90:	e015      	b.n	8008dbe <xEventGroupSetBits+0x52>
	configASSERT( xEventGroup );
 8008d92:	f240 211d 	movw	r1, #541	; 0x21d
 8008d96:	481a      	ldr	r0, [pc, #104]	; (8008e00 <xEventGroupSetBits+0x94>)
 8008d98:	f003 fae2 	bl	800c360 <vAssertCalled>
 8008d9c:	e7ea      	b.n	8008d74 <xEventGroupSetBits+0x8>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8008d9e:	f240 211e 	movw	r1, #542	; 0x21e
 8008da2:	4817      	ldr	r0, [pc, #92]	; (8008e00 <xEventGroupSetBits+0x94>)
 8008da4:	f003 fadc 	bl	800c360 <vAssertCalled>
 8008da8:	e7e7      	b.n	8008d7a <xEventGroupSetBits+0xe>
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 8008daa:	6829      	ldr	r1, [r5, #0]
 8008dac:	ea32 0101 	bics.w	r1, r2, r1
 8008db0:	bf0c      	ite	eq
 8008db2:	2101      	moveq	r1, #1
 8008db4:	2100      	movne	r1, #0
 8008db6:	e00e      	b.n	8008dd6 <xEventGroupSetBits+0x6a>
 8008db8:	4620      	mov	r0, r4
		while( pxListItem != pxListEnd )
 8008dba:	42a6      	cmp	r6, r4
 8008dbc:	d018      	beq.n	8008df0 <xEventGroupSetBits+0x84>
			pxNext = listGET_NEXT( pxListItem );
 8008dbe:	6844      	ldr	r4, [r0, #4]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 8008dc0:	6803      	ldr	r3, [r0, #0]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8008dc2:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 8008dc6:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 8008dca:	d1ee      	bne.n	8008daa <xEventGroupSetBits+0x3e>
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 8008dcc:	6829      	ldr	r1, [r5, #0]
 8008dce:	420a      	tst	r2, r1
 8008dd0:	bf14      	ite	ne
 8008dd2:	2101      	movne	r1, #1
 8008dd4:	2100      	moveq	r1, #0
			if( xMatchFound != pdFALSE )
 8008dd6:	2900      	cmp	r1, #0
 8008dd8:	d0ee      	beq.n	8008db8 <xEventGroupSetBits+0x4c>
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 8008dda:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
					uxBitsToClear |= uxBitsWaitedFor;
 8008dde:	bf18      	it	ne
 8008de0:	4317      	orrne	r7, r2
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8008de2:	6829      	ldr	r1, [r5, #0]
 8008de4:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8008de8:	f001 fbd2 	bl	800a590 <vTaskRemoveFromUnorderedEventList>
 8008dec:	e7e4      	b.n	8008db8 <xEventGroupSetBits+0x4c>
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 8008dee:	2700      	movs	r7, #0
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 8008df0:	682b      	ldr	r3, [r5, #0]
 8008df2:	ea23 0707 	bic.w	r7, r3, r7
 8008df6:	602f      	str	r7, [r5, #0]
	( void ) xTaskResumeAll();
 8008df8:	f001 f9ec 	bl	800a1d4 <xTaskResumeAll>
}
 8008dfc:	6828      	ldr	r0, [r5, #0]
 8008dfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008e00:	0800d01c 	.word	0x0800d01c

08008e04 <vEventGroupDelete>:
{
 8008e04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008e06:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8008e08:	f001 f90a 	bl	800a020 <vTaskSuspendAll>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8008e0c:	6863      	ldr	r3, [r4, #4]
 8008e0e:	b17b      	cbz	r3, 8008e30 <vEventGroupDelete+0x2c>
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 8008e10:	f104 050c 	add.w	r5, r4, #12
 8008e14:	4f0c      	ldr	r7, [pc, #48]	; (8008e48 <vEventGroupDelete+0x44>)
 8008e16:	f240 267d 	movw	r6, #637	; 0x27d
 8008e1a:	6923      	ldr	r3, [r4, #16]
 8008e1c:	42ab      	cmp	r3, r5
 8008e1e:	d00d      	beq.n	8008e3c <vEventGroupDelete+0x38>
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 8008e20:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 8008e24:	6920      	ldr	r0, [r4, #16]
 8008e26:	f001 fbb3 	bl	800a590 <vTaskRemoveFromUnorderedEventList>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8008e2a:	6863      	ldr	r3, [r4, #4]
 8008e2c:	2b00      	cmp	r3, #0
 8008e2e:	d1f4      	bne.n	8008e1a <vEventGroupDelete+0x16>
			vPortFree( pxEventBits );
 8008e30:	4620      	mov	r0, r4
 8008e32:	f000 fa87 	bl	8009344 <vPortFree>
	( void ) xTaskResumeAll();
 8008e36:	f001 f9cd 	bl	800a1d4 <xTaskResumeAll>
 8008e3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 8008e3c:	4631      	mov	r1, r6
 8008e3e:	4638      	mov	r0, r7
 8008e40:	f003 fa8e 	bl	800c360 <vAssertCalled>
 8008e44:	e7ec      	b.n	8008e20 <vEventGroupDelete+0x1c>
 8008e46:	bf00      	nop
 8008e48:	0800d01c 	.word	0x0800d01c

08008e4c <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008e4c:	f100 0308 	add.w	r3, r0, #8
 8008e50:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8008e52:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008e56:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008e58:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008e5a:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8008e5c:	2300      	movs	r3, #0
 8008e5e:	6003      	str	r3, [r0, #0]
 8008e60:	4770      	bx	lr

08008e62 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8008e62:	2300      	movs	r3, #0
 8008e64:	6103      	str	r3, [r0, #16]
 8008e66:	4770      	bx	lr

08008e68 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8008e68:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8008e6a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8008e6c:	689a      	ldr	r2, [r3, #8]
 8008e6e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8008e70:	689a      	ldr	r2, [r3, #8]
 8008e72:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8008e74:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8008e76:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8008e78:	6803      	ldr	r3, [r0, #0]
 8008e7a:	3301      	adds	r3, #1
 8008e7c:	6003      	str	r3, [r0, #0]
 8008e7e:	4770      	bx	lr

08008e80 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8008e80:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8008e82:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8008e84:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
 8008e88:	d002      	beq.n	8008e90 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008e8a:	f100 0208 	add.w	r2, r0, #8
 8008e8e:	e002      	b.n	8008e96 <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
 8008e90:	6902      	ldr	r2, [r0, #16]
 8008e92:	e004      	b.n	8008e9e <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008e94:	461a      	mov	r2, r3
 8008e96:	6853      	ldr	r3, [r2, #4]
 8008e98:	681c      	ldr	r4, [r3, #0]
 8008e9a:	42a5      	cmp	r5, r4
 8008e9c:	d2fa      	bcs.n	8008e94 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8008e9e:	6853      	ldr	r3, [r2, #4]
 8008ea0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8008ea2:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8008ea4:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8008ea6:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8008ea8:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8008eaa:	6803      	ldr	r3, [r0, #0]
 8008eac:	3301      	adds	r3, #1
 8008eae:	6003      	str	r3, [r0, #0]
}
 8008eb0:	bc30      	pop	{r4, r5}
 8008eb2:	4770      	bx	lr

08008eb4 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8008eb4:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8008eb6:	6842      	ldr	r2, [r0, #4]
 8008eb8:	6881      	ldr	r1, [r0, #8]
 8008eba:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8008ebc:	6882      	ldr	r2, [r0, #8]
 8008ebe:	6841      	ldr	r1, [r0, #4]
 8008ec0:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8008ec2:	685a      	ldr	r2, [r3, #4]
 8008ec4:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8008ec6:	bf04      	itt	eq
 8008ec8:	6882      	ldreq	r2, [r0, #8]
 8008eca:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8008ecc:	2200      	movs	r2, #0
 8008ece:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8008ed0:	6818      	ldr	r0, [r3, #0]
 8008ed2:	3801      	subs	r0, #1
 8008ed4:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8008ed6:	4770      	bx	lr

08008ed8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8008ed8:	4808      	ldr	r0, [pc, #32]	; (8008efc <prvPortStartFirstTask+0x24>)
 8008eda:	6800      	ldr	r0, [r0, #0]
 8008edc:	6800      	ldr	r0, [r0, #0]
 8008ede:	f380 8808 	msr	MSP, r0
 8008ee2:	f04f 0000 	mov.w	r0, #0
 8008ee6:	f380 8814 	msr	CONTROL, r0
 8008eea:	b662      	cpsie	i
 8008eec:	b661      	cpsie	f
 8008eee:	f3bf 8f4f 	dsb	sy
 8008ef2:	f3bf 8f6f 	isb	sy
 8008ef6:	df00      	svc	0
 8008ef8:	bf00      	nop
 8008efa:	0000      	.short	0x0000
 8008efc:	e000ed08 	.word	0xe000ed08

08008f00 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8008f00:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8008f10 <vPortEnableVFP+0x10>
 8008f04:	6801      	ldr	r1, [r0, #0]
 8008f06:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8008f0a:	6001      	str	r1, [r0, #0]
 8008f0c:	4770      	bx	lr
 8008f0e:	0000      	.short	0x0000
 8008f10:	e000ed88 	.word	0xe000ed88

08008f14 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8008f14:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8008f18:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8008f1c:	f021 0101 	bic.w	r1, r1, #1
 8008f20:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR; portTASK_RETURN_ADDRESS被配置为NULL*/
 8008f24:	2300      	movs	r3, #0
 8008f26:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8008f2a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8008f2e:	f06f 0302 	mvn.w	r3, #2
 8008f32:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8008f36:	3844      	subs	r0, #68	; 0x44
 8008f38:	4770      	bx	lr
 8008f3a:	0000      	movs	r0, r0
 8008f3c:	0000      	movs	r0, r0
	...

08008f40 <SVC_Handler>:
	__asm volatile (
 8008f40:	4b07      	ldr	r3, [pc, #28]	; (8008f60 <pxCurrentTCBConst2>)
 8008f42:	6819      	ldr	r1, [r3, #0]
 8008f44:	6808      	ldr	r0, [r1, #0]
 8008f46:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008f4a:	f380 8809 	msr	PSP, r0
 8008f4e:	f3bf 8f6f 	isb	sy
 8008f52:	f04f 0000 	mov.w	r0, #0
 8008f56:	f380 8811 	msr	BASEPRI, r0
 8008f5a:	4770      	bx	lr
 8008f5c:	f3af 8000 	nop.w

08008f60 <pxCurrentTCBConst2>:
 8008f60:	200009ac 	.word	0x200009ac

08008f64 <vPortEnterCritical>:
{
 8008f64:	b508      	push	{r3, lr}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8008f66:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008f6a:	f383 8811 	msr	BASEPRI, r3
 8008f6e:	f3bf 8f6f 	isb	sy
 8008f72:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8008f76:	4a09      	ldr	r2, [pc, #36]	; (8008f9c <vPortEnterCritical+0x38>)
 8008f78:	6813      	ldr	r3, [r2, #0]
 8008f7a:	3301      	adds	r3, #1
 8008f7c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8008f7e:	2b01      	cmp	r3, #1
 8008f80:	d000      	beq.n	8008f84 <vPortEnterCritical+0x20>
 8008f82:	bd08      	pop	{r3, pc}
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8008f84:	4b06      	ldr	r3, [pc, #24]	; (8008fa0 <vPortEnterCritical+0x3c>)
 8008f86:	681b      	ldr	r3, [r3, #0]
 8008f88:	f013 0fff 	tst.w	r3, #255	; 0xff
 8008f8c:	d0f9      	beq.n	8008f82 <vPortEnterCritical+0x1e>
 8008f8e:	f44f 71e3 	mov.w	r1, #454	; 0x1c6
 8008f92:	4804      	ldr	r0, [pc, #16]	; (8008fa4 <vPortEnterCritical+0x40>)
 8008f94:	f003 f9e4 	bl	800c360 <vAssertCalled>
}
 8008f98:	e7f3      	b.n	8008f82 <vPortEnterCritical+0x1e>
 8008f9a:	bf00      	nop
 8008f9c:	20000028 	.word	0x20000028
 8008fa0:	e000ed04 	.word	0xe000ed04
 8008fa4:	0800d048 	.word	0x0800d048

08008fa8 <vPortExitCritical>:
{
 8008fa8:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
 8008faa:	4b08      	ldr	r3, [pc, #32]	; (8008fcc <vPortExitCritical+0x24>)
 8008fac:	681b      	ldr	r3, [r3, #0]
 8008fae:	b13b      	cbz	r3, 8008fc0 <vPortExitCritical+0x18>
	uxCriticalNesting--;
 8008fb0:	4a06      	ldr	r2, [pc, #24]	; (8008fcc <vPortExitCritical+0x24>)
 8008fb2:	6813      	ldr	r3, [r2, #0]
 8008fb4:	3b01      	subs	r3, #1
 8008fb6:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8008fb8:	b90b      	cbnz	r3, 8008fbe <vPortExitCritical+0x16>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8008fba:	f383 8811 	msr	BASEPRI, r3
 8008fbe:	bd08      	pop	{r3, pc}
	configASSERT( uxCriticalNesting );
 8008fc0:	f240 11cd 	movw	r1, #461	; 0x1cd
 8008fc4:	4802      	ldr	r0, [pc, #8]	; (8008fd0 <vPortExitCritical+0x28>)
 8008fc6:	f003 f9cb 	bl	800c360 <vAssertCalled>
 8008fca:	e7f1      	b.n	8008fb0 <vPortExitCritical+0x8>
 8008fcc:	20000028 	.word	0x20000028
 8008fd0:	0800d048 	.word	0x0800d048
	...

08008fe0 <PendSV_Handler>:
	__asm volatile
 8008fe0:	f3ef 8009 	mrs	r0, PSP
 8008fe4:	f3bf 8f6f 	isb	sy
 8008fe8:	4b15      	ldr	r3, [pc, #84]	; (8009040 <pxCurrentTCBConst>)
 8008fea:	681a      	ldr	r2, [r3, #0]
 8008fec:	f01e 0f10 	tst.w	lr, #16
 8008ff0:	bf08      	it	eq
 8008ff2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8008ff6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008ffa:	6010      	str	r0, [r2, #0]
 8008ffc:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8009000:	f04f 0050 	mov.w	r0, #80	; 0x50
 8009004:	f380 8811 	msr	BASEPRI, r0
 8009008:	f3bf 8f4f 	dsb	sy
 800900c:	f3bf 8f6f 	isb	sy
 8009010:	f001 f9c4 	bl	800a39c <vTaskSwitchContext>
 8009014:	f04f 0000 	mov.w	r0, #0
 8009018:	f380 8811 	msr	BASEPRI, r0
 800901c:	bc08      	pop	{r3}
 800901e:	6819      	ldr	r1, [r3, #0]
 8009020:	6808      	ldr	r0, [r1, #0]
 8009022:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009026:	f01e 0f10 	tst.w	lr, #16
 800902a:	bf08      	it	eq
 800902c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8009030:	f380 8809 	msr	PSP, r0
 8009034:	f3bf 8f6f 	isb	sy
 8009038:	4770      	bx	lr
 800903a:	bf00      	nop
 800903c:	f3af 8000 	nop.w

08009040 <pxCurrentTCBConst>:
 8009040:	200009ac 	.word	0x200009ac

08009044 <SysTick_Handler>:
{
 8009044:	b508      	push	{r3, lr}
	__asm volatile
 8009046:	f04f 0350 	mov.w	r3, #80	; 0x50
 800904a:	f383 8811 	msr	BASEPRI, r3
 800904e:	f3bf 8f6f 	isb	sy
 8009052:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8009056:	f001 f805 	bl	800a064 <xTaskIncrementTick>
 800905a:	b118      	cbz	r0, 8009064 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800905c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009060:	4b02      	ldr	r3, [pc, #8]	; (800906c <SysTick_Handler+0x28>)
 8009062:	601a      	str	r2, [r3, #0]
	__asm volatile
 8009064:	2300      	movs	r3, #0
 8009066:	f383 8811 	msr	BASEPRI, r3
 800906a:	bd08      	pop	{r3, pc}
 800906c:	e000ed04 	.word	0xe000ed04

08009070 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8009070:	4a08      	ldr	r2, [pc, #32]	; (8009094 <vPortSetupTimerInterrupt+0x24>)
 8009072:	2300      	movs	r3, #0
 8009074:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8009076:	4908      	ldr	r1, [pc, #32]	; (8009098 <vPortSetupTimerInterrupt+0x28>)
 8009078:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800907a:	4b08      	ldr	r3, [pc, #32]	; (800909c <vPortSetupTimerInterrupt+0x2c>)
 800907c:	681b      	ldr	r3, [r3, #0]
 800907e:	4908      	ldr	r1, [pc, #32]	; (80090a0 <vPortSetupTimerInterrupt+0x30>)
 8009080:	fba1 1303 	umull	r1, r3, r1, r3
 8009084:	099b      	lsrs	r3, r3, #6
 8009086:	3b01      	subs	r3, #1
 8009088:	4906      	ldr	r1, [pc, #24]	; (80090a4 <vPortSetupTimerInterrupt+0x34>)
 800908a:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800908c:	2307      	movs	r3, #7
 800908e:	6013      	str	r3, [r2, #0]
 8009090:	4770      	bx	lr
 8009092:	bf00      	nop
 8009094:	e000e010 	.word	0xe000e010
 8009098:	e000e018 	.word	0xe000e018
 800909c:	20000000 	.word	0x20000000
 80090a0:	10624dd3 	.word	0x10624dd3
 80090a4:	e000e014 	.word	0xe000e014

080090a8 <xPortStartScheduler>:
{
 80090a8:	b510      	push	{r4, lr}
 80090aa:	b082      	sub	sp, #8
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80090ac:	4b3c      	ldr	r3, [pc, #240]	; (80091a0 <xPortStartScheduler+0xf8>)
 80090ae:	681a      	ldr	r2, [r3, #0]
 80090b0:	4b3c      	ldr	r3, [pc, #240]	; (80091a4 <xPortStartScheduler+0xfc>)
 80090b2:	429a      	cmp	r2, r3
 80090b4:	d01e      	beq.n	80090f4 <xPortStartScheduler+0x4c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80090b6:	4b3a      	ldr	r3, [pc, #232]	; (80091a0 <xPortStartScheduler+0xf8>)
 80090b8:	681a      	ldr	r2, [r3, #0]
 80090ba:	4b3b      	ldr	r3, [pc, #236]	; (80091a8 <xPortStartScheduler+0x100>)
 80090bc:	429a      	cmp	r2, r3
 80090be:	d01f      	beq.n	8009100 <xPortStartScheduler+0x58>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80090c0:	4b3a      	ldr	r3, [pc, #232]	; (80091ac <xPortStartScheduler+0x104>)
 80090c2:	781a      	ldrb	r2, [r3, #0]
 80090c4:	b2d2      	uxtb	r2, r2
 80090c6:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80090c8:	22ff      	movs	r2, #255	; 0xff
 80090ca:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80090cc:	781b      	ldrb	r3, [r3, #0]
 80090ce:	b2db      	uxtb	r3, r3
 80090d0:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80090d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80090d8:	f003 0350 	and.w	r3, r3, #80	; 0x50
 80090dc:	4a34      	ldr	r2, [pc, #208]	; (80091b0 <xPortStartScheduler+0x108>)
 80090de:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80090e0:	2207      	movs	r2, #7
 80090e2:	4b34      	ldr	r3, [pc, #208]	; (80091b4 <xPortStartScheduler+0x10c>)
 80090e4:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80090e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80090ea:	f013 0f80 	tst.w	r3, #128	; 0x80
 80090ee:	d051      	beq.n	8009194 <xPortStartScheduler+0xec>
 80090f0:	2206      	movs	r2, #6
 80090f2:	e00c      	b.n	800910e <xPortStartScheduler+0x66>
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80090f4:	f44f 71a9 	mov.w	r1, #338	; 0x152
 80090f8:	482f      	ldr	r0, [pc, #188]	; (80091b8 <xPortStartScheduler+0x110>)
 80090fa:	f003 f931 	bl	800c360 <vAssertCalled>
 80090fe:	e7da      	b.n	80090b6 <xPortStartScheduler+0xe>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8009100:	f240 1153 	movw	r1, #339	; 0x153
 8009104:	482c      	ldr	r0, [pc, #176]	; (80091b8 <xPortStartScheduler+0x110>)
 8009106:	f003 f92b 	bl	800c360 <vAssertCalled>
 800910a:	e7d9      	b.n	80090c0 <xPortStartScheduler+0x18>
 800910c:	460a      	mov	r2, r1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800910e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009112:	005b      	lsls	r3, r3, #1
 8009114:	b2db      	uxtb	r3, r3
 8009116:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800911a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800911e:	1e51      	subs	r1, r2, #1
 8009120:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009124:	d1f2      	bne.n	800910c <xPortStartScheduler+0x64>
 8009126:	4b23      	ldr	r3, [pc, #140]	; (80091b4 <xPortStartScheduler+0x10c>)
 8009128:	601a      	str	r2, [r3, #0]
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800912a:	2a03      	cmp	r2, #3
 800912c:	d132      	bne.n	8009194 <xPortStartScheduler+0xec>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800912e:	4a21      	ldr	r2, [pc, #132]	; (80091b4 <xPortStartScheduler+0x10c>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8009130:	6813      	ldr	r3, [r2, #0]
 8009132:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8009134:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8009138:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800913a:	9b01      	ldr	r3, [sp, #4]
 800913c:	b2db      	uxtb	r3, r3
 800913e:	4a1b      	ldr	r2, [pc, #108]	; (80091ac <xPortStartScheduler+0x104>)
 8009140:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8009142:	4b1e      	ldr	r3, [pc, #120]	; (80091bc <xPortStartScheduler+0x114>)
 8009144:	681a      	ldr	r2, [r3, #0]
 8009146:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800914a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800914c:	681a      	ldr	r2, [r3, #0]
 800914e:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8009152:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8009154:	f7ff ff8c 	bl	8009070 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8009158:	4c19      	ldr	r4, [pc, #100]	; (80091c0 <xPortStartScheduler+0x118>)
 800915a:	2300      	movs	r3, #0
 800915c:	6023      	str	r3, [r4, #0]
	vPortEnableVFP();
 800915e:	f7ff fecf 	bl	8008f00 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8009162:	4a18      	ldr	r2, [pc, #96]	; (80091c4 <xPortStartScheduler+0x11c>)
 8009164:	6813      	ldr	r3, [r2, #0]
 8009166:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 800916a:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 800916c:	f7ff feb4 	bl	8008ed8 <prvPortStartFirstTask>
	configASSERT( uxCriticalNesting == ~0UL );
 8009170:	6823      	ldr	r3, [r4, #0]
 8009172:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009176:	d004      	beq.n	8009182 <xPortStartScheduler+0xda>
 8009178:	f44f 718b 	mov.w	r1, #278	; 0x116
 800917c:	480e      	ldr	r0, [pc, #56]	; (80091b8 <xPortStartScheduler+0x110>)
 800917e:	f003 f8ef 	bl	800c360 <vAssertCalled>
	__asm volatile
 8009182:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009186:	f383 8811 	msr	BASEPRI, r3
 800918a:	f3bf 8f6f 	isb	sy
 800918e:	f3bf 8f4f 	dsb	sy
 8009192:	e7fe      	b.n	8009192 <xPortStartScheduler+0xea>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8009194:	f44f 71c2 	mov.w	r1, #388	; 0x184
 8009198:	4807      	ldr	r0, [pc, #28]	; (80091b8 <xPortStartScheduler+0x110>)
 800919a:	f003 f8e1 	bl	800c360 <vAssertCalled>
 800919e:	e7c6      	b.n	800912e <xPortStartScheduler+0x86>
 80091a0:	e000ed00 	.word	0xe000ed00
 80091a4:	410fc271 	.word	0x410fc271
 80091a8:	410fc270 	.word	0x410fc270
 80091ac:	e000e400 	.word	0xe000e400
 80091b0:	2000098c 	.word	0x2000098c
 80091b4:	20000990 	.word	0x20000990
 80091b8:	0800d048 	.word	0x0800d048
 80091bc:	e000ed20 	.word	0xe000ed20
 80091c0:	20000028 	.word	0x20000028
 80091c4:	e000ef34 	.word	0xe000ef34

080091c8 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 80091c8:	b508      	push	{r3, lr}
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80091ca:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 80091ce:	2b0f      	cmp	r3, #15
 80091d0:	d906      	bls.n	80091e0 <vPortValidateInterruptPriority+0x18>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 80091d2:	4a0e      	ldr	r2, [pc, #56]	; (800920c <vPortValidateInterruptPriority+0x44>)
 80091d4:	5c9b      	ldrb	r3, [r3, r2]
 80091d6:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 80091d8:	4a0d      	ldr	r2, [pc, #52]	; (8009210 <vPortValidateInterruptPriority+0x48>)
 80091da:	7812      	ldrb	r2, [r2, #0]
 80091dc:	429a      	cmp	r2, r3
 80091de:	d808      	bhi.n	80091f2 <vPortValidateInterruptPriority+0x2a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 80091e0:	4b0c      	ldr	r3, [pc, #48]	; (8009214 <vPortValidateInterruptPriority+0x4c>)
 80091e2:	681b      	ldr	r3, [r3, #0]
 80091e4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80091e8:	4a0b      	ldr	r2, [pc, #44]	; (8009218 <vPortValidateInterruptPriority+0x50>)
 80091ea:	6812      	ldr	r2, [r2, #0]
 80091ec:	4293      	cmp	r3, r2
 80091ee:	d806      	bhi.n	80091fe <vPortValidateInterruptPriority+0x36>
 80091f0:	bd08      	pop	{r3, pc}
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 80091f2:	f44f 7143 	mov.w	r1, #780	; 0x30c
 80091f6:	4809      	ldr	r0, [pc, #36]	; (800921c <vPortValidateInterruptPriority+0x54>)
 80091f8:	f003 f8b2 	bl	800c360 <vAssertCalled>
 80091fc:	e7f0      	b.n	80091e0 <vPortValidateInterruptPriority+0x18>
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 80091fe:	f44f 7147 	mov.w	r1, #796	; 0x31c
 8009202:	4806      	ldr	r0, [pc, #24]	; (800921c <vPortValidateInterruptPriority+0x54>)
 8009204:	f003 f8ac 	bl	800c360 <vAssertCalled>
	}
 8009208:	e7f2      	b.n	80091f0 <vPortValidateInterruptPriority+0x28>
 800920a:	bf00      	nop
 800920c:	e000e3f0 	.word	0xe000e3f0
 8009210:	2000098c 	.word	0x2000098c
 8009214:	e000ed0c 	.word	0xe000ed0c
 8009218:	20000990 	.word	0x20000990
 800921c:	0800d048 	.word	0x0800d048

08009220 <prvInsertBlockIntoFreeList>:
	return xMinimumEverFreeBytesRemaining;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8009220:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8009222:	4a13      	ldr	r2, [pc, #76]	; (8009270 <prvInsertBlockIntoFreeList+0x50>)
 8009224:	e000      	b.n	8009228 <prvInsertBlockIntoFreeList+0x8>
 8009226:	461a      	mov	r2, r3
 8009228:	6813      	ldr	r3, [r2, #0]
 800922a:	4283      	cmp	r3, r0
 800922c:	d3fb      	bcc.n	8009226 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800922e:	6851      	ldr	r1, [r2, #4]
 8009230:	1854      	adds	r4, r2, r1
 8009232:	42a0      	cmp	r0, r4
 8009234:	d00a      	beq.n	800924c <prvInsertBlockIntoFreeList+0x2c>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8009236:	6841      	ldr	r1, [r0, #4]
 8009238:	1844      	adds	r4, r0, r1
 800923a:	42a3      	cmp	r3, r4
 800923c:	d00b      	beq.n	8009256 <prvInsertBlockIntoFreeList+0x36>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800923e:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8009240:	4290      	cmp	r0, r2
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8009242:	bf18      	it	ne
 8009244:	6010      	strne	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8009246:	f85d 4b04 	ldr.w	r4, [sp], #4
 800924a:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800924c:	6840      	ldr	r0, [r0, #4]
 800924e:	4401      	add	r1, r0
 8009250:	6051      	str	r1, [r2, #4]
 8009252:	4610      	mov	r0, r2
 8009254:	e7ef      	b.n	8009236 <prvInsertBlockIntoFreeList+0x16>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8009256:	4c07      	ldr	r4, [pc, #28]	; (8009274 <prvInsertBlockIntoFreeList+0x54>)
 8009258:	6824      	ldr	r4, [r4, #0]
 800925a:	42a3      	cmp	r3, r4
 800925c:	d006      	beq.n	800926c <prvInsertBlockIntoFreeList+0x4c>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800925e:	685b      	ldr	r3, [r3, #4]
 8009260:	4419      	add	r1, r3
 8009262:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8009264:	6813      	ldr	r3, [r2, #0]
 8009266:	681b      	ldr	r3, [r3, #0]
 8009268:	6003      	str	r3, [r0, #0]
 800926a:	e7e9      	b.n	8009240 <prvInsertBlockIntoFreeList+0x20>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 800926c:	6003      	str	r3, [r0, #0]
 800926e:	e7e7      	b.n	8009240 <prvInsertBlockIntoFreeList+0x20>
 8009270:	200009a4 	.word	0x200009a4
 8009274:	20000994 	.word	0x20000994

08009278 <pvPortMalloc>:
{
 8009278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800927a:	4604      	mov	r4, r0
	configASSERT( pxEnd );
 800927c:	4b2b      	ldr	r3, [pc, #172]	; (800932c <pvPortMalloc+0xb4>)
 800927e:	681b      	ldr	r3, [r3, #0]
 8009280:	b1c3      	cbz	r3, 80092b4 <pvPortMalloc+0x3c>
	vTaskSuspendAll();
 8009282:	f000 fecd 	bl	800a020 <vTaskSuspendAll>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8009286:	4b2a      	ldr	r3, [pc, #168]	; (8009330 <pvPortMalloc+0xb8>)
 8009288:	681d      	ldr	r5, [r3, #0]
 800928a:	4225      	tst	r5, r4
 800928c:	d144      	bne.n	8009318 <pvPortMalloc+0xa0>
			if( xWantedSize > 0 )
 800928e:	2c00      	cmp	r4, #0
 8009290:	d045      	beq.n	800931e <pvPortMalloc+0xa6>
				xWantedSize += xHeapStructSize;
 8009292:	f104 0208 	add.w	r2, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8009296:	f012 0f07 	tst.w	r2, #7
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800929a:	bf1c      	itt	ne
 800929c:	f022 0207 	bicne.w	r2, r2, #7
 80092a0:	3208      	addne	r2, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80092a2:	2a00      	cmp	r2, #0
 80092a4:	d038      	beq.n	8009318 <pvPortMalloc+0xa0>
 80092a6:	4b23      	ldr	r3, [pc, #140]	; (8009334 <pvPortMalloc+0xbc>)
 80092a8:	681e      	ldr	r6, [r3, #0]
 80092aa:	42b2      	cmp	r2, r6
 80092ac:	d834      	bhi.n	8009318 <pvPortMalloc+0xa0>
				pxBlock = xStart.pxNextFreeBlock;
 80092ae:	4922      	ldr	r1, [pc, #136]	; (8009338 <pvPortMalloc+0xc0>)
 80092b0:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80092b2:	e006      	b.n	80092c2 <pvPortMalloc+0x4a>
	configASSERT( pxEnd );
 80092b4:	21b5      	movs	r1, #181	; 0xb5
 80092b6:	4821      	ldr	r0, [pc, #132]	; (800933c <pvPortMalloc+0xc4>)
 80092b8:	f003 f852 	bl	800c360 <vAssertCalled>
 80092bc:	e7e1      	b.n	8009282 <pvPortMalloc+0xa>
 80092be:	4621      	mov	r1, r4
					pxBlock = pxBlock->pxNextFreeBlock;
 80092c0:	461c      	mov	r4, r3
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80092c2:	6863      	ldr	r3, [r4, #4]
 80092c4:	429a      	cmp	r2, r3
 80092c6:	d902      	bls.n	80092ce <pvPortMalloc+0x56>
 80092c8:	6823      	ldr	r3, [r4, #0]
 80092ca:	2b00      	cmp	r3, #0
 80092cc:	d1f7      	bne.n	80092be <pvPortMalloc+0x46>
				if( pxBlock != pxEnd )
 80092ce:	4b17      	ldr	r3, [pc, #92]	; (800932c <pvPortMalloc+0xb4>)
 80092d0:	681b      	ldr	r3, [r3, #0]
 80092d2:	429c      	cmp	r4, r3
 80092d4:	d020      	beq.n	8009318 <pvPortMalloc+0xa0>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80092d6:	680f      	ldr	r7, [r1, #0]
 80092d8:	3708      	adds	r7, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80092da:	6823      	ldr	r3, [r4, #0]
 80092dc:	600b      	str	r3, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80092de:	6863      	ldr	r3, [r4, #4]
 80092e0:	1a9b      	subs	r3, r3, r2
 80092e2:	2b10      	cmp	r3, #16
 80092e4:	d812      	bhi.n	800930c <pvPortMalloc+0x94>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80092e6:	6862      	ldr	r2, [r4, #4]
 80092e8:	1ab6      	subs	r6, r6, r2
 80092ea:	4912      	ldr	r1, [pc, #72]	; (8009334 <pvPortMalloc+0xbc>)
 80092ec:	600e      	str	r6, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80092ee:	4914      	ldr	r1, [pc, #80]	; (8009340 <pvPortMalloc+0xc8>)
 80092f0:	6809      	ldr	r1, [r1, #0]
 80092f2:	428e      	cmp	r6, r1
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80092f4:	bf3c      	itt	cc
 80092f6:	4912      	ldrcc	r1, [pc, #72]	; (8009340 <pvPortMalloc+0xc8>)
 80092f8:	600e      	strcc	r6, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80092fa:	4315      	orrs	r5, r2
 80092fc:	6065      	str	r5, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80092fe:	2300      	movs	r3, #0
 8009300:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 8009302:	f000 ff67 	bl	800a1d4 <xTaskResumeAll>
		if( pvReturn == NULL )
 8009306:	b167      	cbz	r7, 8009322 <pvPortMalloc+0xaa>
}
 8009308:	4638      	mov	r0, r7
 800930a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800930c:	18a0      	adds	r0, r4, r2
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800930e:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8009310:	6062      	str	r2, [r4, #4]
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8009312:	f7ff ff85 	bl	8009220 <prvInsertBlockIntoFreeList>
 8009316:	e7e6      	b.n	80092e6 <pvPortMalloc+0x6e>
	( void ) xTaskResumeAll();
 8009318:	f000 ff5c 	bl	800a1d4 <xTaskResumeAll>
 800931c:	e001      	b.n	8009322 <pvPortMalloc+0xaa>
 800931e:	f000 ff59 	bl	800a1d4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
 8009322:	f003 f8d1 	bl	800c4c8 <vApplicationMallocFailedHook>
 8009326:	2700      	movs	r7, #0
	return pvReturn;
 8009328:	e7ee      	b.n	8009308 <pvPortMalloc+0x90>
 800932a:	bf00      	nop
 800932c:	20000994 	.word	0x20000994
 8009330:	20000998 	.word	0x20000998
 8009334:	2000099c 	.word	0x2000099c
 8009338:	200009a4 	.word	0x200009a4
 800933c:	0800d084 	.word	0x0800d084
 8009340:	200009a0 	.word	0x200009a0

08009344 <vPortFree>:
	if( pv != NULL )
 8009344:	2800      	cmp	r0, #0
 8009346:	d040      	beq.n	80093ca <vPortFree+0x86>
{
 8009348:	b510      	push	{r4, lr}
 800934a:	4604      	mov	r4, r0
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800934c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8009350:	4b1e      	ldr	r3, [pc, #120]	; (80093cc <vPortFree+0x88>)
 8009352:	681b      	ldr	r3, [r3, #0]
 8009354:	421a      	tst	r2, r3
 8009356:	d011      	beq.n	800937c <vPortFree+0x38>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8009358:	f850 3c08 	ldr.w	r3, [r0, #-8]
 800935c:	b1f3      	cbz	r3, 800939c <vPortFree+0x58>
 800935e:	f44f 71a5 	mov.w	r1, #330	; 0x14a
 8009362:	481b      	ldr	r0, [pc, #108]	; (80093d0 <vPortFree+0x8c>)
 8009364:	f002 fffc 	bl	800c360 <vAssertCalled>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 8009368:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800936c:	4a17      	ldr	r2, [pc, #92]	; (80093cc <vPortFree+0x88>)
 800936e:	6812      	ldr	r2, [r2, #0]
 8009370:	4213      	tst	r3, r2
 8009372:	d002      	beq.n	800937a <vPortFree+0x36>
			if( pxLink->pxNextFreeBlock == NULL )
 8009374:	f854 1c08 	ldr.w	r1, [r4, #-8]
 8009378:	b1a1      	cbz	r1, 80093a4 <vPortFree+0x60>
 800937a:	bd10      	pop	{r4, pc}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800937c:	f240 1149 	movw	r1, #329	; 0x149
 8009380:	4813      	ldr	r0, [pc, #76]	; (80093d0 <vPortFree+0x8c>)
 8009382:	f002 ffed 	bl	800c360 <vAssertCalled>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8009386:	f854 3c08 	ldr.w	r3, [r4, #-8]
 800938a:	2b00      	cmp	r3, #0
 800938c:	d1e7      	bne.n	800935e <vPortFree+0x1a>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 800938e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8009392:	4a0e      	ldr	r2, [pc, #56]	; (80093cc <vPortFree+0x88>)
 8009394:	6812      	ldr	r2, [r2, #0]
 8009396:	4213      	tst	r3, r2
 8009398:	d0ef      	beq.n	800937a <vPortFree+0x36>
 800939a:	e003      	b.n	80093a4 <vPortFree+0x60>
 800939c:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80093a0:	4a0a      	ldr	r2, [pc, #40]	; (80093cc <vPortFree+0x88>)
 80093a2:	6812      	ldr	r2, [r2, #0]
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80093a4:	ea23 0302 	bic.w	r3, r3, r2
 80093a8:	f844 3c04 	str.w	r3, [r4, #-4]
				vTaskSuspendAll();
 80093ac:	f000 fe38 	bl	800a020 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80093b0:	4a08      	ldr	r2, [pc, #32]	; (80093d4 <vPortFree+0x90>)
 80093b2:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80093b6:	6811      	ldr	r1, [r2, #0]
 80093b8:	440b      	add	r3, r1
 80093ba:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80093bc:	f1a4 0008 	sub.w	r0, r4, #8
 80093c0:	f7ff ff2e 	bl	8009220 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 80093c4:	f000 ff06 	bl	800a1d4 <xTaskResumeAll>
}
 80093c8:	bd10      	pop	{r4, pc}
 80093ca:	4770      	bx	lr
 80093cc:	20000998 	.word	0x20000998
 80093d0:	0800d084 	.word	0x0800d084
 80093d4:	2000099c 	.word	0x2000099c

080093d8 <xPortGetFreeHeapSize>:
}
 80093d8:	4b01      	ldr	r3, [pc, #4]	; (80093e0 <xPortGetFreeHeapSize+0x8>)
 80093da:	6818      	ldr	r0, [r3, #0]
 80093dc:	4770      	bx	lr
 80093de:	bf00      	nop
 80093e0:	2000099c 	.word	0x2000099c

080093e4 <xPortGetMinimumEverFreeHeapSize>:
}
 80093e4:	4b01      	ldr	r3, [pc, #4]	; (80093ec <xPortGetMinimumEverFreeHeapSize+0x8>)
 80093e6:	6818      	ldr	r0, [r3, #0]
 80093e8:	4770      	bx	lr
 80093ea:	bf00      	nop
 80093ec:	200009a0 	.word	0x200009a0

080093f0 <vPortDefineHeapRegions>:
/*-----------------------------------------------------------*/

void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )
{
 80093f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80093f4:	4605      	mov	r5, r0
BaseType_t xDefinedRegions = 0;
size_t xAddress;
const HeapRegion_t *pxHeapRegion;

	/* Can only call once! */
	configASSERT( pxEnd == NULL );
 80093f6:	4b37      	ldr	r3, [pc, #220]	; (80094d4 <vPortDefineHeapRegions+0xe4>)
 80093f8:	681b      	ldr	r3, [r3, #0]
 80093fa:	b123      	cbz	r3, 8009406 <vPortDefineHeapRegions+0x16>
 80093fc:	f240 11bd 	movw	r1, #445	; 0x1bd
 8009400:	4835      	ldr	r0, [pc, #212]	; (80094d8 <vPortDefineHeapRegions+0xe8>)
 8009402:	f002 ffad 	bl	800c360 <vAssertCalled>

	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );

	while( pxHeapRegion->xSizeInBytes > 0 )
 8009406:	f8d5 b004 	ldr.w	fp, [r5, #4]
 800940a:	f1bb 0f00 	cmp.w	fp, #0
 800940e:	d055      	beq.n	80094bc <vPortDefineHeapRegions+0xcc>
 8009410:	3508      	adds	r5, #8
 8009412:	2600      	movs	r6, #0
 8009414:	46b0      	mov	r8, r6
		}
		else
		{
			/* Should only get here if one region has already been added to the
			heap. */
			configASSERT( pxEnd != NULL );
 8009416:	4f2f      	ldr	r7, [pc, #188]	; (80094d4 <vPortDefineHeapRegions+0xe4>)

			/* Check blocks are passed in with increasing start addresses. */
			configASSERT( xAddress > ( size_t ) pxEnd );
 8009418:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 80094d8 <vPortDefineHeapRegions+0xe8>
			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
 800941c:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 80094e8 <vPortDefineHeapRegions+0xf8>
 8009420:	e01d      	b.n	800945e <vPortDefineHeapRegions+0x6e>
			configASSERT( pxEnd != NULL );
 8009422:	683b      	ldr	r3, [r7, #0]
 8009424:	b37b      	cbz	r3, 8009486 <vPortDefineHeapRegions+0x96>
			configASSERT( xAddress > ( size_t ) pxEnd );
 8009426:	683b      	ldr	r3, [r7, #0]
 8009428:	42a3      	cmp	r3, r4
 800942a:	d232      	bcs.n	8009492 <vPortDefineHeapRegions+0xa2>
		}

		/* Remember the location of the end marker in the previous region, if
		any. */
		pxPreviousFreeBlock = pxEnd;
 800942c:	6839      	ldr	r1, [r7, #0]

		/* pxEnd is used to mark the end of the list of free blocks and is
		inserted at the end of the region space. */
		xAddress = xAlignedHeap + xTotalRegionSize;
 800942e:	eb0b 0304 	add.w	r3, fp, r4
		xAddress -= xHeapStructSize;
 8009432:	3b08      	subs	r3, #8
		xAddress &= ~portBYTE_ALIGNMENT_MASK;
 8009434:	f023 0307 	bic.w	r3, r3, #7
		pxEnd = ( BlockLink_t * ) xAddress;
 8009438:	603b      	str	r3, [r7, #0]
		pxEnd->xBlockSize = 0;
 800943a:	2200      	movs	r2, #0
 800943c:	605a      	str	r2, [r3, #4]
		pxEnd->pxNextFreeBlock = NULL;
 800943e:	601a      	str	r2, [r3, #0]

		/* To start with there is a single free block in this region that is
		sized to take up the entire heap region minus the space taken by the
		free block structure. */
		pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;
 8009440:	4622      	mov	r2, r4
		pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;
 8009442:	1b18      	subs	r0, r3, r4
 8009444:	6060      	str	r0, [r4, #4]
		pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;
 8009446:	6023      	str	r3, [r4, #0]

		/* If this is not the first region that makes up the entire heap space
		then link the previous region to this region. */
		if( pxPreviousFreeBlock != NULL )
 8009448:	b101      	cbz	r1, 800944c <vPortDefineHeapRegions+0x5c>
		{
			pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;
 800944a:	600c      	str	r4, [r1, #0]
		}

		xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;
 800944c:	6853      	ldr	r3, [r2, #4]
 800944e:	4498      	add	r8, r3

		/* Move onto the next HeapRegion_t structure. */
		xDefinedRegions++;
 8009450:	3601      	adds	r6, #1
 8009452:	3508      	adds	r5, #8
	while( pxHeapRegion->xSizeInBytes > 0 )
 8009454:	f855 bc04 	ldr.w	fp, [r5, #-4]
 8009458:	f1bb 0f00 	cmp.w	fp, #0
 800945c:	d01f      	beq.n	800949e <vPortDefineHeapRegions+0xae>
		xAddress = ( size_t ) pxHeapRegion->pucStartAddress;
 800945e:	f855 4c08 	ldr.w	r4, [r5, #-8]
		if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8009462:	f014 0f07 	tst.w	r4, #7
 8009466:	d006      	beq.n	8009476 <vPortDefineHeapRegions+0x86>
			xAddress += ( portBYTE_ALIGNMENT - 1 );
 8009468:	1de2      	adds	r2, r4, #7
			xAddress &= ~portBYTE_ALIGNMENT_MASK;
 800946a:	f022 0207 	bic.w	r2, r2, #7
			xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;
 800946e:	44a3      	add	fp, r4
 8009470:	ebab 0b02 	sub.w	fp, fp, r2
			xAddress &= ~portBYTE_ALIGNMENT_MASK;
 8009474:	4614      	mov	r4, r2
		if( xDefinedRegions == 0 )
 8009476:	2e00      	cmp	r6, #0
 8009478:	d1d3      	bne.n	8009422 <vPortDefineHeapRegions+0x32>
			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
 800947a:	f8c9 4000 	str.w	r4, [r9]
			xStart.xBlockSize = ( size_t ) 0;
 800947e:	2300      	movs	r3, #0
 8009480:	f8c9 3004 	str.w	r3, [r9, #4]
 8009484:	e7d2      	b.n	800942c <vPortDefineHeapRegions+0x3c>
			configASSERT( pxEnd != NULL );
 8009486:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 800948a:	4650      	mov	r0, sl
 800948c:	f002 ff68 	bl	800c360 <vAssertCalled>
 8009490:	e7c9      	b.n	8009426 <vPortDefineHeapRegions+0x36>
			configASSERT( xAddress > ( size_t ) pxEnd );
 8009492:	f240 11e1 	movw	r1, #481	; 0x1e1
 8009496:	4650      	mov	r0, sl
 8009498:	f002 ff62 	bl	800c360 <vAssertCalled>
 800949c:	e7c6      	b.n	800942c <vPortDefineHeapRegions+0x3c>
		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
	}

	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
 800949e:	4b0f      	ldr	r3, [pc, #60]	; (80094dc <vPortDefineHeapRegions+0xec>)
 80094a0:	f8c3 8000 	str.w	r8, [r3]
	xFreeBytesRemaining = xTotalHeapSize;
 80094a4:	4b0e      	ldr	r3, [pc, #56]	; (80094e0 <vPortDefineHeapRegions+0xf0>)
 80094a6:	f8c3 8000 	str.w	r8, [r3]

	/* Check something was actually defined before it is accessed. */
	configASSERT( xTotalHeapSize );
 80094aa:	f1b8 0f00 	cmp.w	r8, #0
 80094ae:	d00a      	beq.n	80094c6 <vPortDefineHeapRegions+0xd6>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80094b0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80094b4:	4b0b      	ldr	r3, [pc, #44]	; (80094e4 <vPortDefineHeapRegions+0xf4>)
 80094b6:	601a      	str	r2, [r3, #0]
}
 80094b8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
 80094bc:	2300      	movs	r3, #0
 80094be:	4a07      	ldr	r2, [pc, #28]	; (80094dc <vPortDefineHeapRegions+0xec>)
 80094c0:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = xTotalHeapSize;
 80094c2:	4a07      	ldr	r2, [pc, #28]	; (80094e0 <vPortDefineHeapRegions+0xf0>)
 80094c4:	6013      	str	r3, [r2, #0]
	configASSERT( xTotalHeapSize );
 80094c6:	f240 210a 	movw	r1, #522	; 0x20a
 80094ca:	4803      	ldr	r0, [pc, #12]	; (80094d8 <vPortDefineHeapRegions+0xe8>)
 80094cc:	f002 ff48 	bl	800c360 <vAssertCalled>
 80094d0:	e7ee      	b.n	80094b0 <vPortDefineHeapRegions+0xc0>
 80094d2:	bf00      	nop
 80094d4:	20000994 	.word	0x20000994
 80094d8:	0800d084 	.word	0x0800d084
 80094dc:	200009a0 	.word	0x200009a0
 80094e0:	2000099c 	.word	0x2000099c
 80094e4:	20000998 	.word	0x20000998
 80094e8:	200009a4 	.word	0x200009a4

080094ec <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 80094ec:	b570      	push	{r4, r5, r6, lr}
 80094ee:	4604      	mov	r4, r0
 80094f0:	4616      	mov	r6, r2
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80094f2:	6b85      	ldr	r5, [r0, #56]	; 0x38

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80094f4:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80094f6:	b95a      	cbnz	r2, 8009510 <prvCopyDataToQueue+0x24>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80094f8:	6803      	ldr	r3, [r0, #0]
BaseType_t xReturn = pdFALSE;
 80094fa:	2000      	movs	r0, #0
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80094fc:	b113      	cbz	r3, 8009504 <prvCopyDataToQueue+0x18>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80094fe:	3501      	adds	r5, #1
 8009500:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 8009502:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8009504:	6860      	ldr	r0, [r4, #4]
 8009506:	f001 fa1d 	bl	800a944 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 800950a:	2300      	movs	r3, #0
 800950c:	6063      	str	r3, [r4, #4]
 800950e:	e7f6      	b.n	80094fe <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 8009510:	b96e      	cbnz	r6, 800952e <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8009512:	6880      	ldr	r0, [r0, #8]
 8009514:	f003 f8df 	bl	800c6d6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8009518:	68a3      	ldr	r3, [r4, #8]
 800951a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800951c:	4413      	add	r3, r2
 800951e:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8009520:	6862      	ldr	r2, [r4, #4]
 8009522:	4293      	cmp	r3, r2
 8009524:	d319      	bcc.n	800955a <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8009526:	6823      	ldr	r3, [r4, #0]
 8009528:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 800952a:	2000      	movs	r0, #0
 800952c:	e7e7      	b.n	80094fe <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800952e:	68c0      	ldr	r0, [r0, #12]
 8009530:	f003 f8d1 	bl	800c6d6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8009534:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009536:	4252      	negs	r2, r2
 8009538:	68e3      	ldr	r3, [r4, #12]
 800953a:	4413      	add	r3, r2
 800953c:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800953e:	6821      	ldr	r1, [r4, #0]
 8009540:	428b      	cmp	r3, r1
 8009542:	d202      	bcs.n	800954a <prvCopyDataToQueue+0x5e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8009544:	6863      	ldr	r3, [r4, #4]
 8009546:	441a      	add	r2, r3
 8009548:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800954a:	2e02      	cmp	r6, #2
 800954c:	d001      	beq.n	8009552 <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 800954e:	2000      	movs	r0, #0
 8009550:	e7d5      	b.n	80094fe <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8009552:	b125      	cbz	r5, 800955e <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 8009554:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
 8009556:	2000      	movs	r0, #0
 8009558:	e7d1      	b.n	80094fe <prvCopyDataToQueue+0x12>
 800955a:	2000      	movs	r0, #0
 800955c:	e7cf      	b.n	80094fe <prvCopyDataToQueue+0x12>
 800955e:	2000      	movs	r0, #0
 8009560:	e7cd      	b.n	80094fe <prvCopyDataToQueue+0x12>

08009562 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8009562:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8009564:	b172      	cbz	r2, 8009584 <prvCopyDataFromQueue+0x22>
{
 8009566:	b510      	push	{r4, lr}
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8009568:	68c3      	ldr	r3, [r0, #12]
 800956a:	4413      	add	r3, r2
 800956c:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800956e:	6844      	ldr	r4, [r0, #4]
 8009570:	42a3      	cmp	r3, r4
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8009572:	bf24      	itt	cs
 8009574:	6803      	ldrcs	r3, [r0, #0]
 8009576:	60c3      	strcs	r3, [r0, #12]
 8009578:	460c      	mov	r4, r1
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800957a:	68c1      	ldr	r1, [r0, #12]
 800957c:	4620      	mov	r0, r4
 800957e:	f003 f8aa 	bl	800c6d6 <memcpy>
 8009582:	bd10      	pop	{r4, pc}
 8009584:	4770      	bx	lr

08009586 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8009586:	b570      	push	{r4, r5, r6, lr}
 8009588:	4605      	mov	r5, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800958a:	f7ff fceb 	bl	8008f64 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800958e:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8009592:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009594:	2c00      	cmp	r4, #0
 8009596:	dd03      	ble.n	80095a0 <prvUnlockQueue+0x1a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009598:	6a6b      	ldr	r3, [r5, #36]	; 0x24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800959a:	f105 0624 	add.w	r6, r5, #36	; 0x24
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800959e:	b9e3      	cbnz	r3, 80095da <prvUnlockQueue+0x54>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 80095a0:	23ff      	movs	r3, #255	; 0xff
 80095a2:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 80095a6:	f7ff fcff 	bl	8008fa8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 80095aa:	f7ff fcdb 	bl	8008f64 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 80095ae:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 80095b2:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 80095b4:	2c00      	cmp	r4, #0
 80095b6:	dd03      	ble.n	80095c0 <prvUnlockQueue+0x3a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80095b8:	692b      	ldr	r3, [r5, #16]
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80095ba:	f105 0610 	add.w	r6, r5, #16
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80095be:	b9db      	cbnz	r3, 80095f8 <prvUnlockQueue+0x72>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 80095c0:	23ff      	movs	r3, #255	; 0xff
 80095c2:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80095c6:	f7ff fcef 	bl	8008fa8 <vPortExitCritical>
 80095ca:	bd70      	pop	{r4, r5, r6, pc}
 80095cc:	3c01      	subs	r4, #1
 80095ce:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80095d0:	2c00      	cmp	r4, #0
 80095d2:	d0e5      	beq.n	80095a0 <prvUnlockQueue+0x1a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80095d4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80095d6:	2b00      	cmp	r3, #0
 80095d8:	d0e2      	beq.n	80095a0 <prvUnlockQueue+0x1a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80095da:	4630      	mov	r0, r6
 80095dc:	f000 ff94 	bl	800a508 <xTaskRemoveFromEventList>
 80095e0:	2800      	cmp	r0, #0
 80095e2:	d0f3      	beq.n	80095cc <prvUnlockQueue+0x46>
						vTaskMissedYield();
 80095e4:	f001 f86a 	bl	800a6bc <vTaskMissedYield>
 80095e8:	e7f0      	b.n	80095cc <prvUnlockQueue+0x46>
 80095ea:	3c01      	subs	r4, #1
 80095ec:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80095ee:	2c00      	cmp	r4, #0
 80095f0:	d0e6      	beq.n	80095c0 <prvUnlockQueue+0x3a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80095f2:	692b      	ldr	r3, [r5, #16]
 80095f4:	2b00      	cmp	r3, #0
 80095f6:	d0e3      	beq.n	80095c0 <prvUnlockQueue+0x3a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80095f8:	4630      	mov	r0, r6
 80095fa:	f000 ff85 	bl	800a508 <xTaskRemoveFromEventList>
 80095fe:	2800      	cmp	r0, #0
 8009600:	d0f3      	beq.n	80095ea <prvUnlockQueue+0x64>
					vTaskMissedYield();
 8009602:	f001 f85b 	bl	800a6bc <vTaskMissedYield>
 8009606:	e7f0      	b.n	80095ea <prvUnlockQueue+0x64>

08009608 <xQueueGenericReset>:
{
 8009608:	b538      	push	{r3, r4, r5, lr}
 800960a:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 800960c:	4604      	mov	r4, r0
 800960e:	b1d0      	cbz	r0, 8009646 <xQueueGenericReset+0x3e>
	taskENTER_CRITICAL();
 8009610:	f7ff fca8 	bl	8008f64 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8009614:	6822      	ldr	r2, [r4, #0]
 8009616:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8009618:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800961a:	fb03 f301 	mul.w	r3, r3, r1
 800961e:	18d0      	adds	r0, r2, r3
 8009620:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009622:	2000      	movs	r0, #0
 8009624:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8009626:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8009628:	1a5b      	subs	r3, r3, r1
 800962a:	4413      	add	r3, r2
 800962c:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800962e:	23ff      	movs	r3, #255	; 0xff
 8009630:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8009634:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 8009638:	b9d5      	cbnz	r5, 8009670 <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800963a:	6923      	ldr	r3, [r4, #16]
 800963c:	b94b      	cbnz	r3, 8009652 <xQueueGenericReset+0x4a>
	taskEXIT_CRITICAL();
 800963e:	f7ff fcb3 	bl	8008fa8 <vPortExitCritical>
}
 8009642:	2001      	movs	r0, #1
 8009644:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxQueue );
 8009646:	f240 111b 	movw	r1, #283	; 0x11b
 800964a:	480e      	ldr	r0, [pc, #56]	; (8009684 <xQueueGenericReset+0x7c>)
 800964c:	f002 fe88 	bl	800c360 <vAssertCalled>
 8009650:	e7de      	b.n	8009610 <xQueueGenericReset+0x8>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8009652:	f104 0010 	add.w	r0, r4, #16
 8009656:	f000 ff57 	bl	800a508 <xTaskRemoveFromEventList>
 800965a:	2800      	cmp	r0, #0
 800965c:	d0ef      	beq.n	800963e <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 800965e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009662:	4b09      	ldr	r3, [pc, #36]	; (8009688 <xQueueGenericReset+0x80>)
 8009664:	601a      	str	r2, [r3, #0]
 8009666:	f3bf 8f4f 	dsb	sy
 800966a:	f3bf 8f6f 	isb	sy
 800966e:	e7e6      	b.n	800963e <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009670:	f104 0010 	add.w	r0, r4, #16
 8009674:	f7ff fbea 	bl	8008e4c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8009678:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800967c:	f7ff fbe6 	bl	8008e4c <vListInitialise>
 8009680:	e7dd      	b.n	800963e <xQueueGenericReset+0x36>
 8009682:	bf00      	nop
 8009684:	0800d0bc 	.word	0x0800d0bc
 8009688:	e000ed04 	.word	0xe000ed04

0800968c <xQueueGenericCreate>:
	{
 800968c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800968e:	460d      	mov	r5, r1
 8009690:	4617      	mov	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8009692:	4606      	mov	r6, r0
 8009694:	b1a0      	cbz	r0, 80096c0 <xQueueGenericCreate+0x34>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009696:	fb05 f006 	mul.w	r0, r5, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800969a:	3050      	adds	r0, #80	; 0x50
 800969c:	f7ff fdec 	bl	8009278 <pvPortMalloc>
		if( pxNewQueue != NULL )
 80096a0:	4604      	mov	r4, r0
 80096a2:	b158      	cbz	r0, 80096bc <xQueueGenericCreate+0x30>
	if( uxItemSize == ( UBaseType_t ) 0 )
 80096a4:	b195      	cbz	r5, 80096cc <xQueueGenericCreate+0x40>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 80096a6:	f100 0350 	add.w	r3, r0, #80	; 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80096aa:	6003      	str	r3, [r0, #0]
	pxNewQueue->uxLength = uxQueueLength;
 80096ac:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 80096ae:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80096b0:	2101      	movs	r1, #1
 80096b2:	4620      	mov	r0, r4
 80096b4:	f7ff ffa8 	bl	8009608 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 80096b8:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
	}
 80096bc:	4620      	mov	r0, r4
 80096be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80096c0:	f44f 71c4 	mov.w	r1, #392	; 0x188
 80096c4:	4802      	ldr	r0, [pc, #8]	; (80096d0 <xQueueGenericCreate+0x44>)
 80096c6:	f002 fe4b 	bl	800c360 <vAssertCalled>
 80096ca:	e7e4      	b.n	8009696 <xQueueGenericCreate+0xa>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80096cc:	6020      	str	r0, [r4, #0]
 80096ce:	e7ed      	b.n	80096ac <xQueueGenericCreate+0x20>
 80096d0:	0800d0bc 	.word	0x0800d0bc

080096d4 <xQueueCreateCountingSemaphore>:
	{
 80096d4:	b538      	push	{r3, r4, r5, lr}
 80096d6:	460d      	mov	r5, r1
		configASSERT( uxMaxCount != 0 );
 80096d8:	4604      	mov	r4, r0
 80096da:	b158      	cbz	r0, 80096f4 <xQueueCreateCountingSemaphore+0x20>
		configASSERT( uxInitialCount <= uxMaxCount );
 80096dc:	42ac      	cmp	r4, r5
 80096de:	d30f      	bcc.n	8009700 <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80096e0:	2202      	movs	r2, #2
 80096e2:	2100      	movs	r1, #0
 80096e4:	4620      	mov	r0, r4
 80096e6:	f7ff ffd1 	bl	800968c <xQueueGenericCreate>
		if( xHandle != NULL )
 80096ea:	4603      	mov	r3, r0
 80096ec:	b100      	cbz	r0, 80096f0 <xQueueCreateCountingSemaphore+0x1c>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80096ee:	6385      	str	r5, [r0, #56]	; 0x38
	}
 80096f0:	4618      	mov	r0, r3
 80096f2:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( uxMaxCount != 0 );
 80096f4:	f240 21d7 	movw	r1, #727	; 0x2d7
 80096f8:	4804      	ldr	r0, [pc, #16]	; (800970c <xQueueCreateCountingSemaphore+0x38>)
 80096fa:	f002 fe31 	bl	800c360 <vAssertCalled>
 80096fe:	e7ed      	b.n	80096dc <xQueueCreateCountingSemaphore+0x8>
		configASSERT( uxInitialCount <= uxMaxCount );
 8009700:	f44f 7136 	mov.w	r1, #728	; 0x2d8
 8009704:	4801      	ldr	r0, [pc, #4]	; (800970c <xQueueCreateCountingSemaphore+0x38>)
 8009706:	f002 fe2b 	bl	800c360 <vAssertCalled>
 800970a:	e7e9      	b.n	80096e0 <xQueueCreateCountingSemaphore+0xc>
 800970c:	0800d0bc 	.word	0x0800d0bc

08009710 <xQueueGenericSend>:
{
 8009710:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009714:	b084      	sub	sp, #16
 8009716:	4688      	mov	r8, r1
 8009718:	9201      	str	r2, [sp, #4]
 800971a:	461d      	mov	r5, r3
	configASSERT( pxQueue );
 800971c:	4604      	mov	r4, r0
 800971e:	b198      	cbz	r0, 8009748 <xQueueGenericSend+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8009720:	f1b8 0f00 	cmp.w	r8, #0
 8009724:	d016      	beq.n	8009754 <xQueueGenericSend+0x44>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8009726:	2d02      	cmp	r5, #2
 8009728:	d01d      	beq.n	8009766 <xQueueGenericSend+0x56>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800972a:	f001 f8ad 	bl	800a888 <xTaskGetSchedulerState>
 800972e:	b930      	cbnz	r0, 800973e <xQueueGenericSend+0x2e>
 8009730:	9b01      	ldr	r3, [sp, #4]
 8009732:	b123      	cbz	r3, 800973e <xQueueGenericSend+0x2e>
 8009734:	f44f 713e 	mov.w	r1, #760	; 0x2f8
 8009738:	4851      	ldr	r0, [pc, #324]	; (8009880 <xQueueGenericSend+0x170>)
 800973a:	f002 fe11 	bl	800c360 <vAssertCalled>
{
 800973e:	f04f 0900 	mov.w	r9, #0
		prvLockQueue( pxQueue );
 8009742:	464e      	mov	r6, r9
					portYIELD_WITHIN_API();
 8009744:	4f4f      	ldr	r7, [pc, #316]	; (8009884 <xQueueGenericSend+0x174>)
 8009746:	e04b      	b.n	80097e0 <xQueueGenericSend+0xd0>
	configASSERT( pxQueue );
 8009748:	f240 21f3 	movw	r1, #755	; 0x2f3
 800974c:	484c      	ldr	r0, [pc, #304]	; (8009880 <xQueueGenericSend+0x170>)
 800974e:	f002 fe07 	bl	800c360 <vAssertCalled>
 8009752:	e7e5      	b.n	8009720 <xQueueGenericSend+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8009754:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009756:	2b00      	cmp	r3, #0
 8009758:	d0e5      	beq.n	8009726 <xQueueGenericSend+0x16>
 800975a:	f44f 713d 	mov.w	r1, #756	; 0x2f4
 800975e:	4848      	ldr	r0, [pc, #288]	; (8009880 <xQueueGenericSend+0x170>)
 8009760:	f002 fdfe 	bl	800c360 <vAssertCalled>
 8009764:	e7df      	b.n	8009726 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8009766:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009768:	2b01      	cmp	r3, #1
 800976a:	d0de      	beq.n	800972a <xQueueGenericSend+0x1a>
 800976c:	f240 21f5 	movw	r1, #757	; 0x2f5
 8009770:	4843      	ldr	r0, [pc, #268]	; (8009880 <xQueueGenericSend+0x170>)
 8009772:	f002 fdf5 	bl	800c360 <vAssertCalled>
 8009776:	e7d8      	b.n	800972a <xQueueGenericSend+0x1a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8009778:	462a      	mov	r2, r5
 800977a:	4641      	mov	r1, r8
 800977c:	4620      	mov	r0, r4
 800977e:	f7ff feb5 	bl	80094ec <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009782:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009784:	b973      	cbnz	r3, 80097a4 <xQueueGenericSend+0x94>
					else if( xYieldRequired != pdFALSE )
 8009786:	b138      	cbz	r0, 8009798 <xQueueGenericSend+0x88>
						queueYIELD_IF_USING_PREEMPTION();
 8009788:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800978c:	4b3d      	ldr	r3, [pc, #244]	; (8009884 <xQueueGenericSend+0x174>)
 800978e:	601a      	str	r2, [r3, #0]
 8009790:	f3bf 8f4f 	dsb	sy
 8009794:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8009798:	f7ff fc06 	bl	8008fa8 <vPortExitCritical>
				return pdPASS;
 800979c:	2001      	movs	r0, #1
}
 800979e:	b004      	add	sp, #16
 80097a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80097a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80097a8:	f000 feae 	bl	800a508 <xTaskRemoveFromEventList>
 80097ac:	2800      	cmp	r0, #0
 80097ae:	d0f3      	beq.n	8009798 <xQueueGenericSend+0x88>
							queueYIELD_IF_USING_PREEMPTION();
 80097b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80097b4:	4b33      	ldr	r3, [pc, #204]	; (8009884 <xQueueGenericSend+0x174>)
 80097b6:	601a      	str	r2, [r3, #0]
 80097b8:	f3bf 8f4f 	dsb	sy
 80097bc:	f3bf 8f6f 	isb	sy
 80097c0:	e7ea      	b.n	8009798 <xQueueGenericSend+0x88>
					taskEXIT_CRITICAL();
 80097c2:	f7ff fbf1 	bl	8008fa8 <vPortExitCritical>
					return errQUEUE_FULL;
 80097c6:	2000      	movs	r0, #0
 80097c8:	e7e9      	b.n	800979e <xQueueGenericSend+0x8e>
					vTaskSetTimeOutState( &xTimeOut );
 80097ca:	a802      	add	r0, sp, #8
 80097cc:	f000 ff24 	bl	800a618 <vTaskSetTimeOutState>
 80097d0:	e014      	b.n	80097fc <xQueueGenericSend+0xec>
				prvUnlockQueue( pxQueue );
 80097d2:	4620      	mov	r0, r4
 80097d4:	f7ff fed7 	bl	8009586 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80097d8:	f000 fcfc 	bl	800a1d4 <xTaskResumeAll>
 80097dc:	f04f 0901 	mov.w	r9, #1
		taskENTER_CRITICAL();
 80097e0:	f7ff fbc0 	bl	8008f64 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80097e4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80097e6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80097e8:	429a      	cmp	r2, r3
 80097ea:	d3c5      	bcc.n	8009778 <xQueueGenericSend+0x68>
 80097ec:	2d02      	cmp	r5, #2
 80097ee:	d0c3      	beq.n	8009778 <xQueueGenericSend+0x68>
				if( xTicksToWait == ( TickType_t ) 0 )
 80097f0:	9b01      	ldr	r3, [sp, #4]
 80097f2:	2b00      	cmp	r3, #0
 80097f4:	d0e5      	beq.n	80097c2 <xQueueGenericSend+0xb2>
				else if( xEntryTimeSet == pdFALSE )
 80097f6:	f1b9 0f00 	cmp.w	r9, #0
 80097fa:	d0e6      	beq.n	80097ca <xQueueGenericSend+0xba>
		taskEXIT_CRITICAL();
 80097fc:	f7ff fbd4 	bl	8008fa8 <vPortExitCritical>
		vTaskSuspendAll();
 8009800:	f000 fc0e 	bl	800a020 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8009804:	f7ff fbae 	bl	8008f64 <vPortEnterCritical>
 8009808:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800980c:	b25b      	sxtb	r3, r3
 800980e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009812:	bf08      	it	eq
 8009814:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
 8009818:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800981c:	b25b      	sxtb	r3, r3
 800981e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009822:	bf08      	it	eq
 8009824:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
 8009828:	f7ff fbbe 	bl	8008fa8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800982c:	a901      	add	r1, sp, #4
 800982e:	a802      	add	r0, sp, #8
 8009830:	f000 ff08 	bl	800a644 <xTaskCheckForTimeOut>
 8009834:	b9e8      	cbnz	r0, 8009872 <xQueueGenericSend+0x162>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8009836:	f7ff fb95 	bl	8008f64 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800983a:	f8d4 a038 	ldr.w	sl, [r4, #56]	; 0x38
 800983e:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8009842:	f7ff fbb1 	bl	8008fa8 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8009846:	45ca      	cmp	sl, r9
 8009848:	d1c3      	bne.n	80097d2 <xQueueGenericSend+0xc2>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800984a:	9901      	ldr	r1, [sp, #4]
 800984c:	f104 0010 	add.w	r0, r4, #16
 8009850:	f000 fe16 	bl	800a480 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8009854:	4620      	mov	r0, r4
 8009856:	f7ff fe96 	bl	8009586 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800985a:	f000 fcbb 	bl	800a1d4 <xTaskResumeAll>
 800985e:	2800      	cmp	r0, #0
 8009860:	d1bc      	bne.n	80097dc <xQueueGenericSend+0xcc>
					portYIELD_WITHIN_API();
 8009862:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8009866:	603b      	str	r3, [r7, #0]
 8009868:	f3bf 8f4f 	dsb	sy
 800986c:	f3bf 8f6f 	isb	sy
 8009870:	e7b4      	b.n	80097dc <xQueueGenericSend+0xcc>
			prvUnlockQueue( pxQueue );
 8009872:	4620      	mov	r0, r4
 8009874:	f7ff fe87 	bl	8009586 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8009878:	f000 fcac 	bl	800a1d4 <xTaskResumeAll>
			return errQUEUE_FULL;
 800987c:	2000      	movs	r0, #0
 800987e:	e78e      	b.n	800979e <xQueueGenericSend+0x8e>
 8009880:	0800d0bc 	.word	0x0800d0bc
 8009884:	e000ed04 	.word	0xe000ed04

08009888 <xQueueGiveFromISR>:
{
 8009888:	b570      	push	{r4, r5, r6, lr}
 800988a:	460e      	mov	r6, r1
	configASSERT( pxQueue );
 800988c:	4604      	mov	r4, r0
 800988e:	b318      	cbz	r0, 80098d8 <xQueueGiveFromISR+0x50>
	configASSERT( pxQueue->uxItemSize == 0 );
 8009890:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8009892:	bb3b      	cbnz	r3, 80098e4 <xQueueGiveFromISR+0x5c>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8009894:	6823      	ldr	r3, [r4, #0]
 8009896:	b35b      	cbz	r3, 80098f0 <xQueueGiveFromISR+0x68>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8009898:	f7ff fc96 	bl	80091c8 <vPortValidateInterruptPriority>
	__asm volatile
 800989c:	f3ef 8511 	mrs	r5, BASEPRI
 80098a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80098a4:	f383 8811 	msr	BASEPRI, r3
 80098a8:	f3bf 8f6f 	isb	sy
 80098ac:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80098b0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 80098b2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80098b4:	429a      	cmp	r2, r3
 80098b6:	d231      	bcs.n	800991c <xQueueGiveFromISR+0x94>
			const int8_t cTxLock = pxQueue->cTxLock;
 80098b8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80098bc:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80098be:	3201      	adds	r2, #1
 80098c0:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 80098c2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80098c6:	d01c      	beq.n	8009902 <xQueueGiveFromISR+0x7a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80098c8:	3301      	adds	r3, #1
 80098ca:	b25b      	sxtb	r3, r3
 80098cc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 80098d0:	2001      	movs	r0, #1
	__asm volatile
 80098d2:	f385 8811 	msr	BASEPRI, r5
}
 80098d6:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
 80098d8:	f240 4156 	movw	r1, #1110	; 0x456
 80098dc:	4812      	ldr	r0, [pc, #72]	; (8009928 <xQueueGiveFromISR+0xa0>)
 80098de:	f002 fd3f 	bl	800c360 <vAssertCalled>
 80098e2:	e7d5      	b.n	8009890 <xQueueGiveFromISR+0x8>
	configASSERT( pxQueue->uxItemSize == 0 );
 80098e4:	f240 415a 	movw	r1, #1114	; 0x45a
 80098e8:	480f      	ldr	r0, [pc, #60]	; (8009928 <xQueueGiveFromISR+0xa0>)
 80098ea:	f002 fd39 	bl	800c360 <vAssertCalled>
 80098ee:	e7d1      	b.n	8009894 <xQueueGiveFromISR+0xc>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 80098f0:	6863      	ldr	r3, [r4, #4]
 80098f2:	2b00      	cmp	r3, #0
 80098f4:	d0d0      	beq.n	8009898 <xQueueGiveFromISR+0x10>
 80098f6:	f240 415f 	movw	r1, #1119	; 0x45f
 80098fa:	480b      	ldr	r0, [pc, #44]	; (8009928 <xQueueGiveFromISR+0xa0>)
 80098fc:	f002 fd30 	bl	800c360 <vAssertCalled>
 8009900:	e7ca      	b.n	8009898 <xQueueGiveFromISR+0x10>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009902:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009904:	b90b      	cbnz	r3, 800990a <xQueueGiveFromISR+0x82>
			xReturn = pdPASS;
 8009906:	2001      	movs	r0, #1
 8009908:	e7e3      	b.n	80098d2 <xQueueGiveFromISR+0x4a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800990a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800990e:	f000 fdfb 	bl	800a508 <xTaskRemoveFromEventList>
 8009912:	b128      	cbz	r0, 8009920 <xQueueGiveFromISR+0x98>
							if( pxHigherPriorityTaskWoken != NULL )
 8009914:	b136      	cbz	r6, 8009924 <xQueueGiveFromISR+0x9c>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8009916:	2001      	movs	r0, #1
 8009918:	6030      	str	r0, [r6, #0]
 800991a:	e7da      	b.n	80098d2 <xQueueGiveFromISR+0x4a>
			xReturn = errQUEUE_FULL;
 800991c:	2000      	movs	r0, #0
 800991e:	e7d8      	b.n	80098d2 <xQueueGiveFromISR+0x4a>
			xReturn = pdPASS;
 8009920:	2001      	movs	r0, #1
 8009922:	e7d6      	b.n	80098d2 <xQueueGiveFromISR+0x4a>
 8009924:	2001      	movs	r0, #1
 8009926:	e7d4      	b.n	80098d2 <xQueueGiveFromISR+0x4a>
 8009928:	0800d0bc 	.word	0x0800d0bc

0800992c <xQueueGenericReceive>:
{
 800992c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009930:	b084      	sub	sp, #16
 8009932:	4689      	mov	r9, r1
 8009934:	9201      	str	r2, [sp, #4]
 8009936:	4698      	mov	r8, r3
	configASSERT( pxQueue );
 8009938:	4604      	mov	r4, r0
 800993a:	b188      	cbz	r0, 8009960 <xQueueGenericReceive+0x34>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800993c:	f1b9 0f00 	cmp.w	r9, #0
 8009940:	d014      	beq.n	800996c <xQueueGenericReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8009942:	f000 ffa1 	bl	800a888 <xTaskGetSchedulerState>
 8009946:	b930      	cbnz	r0, 8009956 <xQueueGenericReceive+0x2a>
 8009948:	9b01      	ldr	r3, [sp, #4]
 800994a:	b123      	cbz	r3, 8009956 <xQueueGenericReceive+0x2a>
 800994c:	f240 41fa 	movw	r1, #1274	; 0x4fa
 8009950:	485e      	ldr	r0, [pc, #376]	; (8009acc <xQueueGenericReceive+0x1a0>)
 8009952:	f002 fd05 	bl	800c360 <vAssertCalled>
{
 8009956:	f04f 0a00 	mov.w	sl, #0
		prvLockQueue( pxQueue );
 800995a:	4655      	mov	r5, sl
					portYIELD_WITHIN_API();
 800995c:	4e5c      	ldr	r6, [pc, #368]	; (8009ad0 <xQueueGenericReceive+0x1a4>)
 800995e:	e06c      	b.n	8009a3a <xQueueGenericReceive+0x10e>
	configASSERT( pxQueue );
 8009960:	f240 41f6 	movw	r1, #1270	; 0x4f6
 8009964:	4859      	ldr	r0, [pc, #356]	; (8009acc <xQueueGenericReceive+0x1a0>)
 8009966:	f002 fcfb 	bl	800c360 <vAssertCalled>
 800996a:	e7e7      	b.n	800993c <xQueueGenericReceive+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800996c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800996e:	2b00      	cmp	r3, #0
 8009970:	d0e7      	beq.n	8009942 <xQueueGenericReceive+0x16>
 8009972:	f240 41f7 	movw	r1, #1271	; 0x4f7
 8009976:	4855      	ldr	r0, [pc, #340]	; (8009acc <xQueueGenericReceive+0x1a0>)
 8009978:	f002 fcf2 	bl	800c360 <vAssertCalled>
 800997c:	e7e1      	b.n	8009942 <xQueueGenericReceive+0x16>
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800997e:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8009980:	4649      	mov	r1, r9
 8009982:	4620      	mov	r0, r4
 8009984:	f7ff fded 	bl	8009562 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8009988:	f1b8 0f00 	cmp.w	r8, #0
 800998c:	d11e      	bne.n	80099cc <xQueueGenericReceive+0xa0>
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800998e:	1e7b      	subs	r3, r7, #1
 8009990:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8009992:	6823      	ldr	r3, [r4, #0]
 8009994:	b13b      	cbz	r3, 80099a6 <xQueueGenericReceive+0x7a>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8009996:	6923      	ldr	r3, [r4, #16]
 8009998:	b94b      	cbnz	r3, 80099ae <xQueueGenericReceive+0x82>
				taskEXIT_CRITICAL();
 800999a:	f7ff fb05 	bl	8008fa8 <vPortExitCritical>
				return pdPASS;
 800999e:	2001      	movs	r0, #1
}
 80099a0:	b004      	add	sp, #16
 80099a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 80099a6:	f001 f913 	bl	800abd0 <pvTaskIncrementMutexHeldCount>
 80099aa:	6060      	str	r0, [r4, #4]
 80099ac:	e7f3      	b.n	8009996 <xQueueGenericReceive+0x6a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80099ae:	f104 0010 	add.w	r0, r4, #16
 80099b2:	f000 fda9 	bl	800a508 <xTaskRemoveFromEventList>
 80099b6:	2800      	cmp	r0, #0
 80099b8:	d0ef      	beq.n	800999a <xQueueGenericReceive+0x6e>
							queueYIELD_IF_USING_PREEMPTION();
 80099ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80099be:	4b44      	ldr	r3, [pc, #272]	; (8009ad0 <xQueueGenericReceive+0x1a4>)
 80099c0:	601a      	str	r2, [r3, #0]
 80099c2:	f3bf 8f4f 	dsb	sy
 80099c6:	f3bf 8f6f 	isb	sy
 80099ca:	e7e6      	b.n	800999a <xQueueGenericReceive+0x6e>
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 80099cc:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80099ce:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80099d0:	2b00      	cmp	r3, #0
 80099d2:	d0e2      	beq.n	800999a <xQueueGenericReceive+0x6e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80099d4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80099d8:	f000 fd96 	bl	800a508 <xTaskRemoveFromEventList>
 80099dc:	2800      	cmp	r0, #0
 80099de:	d0dc      	beq.n	800999a <xQueueGenericReceive+0x6e>
							queueYIELD_IF_USING_PREEMPTION();
 80099e0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80099e4:	4b3a      	ldr	r3, [pc, #232]	; (8009ad0 <xQueueGenericReceive+0x1a4>)
 80099e6:	601a      	str	r2, [r3, #0]
 80099e8:	f3bf 8f4f 	dsb	sy
 80099ec:	f3bf 8f6f 	isb	sy
 80099f0:	e7d3      	b.n	800999a <xQueueGenericReceive+0x6e>
					taskEXIT_CRITICAL();
 80099f2:	f7ff fad9 	bl	8008fa8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80099f6:	2000      	movs	r0, #0
 80099f8:	e7d2      	b.n	80099a0 <xQueueGenericReceive+0x74>
					vTaskSetTimeOutState( &xTimeOut );
 80099fa:	a802      	add	r0, sp, #8
 80099fc:	f000 fe0c 	bl	800a618 <vTaskSetTimeOutState>
 8009a00:	e026      	b.n	8009a50 <xQueueGenericReceive+0x124>
						taskENTER_CRITICAL();
 8009a02:	f7ff faaf 	bl	8008f64 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8009a06:	6860      	ldr	r0, [r4, #4]
 8009a08:	f000 ff4e 	bl	800a8a8 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8009a0c:	f7ff facc 	bl	8008fa8 <vPortExitCritical>
 8009a10:	e046      	b.n	8009aa0 <xQueueGenericReceive+0x174>
				prvUnlockQueue( pxQueue );
 8009a12:	4620      	mov	r0, r4
 8009a14:	f7ff fdb7 	bl	8009586 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8009a18:	f000 fbdc 	bl	800a1d4 <xTaskResumeAll>
 8009a1c:	e00b      	b.n	8009a36 <xQueueGenericReceive+0x10a>
			prvUnlockQueue( pxQueue );
 8009a1e:	4620      	mov	r0, r4
 8009a20:	f7ff fdb1 	bl	8009586 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8009a24:	f000 fbd6 	bl	800a1d4 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8009a28:	f7ff fa9c 	bl	8008f64 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8009a2c:	6ba7      	ldr	r7, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8009a2e:	f7ff fabb 	bl	8008fa8 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8009a32:	2f00      	cmp	r7, #0
 8009a34:	d048      	beq.n	8009ac8 <xQueueGenericReceive+0x19c>
 8009a36:	f04f 0a01 	mov.w	sl, #1
		taskENTER_CRITICAL();
 8009a3a:	f7ff fa93 	bl	8008f64 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8009a3e:	6ba7      	ldr	r7, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8009a40:	2f00      	cmp	r7, #0
 8009a42:	d19c      	bne.n	800997e <xQueueGenericReceive+0x52>
				if( xTicksToWait == ( TickType_t ) 0 )
 8009a44:	9b01      	ldr	r3, [sp, #4]
 8009a46:	2b00      	cmp	r3, #0
 8009a48:	d0d3      	beq.n	80099f2 <xQueueGenericReceive+0xc6>
				else if( xEntryTimeSet == pdFALSE )
 8009a4a:	f1ba 0f00 	cmp.w	sl, #0
 8009a4e:	d0d4      	beq.n	80099fa <xQueueGenericReceive+0xce>
		taskEXIT_CRITICAL();
 8009a50:	f7ff faaa 	bl	8008fa8 <vPortExitCritical>
		vTaskSuspendAll();
 8009a54:	f000 fae4 	bl	800a020 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8009a58:	f7ff fa84 	bl	8008f64 <vPortEnterCritical>
 8009a5c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8009a60:	b25b      	sxtb	r3, r3
 8009a62:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009a66:	bf08      	it	eq
 8009a68:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
 8009a6c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8009a70:	b25b      	sxtb	r3, r3
 8009a72:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009a76:	bf08      	it	eq
 8009a78:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
 8009a7c:	f7ff fa94 	bl	8008fa8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8009a80:	a901      	add	r1, sp, #4
 8009a82:	a802      	add	r0, sp, #8
 8009a84:	f000 fdde 	bl	800a644 <xTaskCheckForTimeOut>
 8009a88:	2800      	cmp	r0, #0
 8009a8a:	d1c8      	bne.n	8009a1e <xQueueGenericReceive+0xf2>
	taskENTER_CRITICAL();
 8009a8c:	f7ff fa6a 	bl	8008f64 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8009a90:	6ba7      	ldr	r7, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8009a92:	f7ff fa89 	bl	8008fa8 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8009a96:	2f00      	cmp	r7, #0
 8009a98:	d1bb      	bne.n	8009a12 <xQueueGenericReceive+0xe6>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8009a9a:	6823      	ldr	r3, [r4, #0]
 8009a9c:	2b00      	cmp	r3, #0
 8009a9e:	d0b0      	beq.n	8009a02 <xQueueGenericReceive+0xd6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8009aa0:	9901      	ldr	r1, [sp, #4]
 8009aa2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009aa6:	f000 fceb 	bl	800a480 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8009aaa:	4620      	mov	r0, r4
 8009aac:	f7ff fd6b 	bl	8009586 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8009ab0:	f000 fb90 	bl	800a1d4 <xTaskResumeAll>
 8009ab4:	2800      	cmp	r0, #0
 8009ab6:	d1be      	bne.n	8009a36 <xQueueGenericReceive+0x10a>
					portYIELD_WITHIN_API();
 8009ab8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8009abc:	6033      	str	r3, [r6, #0]
 8009abe:	f3bf 8f4f 	dsb	sy
 8009ac2:	f3bf 8f6f 	isb	sy
 8009ac6:	e7b6      	b.n	8009a36 <xQueueGenericReceive+0x10a>
				return errQUEUE_EMPTY;
 8009ac8:	2000      	movs	r0, #0
 8009aca:	e769      	b.n	80099a0 <xQueueGenericReceive+0x74>
 8009acc:	0800d0bc 	.word	0x0800d0bc
 8009ad0:	e000ed04 	.word	0xe000ed04

08009ad4 <uxQueueMessagesWaiting>:
{
 8009ad4:	b510      	push	{r4, lr}
	configASSERT( xQueue );
 8009ad6:	4604      	mov	r4, r0
 8009ad8:	b130      	cbz	r0, 8009ae8 <uxQueueMessagesWaiting+0x14>
	taskENTER_CRITICAL();
 8009ada:	f7ff fa43 	bl	8008f64 <vPortEnterCritical>
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8009ade:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8009ae0:	f7ff fa62 	bl	8008fa8 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8009ae4:	4620      	mov	r0, r4
 8009ae6:	bd10      	pop	{r4, pc}
	configASSERT( xQueue );
 8009ae8:	f240 6149 	movw	r1, #1609	; 0x649
 8009aec:	4801      	ldr	r0, [pc, #4]	; (8009af4 <uxQueueMessagesWaiting+0x20>)
 8009aee:	f002 fc37 	bl	800c360 <vAssertCalled>
 8009af2:	e7f2      	b.n	8009ada <uxQueueMessagesWaiting+0x6>
 8009af4:	0800d0bc 	.word	0x0800d0bc

08009af8 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8009af8:	b410      	push	{r4}

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8009afa:	4b0b      	ldr	r3, [pc, #44]	; (8009b28 <vQueueAddToRegistry+0x30>)
 8009afc:	681b      	ldr	r3, [r3, #0]
 8009afe:	b153      	cbz	r3, 8009b16 <vQueueAddToRegistry+0x1e>
 8009b00:	2301      	movs	r3, #1
 8009b02:	4c09      	ldr	r4, [pc, #36]	; (8009b28 <vQueueAddToRegistry+0x30>)
 8009b04:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
 8009b08:	b132      	cbz	r2, 8009b18 <vQueueAddToRegistry+0x20>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8009b0a:	3301      	adds	r3, #1
 8009b0c:	2b08      	cmp	r3, #8
 8009b0e:	d1f9      	bne.n	8009b04 <vQueueAddToRegistry+0xc>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8009b10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009b14:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8009b16:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8009b18:	4a03      	ldr	r2, [pc, #12]	; (8009b28 <vQueueAddToRegistry+0x30>)
 8009b1a:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8009b1e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8009b22:	6058      	str	r0, [r3, #4]
				break;
 8009b24:	e7f4      	b.n	8009b10 <vQueueAddToRegistry+0x18>
 8009b26:	bf00      	nop
 8009b28:	20004cdc 	.word	0x20004cdc

08009b2c <vQueueUnregisterQueue>:

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8009b2c:	4b0b      	ldr	r3, [pc, #44]	; (8009b5c <vQueueUnregisterQueue+0x30>)
 8009b2e:	685b      	ldr	r3, [r3, #4]
 8009b30:	4298      	cmp	r0, r3
 8009b32:	d009      	beq.n	8009b48 <vQueueUnregisterQueue+0x1c>
 8009b34:	4a09      	ldr	r2, [pc, #36]	; (8009b5c <vQueueUnregisterQueue+0x30>)
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8009b36:	2301      	movs	r3, #1
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8009b38:	68d1      	ldr	r1, [r2, #12]
 8009b3a:	4281      	cmp	r1, r0
 8009b3c:	d005      	beq.n	8009b4a <vQueueUnregisterQueue+0x1e>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8009b3e:	3301      	adds	r3, #1
 8009b40:	3208      	adds	r2, #8
 8009b42:	2b08      	cmp	r3, #8
 8009b44:	d1f8      	bne.n	8009b38 <vQueueUnregisterQueue+0xc>
 8009b46:	4770      	bx	lr
 8009b48:	2300      	movs	r3, #0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 8009b4a:	4a04      	ldr	r2, [pc, #16]	; (8009b5c <vQueueUnregisterQueue+0x30>)
 8009b4c:	2100      	movs	r1, #0
 8009b4e:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 8009b52:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8009b56:	6059      	str	r1, [r3, #4]
				break;
 8009b58:	4770      	bx	lr
 8009b5a:	bf00      	nop
 8009b5c:	20004cdc 	.word	0x20004cdc

08009b60 <vQueueDelete>:
{
 8009b60:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
 8009b62:	4604      	mov	r4, r0
 8009b64:	b130      	cbz	r0, 8009b74 <vQueueDelete+0x14>
		vQueueUnregisterQueue( pxQueue );
 8009b66:	4620      	mov	r0, r4
 8009b68:	f7ff ffe0 	bl	8009b2c <vQueueUnregisterQueue>
		vPortFree( pxQueue );
 8009b6c:	4620      	mov	r0, r4
 8009b6e:	f7ff fbe9 	bl	8009344 <vPortFree>
 8009b72:	bd10      	pop	{r4, pc}
	configASSERT( pxQueue );
 8009b74:	f240 6177 	movw	r1, #1655	; 0x677
 8009b78:	4801      	ldr	r0, [pc, #4]	; (8009b80 <vQueueDelete+0x20>)
 8009b7a:	f002 fbf1 	bl	800c360 <vAssertCalled>
 8009b7e:	e7f2      	b.n	8009b66 <vQueueDelete+0x6>
 8009b80:	0800d0bc 	.word	0x0800d0bc

08009b84 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8009b84:	4b08      	ldr	r3, [pc, #32]	; (8009ba8 <prvResetNextTaskUnblockTime+0x24>)
 8009b86:	681b      	ldr	r3, [r3, #0]
 8009b88:	681b      	ldr	r3, [r3, #0]
 8009b8a:	b13b      	cbz	r3, 8009b9c <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8009b8c:	4b06      	ldr	r3, [pc, #24]	; (8009ba8 <prvResetNextTaskUnblockTime+0x24>)
 8009b8e:	681b      	ldr	r3, [r3, #0]
 8009b90:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8009b92:	68db      	ldr	r3, [r3, #12]
 8009b94:	685a      	ldr	r2, [r3, #4]
 8009b96:	4b05      	ldr	r3, [pc, #20]	; (8009bac <prvResetNextTaskUnblockTime+0x28>)
 8009b98:	601a      	str	r2, [r3, #0]
 8009b9a:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
 8009b9c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009ba0:	4b02      	ldr	r3, [pc, #8]	; (8009bac <prvResetNextTaskUnblockTime+0x28>)
 8009ba2:	601a      	str	r2, [r3, #0]
 8009ba4:	4770      	bx	lr
 8009ba6:	bf00      	nop
 8009ba8:	200009b0 	.word	0x200009b0
 8009bac:	20000a8c 	.word	0x20000a8c

08009bb0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8009bb0:	b570      	push	{r4, r5, r6, lr}
 8009bb2:	4604      	mov	r4, r0
 8009bb4:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8009bb6:	4b1d      	ldr	r3, [pc, #116]	; (8009c2c <prvAddCurrentTaskToDelayedList+0x7c>)
 8009bb8:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8009bba:	4b1d      	ldr	r3, [pc, #116]	; (8009c30 <prvAddCurrentTaskToDelayedList+0x80>)
 8009bbc:	6818      	ldr	r0, [r3, #0]
 8009bbe:	3004      	adds	r0, #4
 8009bc0:	f7ff f978 	bl	8008eb4 <uxListRemove>
 8009bc4:	b948      	cbnz	r0, 8009bda <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8009bc6:	4b1a      	ldr	r3, [pc, #104]	; (8009c30 <prvAddCurrentTaskToDelayedList+0x80>)
 8009bc8:	681a      	ldr	r2, [r3, #0]
 8009bca:	491a      	ldr	r1, [pc, #104]	; (8009c34 <prvAddCurrentTaskToDelayedList+0x84>)
 8009bcc:	680b      	ldr	r3, [r1, #0]
 8009bce:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8009bd0:	2201      	movs	r2, #1
 8009bd2:	4082      	lsls	r2, r0
 8009bd4:	ea23 0302 	bic.w	r3, r3, r2
 8009bd8:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8009bda:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 8009bde:	d013      	beq.n	8009c08 <prvAddCurrentTaskToDelayedList+0x58>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8009be0:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8009be2:	4b13      	ldr	r3, [pc, #76]	; (8009c30 <prvAddCurrentTaskToDelayedList+0x80>)
 8009be4:	681b      	ldr	r3, [r3, #0]
 8009be6:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8009be8:	42a5      	cmp	r5, r4
 8009bea:	d816      	bhi.n	8009c1a <prvAddCurrentTaskToDelayedList+0x6a>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8009bec:	4b12      	ldr	r3, [pc, #72]	; (8009c38 <prvAddCurrentTaskToDelayedList+0x88>)
 8009bee:	6818      	ldr	r0, [r3, #0]
 8009bf0:	4b0f      	ldr	r3, [pc, #60]	; (8009c30 <prvAddCurrentTaskToDelayedList+0x80>)
 8009bf2:	6819      	ldr	r1, [r3, #0]
 8009bf4:	3104      	adds	r1, #4
 8009bf6:	f7ff f943 	bl	8008e80 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 8009bfa:	4b10      	ldr	r3, [pc, #64]	; (8009c3c <prvAddCurrentTaskToDelayedList+0x8c>)
 8009bfc:	681b      	ldr	r3, [r3, #0]
 8009bfe:	429c      	cmp	r4, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
 8009c00:	bf3c      	itt	cc
 8009c02:	4b0e      	ldrcc	r3, [pc, #56]	; (8009c3c <prvAddCurrentTaskToDelayedList+0x8c>)
 8009c04:	601c      	strcc	r4, [r3, #0]
 8009c06:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8009c08:	2e00      	cmp	r6, #0
 8009c0a:	d0e9      	beq.n	8009be0 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8009c0c:	4b08      	ldr	r3, [pc, #32]	; (8009c30 <prvAddCurrentTaskToDelayedList+0x80>)
 8009c0e:	6819      	ldr	r1, [r3, #0]
 8009c10:	3104      	adds	r1, #4
 8009c12:	480b      	ldr	r0, [pc, #44]	; (8009c40 <prvAddCurrentTaskToDelayedList+0x90>)
 8009c14:	f7ff f928 	bl	8008e68 <vListInsertEnd>
 8009c18:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8009c1a:	4b0a      	ldr	r3, [pc, #40]	; (8009c44 <prvAddCurrentTaskToDelayedList+0x94>)
 8009c1c:	6818      	ldr	r0, [r3, #0]
 8009c1e:	4b04      	ldr	r3, [pc, #16]	; (8009c30 <prvAddCurrentTaskToDelayedList+0x80>)
 8009c20:	6819      	ldr	r1, [r3, #0]
 8009c22:	3104      	adds	r1, #4
 8009c24:	f7ff f92c 	bl	8008e80 <vListInsert>
 8009c28:	bd70      	pop	{r4, r5, r6, pc}
 8009c2a:	bf00      	nop
 8009c2c:	20000ad4 	.word	0x20000ad4
 8009c30:	200009ac 	.word	0x200009ac
 8009c34:	20000a5c 	.word	0x20000a5c
 8009c38:	200009b0 	.word	0x200009b0
 8009c3c:	20000a8c 	.word	0x20000a8c
 8009c40:	20000aac 	.word	0x20000aac
 8009c44:	200009b4 	.word	0x200009b4

08009c48 <prvWriteNameToBuffer>:
	{
 8009c48:	b510      	push	{r4, lr}
 8009c4a:	4604      	mov	r4, r0
		strcpy( pcBuffer, pcTaskName );
 8009c4c:	f002 fd70 	bl	800c730 <strcpy>
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 8009c50:	4620      	mov	r0, r4
 8009c52:	f7f6 fabd 	bl	80001d0 <strlen>
 8009c56:	280e      	cmp	r0, #14
 8009c58:	d808      	bhi.n	8009c6c <prvWriteNameToBuffer+0x24>
 8009c5a:	4420      	add	r0, r4
 8009c5c:	f104 020f 	add.w	r2, r4, #15
			pcBuffer[ x ] = ' ';
 8009c60:	2320      	movs	r3, #32
 8009c62:	f800 3b01 	strb.w	r3, [r0], #1
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
 8009c66:	4290      	cmp	r0, r2
 8009c68:	d1fb      	bne.n	8009c62 <prvWriteNameToBuffer+0x1a>
 8009c6a:	200f      	movs	r0, #15
		pcBuffer[ x ] = 0x00;
 8009c6c:	2300      	movs	r3, #0
 8009c6e:	5423      	strb	r3, [r4, r0]
	}
 8009c70:	4420      	add	r0, r4
 8009c72:	bd10      	pop	{r4, pc}

08009c74 <xTaskCreate>:
	{
 8009c74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009c78:	b083      	sub	sp, #12
 8009c7a:	9001      	str	r0, [sp, #4]
 8009c7c:	4689      	mov	r9, r1
 8009c7e:	4698      	mov	r8, r3
 8009c80:	9e0d      	ldr	r6, [sp, #52]	; 0x34
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009c82:	0095      	lsls	r5, r2, #2
 8009c84:	4628      	mov	r0, r5
 8009c86:	f7ff faf7 	bl	8009278 <pvPortMalloc>
			if( pxStack != NULL )
 8009c8a:	2800      	cmp	r0, #0
 8009c8c:	f000 8091 	beq.w	8009db2 <xTaskCreate+0x13e>
 8009c90:	4607      	mov	r7, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8009c92:	206c      	movs	r0, #108	; 0x6c
 8009c94:	f7ff faf0 	bl	8009278 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8009c98:	4604      	mov	r4, r0
 8009c9a:	2800      	cmp	r0, #0
 8009c9c:	f000 8086 	beq.w	8009dac <xTaskCreate+0x138>
					pxNewTCB->pxStack = pxStack;
 8009ca0:	6307      	str	r7, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8009ca2:	462a      	mov	r2, r5
 8009ca4:	21a5      	movs	r1, #165	; 0xa5
 8009ca6:	4638      	mov	r0, r7
 8009ca8:	f002 fd3a 	bl	800c720 <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 ); //pxNewTCB->pxStack表示任务的栈空间，栈向下增长，初始化时加上栈的深度回到栈顶
 8009cac:	3d04      	subs	r5, #4
 8009cae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009cb0:	441d      	add	r5, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8009cb2:	f025 0507 	bic.w	r5, r5, #7
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8009cb6:	f899 3000 	ldrb.w	r3, [r9]
 8009cba:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
 8009cbe:	f899 3000 	ldrb.w	r3, [r9]
 8009cc2:	b163      	cbz	r3, 8009cde <xTaskCreate+0x6a>
 8009cc4:	464b      	mov	r3, r9
 8009cc6:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8009cca:	f109 010f 	add.w	r1, r9, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8009cce:	7858      	ldrb	r0, [r3, #1]
 8009cd0:	f802 0f01 	strb.w	r0, [r2, #1]!
		if( pcName[ x ] == 0x00 )
 8009cd4:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8009cd8:	b108      	cbz	r0, 8009cde <xTaskCreate+0x6a>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8009cda:	428b      	cmp	r3, r1
 8009cdc:	d1f7      	bne.n	8009cce <xTaskCreate+0x5a>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8009cde:	2700      	movs	r7, #0
 8009ce0:	f884 7043 	strb.w	r7, [r4, #67]	; 0x43
 8009ce4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009ce6:	2b06      	cmp	r3, #6
 8009ce8:	bf28      	it	cs
 8009cea:	2306      	movcs	r3, #6
 8009cec:	469a      	mov	sl, r3
	pxNewTCB->uxPriority = uxPriority;
 8009cee:	62e3      	str	r3, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8009cf0:	64e3      	str	r3, [r4, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8009cf2:	6527      	str	r7, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8009cf4:	f104 0b04 	add.w	fp, r4, #4
 8009cf8:	4658      	mov	r0, fp
 8009cfa:	f7ff f8b2 	bl	8008e62 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8009cfe:	f104 0018 	add.w	r0, r4, #24
 8009d02:	f7ff f8ae 	bl	8008e62 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8009d06:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009d08:	f1ca 0307 	rsb	r3, sl, #7
 8009d0c:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8009d0e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulRunTimeCounter = 0UL;
 8009d10:	6627      	str	r7, [r4, #96]	; 0x60
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 8009d12:	6567      	str	r7, [r4, #84]	; 0x54
 8009d14:	65a7      	str	r7, [r4, #88]	; 0x58
 8009d16:	65e7      	str	r7, [r4, #92]	; 0x5c
		pxNewTCB->ulNotifiedValue = 0;
 8009d18:	6667      	str	r7, [r4, #100]	; 0x64
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8009d1a:	f884 7068 	strb.w	r7, [r4, #104]	; 0x68
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8009d1e:	4642      	mov	r2, r8
 8009d20:	9901      	ldr	r1, [sp, #4]
 8009d22:	4628      	mov	r0, r5
 8009d24:	f7ff f8f6 	bl	8008f14 <pxPortInitialiseStack>
 8009d28:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8009d2a:	b106      	cbz	r6, 8009d2e <xTaskCreate+0xba>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8009d2c:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 8009d2e:	f7ff f919 	bl	8008f64 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8009d32:	4a36      	ldr	r2, [pc, #216]	; (8009e0c <xTaskCreate+0x198>)
 8009d34:	6813      	ldr	r3, [r2, #0]
 8009d36:	3301      	adds	r3, #1
 8009d38:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8009d3a:	4b35      	ldr	r3, [pc, #212]	; (8009e10 <xTaskCreate+0x19c>)
 8009d3c:	681b      	ldr	r3, [r3, #0]
 8009d3e:	2b00      	cmp	r3, #0
 8009d40:	d03a      	beq.n	8009db8 <xTaskCreate+0x144>
			if( xSchedulerRunning == pdFALSE )
 8009d42:	4b34      	ldr	r3, [pc, #208]	; (8009e14 <xTaskCreate+0x1a0>)
 8009d44:	681b      	ldr	r3, [r3, #0]
 8009d46:	b93b      	cbnz	r3, 8009d58 <xTaskCreate+0xe4>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8009d48:	4b31      	ldr	r3, [pc, #196]	; (8009e10 <xTaskCreate+0x19c>)
 8009d4a:	681b      	ldr	r3, [r3, #0]
 8009d4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009d4e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009d50:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8009d52:	bf9c      	itt	ls
 8009d54:	4b2e      	ldrls	r3, [pc, #184]	; (8009e10 <xTaskCreate+0x19c>)
 8009d56:	601c      	strls	r4, [r3, #0]
		uxTaskNumber++;
 8009d58:	4a2f      	ldr	r2, [pc, #188]	; (8009e18 <xTaskCreate+0x1a4>)
 8009d5a:	6813      	ldr	r3, [r2, #0]
 8009d5c:	3301      	adds	r3, #1
 8009d5e:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8009d60:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8009d62:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8009d64:	4a2d      	ldr	r2, [pc, #180]	; (8009e1c <xTaskCreate+0x1a8>)
 8009d66:	6811      	ldr	r1, [r2, #0]
 8009d68:	2301      	movs	r3, #1
 8009d6a:	4083      	lsls	r3, r0
 8009d6c:	430b      	orrs	r3, r1
 8009d6e:	6013      	str	r3, [r2, #0]
 8009d70:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009d74:	4659      	mov	r1, fp
 8009d76:	4b2a      	ldr	r3, [pc, #168]	; (8009e20 <xTaskCreate+0x1ac>)
 8009d78:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8009d7c:	f7ff f874 	bl	8008e68 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8009d80:	f7ff f912 	bl	8008fa8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8009d84:	4b23      	ldr	r3, [pc, #140]	; (8009e14 <xTaskCreate+0x1a0>)
 8009d86:	681b      	ldr	r3, [r3, #0]
 8009d88:	2b00      	cmp	r3, #0
 8009d8a:	d039      	beq.n	8009e00 <xTaskCreate+0x18c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8009d8c:	4b20      	ldr	r3, [pc, #128]	; (8009e10 <xTaskCreate+0x19c>)
 8009d8e:	681b      	ldr	r3, [r3, #0]
 8009d90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009d92:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009d94:	429a      	cmp	r2, r3
 8009d96:	d237      	bcs.n	8009e08 <xTaskCreate+0x194>
			taskYIELD_IF_USING_PREEMPTION();
 8009d98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009d9c:	4b21      	ldr	r3, [pc, #132]	; (8009e24 <xTaskCreate+0x1b0>)
 8009d9e:	601a      	str	r2, [r3, #0]
 8009da0:	f3bf 8f4f 	dsb	sy
 8009da4:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 8009da8:	2001      	movs	r0, #1
 8009daa:	e02a      	b.n	8009e02 <xTaskCreate+0x18e>
					vPortFree( pxStack );
 8009dac:	4638      	mov	r0, r7
 8009dae:	f7ff fac9 	bl	8009344 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8009db2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8009db6:	e024      	b.n	8009e02 <xTaskCreate+0x18e>
			pxCurrentTCB = pxNewTCB;
 8009db8:	4b15      	ldr	r3, [pc, #84]	; (8009e10 <xTaskCreate+0x19c>)
 8009dba:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8009dbc:	6813      	ldr	r3, [r2, #0]
 8009dbe:	2b01      	cmp	r3, #1
 8009dc0:	d1ca      	bne.n	8009d58 <xTaskCreate+0xe4>
 8009dc2:	4d17      	ldr	r5, [pc, #92]	; (8009e20 <xTaskCreate+0x1ac>)
 8009dc4:	f105 068c 	add.w	r6, r5, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8009dc8:	4628      	mov	r0, r5
 8009dca:	f7ff f83f 	bl	8008e4c <vListInitialise>
 8009dce:	3514      	adds	r5, #20
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8009dd0:	42ae      	cmp	r6, r5
 8009dd2:	d1f9      	bne.n	8009dc8 <xTaskCreate+0x154>
	vListInitialise( &xDelayedTaskList1 );
 8009dd4:	4e14      	ldr	r6, [pc, #80]	; (8009e28 <xTaskCreate+0x1b4>)
 8009dd6:	4630      	mov	r0, r6
 8009dd8:	f7ff f838 	bl	8008e4c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8009ddc:	4d13      	ldr	r5, [pc, #76]	; (8009e2c <xTaskCreate+0x1b8>)
 8009dde:	4628      	mov	r0, r5
 8009de0:	f7ff f834 	bl	8008e4c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8009de4:	4812      	ldr	r0, [pc, #72]	; (8009e30 <xTaskCreate+0x1bc>)
 8009de6:	f7ff f831 	bl	8008e4c <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8009dea:	4812      	ldr	r0, [pc, #72]	; (8009e34 <xTaskCreate+0x1c0>)
 8009dec:	f7ff f82e 	bl	8008e4c <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8009df0:	4811      	ldr	r0, [pc, #68]	; (8009e38 <xTaskCreate+0x1c4>)
 8009df2:	f7ff f82b 	bl	8008e4c <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8009df6:	4b11      	ldr	r3, [pc, #68]	; (8009e3c <xTaskCreate+0x1c8>)
 8009df8:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8009dfa:	4b11      	ldr	r3, [pc, #68]	; (8009e40 <xTaskCreate+0x1cc>)
 8009dfc:	601d      	str	r5, [r3, #0]
 8009dfe:	e7ab      	b.n	8009d58 <xTaskCreate+0xe4>
			xReturn = pdPASS;
 8009e00:	2001      	movs	r0, #1
	}
 8009e02:	b003      	add	sp, #12
 8009e04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
 8009e08:	2001      	movs	r0, #1
		return xReturn;
 8009e0a:	e7fa      	b.n	8009e02 <xTaskCreate+0x18e>
 8009e0c:	20000a48 	.word	0x20000a48
 8009e10:	200009ac 	.word	0x200009ac
 8009e14:	20000aa8 	.word	0x20000aa8
 8009e18:	20000a58 	.word	0x20000a58
 8009e1c:	20000a5c 	.word	0x20000a5c
 8009e20:	200009b8 	.word	0x200009b8
 8009e24:	e000ed04 	.word	0xe000ed04
 8009e28:	20000a60 	.word	0x20000a60
 8009e2c:	20000a74 	.word	0x20000a74
 8009e30:	20000a94 	.word	0x20000a94
 8009e34:	20000ac0 	.word	0x20000ac0
 8009e38:	20000aac 	.word	0x20000aac
 8009e3c:	200009b0 	.word	0x200009b0
 8009e40:	200009b4 	.word	0x200009b4

08009e44 <vTaskDelete>:
	{
 8009e44:	b538      	push	{r3, r4, r5, lr}
 8009e46:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 8009e48:	f7ff f88c 	bl	8008f64 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8009e4c:	2c00      	cmp	r4, #0
 8009e4e:	d037      	beq.n	8009ec0 <vTaskDelete+0x7c>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8009e50:	1d25      	adds	r5, r4, #4
 8009e52:	4628      	mov	r0, r5
 8009e54:	f7ff f82e 	bl	8008eb4 <uxListRemove>
 8009e58:	b970      	cbnz	r0, 8009e78 <vTaskDelete+0x34>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8009e5a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009e5c:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8009e60:	4a26      	ldr	r2, [pc, #152]	; (8009efc <vTaskDelete+0xb8>)
 8009e62:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8009e66:	b93a      	cbnz	r2, 8009e78 <vTaskDelete+0x34>
 8009e68:	4825      	ldr	r0, [pc, #148]	; (8009f00 <vTaskDelete+0xbc>)
 8009e6a:	6802      	ldr	r2, [r0, #0]
 8009e6c:	2101      	movs	r1, #1
 8009e6e:	fa01 f303 	lsl.w	r3, r1, r3
 8009e72:	ea22 0303 	bic.w	r3, r2, r3
 8009e76:	6003      	str	r3, [r0, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8009e78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009e7a:	b11b      	cbz	r3, 8009e84 <vTaskDelete+0x40>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8009e7c:	f104 0018 	add.w	r0, r4, #24
 8009e80:	f7ff f818 	bl	8008eb4 <uxListRemove>
			uxTaskNumber++;
 8009e84:	4a1f      	ldr	r2, [pc, #124]	; (8009f04 <vTaskDelete+0xc0>)
 8009e86:	6813      	ldr	r3, [r2, #0]
 8009e88:	3301      	adds	r3, #1
 8009e8a:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 8009e8c:	4b1e      	ldr	r3, [pc, #120]	; (8009f08 <vTaskDelete+0xc4>)
 8009e8e:	681b      	ldr	r3, [r3, #0]
 8009e90:	429c      	cmp	r4, r3
 8009e92:	d018      	beq.n	8009ec6 <vTaskDelete+0x82>
				--uxCurrentNumberOfTasks;
 8009e94:	4a1d      	ldr	r2, [pc, #116]	; (8009f0c <vTaskDelete+0xc8>)
 8009e96:	6813      	ldr	r3, [r2, #0]
 8009e98:	3b01      	subs	r3, #1
 8009e9a:	6013      	str	r3, [r2, #0]
			vPortFree( pxTCB->pxStack );
 8009e9c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8009e9e:	f7ff fa51 	bl	8009344 <vPortFree>
			vPortFree( pxTCB );
 8009ea2:	4620      	mov	r0, r4
 8009ea4:	f7ff fa4e 	bl	8009344 <vPortFree>
				prvResetNextTaskUnblockTime();
 8009ea8:	f7ff fe6c 	bl	8009b84 <prvResetNextTaskUnblockTime>
		taskEXIT_CRITICAL();
 8009eac:	f7ff f87c 	bl	8008fa8 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8009eb0:	4b17      	ldr	r3, [pc, #92]	; (8009f10 <vTaskDelete+0xcc>)
 8009eb2:	681b      	ldr	r3, [r3, #0]
 8009eb4:	b11b      	cbz	r3, 8009ebe <vTaskDelete+0x7a>
			if( pxTCB == pxCurrentTCB )
 8009eb6:	4b14      	ldr	r3, [pc, #80]	; (8009f08 <vTaskDelete+0xc4>)
 8009eb8:	681b      	ldr	r3, [r3, #0]
 8009eba:	429c      	cmp	r4, r3
 8009ebc:	d00c      	beq.n	8009ed8 <vTaskDelete+0x94>
 8009ebe:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8009ec0:	4b11      	ldr	r3, [pc, #68]	; (8009f08 <vTaskDelete+0xc4>)
 8009ec2:	681c      	ldr	r4, [r3, #0]
 8009ec4:	e7c4      	b.n	8009e50 <vTaskDelete+0xc>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8009ec6:	4629      	mov	r1, r5
 8009ec8:	4812      	ldr	r0, [pc, #72]	; (8009f14 <vTaskDelete+0xd0>)
 8009eca:	f7fe ffcd 	bl	8008e68 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 8009ece:	4a12      	ldr	r2, [pc, #72]	; (8009f18 <vTaskDelete+0xd4>)
 8009ed0:	6813      	ldr	r3, [r2, #0]
 8009ed2:	3301      	adds	r3, #1
 8009ed4:	6013      	str	r3, [r2, #0]
 8009ed6:	e7e9      	b.n	8009eac <vTaskDelete+0x68>
				configASSERT( uxSchedulerSuspended == 0 );
 8009ed8:	4b10      	ldr	r3, [pc, #64]	; (8009f1c <vTaskDelete+0xd8>)
 8009eda:	681b      	ldr	r3, [r3, #0]
 8009edc:	b943      	cbnz	r3, 8009ef0 <vTaskDelete+0xac>
				portYIELD_WITHIN_API();
 8009ede:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009ee2:	4b0f      	ldr	r3, [pc, #60]	; (8009f20 <vTaskDelete+0xdc>)
 8009ee4:	601a      	str	r2, [r3, #0]
 8009ee6:	f3bf 8f4f 	dsb	sy
 8009eea:	f3bf 8f6f 	isb	sy
	}
 8009eee:	e7e6      	b.n	8009ebe <vTaskDelete+0x7a>
				configASSERT( uxSchedulerSuspended == 0 );
 8009ef0:	f240 4166 	movw	r1, #1126	; 0x466
 8009ef4:	480b      	ldr	r0, [pc, #44]	; (8009f24 <vTaskDelete+0xe0>)
 8009ef6:	f002 fa33 	bl	800c360 <vAssertCalled>
 8009efa:	e7f0      	b.n	8009ede <vTaskDelete+0x9a>
 8009efc:	200009b8 	.word	0x200009b8
 8009f00:	20000a5c 	.word	0x20000a5c
 8009f04:	20000a58 	.word	0x20000a58
 8009f08:	200009ac 	.word	0x200009ac
 8009f0c:	20000a48 	.word	0x20000a48
 8009f10:	20000aa8 	.word	0x20000aa8
 8009f14:	20000ac0 	.word	0x20000ac0
 8009f18:	20000a4c 	.word	0x20000a4c
 8009f1c:	20000a54 	.word	0x20000a54
 8009f20:	e000ed04 	.word	0xe000ed04
 8009f24:	0800d0e0 	.word	0x0800d0e0

08009f28 <eTaskGetState>:
	{
 8009f28:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxTCB );
 8009f2a:	4605      	mov	r5, r0
 8009f2c:	b1d8      	cbz	r0, 8009f66 <eTaskGetState+0x3e>
		if( pxTCB == pxCurrentTCB )
 8009f2e:	4b18      	ldr	r3, [pc, #96]	; (8009f90 <eTaskGetState+0x68>)
 8009f30:	681b      	ldr	r3, [r3, #0]
 8009f32:	429d      	cmp	r5, r3
 8009f34:	d023      	beq.n	8009f7e <eTaskGetState+0x56>
			taskENTER_CRITICAL();
 8009f36:	f7ff f815 	bl	8008f64 <vPortEnterCritical>
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 8009f3a:	696c      	ldr	r4, [r5, #20]
			taskEXIT_CRITICAL();
 8009f3c:	f7ff f834 	bl	8008fa8 <vPortExitCritical>
			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 8009f40:	4b14      	ldr	r3, [pc, #80]	; (8009f94 <eTaskGetState+0x6c>)
 8009f42:	681b      	ldr	r3, [r3, #0]
 8009f44:	429c      	cmp	r4, r3
 8009f46:	d01c      	beq.n	8009f82 <eTaskGetState+0x5a>
 8009f48:	4b13      	ldr	r3, [pc, #76]	; (8009f98 <eTaskGetState+0x70>)
 8009f4a:	681b      	ldr	r3, [r3, #0]
 8009f4c:	429c      	cmp	r4, r3
 8009f4e:	d01a      	beq.n	8009f86 <eTaskGetState+0x5e>
				else if( pxStateList == &xSuspendedTaskList )
 8009f50:	4b12      	ldr	r3, [pc, #72]	; (8009f9c <eTaskGetState+0x74>)
 8009f52:	429c      	cmp	r4, r3
 8009f54:	d00d      	beq.n	8009f72 <eTaskGetState+0x4a>
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 8009f56:	4b12      	ldr	r3, [pc, #72]	; (8009fa0 <eTaskGetState+0x78>)
 8009f58:	429c      	cmp	r4, r3
 8009f5a:	d016      	beq.n	8009f8a <eTaskGetState+0x62>
				eReturn = eReady;
 8009f5c:	2c00      	cmp	r4, #0
 8009f5e:	bf0c      	ite	eq
 8009f60:	2004      	moveq	r0, #4
 8009f62:	2001      	movne	r0, #1
 8009f64:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pxTCB );
 8009f66:	f240 41fc 	movw	r1, #1276	; 0x4fc
 8009f6a:	480e      	ldr	r0, [pc, #56]	; (8009fa4 <eTaskGetState+0x7c>)
 8009f6c:	f002 f9f8 	bl	800c360 <vAssertCalled>
 8009f70:	e7dd      	b.n	8009f2e <eTaskGetState+0x6>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 8009f72:	6aab      	ldr	r3, [r5, #40]	; 0x28
						eReturn = eBlocked;
 8009f74:	2b00      	cmp	r3, #0
 8009f76:	bf0c      	ite	eq
 8009f78:	2003      	moveq	r0, #3
 8009f7a:	2002      	movne	r0, #2
 8009f7c:	bd38      	pop	{r3, r4, r5, pc}
			eReturn = eRunning;
 8009f7e:	2000      	movs	r0, #0
 8009f80:	bd38      	pop	{r3, r4, r5, pc}
				eReturn = eBlocked;
 8009f82:	2002      	movs	r0, #2
 8009f84:	bd38      	pop	{r3, r4, r5, pc}
 8009f86:	2002      	movs	r0, #2
 8009f88:	bd38      	pop	{r3, r4, r5, pc}
					eReturn = eDeleted;
 8009f8a:	2004      	movs	r0, #4
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8009f8c:	bd38      	pop	{r3, r4, r5, pc}
 8009f8e:	bf00      	nop
 8009f90:	200009ac 	.word	0x200009ac
 8009f94:	200009b0 	.word	0x200009b0
 8009f98:	200009b4 	.word	0x200009b4
 8009f9c:	20000aac 	.word	0x20000aac
 8009fa0:	20000ac0 	.word	0x20000ac0
 8009fa4:	0800d0e0 	.word	0x0800d0e0

08009fa8 <vTaskStartScheduler>:
{
 8009fa8:	b500      	push	{lr}
 8009faa:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 8009fac:	4b15      	ldr	r3, [pc, #84]	; (800a004 <vTaskStartScheduler+0x5c>)
 8009fae:	9301      	str	r3, [sp, #4]
 8009fb0:	2300      	movs	r3, #0
 8009fb2:	9300      	str	r3, [sp, #0]
 8009fb4:	2280      	movs	r2, #128	; 0x80
 8009fb6:	4914      	ldr	r1, [pc, #80]	; (800a008 <vTaskStartScheduler+0x60>)
 8009fb8:	4814      	ldr	r0, [pc, #80]	; (800a00c <vTaskStartScheduler+0x64>)
 8009fba:	f7ff fe5b 	bl	8009c74 <xTaskCreate>
	if( xReturn == pdPASS )
 8009fbe:	2801      	cmp	r0, #1
 8009fc0:	d005      	beq.n	8009fce <vTaskStartScheduler+0x26>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8009fc2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8009fc6:	d017      	beq.n	8009ff8 <vTaskStartScheduler+0x50>
}
 8009fc8:	b003      	add	sp, #12
 8009fca:	f85d fb04 	ldr.w	pc, [sp], #4
	__asm volatile
 8009fce:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009fd2:	f383 8811 	msr	BASEPRI, r3
 8009fd6:	f3bf 8f6f 	isb	sy
 8009fda:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8009fde:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009fe2:	4b0b      	ldr	r3, [pc, #44]	; (800a010 <vTaskStartScheduler+0x68>)
 8009fe4:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8009fe6:	2201      	movs	r2, #1
 8009fe8:	4b0a      	ldr	r3, [pc, #40]	; (800a014 <vTaskStartScheduler+0x6c>)
 8009fea:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8009fec:	2200      	movs	r2, #0
 8009fee:	4b0a      	ldr	r3, [pc, #40]	; (800a018 <vTaskStartScheduler+0x70>)
 8009ff0:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8009ff2:	f7ff f859 	bl	80090a8 <xPortStartScheduler>
 8009ff6:	e7e7      	b.n	8009fc8 <vTaskStartScheduler+0x20>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8009ff8:	f44f 61f1 	mov.w	r1, #1928	; 0x788
 8009ffc:	4807      	ldr	r0, [pc, #28]	; (800a01c <vTaskStartScheduler+0x74>)
 8009ffe:	f002 f9af 	bl	800c360 <vAssertCalled>
}
 800a002:	e7e1      	b.n	8009fc8 <vTaskStartScheduler+0x20>
 800a004:	20000a88 	.word	0x20000a88
 800a008:	0800d12c 	.word	0x0800d12c
 800a00c:	0800a31d 	.word	0x0800a31d
 800a010:	20000a8c 	.word	0x20000a8c
 800a014:	20000aa8 	.word	0x20000aa8
 800a018:	20000ad4 	.word	0x20000ad4
 800a01c:	0800d0e0 	.word	0x0800d0e0

0800a020 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800a020:	4a02      	ldr	r2, [pc, #8]	; (800a02c <vTaskSuspendAll+0xc>)
 800a022:	6813      	ldr	r3, [r2, #0]
 800a024:	3301      	adds	r3, #1
 800a026:	6013      	str	r3, [r2, #0]
 800a028:	4770      	bx	lr
 800a02a:	bf00      	nop
 800a02c:	20000a54 	.word	0x20000a54

0800a030 <xTaskGetTickCount>:
		xTicks = xTickCount;
 800a030:	4b01      	ldr	r3, [pc, #4]	; (800a038 <xTaskGetTickCount+0x8>)
 800a032:	6818      	ldr	r0, [r3, #0]
}
 800a034:	4770      	bx	lr
 800a036:	bf00      	nop
 800a038:	20000ad4 	.word	0x20000ad4

0800a03c <pcTaskGetName>:
{
 800a03c:	b510      	push	{r4, lr}
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800a03e:	4604      	mov	r4, r0
 800a040:	b110      	cbz	r0, 800a048 <pcTaskGetName+0xc>
}
 800a042:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800a046:	bd10      	pop	{r4, pc}
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800a048:	4b04      	ldr	r3, [pc, #16]	; (800a05c <pcTaskGetName+0x20>)
 800a04a:	681c      	ldr	r4, [r3, #0]
	configASSERT( pxTCB );
 800a04c:	2c00      	cmp	r4, #0
 800a04e:	d1f8      	bne.n	800a042 <pcTaskGetName+0x6>
 800a050:	f44f 6109 	mov.w	r1, #2192	; 0x890
 800a054:	4802      	ldr	r0, [pc, #8]	; (800a060 <pcTaskGetName+0x24>)
 800a056:	f002 f983 	bl	800c360 <vAssertCalled>
 800a05a:	e7f2      	b.n	800a042 <pcTaskGetName+0x6>
 800a05c:	200009ac 	.word	0x200009ac
 800a060:	0800d0e0 	.word	0x0800d0e0

0800a064 <xTaskIncrementTick>:
{
 800a064:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	traceTASK_INCREMENT_TICK( xTickCount );
 800a068:	4b4c      	ldr	r3, [pc, #304]	; (800a19c <xTaskIncrementTick+0x138>)
 800a06a:	681b      	ldr	r3, [r3, #0]
 800a06c:	b93b      	cbnz	r3, 800a07e <xTaskIncrementTick+0x1a>
 800a06e:	4b4c      	ldr	r3, [pc, #304]	; (800a1a0 <xTaskIncrementTick+0x13c>)
 800a070:	681b      	ldr	r3, [r3, #0]
 800a072:	3301      	adds	r3, #1
 800a074:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800a078:	d23c      	bcs.n	800a0f4 <xTaskIncrementTick+0x90>
 800a07a:	4a49      	ldr	r2, [pc, #292]	; (800a1a0 <xTaskIncrementTick+0x13c>)
 800a07c:	6013      	str	r3, [r2, #0]
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800a07e:	4b47      	ldr	r3, [pc, #284]	; (800a19c <xTaskIncrementTick+0x138>)
 800a080:	681b      	ldr	r3, [r3, #0]
 800a082:	2b00      	cmp	r3, #0
 800a084:	f040 8082 	bne.w	800a18c <xTaskIncrementTick+0x128>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800a088:	4b46      	ldr	r3, [pc, #280]	; (800a1a4 <xTaskIncrementTick+0x140>)
 800a08a:	681a      	ldr	r2, [r3, #0]
 800a08c:	f102 0801 	add.w	r8, r2, #1
		xTickCount = xConstTickCount;
 800a090:	f8c3 8000 	str.w	r8, [r3]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800a094:	f1b8 0f00 	cmp.w	r8, #0
 800a098:	d110      	bne.n	800a0bc <xTaskIncrementTick+0x58>
			taskSWITCH_DELAYED_LISTS();
 800a09a:	4b43      	ldr	r3, [pc, #268]	; (800a1a8 <xTaskIncrementTick+0x144>)
 800a09c:	681b      	ldr	r3, [r3, #0]
 800a09e:	681b      	ldr	r3, [r3, #0]
 800a0a0:	2b00      	cmp	r3, #0
 800a0a2:	d12f      	bne.n	800a104 <xTaskIncrementTick+0xa0>
 800a0a4:	4a40      	ldr	r2, [pc, #256]	; (800a1a8 <xTaskIncrementTick+0x144>)
 800a0a6:	6811      	ldr	r1, [r2, #0]
 800a0a8:	4b40      	ldr	r3, [pc, #256]	; (800a1ac <xTaskIncrementTick+0x148>)
 800a0aa:	6818      	ldr	r0, [r3, #0]
 800a0ac:	6010      	str	r0, [r2, #0]
 800a0ae:	6019      	str	r1, [r3, #0]
 800a0b0:	4a3f      	ldr	r2, [pc, #252]	; (800a1b0 <xTaskIncrementTick+0x14c>)
 800a0b2:	6813      	ldr	r3, [r2, #0]
 800a0b4:	3301      	adds	r3, #1
 800a0b6:	6013      	str	r3, [r2, #0]
 800a0b8:	f7ff fd64 	bl	8009b84 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800a0bc:	4b3d      	ldr	r3, [pc, #244]	; (800a1b4 <xTaskIncrementTick+0x150>)
 800a0be:	681b      	ldr	r3, [r3, #0]
 800a0c0:	4598      	cmp	r8, r3
 800a0c2:	d225      	bcs.n	800a110 <xTaskIncrementTick+0xac>
BaseType_t xSwitchRequired = pdFALSE;
 800a0c4:	2600      	movs	r6, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800a0c6:	4b3c      	ldr	r3, [pc, #240]	; (800a1b8 <xTaskIncrementTick+0x154>)
 800a0c8:	681b      	ldr	r3, [r3, #0]
 800a0ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a0cc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800a0d0:	4a3a      	ldr	r2, [pc, #232]	; (800a1bc <xTaskIncrementTick+0x158>)
 800a0d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
				xSwitchRequired = pdTRUE;
 800a0d6:	2b02      	cmp	r3, #2
 800a0d8:	bf28      	it	cs
 800a0da:	2601      	movcs	r6, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 800a0dc:	4b38      	ldr	r3, [pc, #224]	; (800a1c0 <xTaskIncrementTick+0x15c>)
 800a0de:	681b      	ldr	r3, [r3, #0]
 800a0e0:	2b00      	cmp	r3, #0
 800a0e2:	d050      	beq.n	800a186 <xTaskIncrementTick+0x122>
		if( xYieldPending != pdFALSE )
 800a0e4:	4b37      	ldr	r3, [pc, #220]	; (800a1c4 <xTaskIncrementTick+0x160>)
 800a0e6:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 800a0e8:	2b00      	cmp	r3, #0
}
 800a0ea:	bf0c      	ite	eq
 800a0ec:	4630      	moveq	r0, r6
 800a0ee:	2001      	movne	r0, #1
 800a0f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	traceTASK_INCREMENT_TICK( xTickCount );
 800a0f4:	2200      	movs	r2, #0
 800a0f6:	4b2a      	ldr	r3, [pc, #168]	; (800a1a0 <xTaskIncrementTick+0x13c>)
 800a0f8:	601a      	str	r2, [r3, #0]
 800a0fa:	4a33      	ldr	r2, [pc, #204]	; (800a1c8 <xTaskIncrementTick+0x164>)
 800a0fc:	6813      	ldr	r3, [r2, #0]
 800a0fe:	3301      	adds	r3, #1
 800a100:	6013      	str	r3, [r2, #0]
 800a102:	e7bc      	b.n	800a07e <xTaskIncrementTick+0x1a>
			taskSWITCH_DELAYED_LISTS();
 800a104:	f640 11dd 	movw	r1, #2525	; 0x9dd
 800a108:	4830      	ldr	r0, [pc, #192]	; (800a1cc <xTaskIncrementTick+0x168>)
 800a10a:	f002 f929 	bl	800c360 <vAssertCalled>
 800a10e:	e7c9      	b.n	800a0a4 <xTaskIncrementTick+0x40>
 800a110:	2600      	movs	r6, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800a112:	4f25      	ldr	r7, [pc, #148]	; (800a1a8 <xTaskIncrementTick+0x144>)
					prvAddTaskToReadyList( pxTCB );
 800a114:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 800a1d0 <xTaskIncrementTick+0x16c>
 800a118:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 800a1bc <xTaskIncrementTick+0x158>
 800a11c:	e021      	b.n	800a162 <xTaskIncrementTick+0xfe>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a11e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a122:	4b24      	ldr	r3, [pc, #144]	; (800a1b4 <xTaskIncrementTick+0x150>)
 800a124:	601a      	str	r2, [r3, #0]
					break;
 800a126:	e7ce      	b.n	800a0c6 <xTaskIncrementTick+0x62>
						xNextTaskUnblockTime = xItemValue;
 800a128:	4a22      	ldr	r2, [pc, #136]	; (800a1b4 <xTaskIncrementTick+0x150>)
 800a12a:	6013      	str	r3, [r2, #0]
						break;
 800a12c:	e7cb      	b.n	800a0c6 <xTaskIncrementTick+0x62>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800a12e:	f104 0018 	add.w	r0, r4, #24
 800a132:	f7fe febf 	bl	8008eb4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800a136:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a138:	f8d9 2000 	ldr.w	r2, [r9]
 800a13c:	2301      	movs	r3, #1
 800a13e:	4083      	lsls	r3, r0
 800a140:	4313      	orrs	r3, r2
 800a142:	f8c9 3000 	str.w	r3, [r9]
 800a146:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a14a:	4629      	mov	r1, r5
 800a14c:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 800a150:	f7fe fe8a 	bl	8008e68 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800a154:	4b18      	ldr	r3, [pc, #96]	; (800a1b8 <xTaskIncrementTick+0x154>)
 800a156:	681b      	ldr	r3, [r3, #0]
 800a158:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a15a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 800a15c:	429a      	cmp	r2, r3
 800a15e:	bf28      	it	cs
 800a160:	2601      	movcs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800a162:	683b      	ldr	r3, [r7, #0]
 800a164:	681b      	ldr	r3, [r3, #0]
 800a166:	2b00      	cmp	r3, #0
 800a168:	d0d9      	beq.n	800a11e <xTaskIncrementTick+0xba>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800a16a:	683b      	ldr	r3, [r7, #0]
 800a16c:	68db      	ldr	r3, [r3, #12]
 800a16e:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800a170:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
 800a172:	4598      	cmp	r8, r3
 800a174:	d3d8      	bcc.n	800a128 <xTaskIncrementTick+0xc4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800a176:	1d25      	adds	r5, r4, #4
 800a178:	4628      	mov	r0, r5
 800a17a:	f7fe fe9b 	bl	8008eb4 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800a17e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a180:	2b00      	cmp	r3, #0
 800a182:	d1d4      	bne.n	800a12e <xTaskIncrementTick+0xca>
 800a184:	e7d7      	b.n	800a136 <xTaskIncrementTick+0xd2>
				vApplicationTickHook();
 800a186:	f002 f9f9 	bl	800c57c <vApplicationTickHook>
 800a18a:	e7ab      	b.n	800a0e4 <xTaskIncrementTick+0x80>
		++uxPendedTicks;
 800a18c:	4a0c      	ldr	r2, [pc, #48]	; (800a1c0 <xTaskIncrementTick+0x15c>)
 800a18e:	6813      	ldr	r3, [r2, #0]
 800a190:	3301      	adds	r3, #1
 800a192:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
 800a194:	f002 f9f2 	bl	800c57c <vApplicationTickHook>
BaseType_t xSwitchRequired = pdFALSE;
 800a198:	2600      	movs	r6, #0
 800a19a:	e7a3      	b.n	800a0e4 <xTaskIncrementTick+0x80>
 800a19c:	20000a54 	.word	0x20000a54
 800a1a0:	20004d1c 	.word	0x20004d1c
 800a1a4:	20000ad4 	.word	0x20000ad4
 800a1a8:	200009b0 	.word	0x200009b0
 800a1ac:	200009b4 	.word	0x200009b4
 800a1b0:	20000a90 	.word	0x20000a90
 800a1b4:	20000a8c 	.word	0x20000a8c
 800a1b8:	200009ac 	.word	0x200009ac
 800a1bc:	200009b8 	.word	0x200009b8
 800a1c0:	20000a50 	.word	0x20000a50
 800a1c4:	20000ad8 	.word	0x20000ad8
 800a1c8:	20004d24 	.word	0x20004d24
 800a1cc:	0800d0e0 	.word	0x0800d0e0
 800a1d0:	20000a5c 	.word	0x20000a5c

0800a1d4 <xTaskResumeAll>:
{
 800a1d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( uxSchedulerSuspended );
 800a1d8:	4b34      	ldr	r3, [pc, #208]	; (800a2ac <xTaskResumeAll+0xd8>)
 800a1da:	681b      	ldr	r3, [r3, #0]
 800a1dc:	2b00      	cmp	r3, #0
 800a1de:	d033      	beq.n	800a248 <xTaskResumeAll+0x74>
	taskENTER_CRITICAL();
 800a1e0:	f7fe fec0 	bl	8008f64 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800a1e4:	4b31      	ldr	r3, [pc, #196]	; (800a2ac <xTaskResumeAll+0xd8>)
 800a1e6:	681a      	ldr	r2, [r3, #0]
 800a1e8:	3a01      	subs	r2, #1
 800a1ea:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800a1ec:	681b      	ldr	r3, [r3, #0]
 800a1ee:	2b00      	cmp	r3, #0
 800a1f0:	d153      	bne.n	800a29a <xTaskResumeAll+0xc6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800a1f2:	4b2f      	ldr	r3, [pc, #188]	; (800a2b0 <xTaskResumeAll+0xdc>)
 800a1f4:	681b      	ldr	r3, [r3, #0]
 800a1f6:	b36b      	cbz	r3, 800a254 <xTaskResumeAll+0x80>
 800a1f8:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800a1fa:	4e2e      	ldr	r6, [pc, #184]	; (800a2b4 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList( pxTCB );
 800a1fc:	4f2e      	ldr	r7, [pc, #184]	; (800a2b8 <xTaskResumeAll+0xe4>)
 800a1fe:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800a2d0 <xTaskResumeAll+0xfc>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800a202:	6833      	ldr	r3, [r6, #0]
 800a204:	b343      	cbz	r3, 800a258 <xTaskResumeAll+0x84>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800a206:	68f3      	ldr	r3, [r6, #12]
 800a208:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800a20a:	f104 0018 	add.w	r0, r4, #24
 800a20e:	f7fe fe51 	bl	8008eb4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800a212:	1d25      	adds	r5, r4, #4
 800a214:	4628      	mov	r0, r5
 800a216:	f7fe fe4d 	bl	8008eb4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800a21a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a21c:	683a      	ldr	r2, [r7, #0]
 800a21e:	2301      	movs	r3, #1
 800a220:	4083      	lsls	r3, r0
 800a222:	4313      	orrs	r3, r2
 800a224:	603b      	str	r3, [r7, #0]
 800a226:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a22a:	4629      	mov	r1, r5
 800a22c:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 800a230:	f7fe fe1a 	bl	8008e68 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800a234:	4b21      	ldr	r3, [pc, #132]	; (800a2bc <xTaskResumeAll+0xe8>)
 800a236:	681b      	ldr	r3, [r3, #0]
 800a238:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a23a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a23c:	429a      	cmp	r2, r3
 800a23e:	d3e0      	bcc.n	800a202 <xTaskResumeAll+0x2e>
						xYieldPending = pdTRUE;
 800a240:	2201      	movs	r2, #1
 800a242:	4b1f      	ldr	r3, [pc, #124]	; (800a2c0 <xTaskResumeAll+0xec>)
 800a244:	601a      	str	r2, [r3, #0]
 800a246:	e7dc      	b.n	800a202 <xTaskResumeAll+0x2e>
	configASSERT( uxSchedulerSuspended );
 800a248:	f240 71ec 	movw	r1, #2028	; 0x7ec
 800a24c:	481d      	ldr	r0, [pc, #116]	; (800a2c4 <xTaskResumeAll+0xf0>)
 800a24e:	f002 f887 	bl	800c360 <vAssertCalled>
 800a252:	e7c5      	b.n	800a1e0 <xTaskResumeAll+0xc>
BaseType_t xAlreadyYielded = pdFALSE;
 800a254:	2400      	movs	r4, #0
 800a256:	e021      	b.n	800a29c <xTaskResumeAll+0xc8>
				if( pxTCB != NULL )
 800a258:	b10c      	cbz	r4, 800a25e <xTaskResumeAll+0x8a>
					prvResetNextTaskUnblockTime();
 800a25a:	f7ff fc93 	bl	8009b84 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800a25e:	4b1a      	ldr	r3, [pc, #104]	; (800a2c8 <xTaskResumeAll+0xf4>)
 800a260:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800a262:	b16c      	cbz	r4, 800a280 <xTaskResumeAll+0xac>
								xYieldPending = pdTRUE;
 800a264:	4e16      	ldr	r6, [pc, #88]	; (800a2c0 <xTaskResumeAll+0xec>)
 800a266:	2501      	movs	r5, #1
 800a268:	e001      	b.n	800a26e <xTaskResumeAll+0x9a>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800a26a:	3c01      	subs	r4, #1
 800a26c:	d005      	beq.n	800a27a <xTaskResumeAll+0xa6>
							if( xTaskIncrementTick() != pdFALSE )
 800a26e:	f7ff fef9 	bl	800a064 <xTaskIncrementTick>
 800a272:	2800      	cmp	r0, #0
 800a274:	d0f9      	beq.n	800a26a <xTaskResumeAll+0x96>
								xYieldPending = pdTRUE;
 800a276:	6035      	str	r5, [r6, #0]
 800a278:	e7f7      	b.n	800a26a <xTaskResumeAll+0x96>
						uxPendedTicks = 0;
 800a27a:	2200      	movs	r2, #0
 800a27c:	4b12      	ldr	r3, [pc, #72]	; (800a2c8 <xTaskResumeAll+0xf4>)
 800a27e:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
 800a280:	4b0f      	ldr	r3, [pc, #60]	; (800a2c0 <xTaskResumeAll+0xec>)
 800a282:	681b      	ldr	r3, [r3, #0]
 800a284:	b17b      	cbz	r3, 800a2a6 <xTaskResumeAll+0xd2>
					taskYIELD_IF_USING_PREEMPTION();
 800a286:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a28a:	4b10      	ldr	r3, [pc, #64]	; (800a2cc <xTaskResumeAll+0xf8>)
 800a28c:	601a      	str	r2, [r3, #0]
 800a28e:	f3bf 8f4f 	dsb	sy
 800a292:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 800a296:	2401      	movs	r4, #1
 800a298:	e000      	b.n	800a29c <xTaskResumeAll+0xc8>
BaseType_t xAlreadyYielded = pdFALSE;
 800a29a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800a29c:	f7fe fe84 	bl	8008fa8 <vPortExitCritical>
}
 800a2a0:	4620      	mov	r0, r4
 800a2a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
BaseType_t xAlreadyYielded = pdFALSE;
 800a2a6:	2400      	movs	r4, #0
 800a2a8:	e7f8      	b.n	800a29c <xTaskResumeAll+0xc8>
 800a2aa:	bf00      	nop
 800a2ac:	20000a54 	.word	0x20000a54
 800a2b0:	20000a48 	.word	0x20000a48
 800a2b4:	20000a94 	.word	0x20000a94
 800a2b8:	20000a5c 	.word	0x20000a5c
 800a2bc:	200009ac 	.word	0x200009ac
 800a2c0:	20000ad8 	.word	0x20000ad8
 800a2c4:	0800d0e0 	.word	0x0800d0e0
 800a2c8:	20000a50 	.word	0x20000a50
 800a2cc:	e000ed04 	.word	0xe000ed04
 800a2d0:	200009b8 	.word	0x200009b8

0800a2d4 <vTaskDelay>:
	{
 800a2d4:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800a2d6:	b160      	cbz	r0, 800a2f2 <vTaskDelay+0x1e>
 800a2d8:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 800a2da:	4b0d      	ldr	r3, [pc, #52]	; (800a310 <vTaskDelay+0x3c>)
 800a2dc:	681b      	ldr	r3, [r3, #0]
 800a2de:	b98b      	cbnz	r3, 800a304 <vTaskDelay+0x30>
			vTaskSuspendAll();
 800a2e0:	f7ff fe9e 	bl	800a020 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800a2e4:	2100      	movs	r1, #0
 800a2e6:	4620      	mov	r0, r4
 800a2e8:	f7ff fc62 	bl	8009bb0 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800a2ec:	f7ff ff72 	bl	800a1d4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800a2f0:	b938      	cbnz	r0, 800a302 <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
 800a2f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a2f6:	4b07      	ldr	r3, [pc, #28]	; (800a314 <vTaskDelay+0x40>)
 800a2f8:	601a      	str	r2, [r3, #0]
 800a2fa:	f3bf 8f4f 	dsb	sy
 800a2fe:	f3bf 8f6f 	isb	sy
 800a302:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800a304:	f44f 619a 	mov.w	r1, #1232	; 0x4d0
 800a308:	4803      	ldr	r0, [pc, #12]	; (800a318 <vTaskDelay+0x44>)
 800a30a:	f002 f829 	bl	800c360 <vAssertCalled>
 800a30e:	e7e7      	b.n	800a2e0 <vTaskDelay+0xc>
 800a310:	20000a54 	.word	0x20000a54
 800a314:	e000ed04 	.word	0xe000ed04
 800a318:	0800d0e0 	.word	0x0800d0e0

0800a31c <prvIdleTask>:
{
 800a31c:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800a31e:	4d1a      	ldr	r5, [pc, #104]	; (800a388 <prvIdleTask+0x6c>)
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800a320:	4e1a      	ldr	r6, [pc, #104]	; (800a38c <prvIdleTask+0x70>)
					--uxCurrentNumberOfTasks;
 800a322:	4f1b      	ldr	r7, [pc, #108]	; (800a390 <prvIdleTask+0x74>)
				taskYIELD();
 800a324:	f8df 8070 	ldr.w	r8, [pc, #112]	; 800a398 <prvIdleTask+0x7c>
 800a328:	e00d      	b.n	800a346 <prvIdleTask+0x2a>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800a32a:	4b1a      	ldr	r3, [pc, #104]	; (800a394 <prvIdleTask+0x78>)
 800a32c:	681b      	ldr	r3, [r3, #0]
 800a32e:	2b01      	cmp	r3, #1
 800a330:	d907      	bls.n	800a342 <prvIdleTask+0x26>
				taskYIELD();
 800a332:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800a336:	f8c8 3000 	str.w	r3, [r8]
 800a33a:	f3bf 8f4f 	dsb	sy
 800a33e:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 800a342:	f001 fff3 	bl	800c32c <vApplicationIdleHook>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800a346:	682b      	ldr	r3, [r5, #0]
 800a348:	2b00      	cmp	r3, #0
 800a34a:	d0ee      	beq.n	800a32a <prvIdleTask+0xe>
			vTaskSuspendAll();
 800a34c:	f7ff fe68 	bl	800a020 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800a350:	6834      	ldr	r4, [r6, #0]
			( void ) xTaskResumeAll();
 800a352:	f7ff ff3f 	bl	800a1d4 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800a356:	2c00      	cmp	r4, #0
 800a358:	d0f5      	beq.n	800a346 <prvIdleTask+0x2a>
				taskENTER_CRITICAL();
 800a35a:	f7fe fe03 	bl	8008f64 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800a35e:	68f3      	ldr	r3, [r6, #12]
 800a360:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800a362:	1d20      	adds	r0, r4, #4
 800a364:	f7fe fda6 	bl	8008eb4 <uxListRemove>
					--uxCurrentNumberOfTasks;
 800a368:	683b      	ldr	r3, [r7, #0]
 800a36a:	3b01      	subs	r3, #1
 800a36c:	603b      	str	r3, [r7, #0]
					--uxDeletedTasksWaitingCleanUp;
 800a36e:	682b      	ldr	r3, [r5, #0]
 800a370:	3b01      	subs	r3, #1
 800a372:	602b      	str	r3, [r5, #0]
				taskEXIT_CRITICAL();
 800a374:	f7fe fe18 	bl	8008fa8 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800a378:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800a37a:	f7fe ffe3 	bl	8009344 <vPortFree>
			vPortFree( pxTCB );
 800a37e:	4620      	mov	r0, r4
 800a380:	f7fe ffe0 	bl	8009344 <vPortFree>
 800a384:	e7df      	b.n	800a346 <prvIdleTask+0x2a>
 800a386:	bf00      	nop
 800a388:	20000a4c 	.word	0x20000a4c
 800a38c:	20000ac0 	.word	0x20000ac0
 800a390:	20000a48 	.word	0x20000a48
 800a394:	200009b8 	.word	0x200009b8
 800a398:	e000ed04 	.word	0xe000ed04

0800a39c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800a39c:	4b31      	ldr	r3, [pc, #196]	; (800a464 <vTaskSwitchContext+0xc8>)
 800a39e:	681b      	ldr	r3, [r3, #0]
 800a3a0:	b11b      	cbz	r3, 800a3aa <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 800a3a2:	2201      	movs	r2, #1
 800a3a4:	4b30      	ldr	r3, [pc, #192]	; (800a468 <vTaskSwitchContext+0xcc>)
 800a3a6:	601a      	str	r2, [r3, #0]
 800a3a8:	4770      	bx	lr
{
 800a3aa:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
 800a3ac:	2200      	movs	r2, #0
 800a3ae:	4b2e      	ldr	r3, [pc, #184]	; (800a468 <vTaskSwitchContext+0xcc>)
 800a3b0:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 800a3b2:	f002 f8df 	bl	800c574 <xGetRunTimeCounterValue>
				if( ulTotalRunTime > ulTaskSwitchedInTime )
 800a3b6:	4b2d      	ldr	r3, [pc, #180]	; (800a46c <vTaskSwitchContext+0xd0>)
 800a3b8:	681a      	ldr	r2, [r3, #0]
 800a3ba:	4290      	cmp	r0, r2
 800a3bc:	d905      	bls.n	800a3ca <vTaskSwitchContext+0x2e>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 800a3be:	4b2c      	ldr	r3, [pc, #176]	; (800a470 <vTaskSwitchContext+0xd4>)
 800a3c0:	6819      	ldr	r1, [r3, #0]
 800a3c2:	6e0b      	ldr	r3, [r1, #96]	; 0x60
 800a3c4:	1a9b      	subs	r3, r3, r2
 800a3c6:	4403      	add	r3, r0
 800a3c8:	660b      	str	r3, [r1, #96]	; 0x60
				ulTaskSwitchedInTime = ulTotalRunTime;
 800a3ca:	4b28      	ldr	r3, [pc, #160]	; (800a46c <vTaskSwitchContext+0xd0>)
 800a3cc:	6018      	str	r0, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 800a3ce:	4b28      	ldr	r3, [pc, #160]	; (800a470 <vTaskSwitchContext+0xd4>)
 800a3d0:	681b      	ldr	r3, [r3, #0]
 800a3d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a3d4:	681a      	ldr	r2, [r3, #0]
 800a3d6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800a3da:	d029      	beq.n	800a430 <vTaskSwitchContext+0x94>
 800a3dc:	4b24      	ldr	r3, [pc, #144]	; (800a470 <vTaskSwitchContext+0xd4>)
 800a3de:	6818      	ldr	r0, [r3, #0]
 800a3e0:	6819      	ldr	r1, [r3, #0]
 800a3e2:	3134      	adds	r1, #52	; 0x34
 800a3e4:	f002 f878 	bl	800c4d8 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800a3e8:	4b22      	ldr	r3, [pc, #136]	; (800a474 <vTaskSwitchContext+0xd8>)
 800a3ea:	681c      	ldr	r4, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 800a3ec:	fab4 f484 	clz	r4, r4
 800a3f0:	b2e4      	uxtb	r4, r4
 800a3f2:	f1c4 041f 	rsb	r4, r4, #31
 800a3f6:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 800a3fa:	4b1f      	ldr	r3, [pc, #124]	; (800a478 <vTaskSwitchContext+0xdc>)
 800a3fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a400:	b31b      	cbz	r3, 800a44a <vTaskSwitchContext+0xae>
 800a402:	4b1d      	ldr	r3, [pc, #116]	; (800a478 <vTaskSwitchContext+0xdc>)
 800a404:	00a2      	lsls	r2, r4, #2
 800a406:	1911      	adds	r1, r2, r4
 800a408:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800a40c:	6848      	ldr	r0, [r1, #4]
 800a40e:	6840      	ldr	r0, [r0, #4]
 800a410:	6048      	str	r0, [r1, #4]
 800a412:	4422      	add	r2, r4
 800a414:	460b      	mov	r3, r1
 800a416:	3308      	adds	r3, #8
 800a418:	4298      	cmp	r0, r3
 800a41a:	d01c      	beq.n	800a456 <vTaskSwitchContext+0xba>
 800a41c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 800a420:	4b15      	ldr	r3, [pc, #84]	; (800a478 <vTaskSwitchContext+0xdc>)
 800a422:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 800a426:	6863      	ldr	r3, [r4, #4]
 800a428:	68da      	ldr	r2, [r3, #12]
 800a42a:	4b11      	ldr	r3, [pc, #68]	; (800a470 <vTaskSwitchContext+0xd4>)
 800a42c:	601a      	str	r2, [r3, #0]
 800a42e:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
 800a430:	685a      	ldr	r2, [r3, #4]
 800a432:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800a436:	d1d1      	bne.n	800a3dc <vTaskSwitchContext+0x40>
 800a438:	689a      	ldr	r2, [r3, #8]
 800a43a:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800a43e:	d1cd      	bne.n	800a3dc <vTaskSwitchContext+0x40>
 800a440:	68db      	ldr	r3, [r3, #12]
 800a442:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 800a446:	d1c9      	bne.n	800a3dc <vTaskSwitchContext+0x40>
 800a448:	e7ce      	b.n	800a3e8 <vTaskSwitchContext+0x4c>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800a44a:	f640 21fa 	movw	r1, #2810	; 0xafa
 800a44e:	480b      	ldr	r0, [pc, #44]	; (800a47c <vTaskSwitchContext+0xe0>)
 800a450:	f001 ff86 	bl	800c360 <vAssertCalled>
 800a454:	e7d5      	b.n	800a402 <vTaskSwitchContext+0x66>
 800a456:	6841      	ldr	r1, [r0, #4]
 800a458:	4613      	mov	r3, r2
 800a45a:	4a07      	ldr	r2, [pc, #28]	; (800a478 <vTaskSwitchContext+0xdc>)
 800a45c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800a460:	6059      	str	r1, [r3, #4]
 800a462:	e7db      	b.n	800a41c <vTaskSwitchContext+0x80>
 800a464:	20000a54 	.word	0x20000a54
 800a468:	20000ad8 	.word	0x20000ad8
 800a46c:	20000a44 	.word	0x20000a44
 800a470:	200009ac 	.word	0x200009ac
 800a474:	20000a5c 	.word	0x20000a5c
 800a478:	200009b8 	.word	0x200009b8
 800a47c:	0800d0e0 	.word	0x0800d0e0

0800a480 <vTaskPlaceOnEventList>:
{
 800a480:	b538      	push	{r3, r4, r5, lr}
 800a482:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 800a484:	4605      	mov	r5, r0
 800a486:	b150      	cbz	r0, 800a49e <vTaskPlaceOnEventList+0x1e>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800a488:	4b08      	ldr	r3, [pc, #32]	; (800a4ac <vTaskPlaceOnEventList+0x2c>)
 800a48a:	6819      	ldr	r1, [r3, #0]
 800a48c:	3118      	adds	r1, #24
 800a48e:	4628      	mov	r0, r5
 800a490:	f7fe fcf6 	bl	8008e80 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800a494:	2101      	movs	r1, #1
 800a496:	4620      	mov	r0, r4
 800a498:	f7ff fb8a 	bl	8009bb0 <prvAddCurrentTaskToDelayedList>
 800a49c:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxEventList );
 800a49e:	f640 310a 	movw	r1, #2826	; 0xb0a
 800a4a2:	4803      	ldr	r0, [pc, #12]	; (800a4b0 <vTaskPlaceOnEventList+0x30>)
 800a4a4:	f001 ff5c 	bl	800c360 <vAssertCalled>
 800a4a8:	e7ee      	b.n	800a488 <vTaskPlaceOnEventList+0x8>
 800a4aa:	bf00      	nop
 800a4ac:	200009ac 	.word	0x200009ac
 800a4b0:	0800d0e0 	.word	0x0800d0e0

0800a4b4 <vTaskPlaceOnUnorderedEventList>:
{
 800a4b4:	b570      	push	{r4, r5, r6, lr}
 800a4b6:	460c      	mov	r4, r1
 800a4b8:	4615      	mov	r5, r2
	configASSERT( pxEventList );
 800a4ba:	4606      	mov	r6, r0
 800a4bc:	b188      	cbz	r0, 800a4e2 <vTaskPlaceOnUnorderedEventList+0x2e>
	configASSERT( uxSchedulerSuspended != 0 );
 800a4be:	4b0f      	ldr	r3, [pc, #60]	; (800a4fc <vTaskPlaceOnUnorderedEventList+0x48>)
 800a4c0:	681b      	ldr	r3, [r3, #0]
 800a4c2:	b1a3      	cbz	r3, 800a4ee <vTaskPlaceOnUnorderedEventList+0x3a>
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800a4c4:	4b0e      	ldr	r3, [pc, #56]	; (800a500 <vTaskPlaceOnUnorderedEventList+0x4c>)
 800a4c6:	681a      	ldr	r2, [r3, #0]
 800a4c8:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 800a4cc:	6194      	str	r4, [r2, #24]
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800a4ce:	6819      	ldr	r1, [r3, #0]
 800a4d0:	3118      	adds	r1, #24
 800a4d2:	4630      	mov	r0, r6
 800a4d4:	f7fe fcc8 	bl	8008e68 <vListInsertEnd>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800a4d8:	2101      	movs	r1, #1
 800a4da:	4628      	mov	r0, r5
 800a4dc:	f7ff fb68 	bl	8009bb0 <prvAddCurrentTaskToDelayedList>
 800a4e0:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxEventList );
 800a4e2:	f640 311b 	movw	r1, #2843	; 0xb1b
 800a4e6:	4807      	ldr	r0, [pc, #28]	; (800a504 <vTaskPlaceOnUnorderedEventList+0x50>)
 800a4e8:	f001 ff3a 	bl	800c360 <vAssertCalled>
 800a4ec:	e7e7      	b.n	800a4be <vTaskPlaceOnUnorderedEventList+0xa>
	configASSERT( uxSchedulerSuspended != 0 );
 800a4ee:	f640 311f 	movw	r1, #2847	; 0xb1f
 800a4f2:	4804      	ldr	r0, [pc, #16]	; (800a504 <vTaskPlaceOnUnorderedEventList+0x50>)
 800a4f4:	f001 ff34 	bl	800c360 <vAssertCalled>
 800a4f8:	e7e4      	b.n	800a4c4 <vTaskPlaceOnUnorderedEventList+0x10>
 800a4fa:	bf00      	nop
 800a4fc:	20000a54 	.word	0x20000a54
 800a500:	200009ac 	.word	0x200009ac
 800a504:	0800d0e0 	.word	0x0800d0e0

0800a508 <xTaskRemoveFromEventList>:
{
 800a508:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800a50a:	68c3      	ldr	r3, [r0, #12]
 800a50c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800a50e:	b32c      	cbz	r4, 800a55c <xTaskRemoveFromEventList+0x54>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800a510:	f104 0518 	add.w	r5, r4, #24
 800a514:	4628      	mov	r0, r5
 800a516:	f7fe fccd 	bl	8008eb4 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800a51a:	4b16      	ldr	r3, [pc, #88]	; (800a574 <xTaskRemoveFromEventList+0x6c>)
 800a51c:	681b      	ldr	r3, [r3, #0]
 800a51e:	bb1b      	cbnz	r3, 800a568 <xTaskRemoveFromEventList+0x60>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800a520:	1d25      	adds	r5, r4, #4
 800a522:	4628      	mov	r0, r5
 800a524:	f7fe fcc6 	bl	8008eb4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800a528:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a52a:	4a13      	ldr	r2, [pc, #76]	; (800a578 <xTaskRemoveFromEventList+0x70>)
 800a52c:	6811      	ldr	r1, [r2, #0]
 800a52e:	2301      	movs	r3, #1
 800a530:	4083      	lsls	r3, r0
 800a532:	430b      	orrs	r3, r1
 800a534:	6013      	str	r3, [r2, #0]
 800a536:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a53a:	4629      	mov	r1, r5
 800a53c:	4b0f      	ldr	r3, [pc, #60]	; (800a57c <xTaskRemoveFromEventList+0x74>)
 800a53e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a542:	f7fe fc91 	bl	8008e68 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800a546:	4b0e      	ldr	r3, [pc, #56]	; (800a580 <xTaskRemoveFromEventList+0x78>)
 800a548:	681b      	ldr	r3, [r3, #0]
 800a54a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a54c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a54e:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 800a550:	bf83      	ittte	hi
 800a552:	2001      	movhi	r0, #1
 800a554:	4b0b      	ldrhi	r3, [pc, #44]	; (800a584 <xTaskRemoveFromEventList+0x7c>)
 800a556:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 800a558:	2000      	movls	r0, #0
}
 800a55a:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxUnblockedTCB );
 800a55c:	f640 3165 	movw	r1, #2917	; 0xb65
 800a560:	4809      	ldr	r0, [pc, #36]	; (800a588 <xTaskRemoveFromEventList+0x80>)
 800a562:	f001 fefd 	bl	800c360 <vAssertCalled>
 800a566:	e7d3      	b.n	800a510 <xTaskRemoveFromEventList+0x8>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800a568:	4629      	mov	r1, r5
 800a56a:	4808      	ldr	r0, [pc, #32]	; (800a58c <xTaskRemoveFromEventList+0x84>)
 800a56c:	f7fe fc7c 	bl	8008e68 <vListInsertEnd>
 800a570:	e7e9      	b.n	800a546 <xTaskRemoveFromEventList+0x3e>
 800a572:	bf00      	nop
 800a574:	20000a54 	.word	0x20000a54
 800a578:	20000a5c 	.word	0x20000a5c
 800a57c:	200009b8 	.word	0x200009b8
 800a580:	200009ac 	.word	0x200009ac
 800a584:	20000ad8 	.word	0x20000ad8
 800a588:	0800d0e0 	.word	0x0800d0e0
 800a58c:	20000a94 	.word	0x20000a94

0800a590 <vTaskRemoveFromUnorderedEventList>:
{
 800a590:	b538      	push	{r3, r4, r5, lr}
 800a592:	4605      	mov	r5, r0
 800a594:	460c      	mov	r4, r1
	configASSERT( uxSchedulerSuspended != pdFALSE );
 800a596:	4b1a      	ldr	r3, [pc, #104]	; (800a600 <vTaskRemoveFromUnorderedEventList+0x70>)
 800a598:	681b      	ldr	r3, [r3, #0]
 800a59a:	b323      	cbz	r3, 800a5e6 <vTaskRemoveFromUnorderedEventList+0x56>
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800a59c:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
 800a5a0:	602c      	str	r4, [r5, #0]
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 800a5a2:	68ec      	ldr	r4, [r5, #12]
	configASSERT( pxUnblockedTCB );
 800a5a4:	b32c      	cbz	r4, 800a5f2 <vTaskRemoveFromUnorderedEventList+0x62>
	( void ) uxListRemove( pxEventListItem );
 800a5a6:	4628      	mov	r0, r5
 800a5a8:	f7fe fc84 	bl	8008eb4 <uxListRemove>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800a5ac:	1d25      	adds	r5, r4, #4
 800a5ae:	4628      	mov	r0, r5
 800a5b0:	f7fe fc80 	bl	8008eb4 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 800a5b4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a5b6:	4a13      	ldr	r2, [pc, #76]	; (800a604 <vTaskRemoveFromUnorderedEventList+0x74>)
 800a5b8:	6811      	ldr	r1, [r2, #0]
 800a5ba:	2301      	movs	r3, #1
 800a5bc:	4083      	lsls	r3, r0
 800a5be:	430b      	orrs	r3, r1
 800a5c0:	6013      	str	r3, [r2, #0]
 800a5c2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a5c6:	4629      	mov	r1, r5
 800a5c8:	4b0f      	ldr	r3, [pc, #60]	; (800a608 <vTaskRemoveFromUnorderedEventList+0x78>)
 800a5ca:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a5ce:	f7fe fc4b 	bl	8008e68 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800a5d2:	4b0e      	ldr	r3, [pc, #56]	; (800a60c <vTaskRemoveFromUnorderedEventList+0x7c>)
 800a5d4:	681b      	ldr	r3, [r3, #0]
 800a5d6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800a5d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a5da:	429a      	cmp	r2, r3
 800a5dc:	d902      	bls.n	800a5e4 <vTaskRemoveFromUnorderedEventList+0x54>
		xYieldPending = pdTRUE;
 800a5de:	2201      	movs	r2, #1
 800a5e0:	4b0b      	ldr	r3, [pc, #44]	; (800a610 <vTaskRemoveFromUnorderedEventList+0x80>)
 800a5e2:	601a      	str	r2, [r3, #0]
 800a5e4:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( uxSchedulerSuspended != pdFALSE );
 800a5e6:	f640 319c 	movw	r1, #2972	; 0xb9c
 800a5ea:	480a      	ldr	r0, [pc, #40]	; (800a614 <vTaskRemoveFromUnorderedEventList+0x84>)
 800a5ec:	f001 feb8 	bl	800c360 <vAssertCalled>
 800a5f0:	e7d4      	b.n	800a59c <vTaskRemoveFromUnorderedEventList+0xc>
	configASSERT( pxUnblockedTCB );
 800a5f2:	f640 31a4 	movw	r1, #2980	; 0xba4
 800a5f6:	4807      	ldr	r0, [pc, #28]	; (800a614 <vTaskRemoveFromUnorderedEventList+0x84>)
 800a5f8:	f001 feb2 	bl	800c360 <vAssertCalled>
 800a5fc:	e7d3      	b.n	800a5a6 <vTaskRemoveFromUnorderedEventList+0x16>
 800a5fe:	bf00      	nop
 800a600:	20000a54 	.word	0x20000a54
 800a604:	20000a5c 	.word	0x20000a5c
 800a608:	200009b8 	.word	0x200009b8
 800a60c:	200009ac 	.word	0x200009ac
 800a610:	20000ad8 	.word	0x20000ad8
 800a614:	0800d0e0 	.word	0x0800d0e0

0800a618 <vTaskSetTimeOutState>:
{
 800a618:	b510      	push	{r4, lr}
	configASSERT( pxTimeOut );
 800a61a:	4604      	mov	r4, r0
 800a61c:	b130      	cbz	r0, 800a62c <vTaskSetTimeOutState+0x14>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800a61e:	4b06      	ldr	r3, [pc, #24]	; (800a638 <vTaskSetTimeOutState+0x20>)
 800a620:	681b      	ldr	r3, [r3, #0]
 800a622:	6023      	str	r3, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800a624:	4b05      	ldr	r3, [pc, #20]	; (800a63c <vTaskSetTimeOutState+0x24>)
 800a626:	681b      	ldr	r3, [r3, #0]
 800a628:	6063      	str	r3, [r4, #4]
 800a62a:	bd10      	pop	{r4, pc}
	configASSERT( pxTimeOut );
 800a62c:	f640 31ba 	movw	r1, #3002	; 0xbba
 800a630:	4803      	ldr	r0, [pc, #12]	; (800a640 <vTaskSetTimeOutState+0x28>)
 800a632:	f001 fe95 	bl	800c360 <vAssertCalled>
 800a636:	e7f2      	b.n	800a61e <vTaskSetTimeOutState+0x6>
 800a638:	20000a90 	.word	0x20000a90
 800a63c:	20000ad4 	.word	0x20000ad4
 800a640:	0800d0e0 	.word	0x0800d0e0

0800a644 <xTaskCheckForTimeOut>:
{
 800a644:	b538      	push	{r3, r4, r5, lr}
 800a646:	460c      	mov	r4, r1
	configASSERT( pxTimeOut );
 800a648:	4605      	mov	r5, r0
 800a64a:	b1c8      	cbz	r0, 800a680 <xTaskCheckForTimeOut+0x3c>
	configASSERT( pxTicksToWait );
 800a64c:	b1f4      	cbz	r4, 800a68c <xTaskCheckForTimeOut+0x48>
	taskENTER_CRITICAL();
 800a64e:	f7fe fc89 	bl	8008f64 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800a652:	4b17      	ldr	r3, [pc, #92]	; (800a6b0 <xTaskCheckForTimeOut+0x6c>)
 800a654:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 800a656:	6823      	ldr	r3, [r4, #0]
 800a658:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800a65c:	d024      	beq.n	800a6a8 <xTaskCheckForTimeOut+0x64>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800a65e:	4915      	ldr	r1, [pc, #84]	; (800a6b4 <xTaskCheckForTimeOut+0x70>)
 800a660:	6809      	ldr	r1, [r1, #0]
 800a662:	6828      	ldr	r0, [r5, #0]
 800a664:	4288      	cmp	r0, r1
 800a666:	d002      	beq.n	800a66e <xTaskCheckForTimeOut+0x2a>
 800a668:	6869      	ldr	r1, [r5, #4]
 800a66a:	428a      	cmp	r2, r1
 800a66c:	d21e      	bcs.n	800a6ac <xTaskCheckForTimeOut+0x68>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800a66e:	6869      	ldr	r1, [r5, #4]
 800a670:	1a50      	subs	r0, r2, r1
 800a672:	4283      	cmp	r3, r0
 800a674:	d810      	bhi.n	800a698 <xTaskCheckForTimeOut+0x54>
			xReturn = pdTRUE;
 800a676:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 800a678:	f7fe fc96 	bl	8008fa8 <vPortExitCritical>
}
 800a67c:	4620      	mov	r0, r4
 800a67e:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxTimeOut );
 800a680:	f640 31c4 	movw	r1, #3012	; 0xbc4
 800a684:	480c      	ldr	r0, [pc, #48]	; (800a6b8 <xTaskCheckForTimeOut+0x74>)
 800a686:	f001 fe6b 	bl	800c360 <vAssertCalled>
 800a68a:	e7df      	b.n	800a64c <xTaskCheckForTimeOut+0x8>
	configASSERT( pxTicksToWait );
 800a68c:	f640 31c5 	movw	r1, #3013	; 0xbc5
 800a690:	4809      	ldr	r0, [pc, #36]	; (800a6b8 <xTaskCheckForTimeOut+0x74>)
 800a692:	f001 fe65 	bl	800c360 <vAssertCalled>
 800a696:	e7da      	b.n	800a64e <xTaskCheckForTimeOut+0xa>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800a698:	1a9b      	subs	r3, r3, r2
 800a69a:	440b      	add	r3, r1
 800a69c:	6023      	str	r3, [r4, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800a69e:	4628      	mov	r0, r5
 800a6a0:	f7ff ffba 	bl	800a618 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800a6a4:	2400      	movs	r4, #0
 800a6a6:	e7e7      	b.n	800a678 <xTaskCheckForTimeOut+0x34>
				xReturn = pdFALSE;
 800a6a8:	2400      	movs	r4, #0
 800a6aa:	e7e5      	b.n	800a678 <xTaskCheckForTimeOut+0x34>
			xReturn = pdTRUE;
 800a6ac:	2401      	movs	r4, #1
 800a6ae:	e7e3      	b.n	800a678 <xTaskCheckForTimeOut+0x34>
 800a6b0:	20000ad4 	.word	0x20000ad4
 800a6b4:	20000a90 	.word	0x20000a90
 800a6b8:	0800d0e0 	.word	0x0800d0e0

0800a6bc <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800a6bc:	2201      	movs	r2, #1
 800a6be:	4b01      	ldr	r3, [pc, #4]	; (800a6c4 <vTaskMissedYield+0x8>)
 800a6c0:	601a      	str	r2, [r3, #0]
 800a6c2:	4770      	bx	lr
 800a6c4:	20000ad8 	.word	0x20000ad8

0800a6c8 <pvTaskGetThreadLocalStoragePointer>:
		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
 800a6c8:	2902      	cmp	r1, #2
 800a6ca:	dc07      	bgt.n	800a6dc <pvTaskGetThreadLocalStoragePointer+0x14>
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800a6cc:	b118      	cbz	r0, 800a6d6 <pvTaskGetThreadLocalStoragePointer+0xe>
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 800a6ce:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 800a6d2:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800a6d4:	4770      	bx	lr
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800a6d6:	4b02      	ldr	r3, [pc, #8]	; (800a6e0 <pvTaskGetThreadLocalStoragePointer+0x18>)
 800a6d8:	6818      	ldr	r0, [r3, #0]
 800a6da:	e7f8      	b.n	800a6ce <pvTaskGetThreadLocalStoragePointer+0x6>
			pvReturn = NULL;
 800a6dc:	2000      	movs	r0, #0
	}
 800a6de:	4770      	bx	lr
 800a6e0:	200009ac 	.word	0x200009ac

0800a6e4 <vTaskGetInfo>:
	{
 800a6e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a6e8:	460c      	mov	r4, r1
 800a6ea:	4617      	mov	r7, r2
 800a6ec:	461e      	mov	r6, r3
		pxTCB = prvGetTCBFromHandle( xTask );
 800a6ee:	4680      	mov	r8, r0
 800a6f0:	b1c8      	cbz	r0, 800a726 <vTaskGetInfo+0x42>
 800a6f2:	4605      	mov	r5, r0
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 800a6f4:	6025      	str	r5, [r4, #0]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 800a6f6:	f105 0334 	add.w	r3, r5, #52	; 0x34
 800a6fa:	6063      	str	r3, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 800a6fc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a6fe:	6123      	str	r3, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 800a700:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800a702:	61e3      	str	r3, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 800a704:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800a706:	60a3      	str	r3, [r4, #8]
			if( pxTaskStatus->eCurrentState == eSuspended )
 800a708:	7b23      	ldrb	r3, [r4, #12]
 800a70a:	2b03      	cmp	r3, #3
 800a70c:	d00e      	beq.n	800a72c <vTaskGetInfo+0x48>
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 800a70e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800a710:	6163      	str	r3, [r4, #20]
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
 800a712:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800a714:	61a3      	str	r3, [r4, #24]
		if( eState != eInvalid )
 800a716:	2e05      	cmp	r6, #5
 800a718:	d011      	beq.n	800a73e <vTaskGetInfo+0x5a>
			pxTaskStatus->eCurrentState = eState;
 800a71a:	7326      	strb	r6, [r4, #12]
		if( xGetFreeStackSpace != pdFALSE )
 800a71c:	b9a7      	cbnz	r7, 800a748 <vTaskGetInfo+0x64>
			pxTaskStatus->usStackHighWaterMark = 0;
 800a71e:	2300      	movs	r3, #0
 800a720:	8423      	strh	r3, [r4, #32]
 800a722:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pxTCB = prvGetTCBFromHandle( xTask );
 800a726:	4b10      	ldr	r3, [pc, #64]	; (800a768 <vTaskGetInfo+0x84>)
 800a728:	681d      	ldr	r5, [r3, #0]
 800a72a:	e7e3      	b.n	800a6f4 <vTaskGetInfo+0x10>
				vTaskSuspendAll();
 800a72c:	f7ff fc78 	bl	800a020 <vTaskSuspendAll>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800a730:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800a732:	b10b      	cbz	r3, 800a738 <vTaskGetInfo+0x54>
						pxTaskStatus->eCurrentState = eBlocked;
 800a734:	2302      	movs	r3, #2
 800a736:	7323      	strb	r3, [r4, #12]
				( void ) xTaskResumeAll();
 800a738:	f7ff fd4c 	bl	800a1d4 <xTaskResumeAll>
 800a73c:	e7e7      	b.n	800a70e <vTaskGetInfo+0x2a>
			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
 800a73e:	4640      	mov	r0, r8
 800a740:	f7ff fbf2 	bl	8009f28 <eTaskGetState>
 800a744:	7320      	strb	r0, [r4, #12]
 800a746:	e7e9      	b.n	800a71c <vTaskGetInfo+0x38>
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 800a748:	6b28      	ldr	r0, [r5, #48]	; 0x30
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800a74a:	7803      	ldrb	r3, [r0, #0]
 800a74c:	2ba5      	cmp	r3, #165	; 0xa5
 800a74e:	d109      	bne.n	800a764 <vTaskGetInfo+0x80>
 800a750:	1c43      	adds	r3, r0, #1
 800a752:	1a19      	subs	r1, r3, r0
 800a754:	f813 2b01 	ldrb.w	r2, [r3], #1
 800a758:	2aa5      	cmp	r2, #165	; 0xa5
 800a75a:	d0fa      	beq.n	800a752 <vTaskGetInfo+0x6e>
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 800a75c:	0889      	lsrs	r1, r1, #2
		return ( uint16_t ) ulCount;
 800a75e:	8421      	strh	r1, [r4, #32]
 800a760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t ulCount = 0U;
 800a764:	2100      	movs	r1, #0
 800a766:	e7f9      	b.n	800a75c <vTaskGetInfo+0x78>
 800a768:	200009ac 	.word	0x200009ac

0800a76c <prvListTasksWithinSingleList>:
	{
 800a76c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800a770:	680f      	ldr	r7, [r1, #0]
 800a772:	b327      	cbz	r7, 800a7be <prvListTasksWithinSingleList+0x52>
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 800a774:	684b      	ldr	r3, [r1, #4]
 800a776:	685b      	ldr	r3, [r3, #4]
 800a778:	604b      	str	r3, [r1, #4]
 800a77a:	f101 0908 	add.w	r9, r1, #8
 800a77e:	454b      	cmp	r3, r9
 800a780:	bf04      	itt	eq
 800a782:	68cb      	ldreq	r3, [r1, #12]
 800a784:	604b      	streq	r3, [r1, #4]
 800a786:	4690      	mov	r8, r2
 800a788:	460c      	mov	r4, r1
 800a78a:	684b      	ldr	r3, [r1, #4]
 800a78c:	f8d3 b00c 	ldr.w	fp, [r3, #12]
 800a790:	4605      	mov	r5, r0
	UBaseType_t uxTask = 0;
 800a792:	2700      	movs	r7, #0
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 800a794:	f04f 0a01 	mov.w	sl, #1
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 800a798:	6863      	ldr	r3, [r4, #4]
 800a79a:	685b      	ldr	r3, [r3, #4]
 800a79c:	6063      	str	r3, [r4, #4]
 800a79e:	4599      	cmp	r9, r3
 800a7a0:	bf04      	itt	eq
 800a7a2:	68e3      	ldreq	r3, [r4, #12]
 800a7a4:	6063      	streq	r3, [r4, #4]
 800a7a6:	6863      	ldr	r3, [r4, #4]
 800a7a8:	68de      	ldr	r6, [r3, #12]
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 800a7aa:	4643      	mov	r3, r8
 800a7ac:	4652      	mov	r2, sl
 800a7ae:	4629      	mov	r1, r5
 800a7b0:	4630      	mov	r0, r6
 800a7b2:	f7ff ff97 	bl	800a6e4 <vTaskGetInfo>
				uxTask++;
 800a7b6:	3701      	adds	r7, #1
 800a7b8:	3524      	adds	r5, #36	; 0x24
			} while( pxNextTCB != pxFirstTCB );
 800a7ba:	45b3      	cmp	fp, r6
 800a7bc:	d1ec      	bne.n	800a798 <prvListTasksWithinSingleList+0x2c>
	}
 800a7be:	4638      	mov	r0, r7
 800a7c0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800a7c4 <uxTaskGetSystemState>:
	{
 800a7c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a7c8:	4607      	mov	r7, r0
 800a7ca:	460c      	mov	r4, r1
 800a7cc:	4616      	mov	r6, r2
		vTaskSuspendAll();
 800a7ce:	f7ff fc27 	bl	800a020 <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 800a7d2:	4b24      	ldr	r3, [pc, #144]	; (800a864 <uxTaskGetSystemState+0xa0>)
 800a7d4:	681b      	ldr	r3, [r3, #0]
 800a7d6:	42a3      	cmp	r3, r4
 800a7d8:	d842      	bhi.n	800a860 <uxTaskGetSystemState+0x9c>
 800a7da:	4b23      	ldr	r3, [pc, #140]	; (800a868 <uxTaskGetSystemState+0xa4>)
 800a7dc:	f103 0578 	add.w	r5, r3, #120	; 0x78
 800a7e0:	f1a3 0814 	sub.w	r8, r3, #20
 800a7e4:	2400      	movs	r4, #0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 800a7e6:	f04f 0901 	mov.w	r9, #1
 800a7ea:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a7ee:	464a      	mov	r2, r9
 800a7f0:	4629      	mov	r1, r5
 800a7f2:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a7f6:	f7ff ffb9 	bl	800a76c <prvListTasksWithinSingleList>
 800a7fa:	4404      	add	r4, r0
 800a7fc:	3d14      	subs	r5, #20
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a7fe:	4545      	cmp	r5, r8
 800a800:	d1f3      	bne.n	800a7ea <uxTaskGetSystemState+0x26>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 800a802:	4b1a      	ldr	r3, [pc, #104]	; (800a86c <uxTaskGetSystemState+0xa8>)
 800a804:	6819      	ldr	r1, [r3, #0]
 800a806:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a80a:	2202      	movs	r2, #2
 800a80c:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a810:	f7ff ffac 	bl	800a76c <prvListTasksWithinSingleList>
 800a814:	4404      	add	r4, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 800a816:	4b16      	ldr	r3, [pc, #88]	; (800a870 <uxTaskGetSystemState+0xac>)
 800a818:	6819      	ldr	r1, [r3, #0]
 800a81a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a81e:	2202      	movs	r2, #2
 800a820:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a824:	f7ff ffa2 	bl	800a76c <prvListTasksWithinSingleList>
 800a828:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 800a82a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a82e:	2204      	movs	r2, #4
 800a830:	4910      	ldr	r1, [pc, #64]	; (800a874 <uxTaskGetSystemState+0xb0>)
 800a832:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a836:	f7ff ff99 	bl	800a76c <prvListTasksWithinSingleList>
 800a83a:	4404      	add	r4, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 800a83c:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800a840:	2203      	movs	r2, #3
 800a842:	490d      	ldr	r1, [pc, #52]	; (800a878 <uxTaskGetSystemState+0xb4>)
 800a844:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800a848:	f7ff ff90 	bl	800a76c <prvListTasksWithinSingleList>
 800a84c:	4404      	add	r4, r0
					if( pulTotalRunTime != NULL )
 800a84e:	b116      	cbz	r6, 800a856 <uxTaskGetSystemState+0x92>
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 800a850:	f001 fe90 	bl	800c574 <xGetRunTimeCounterValue>
 800a854:	6030      	str	r0, [r6, #0]
		( void ) xTaskResumeAll();
 800a856:	f7ff fcbd 	bl	800a1d4 <xTaskResumeAll>
	}
 800a85a:	4620      	mov	r0, r4
 800a85c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 800a860:	2400      	movs	r4, #0
 800a862:	e7f8      	b.n	800a856 <uxTaskGetSystemState+0x92>
 800a864:	20000a48 	.word	0x20000a48
 800a868:	200009b8 	.word	0x200009b8
 800a86c:	200009b0 	.word	0x200009b0
 800a870:	200009b4 	.word	0x200009b4
 800a874:	20000ac0 	.word	0x20000ac0
 800a878:	20000aac 	.word	0x20000aac

0800a87c <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 800a87c:	4b01      	ldr	r3, [pc, #4]	; (800a884 <xTaskGetCurrentTaskHandle+0x8>)
 800a87e:	6818      	ldr	r0, [r3, #0]
	}
 800a880:	4770      	bx	lr
 800a882:	bf00      	nop
 800a884:	200009ac 	.word	0x200009ac

0800a888 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 800a888:	4b05      	ldr	r3, [pc, #20]	; (800a8a0 <xTaskGetSchedulerState+0x18>)
 800a88a:	681b      	ldr	r3, [r3, #0]
 800a88c:	b133      	cbz	r3, 800a89c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800a88e:	4b05      	ldr	r3, [pc, #20]	; (800a8a4 <xTaskGetSchedulerState+0x1c>)
 800a890:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
 800a892:	2b00      	cmp	r3, #0
 800a894:	bf0c      	ite	eq
 800a896:	2002      	moveq	r0, #2
 800a898:	2000      	movne	r0, #0
 800a89a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 800a89c:	2001      	movs	r0, #1
	}
 800a89e:	4770      	bx	lr
 800a8a0:	20000aa8 	.word	0x20000aa8
 800a8a4:	20000a54 	.word	0x20000a54

0800a8a8 <vTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 800a8a8:	2800      	cmp	r0, #0
 800a8aa:	d044      	beq.n	800a936 <vTaskPriorityInherit+0x8e>
	{
 800a8ac:	b538      	push	{r3, r4, r5, lr}
 800a8ae:	4604      	mov	r4, r0
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800a8b0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800a8b2:	4921      	ldr	r1, [pc, #132]	; (800a938 <vTaskPriorityInherit+0x90>)
 800a8b4:	6809      	ldr	r1, [r1, #0]
 800a8b6:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800a8b8:	428a      	cmp	r2, r1
 800a8ba:	d214      	bcs.n	800a8e6 <vTaskPriorityInherit+0x3e>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800a8bc:	6981      	ldr	r1, [r0, #24]
 800a8be:	2900      	cmp	r1, #0
 800a8c0:	db05      	blt.n	800a8ce <vTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a8c2:	491d      	ldr	r1, [pc, #116]	; (800a938 <vTaskPriorityInherit+0x90>)
 800a8c4:	6809      	ldr	r1, [r1, #0]
 800a8c6:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800a8c8:	f1c1 0107 	rsb	r1, r1, #7
 800a8cc:	6181      	str	r1, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800a8ce:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800a8d2:	491a      	ldr	r1, [pc, #104]	; (800a93c <vTaskPriorityInherit+0x94>)
 800a8d4:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800a8d8:	6961      	ldr	r1, [r4, #20]
 800a8da:	4291      	cmp	r1, r2
 800a8dc:	d004      	beq.n	800a8e8 <vTaskPriorityInherit+0x40>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800a8de:	4a16      	ldr	r2, [pc, #88]	; (800a938 <vTaskPriorityInherit+0x90>)
 800a8e0:	6812      	ldr	r2, [r2, #0]
 800a8e2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800a8e4:	62e2      	str	r2, [r4, #44]	; 0x2c
 800a8e6:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800a8e8:	1d25      	adds	r5, r4, #4
 800a8ea:	4628      	mov	r0, r5
 800a8ec:	f7fe fae2 	bl	8008eb4 <uxListRemove>
 800a8f0:	b970      	cbnz	r0, 800a910 <vTaskPriorityInherit+0x68>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800a8f2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a8f4:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800a8f8:	4a10      	ldr	r2, [pc, #64]	; (800a93c <vTaskPriorityInherit+0x94>)
 800a8fa:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800a8fe:	b93a      	cbnz	r2, 800a910 <vTaskPriorityInherit+0x68>
 800a900:	480f      	ldr	r0, [pc, #60]	; (800a940 <vTaskPriorityInherit+0x98>)
 800a902:	6802      	ldr	r2, [r0, #0]
 800a904:	2101      	movs	r1, #1
 800a906:	fa01 f303 	lsl.w	r3, r1, r3
 800a90a:	ea22 0303 	bic.w	r3, r2, r3
 800a90e:	6003      	str	r3, [r0, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800a910:	4b09      	ldr	r3, [pc, #36]	; (800a938 <vTaskPriorityInherit+0x90>)
 800a912:	681b      	ldr	r3, [r3, #0]
 800a914:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800a916:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 800a918:	4a09      	ldr	r2, [pc, #36]	; (800a940 <vTaskPriorityInherit+0x98>)
 800a91a:	6811      	ldr	r1, [r2, #0]
 800a91c:	2301      	movs	r3, #1
 800a91e:	4083      	lsls	r3, r0
 800a920:	430b      	orrs	r3, r1
 800a922:	6013      	str	r3, [r2, #0]
 800a924:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a928:	4629      	mov	r1, r5
 800a92a:	4b04      	ldr	r3, [pc, #16]	; (800a93c <vTaskPriorityInherit+0x94>)
 800a92c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a930:	f7fe fa9a 	bl	8008e68 <vListInsertEnd>
 800a934:	bd38      	pop	{r3, r4, r5, pc}
 800a936:	4770      	bx	lr
 800a938:	200009ac 	.word	0x200009ac
 800a93c:	200009b8 	.word	0x200009b8
 800a940:	20000a5c 	.word	0x20000a5c

0800a944 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 800a944:	2800      	cmp	r0, #0
 800a946:	d046      	beq.n	800a9d6 <xTaskPriorityDisinherit+0x92>
	{
 800a948:	b538      	push	{r3, r4, r5, lr}
 800a94a:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 800a94c:	4b24      	ldr	r3, [pc, #144]	; (800a9e0 <xTaskPriorityDisinherit+0x9c>)
 800a94e:	681b      	ldr	r3, [r3, #0]
 800a950:	4298      	cmp	r0, r3
 800a952:	d004      	beq.n	800a95e <xTaskPriorityDisinherit+0x1a>
 800a954:	f44f 616c 	mov.w	r1, #3776	; 0xec0
 800a958:	4822      	ldr	r0, [pc, #136]	; (800a9e4 <xTaskPriorityDisinherit+0xa0>)
 800a95a:	f001 fd01 	bl	800c360 <vAssertCalled>
			configASSERT( pxTCB->uxMutexesHeld );
 800a95e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800a960:	b14b      	cbz	r3, 800a976 <xTaskPriorityDisinherit+0x32>
			( pxTCB->uxMutexesHeld )--;
 800a962:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800a964:	3b01      	subs	r3, #1
 800a966:	6523      	str	r3, [r4, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800a968:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800a96a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800a96c:	4291      	cmp	r1, r2
 800a96e:	d034      	beq.n	800a9da <xTaskPriorityDisinherit+0x96>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800a970:	b13b      	cbz	r3, 800a982 <xTaskPriorityDisinherit+0x3e>
	BaseType_t xReturn = pdFALSE;
 800a972:	2000      	movs	r0, #0
	}
 800a974:	bd38      	pop	{r3, r4, r5, pc}
			configASSERT( pxTCB->uxMutexesHeld );
 800a976:	f640 61c2 	movw	r1, #3778	; 0xec2
 800a97a:	481a      	ldr	r0, [pc, #104]	; (800a9e4 <xTaskPriorityDisinherit+0xa0>)
 800a97c:	f001 fcf0 	bl	800c360 <vAssertCalled>
 800a980:	e7ef      	b.n	800a962 <xTaskPriorityDisinherit+0x1e>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800a982:	1d25      	adds	r5, r4, #4
 800a984:	4628      	mov	r0, r5
 800a986:	f7fe fa95 	bl	8008eb4 <uxListRemove>
 800a98a:	b970      	cbnz	r0, 800a9aa <xTaskPriorityDisinherit+0x66>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800a98c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a98e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800a992:	4a15      	ldr	r2, [pc, #84]	; (800a9e8 <xTaskPriorityDisinherit+0xa4>)
 800a994:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800a998:	b93a      	cbnz	r2, 800a9aa <xTaskPriorityDisinherit+0x66>
 800a99a:	4814      	ldr	r0, [pc, #80]	; (800a9ec <xTaskPriorityDisinherit+0xa8>)
 800a99c:	6802      	ldr	r2, [r0, #0]
 800a99e:	2101      	movs	r1, #1
 800a9a0:	fa01 f303 	lsl.w	r3, r1, r3
 800a9a4:	ea22 0303 	bic.w	r3, r2, r3
 800a9a8:	6003      	str	r3, [r0, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800a9aa:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800a9ac:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a9ae:	f1c0 0307 	rsb	r3, r0, #7
 800a9b2:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 800a9b4:	4a0d      	ldr	r2, [pc, #52]	; (800a9ec <xTaskPriorityDisinherit+0xa8>)
 800a9b6:	6811      	ldr	r1, [r2, #0]
 800a9b8:	2401      	movs	r4, #1
 800a9ba:	fa04 f300 	lsl.w	r3, r4, r0
 800a9be:	430b      	orrs	r3, r1
 800a9c0:	6013      	str	r3, [r2, #0]
 800a9c2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a9c6:	4629      	mov	r1, r5
 800a9c8:	4b07      	ldr	r3, [pc, #28]	; (800a9e8 <xTaskPriorityDisinherit+0xa4>)
 800a9ca:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800a9ce:	f7fe fa4b 	bl	8008e68 <vListInsertEnd>
					xReturn = pdTRUE;
 800a9d2:	4620      	mov	r0, r4
 800a9d4:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
 800a9d6:	2000      	movs	r0, #0
 800a9d8:	4770      	bx	lr
 800a9da:	2000      	movs	r0, #0
 800a9dc:	bd38      	pop	{r3, r4, r5, pc}
 800a9de:	bf00      	nop
 800a9e0:	200009ac 	.word	0x200009ac
 800a9e4:	0800d0e0 	.word	0x0800d0e0
 800a9e8:	200009b8 	.word	0x200009b8
 800a9ec:	20000a5c 	.word	0x20000a5c

0800a9f0 <vTaskList>:
	{
 800a9f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a9f4:	b085      	sub	sp, #20
 800a9f6:	4605      	mov	r5, r0
		*pcWriteBuffer = 0x00;
 800a9f8:	2300      	movs	r3, #0
 800a9fa:	7003      	strb	r3, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 800a9fc:	4b36      	ldr	r3, [pc, #216]	; (800aad8 <vTaskList+0xe8>)
 800a9fe:	681a      	ldr	r2, [r3, #0]
 800aa00:	9203      	str	r2, [sp, #12]
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
 800aa02:	6818      	ldr	r0, [r3, #0]
 800aa04:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800aa08:	0080      	lsls	r0, r0, #2
 800aa0a:	f7fe fc35 	bl	8009278 <pvPortMalloc>
		if( pxTaskStatusArray != NULL )
 800aa0e:	2800      	cmp	r0, #0
 800aa10:	d05f      	beq.n	800aad2 <vTaskList+0xe2>
 800aa12:	4604      	mov	r4, r0
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
 800aa14:	9903      	ldr	r1, [sp, #12]
 800aa16:	2200      	movs	r2, #0
 800aa18:	f7ff fed4 	bl	800a7c4 <uxTaskGetSystemState>
 800aa1c:	9003      	str	r0, [sp, #12]
			for( x = 0; x < uxArraySize; x++ )
 800aa1e:	2300      	movs	r3, #0
 800aa20:	9302      	str	r3, [sp, #8]
 800aa22:	9a02      	ldr	r2, [sp, #8]
 800aa24:	9b03      	ldr	r3, [sp, #12]
 800aa26:	429a      	cmp	r2, r3
 800aa28:	d250      	bcs.n	800aacc <vTaskList+0xdc>
					case eBlocked:		cStatus = tskBLOCKED_CHAR;
 800aa2a:	f04f 0942 	mov.w	r9, #66	; 0x42
					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
 800aa2e:	f04f 0853 	mov.w	r8, #83	; 0x53
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
 800aa32:	4f2a      	ldr	r7, [pc, #168]	; (800aadc <vTaskList+0xec>)
 800aa34:	e035      	b.n	800aaa2 <vTaskList+0xb2>
					case eBlocked:		cStatus = tskBLOCKED_CHAR;
 800aa36:	464e      	mov	r6, r9
 800aa38:	e006      	b.n	800aa48 <vTaskList+0x58>
					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
 800aa3a:	4646      	mov	r6, r8
										break;
 800aa3c:	e004      	b.n	800aa48 <vTaskList+0x58>
					case eDeleted:		cStatus = tskDELETED_CHAR;
 800aa3e:	2644      	movs	r6, #68	; 0x44
										break;
 800aa40:	e002      	b.n	800aa48 <vTaskList+0x58>
										cStatus = 0x00;
 800aa42:	2600      	movs	r6, #0
										break;
 800aa44:	e000      	b.n	800aa48 <vTaskList+0x58>
					case eReady:		cStatus = tskREADY_CHAR;
 800aa46:	2652      	movs	r6, #82	; 0x52
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 800aa48:	9b02      	ldr	r3, [sp, #8]
 800aa4a:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800aa4e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800aa52:	6859      	ldr	r1, [r3, #4]
 800aa54:	4628      	mov	r0, r5
 800aa56:	f7ff f8f7 	bl	8009c48 <prvWriteNameToBuffer>
 800aa5a:	4605      	mov	r5, r0
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
 800aa5c:	9b02      	ldr	r3, [sp, #8]
 800aa5e:	9a02      	ldr	r2, [sp, #8]
 800aa60:	9902      	ldr	r1, [sp, #8]
 800aa62:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800aa66:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800aa6a:	691b      	ldr	r3, [r3, #16]
 800aa6c:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 800aa70:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800aa74:	6889      	ldr	r1, [r1, #8]
 800aa76:	9101      	str	r1, [sp, #4]
 800aa78:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 800aa7c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800aa80:	8c12      	ldrh	r2, [r2, #32]
 800aa82:	9200      	str	r2, [sp, #0]
 800aa84:	4632      	mov	r2, r6
 800aa86:	4639      	mov	r1, r7
 800aa88:	f001 f9c1 	bl	800be0e <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer );
 800aa8c:	4628      	mov	r0, r5
 800aa8e:	f7f5 fb9f 	bl	80001d0 <strlen>
 800aa92:	4405      	add	r5, r0
			for( x = 0; x < uxArraySize; x++ )
 800aa94:	9b02      	ldr	r3, [sp, #8]
 800aa96:	3301      	adds	r3, #1
 800aa98:	9302      	str	r3, [sp, #8]
 800aa9a:	9a02      	ldr	r2, [sp, #8]
 800aa9c:	9b03      	ldr	r3, [sp, #12]
 800aa9e:	429a      	cmp	r2, r3
 800aaa0:	d214      	bcs.n	800aacc <vTaskList+0xdc>
				switch( pxTaskStatusArray[ x ].eCurrentState )
 800aaa2:	9b02      	ldr	r3, [sp, #8]
 800aaa4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800aaa8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800aaac:	7b1b      	ldrb	r3, [r3, #12]
 800aaae:	3b01      	subs	r3, #1
 800aab0:	2b03      	cmp	r3, #3
 800aab2:	d8c6      	bhi.n	800aa42 <vTaskList+0x52>
 800aab4:	a201      	add	r2, pc, #4	; (adr r2, 800aabc <vTaskList+0xcc>)
 800aab6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800aaba:	bf00      	nop
 800aabc:	0800aa47 	.word	0x0800aa47
 800aac0:	0800aa37 	.word	0x0800aa37
 800aac4:	0800aa3b 	.word	0x0800aa3b
 800aac8:	0800aa3f 	.word	0x0800aa3f
			vPortFree( pxTaskStatusArray );
 800aacc:	4620      	mov	r0, r4
 800aace:	f7fe fc39 	bl	8009344 <vPortFree>
	}
 800aad2:	b005      	add	sp, #20
 800aad4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800aad8:	20000a48 	.word	0x20000a48
 800aadc:	0800d11c 	.word	0x0800d11c

0800aae0 <vTaskGetRunTimeStats>:
	{
 800aae0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800aae4:	b084      	sub	sp, #16
 800aae6:	4604      	mov	r4, r0
		*pcWriteBuffer = 0x00;
 800aae8:	2300      	movs	r3, #0
 800aaea:	7003      	strb	r3, [r0, #0]
		uxArraySize = uxCurrentNumberOfTasks;
 800aaec:	4b2e      	ldr	r3, [pc, #184]	; (800aba8 <vTaskGetRunTimeStats+0xc8>)
 800aaee:	681a      	ldr	r2, [r3, #0]
 800aaf0:	9203      	str	r2, [sp, #12]
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
 800aaf2:	6818      	ldr	r0, [r3, #0]
 800aaf4:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
 800aaf8:	0080      	lsls	r0, r0, #2
 800aafa:	f7fe fbbd 	bl	8009278 <pvPortMalloc>
		if( pxTaskStatusArray != NULL )
 800aafe:	2800      	cmp	r0, #0
 800ab00:	d04e      	beq.n	800aba0 <vTaskGetRunTimeStats+0xc0>
 800ab02:	4605      	mov	r5, r0
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
 800ab04:	9903      	ldr	r1, [sp, #12]
 800ab06:	aa01      	add	r2, sp, #4
 800ab08:	f7ff fe5c 	bl	800a7c4 <uxTaskGetSystemState>
 800ab0c:	9003      	str	r0, [sp, #12]
			ulTotalTime /= 100UL;
 800ab0e:	4a27      	ldr	r2, [pc, #156]	; (800abac <vTaskGetRunTimeStats+0xcc>)
 800ab10:	9b01      	ldr	r3, [sp, #4]
 800ab12:	fba2 2303 	umull	r2, r3, r2, r3
 800ab16:	095b      	lsrs	r3, r3, #5
 800ab18:	9301      	str	r3, [sp, #4]
			if( ulTotalTime > 0 )
 800ab1a:	2b00      	cmp	r3, #0
 800ab1c:	d03d      	beq.n	800ab9a <vTaskGetRunTimeStats+0xba>
				for( x = 0; x < uxArraySize; x++ )
 800ab1e:	2300      	movs	r3, #0
 800ab20:	9302      	str	r3, [sp, #8]
 800ab22:	9a02      	ldr	r2, [sp, #8]
 800ab24:	9b03      	ldr	r3, [sp, #12]
 800ab26:	429a      	cmp	r2, r3
 800ab28:	d237      	bcs.n	800ab9a <vTaskGetRunTimeStats+0xba>
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
 800ab2a:	4f21      	ldr	r7, [pc, #132]	; (800abb0 <vTaskGetRunTimeStats+0xd0>)
							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
 800ab2c:	f8df 8084 	ldr.w	r8, [pc, #132]	; 800abb4 <vTaskGetRunTimeStats+0xd4>
 800ab30:	e013      	b.n	800ab5a <vTaskGetRunTimeStats+0x7a>
 800ab32:	9b02      	ldr	r3, [sp, #8]
 800ab34:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800ab38:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800ab3c:	699a      	ldr	r2, [r3, #24]
 800ab3e:	4641      	mov	r1, r8
 800ab40:	f001 f965 	bl	800be0e <sprintf>
					pcWriteBuffer += strlen( pcWriteBuffer );
 800ab44:	4620      	mov	r0, r4
 800ab46:	f7f5 fb43 	bl	80001d0 <strlen>
 800ab4a:	4404      	add	r4, r0
				for( x = 0; x < uxArraySize; x++ )
 800ab4c:	9b02      	ldr	r3, [sp, #8]
 800ab4e:	3301      	adds	r3, #1
 800ab50:	9302      	str	r3, [sp, #8]
 800ab52:	9a02      	ldr	r2, [sp, #8]
 800ab54:	9b03      	ldr	r3, [sp, #12]
 800ab56:	429a      	cmp	r2, r3
 800ab58:	d21f      	bcs.n	800ab9a <vTaskGetRunTimeStats+0xba>
					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
 800ab5a:	9b02      	ldr	r3, [sp, #8]
 800ab5c:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800ab60:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800ab64:	699e      	ldr	r6, [r3, #24]
 800ab66:	9b01      	ldr	r3, [sp, #4]
 800ab68:	fbb6 f6f3 	udiv	r6, r6, r3
					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
 800ab6c:	9b02      	ldr	r3, [sp, #8]
 800ab6e:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800ab72:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800ab76:	6859      	ldr	r1, [r3, #4]
 800ab78:	4620      	mov	r0, r4
 800ab7a:	f7ff f865 	bl	8009c48 <prvWriteNameToBuffer>
 800ab7e:	4604      	mov	r4, r0
					if( ulStatsAsPercentage > 0UL )
 800ab80:	2e00      	cmp	r6, #0
 800ab82:	d0d6      	beq.n	800ab32 <vTaskGetRunTimeStats+0x52>
							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
 800ab84:	9b02      	ldr	r3, [sp, #8]
 800ab86:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800ab8a:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 800ab8e:	4633      	mov	r3, r6
 800ab90:	6992      	ldr	r2, [r2, #24]
 800ab92:	4639      	mov	r1, r7
 800ab94:	f001 f93b 	bl	800be0e <sprintf>
 800ab98:	e7d4      	b.n	800ab44 <vTaskGetRunTimeStats+0x64>
			vPortFree( pxTaskStatusArray );
 800ab9a:	4628      	mov	r0, r5
 800ab9c:	f7fe fbd2 	bl	8009344 <vPortFree>
	}
 800aba0:	b004      	add	sp, #16
 800aba2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800aba6:	bf00      	nop
 800aba8:	20000a48 	.word	0x20000a48
 800abac:	51eb851f 	.word	0x51eb851f
 800abb0:	0800d104 	.word	0x0800d104
 800abb4:	0800d110 	.word	0x0800d110

0800abb8 <uxTaskResetEventItemValue>:
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 800abb8:	4b04      	ldr	r3, [pc, #16]	; (800abcc <uxTaskResetEventItemValue+0x14>)
 800abba:	681a      	ldr	r2, [r3, #0]
 800abbc:	6990      	ldr	r0, [r2, #24]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800abbe:	681a      	ldr	r2, [r3, #0]
 800abc0:	681b      	ldr	r3, [r3, #0]
 800abc2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800abc4:	f1c3 0307 	rsb	r3, r3, #7
 800abc8:	6193      	str	r3, [r2, #24]
}
 800abca:	4770      	bx	lr
 800abcc:	200009ac 	.word	0x200009ac

0800abd0 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 800abd0:	4b05      	ldr	r3, [pc, #20]	; (800abe8 <pvTaskIncrementMutexHeldCount+0x18>)
 800abd2:	681b      	ldr	r3, [r3, #0]
 800abd4:	b123      	cbz	r3, 800abe0 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 800abd6:	4b04      	ldr	r3, [pc, #16]	; (800abe8 <pvTaskIncrementMutexHeldCount+0x18>)
 800abd8:	681a      	ldr	r2, [r3, #0]
 800abda:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800abdc:	3301      	adds	r3, #1
 800abde:	6513      	str	r3, [r2, #80]	; 0x50
		return pxCurrentTCB;
 800abe0:	4b01      	ldr	r3, [pc, #4]	; (800abe8 <pvTaskIncrementMutexHeldCount+0x18>)
 800abe2:	6818      	ldr	r0, [r3, #0]
	}
 800abe4:	4770      	bx	lr
 800abe6:	bf00      	nop
 800abe8:	200009ac 	.word	0x200009ac

0800abec <ulTaskNotifyTake>:
	{
 800abec:	b538      	push	{r3, r4, r5, lr}
 800abee:	4605      	mov	r5, r0
 800abf0:	460c      	mov	r4, r1
		taskENTER_CRITICAL();
 800abf2:	f7fe f9b7 	bl	8008f64 <vPortEnterCritical>
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 800abf6:	4b19      	ldr	r3, [pc, #100]	; (800ac5c <ulTaskNotifyTake+0x70>)
 800abf8:	681b      	ldr	r3, [r3, #0]
 800abfa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800abfc:	b92b      	cbnz	r3, 800ac0a <ulTaskNotifyTake+0x1e>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 800abfe:	4b17      	ldr	r3, [pc, #92]	; (800ac5c <ulTaskNotifyTake+0x70>)
 800ac00:	681b      	ldr	r3, [r3, #0]
 800ac02:	2201      	movs	r2, #1
 800ac04:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
				if( xTicksToWait > ( TickType_t ) 0 )
 800ac08:	b9ac      	cbnz	r4, 800ac36 <ulTaskNotifyTake+0x4a>
		taskEXIT_CRITICAL();
 800ac0a:	f7fe f9cd 	bl	8008fa8 <vPortExitCritical>
		taskENTER_CRITICAL();
 800ac0e:	f7fe f9a9 	bl	8008f64 <vPortEnterCritical>
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 800ac12:	4b12      	ldr	r3, [pc, #72]	; (800ac5c <ulTaskNotifyTake+0x70>)
 800ac14:	681b      	ldr	r3, [r3, #0]
 800ac16:	6e5c      	ldr	r4, [r3, #100]	; 0x64
			if( ulReturn != 0UL )
 800ac18:	b124      	cbz	r4, 800ac24 <ulTaskNotifyTake+0x38>
				if( xClearCountOnExit != pdFALSE )
 800ac1a:	b9cd      	cbnz	r5, 800ac50 <ulTaskNotifyTake+0x64>
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 800ac1c:	4b0f      	ldr	r3, [pc, #60]	; (800ac5c <ulTaskNotifyTake+0x70>)
 800ac1e:	681b      	ldr	r3, [r3, #0]
 800ac20:	1e62      	subs	r2, r4, #1
 800ac22:	665a      	str	r2, [r3, #100]	; 0x64
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800ac24:	4b0d      	ldr	r3, [pc, #52]	; (800ac5c <ulTaskNotifyTake+0x70>)
 800ac26:	681b      	ldr	r3, [r3, #0]
 800ac28:	2200      	movs	r2, #0
 800ac2a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		taskEXIT_CRITICAL();
 800ac2e:	f7fe f9bb 	bl	8008fa8 <vPortExitCritical>
	}
 800ac32:	4620      	mov	r0, r4
 800ac34:	bd38      	pop	{r3, r4, r5, pc}
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800ac36:	4611      	mov	r1, r2
 800ac38:	4620      	mov	r0, r4
 800ac3a:	f7fe ffb9 	bl	8009bb0 <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 800ac3e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ac42:	4b07      	ldr	r3, [pc, #28]	; (800ac60 <ulTaskNotifyTake+0x74>)
 800ac44:	601a      	str	r2, [r3, #0]
 800ac46:	f3bf 8f4f 	dsb	sy
 800ac4a:	f3bf 8f6f 	isb	sy
 800ac4e:	e7dc      	b.n	800ac0a <ulTaskNotifyTake+0x1e>
					pxCurrentTCB->ulNotifiedValue = 0UL;
 800ac50:	4b02      	ldr	r3, [pc, #8]	; (800ac5c <ulTaskNotifyTake+0x70>)
 800ac52:	681b      	ldr	r3, [r3, #0]
 800ac54:	2200      	movs	r2, #0
 800ac56:	665a      	str	r2, [r3, #100]	; 0x64
 800ac58:	e7e4      	b.n	800ac24 <ulTaskNotifyTake+0x38>
 800ac5a:	bf00      	nop
 800ac5c:	200009ac 	.word	0x200009ac
 800ac60:	e000ed04 	.word	0xe000ed04

0800ac64 <xTaskGenericNotify>:
	{
 800ac64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ac66:	460f      	mov	r7, r1
 800ac68:	4615      	mov	r5, r2
 800ac6a:	461e      	mov	r6, r3
		configASSERT( xTaskToNotify );
 800ac6c:	4604      	mov	r4, r0
 800ac6e:	b188      	cbz	r0, 800ac94 <xTaskGenericNotify+0x30>
		taskENTER_CRITICAL();
 800ac70:	f7fe f978 	bl	8008f64 <vPortEnterCritical>
			if( pulPreviousNotificationValue != NULL )
 800ac74:	b10e      	cbz	r6, 800ac7a <xTaskGenericNotify+0x16>
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 800ac76:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ac78:	6033      	str	r3, [r6, #0]
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800ac7a:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800ac7e:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800ac80:	2202      	movs	r2, #2
 800ac82:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			switch( eAction )
 800ac86:	1e6a      	subs	r2, r5, #1
 800ac88:	2a03      	cmp	r2, #3
 800ac8a:	d80c      	bhi.n	800aca6 <xTaskGenericNotify+0x42>
 800ac8c:	e8df f002 	tbb	[pc, r2]
 800ac90:	18161208 	.word	0x18161208
		configASSERT( xTaskToNotify );
 800ac94:	f241 01f6 	movw	r1, #4342	; 0x10f6
 800ac98:	4822      	ldr	r0, [pc, #136]	; (800ad24 <xTaskGenericNotify+0xc0>)
 800ac9a:	f001 fb61 	bl	800c360 <vAssertCalled>
 800ac9e:	e7e7      	b.n	800ac70 <xTaskGenericNotify+0xc>
					pxTCB->ulNotifiedValue |= ulValue;
 800aca0:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800aca2:	4317      	orrs	r7, r2
 800aca4:	6667      	str	r7, [r4, #100]	; 0x64
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800aca6:	2b01      	cmp	r3, #1
 800aca8:	d00e      	beq.n	800acc8 <xTaskGenericNotify+0x64>
 800acaa:	2401      	movs	r4, #1
		taskEXIT_CRITICAL();
 800acac:	f7fe f97c 	bl	8008fa8 <vPortExitCritical>
	}
 800acb0:	4620      	mov	r0, r4
 800acb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					( pxTCB->ulNotifiedValue )++;
 800acb4:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800acb6:	3201      	adds	r2, #1
 800acb8:	6662      	str	r2, [r4, #100]	; 0x64
					break;
 800acba:	e7f4      	b.n	800aca6 <xTaskGenericNotify+0x42>
					pxTCB->ulNotifiedValue = ulValue;
 800acbc:	6667      	str	r7, [r4, #100]	; 0x64
					break;
 800acbe:	e7f2      	b.n	800aca6 <xTaskGenericNotify+0x42>
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 800acc0:	2b02      	cmp	r3, #2
 800acc2:	d02b      	beq.n	800ad1c <xTaskGenericNotify+0xb8>
						pxTCB->ulNotifiedValue = ulValue;
 800acc4:	6667      	str	r7, [r4, #100]	; 0x64
 800acc6:	e7ee      	b.n	800aca6 <xTaskGenericNotify+0x42>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800acc8:	1d25      	adds	r5, r4, #4
 800acca:	4628      	mov	r0, r5
 800accc:	f7fe f8f2 	bl	8008eb4 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 800acd0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800acd2:	4a15      	ldr	r2, [pc, #84]	; (800ad28 <xTaskGenericNotify+0xc4>)
 800acd4:	6811      	ldr	r1, [r2, #0]
 800acd6:	2301      	movs	r3, #1
 800acd8:	4083      	lsls	r3, r0
 800acda:	430b      	orrs	r3, r1
 800acdc:	6013      	str	r3, [r2, #0]
 800acde:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800ace2:	4629      	mov	r1, r5
 800ace4:	4b11      	ldr	r3, [pc, #68]	; (800ad2c <xTaskGenericNotify+0xc8>)
 800ace6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800acea:	f7fe f8bd 	bl	8008e68 <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800acee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800acf0:	b123      	cbz	r3, 800acfc <xTaskGenericNotify+0x98>
 800acf2:	f241 112e 	movw	r1, #4398	; 0x112e
 800acf6:	480b      	ldr	r0, [pc, #44]	; (800ad24 <xTaskGenericNotify+0xc0>)
 800acf8:	f001 fb32 	bl	800c360 <vAssertCalled>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800acfc:	4b0c      	ldr	r3, [pc, #48]	; (800ad30 <xTaskGenericNotify+0xcc>)
 800acfe:	681b      	ldr	r3, [r3, #0]
 800ad00:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ad02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ad04:	429a      	cmp	r2, r3
 800ad06:	d90b      	bls.n	800ad20 <xTaskGenericNotify+0xbc>
					taskYIELD_IF_USING_PREEMPTION();
 800ad08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800ad0c:	4b09      	ldr	r3, [pc, #36]	; (800ad34 <xTaskGenericNotify+0xd0>)
 800ad0e:	601a      	str	r2, [r3, #0]
 800ad10:	f3bf 8f4f 	dsb	sy
 800ad14:	f3bf 8f6f 	isb	sy
 800ad18:	2401      	movs	r4, #1
 800ad1a:	e7c7      	b.n	800acac <xTaskGenericNotify+0x48>
						xReturn = pdFAIL;
 800ad1c:	2400      	movs	r4, #0
 800ad1e:	e7c5      	b.n	800acac <xTaskGenericNotify+0x48>
 800ad20:	2401      	movs	r4, #1
 800ad22:	e7c3      	b.n	800acac <xTaskGenericNotify+0x48>
 800ad24:	0800d0e0 	.word	0x0800d0e0
 800ad28:	20000a5c 	.word	0x20000a5c
 800ad2c:	200009b8 	.word	0x200009b8
 800ad30:	200009ac 	.word	0x200009ac
 800ad34:	e000ed04 	.word	0xe000ed04

0800ad38 <vTaskNotifyGiveFromISR>:
	{
 800ad38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ad3a:	460e      	mov	r6, r1
		configASSERT( xTaskToNotify );
 800ad3c:	4604      	mov	r4, r0
 800ad3e:	b1c8      	cbz	r0, 800ad74 <vTaskNotifyGiveFromISR+0x3c>
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800ad40:	f7fe fa42 	bl	80091c8 <vPortValidateInterruptPriority>
	__asm volatile
 800ad44:	f3ef 8511 	mrs	r5, BASEPRI
 800ad48:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ad4c:	f383 8811 	msr	BASEPRI, r3
 800ad50:	f3bf 8f6f 	isb	sy
 800ad54:	f3bf 8f4f 	dsb	sy
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 800ad58:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
 800ad5c:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800ad5e:	2202      	movs	r2, #2
 800ad60:	f884 2068 	strb.w	r2, [r4, #104]	; 0x68
			( pxTCB->ulNotifiedValue )++;
 800ad64:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800ad66:	3201      	adds	r2, #1
 800ad68:	6662      	str	r2, [r4, #100]	; 0x64
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800ad6a:	2b01      	cmp	r3, #1
 800ad6c:	d008      	beq.n	800ad80 <vTaskNotifyGiveFromISR+0x48>
	__asm volatile
 800ad6e:	f385 8811 	msr	BASEPRI, r5
 800ad72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		configASSERT( xTaskToNotify );
 800ad74:	f241 11dc 	movw	r1, #4572	; 0x11dc
 800ad78:	481a      	ldr	r0, [pc, #104]	; (800ade4 <vTaskNotifyGiveFromISR+0xac>)
 800ad7a:	f001 faf1 	bl	800c360 <vAssertCalled>
 800ad7e:	e7df      	b.n	800ad40 <vTaskNotifyGiveFromISR+0x8>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800ad80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ad82:	b123      	cbz	r3, 800ad8e <vTaskNotifyGiveFromISR+0x56>
 800ad84:	f241 2102 	movw	r1, #4610	; 0x1202
 800ad88:	4816      	ldr	r0, [pc, #88]	; (800ade4 <vTaskNotifyGiveFromISR+0xac>)
 800ad8a:	f001 fae9 	bl	800c360 <vAssertCalled>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800ad8e:	4b16      	ldr	r3, [pc, #88]	; (800ade8 <vTaskNotifyGiveFromISR+0xb0>)
 800ad90:	681b      	ldr	r3, [r3, #0]
 800ad92:	b9e3      	cbnz	r3, 800adce <vTaskNotifyGiveFromISR+0x96>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800ad94:	1d27      	adds	r7, r4, #4
 800ad96:	4638      	mov	r0, r7
 800ad98:	f7fe f88c 	bl	8008eb4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800ad9c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800ad9e:	4a13      	ldr	r2, [pc, #76]	; (800adec <vTaskNotifyGiveFromISR+0xb4>)
 800ada0:	6811      	ldr	r1, [r2, #0]
 800ada2:	2301      	movs	r3, #1
 800ada4:	4083      	lsls	r3, r0
 800ada6:	430b      	orrs	r3, r1
 800ada8:	6013      	str	r3, [r2, #0]
 800adaa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800adae:	4639      	mov	r1, r7
 800adb0:	4b0f      	ldr	r3, [pc, #60]	; (800adf0 <vTaskNotifyGiveFromISR+0xb8>)
 800adb2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800adb6:	f7fe f857 	bl	8008e68 <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800adba:	4b0e      	ldr	r3, [pc, #56]	; (800adf4 <vTaskNotifyGiveFromISR+0xbc>)
 800adbc:	681b      	ldr	r3, [r3, #0]
 800adbe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800adc0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800adc2:	429a      	cmp	r2, r3
 800adc4:	d9d3      	bls.n	800ad6e <vTaskNotifyGiveFromISR+0x36>
					if( pxHigherPriorityTaskWoken != NULL )
 800adc6:	b146      	cbz	r6, 800adda <vTaskNotifyGiveFromISR+0xa2>
						*pxHigherPriorityTaskWoken = pdTRUE;
 800adc8:	2301      	movs	r3, #1
 800adca:	6033      	str	r3, [r6, #0]
 800adcc:	e7cf      	b.n	800ad6e <vTaskNotifyGiveFromISR+0x36>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800adce:	f104 0118 	add.w	r1, r4, #24
 800add2:	4809      	ldr	r0, [pc, #36]	; (800adf8 <vTaskNotifyGiveFromISR+0xc0>)
 800add4:	f7fe f848 	bl	8008e68 <vListInsertEnd>
 800add8:	e7ef      	b.n	800adba <vTaskNotifyGiveFromISR+0x82>
						xYieldPending = pdTRUE;
 800adda:	2201      	movs	r2, #1
 800addc:	4b07      	ldr	r3, [pc, #28]	; (800adfc <vTaskNotifyGiveFromISR+0xc4>)
 800adde:	601a      	str	r2, [r3, #0]
 800ade0:	e7c5      	b.n	800ad6e <vTaskNotifyGiveFromISR+0x36>
 800ade2:	bf00      	nop
 800ade4:	0800d0e0 	.word	0x0800d0e0
 800ade8:	20000a54 	.word	0x20000a54
 800adec:	20000a5c 	.word	0x20000a5c
 800adf0:	200009b8 	.word	0x200009b8
 800adf4:	200009ac 	.word	0x200009ac
 800adf8:	20000a94 	.word	0x20000a94
 800adfc:	20000ad8 	.word	0x20000ad8

0800ae00 <prvQueryHeapCommand>:
/*-----------------------------------------------------------*/

#if( configINCLUDE_QUERY_HEAP_COMMAND == 1 )

	static BaseType_t prvQueryHeapCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
	{
 800ae00:	b538      	push	{r3, r4, r5, lr}
		/* Remove compile time warnings about unused parameters, and check the
		write buffer is not NULL.  NOTE - for simplicity, this example assumes the
		write buffer length is adequate, so does not check for buffer overflows. */
		( void ) pcCommandString;
		( void ) xWriteBufferLen;
		configASSERT( pcWriteBuffer );
 800ae02:	4604      	mov	r4, r0
 800ae04:	b160      	cbz	r0, 800ae20 <prvQueryHeapCommand+0x20>

		sprintf( pcWriteBuffer, "Current free heap %d bytes, minimum ever free heap %d bytes\r\n", ( int ) xPortGetFreeHeapSize(), ( int ) xPortGetMinimumEverFreeHeapSize() );
 800ae06:	f7fe fae7 	bl	80093d8 <xPortGetFreeHeapSize>
 800ae0a:	4605      	mov	r5, r0
 800ae0c:	f7fe faea 	bl	80093e4 <xPortGetMinimumEverFreeHeapSize>
 800ae10:	4603      	mov	r3, r0
 800ae12:	462a      	mov	r2, r5
 800ae14:	4905      	ldr	r1, [pc, #20]	; (800ae2c <prvQueryHeapCommand+0x2c>)
 800ae16:	4620      	mov	r0, r4
 800ae18:	f000 fff9 	bl	800be0e <sprintf>

		/* There is no more data to return after this single string, so return
		pdFALSE. */
		return pdFALSE;
	}
 800ae1c:	2000      	movs	r0, #0
 800ae1e:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pcWriteBuffer );
 800ae20:	f44f 7194 	mov.w	r1, #296	; 0x128
 800ae24:	4802      	ldr	r0, [pc, #8]	; (800ae30 <prvQueryHeapCommand+0x30>)
 800ae26:	f001 fa9b 	bl	800c360 <vAssertCalled>
 800ae2a:	e7ec      	b.n	800ae06 <prvQueryHeapCommand+0x6>
 800ae2c:	0800d190 	.word	0x0800d190
 800ae30:	0800d154 	.word	0x0800d154

0800ae34 <prvRunTimeStatsCommand>:
/*-----------------------------------------------------------*/

#if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static BaseType_t prvRunTimeStatsCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
	{
 800ae34:	b510      	push	{r4, lr}
		/* Remove compile time warnings about unused parameters, and check the
		write buffer is not NULL.  NOTE - for simplicity, this example assumes the
		write buffer length is adequate, so does not check for buffer overflows. */
		( void ) pcCommandString;
		( void ) xWriteBufferLen;
		configASSERT( pcWriteBuffer );
 800ae36:	4604      	mov	r4, r0
 800ae38:	b150      	cbz	r0, 800ae50 <prvRunTimeStatsCommand+0x1c>

		/* Generate a table of task stats. */
		strcpy( pcWriteBuffer, pcHeader );
 800ae3a:	2251      	movs	r2, #81	; 0x51
 800ae3c:	4907      	ldr	r1, [pc, #28]	; (800ae5c <prvRunTimeStatsCommand+0x28>)
 800ae3e:	4620      	mov	r0, r4
 800ae40:	f001 fc49 	bl	800c6d6 <memcpy>
		vTaskGetRunTimeStats( pcWriteBuffer + strlen( pcHeader ) );
 800ae44:	f104 0050 	add.w	r0, r4, #80	; 0x50
 800ae48:	f7ff fe4a 	bl	800aae0 <vTaskGetRunTimeStats>

		/* There is no more data to return after this single string, so return
		pdFALSE. */
		return pdFALSE;
	}
 800ae4c:	2000      	movs	r0, #0
 800ae4e:	bd10      	pop	{r4, pc}
		configASSERT( pcWriteBuffer );
 800ae50:	f240 113f 	movw	r1, #319	; 0x13f
 800ae54:	4802      	ldr	r0, [pc, #8]	; (800ae60 <prvRunTimeStatsCommand+0x2c>)
 800ae56:	f001 fa83 	bl	800c360 <vAssertCalled>
 800ae5a:	e7ee      	b.n	800ae3a <prvRunTimeStatsCommand+0x6>
 800ae5c:	0800d1d0 	.word	0x0800d1d0
 800ae60:	0800d154 	.word	0x0800d154

0800ae64 <prvTaskStatsCommand>:
	{
 800ae64:	b510      	push	{r4, lr}
		configASSERT( pcWriteBuffer );
 800ae66:	4604      	mov	r4, r0
 800ae68:	b1e0      	cbz	r0, 800aea4 <prvTaskStatsCommand+0x40>
		strcpy( pcWriteBuffer, "Task" );
 800ae6a:	4b11      	ldr	r3, [pc, #68]	; (800aeb0 <prvTaskStatsCommand+0x4c>)
 800ae6c:	6818      	ldr	r0, [r3, #0]
 800ae6e:	6020      	str	r0, [r4, #0]
 800ae70:	791b      	ldrb	r3, [r3, #4]
 800ae72:	7123      	strb	r3, [r4, #4]
		pcWriteBuffer += strlen( pcWriteBuffer );
 800ae74:	4620      	mov	r0, r4
 800ae76:	f7f5 f9ab 	bl	80001d0 <strlen>
 800ae7a:	4404      	add	r4, r0
 800ae7c:	f104 0109 	add.w	r1, r4, #9
 800ae80:	4620      	mov	r0, r4
			*pcWriteBuffer = ' ';
 800ae82:	2220      	movs	r2, #32
			*pcWriteBuffer = 0x00;
 800ae84:	2300      	movs	r3, #0
			*pcWriteBuffer = ' ';
 800ae86:	7002      	strb	r2, [r0, #0]
			*pcWriteBuffer = 0x00;
 800ae88:	f800 3f01 	strb.w	r3, [r0, #1]!
		for( xSpacePadding = strlen( "Task" ); xSpacePadding < ( configMAX_TASK_NAME_LEN - 3 ); xSpacePadding++ )
 800ae8c:	4281      	cmp	r1, r0
 800ae8e:	d1fa      	bne.n	800ae86 <prvTaskStatsCommand+0x22>
		strcpy( pcWriteBuffer, pcHeader );
 800ae90:	224c      	movs	r2, #76	; 0x4c
 800ae92:	4908      	ldr	r1, [pc, #32]	; (800aeb4 <prvTaskStatsCommand+0x50>)
 800ae94:	f001 fc1f 	bl	800c6d6 <memcpy>
		vTaskList( pcWriteBuffer + strlen( pcHeader ) );
 800ae98:	f104 0054 	add.w	r0, r4, #84	; 0x54
 800ae9c:	f7ff fda8 	bl	800a9f0 <vTaskList>
	}
 800aea0:	2000      	movs	r0, #0
 800aea2:	bd10      	pop	{r4, pc}
		configASSERT( pcWriteBuffer );
 800aea4:	f44f 7181 	mov.w	r1, #258	; 0x102
 800aea8:	4803      	ldr	r0, [pc, #12]	; (800aeb8 <prvTaskStatsCommand+0x54>)
 800aeaa:	f001 fa59 	bl	800c360 <vAssertCalled>
 800aeae:	e7dc      	b.n	800ae6a <prvTaskStatsCommand+0x6>
 800aeb0:	0800d224 	.word	0x0800d224
 800aeb4:	0800d22c 	.word	0x0800d22c
 800aeb8:	0800d154 	.word	0x0800d154

0800aebc <prvParameterEchoCommand>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvParameterEchoCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 800aebc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800aebe:	b083      	sub	sp, #12
 800aec0:	460e      	mov	r6, r1
 800aec2:	4615      	mov	r5, r2
	/* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
	( void ) pcCommandString;
	( void ) xWriteBufferLen;
	configASSERT( pcWriteBuffer );
 800aec4:	4604      	mov	r4, r0
 800aec6:	b338      	cbz	r0, 800af18 <prvParameterEchoCommand+0x5c>

	if( lParameterNumber == 0 )
 800aec8:	4b21      	ldr	r3, [pc, #132]	; (800af50 <prvParameterEchoCommand+0x94>)
 800aeca:	6819      	ldr	r1, [r3, #0]
 800aecc:	b351      	cbz	r1, 800af24 <prvParameterEchoCommand+0x68>
		xReturn = pdPASS;
	}
	else
	{
		/* Obtain the parameter string. */
		pcParameter = FreeRTOS_CLIGetParameter
 800aece:	aa01      	add	r2, sp, #4
 800aed0:	4628      	mov	r0, r5
 800aed2:	f7f8 f8bb 	bl	800304c <FreeRTOS_CLIGetParameter>
							pcCommandString,		/* The command string itself. */
							lParameterNumber,		/* Return the next parameter. */
							&xParameterStringLength	/* Store the parameter string length. */
						);

		if( pcParameter != NULL )
 800aed6:	4607      	mov	r7, r0
 800aed8:	2800      	cmp	r0, #0
 800aeda:	d034      	beq.n	800af46 <prvParameterEchoCommand+0x8a>
		{
			/* Return the parameter string. */
			memset( pcWriteBuffer, 0x00, xWriteBufferLen );
 800aedc:	4632      	mov	r2, r6
 800aede:	2100      	movs	r1, #0
 800aee0:	4620      	mov	r0, r4
 800aee2:	f001 fc1d 	bl	800c720 <memset>
			sprintf( pcWriteBuffer, "%d: ", ( int ) lParameterNumber );
 800aee6:	4d1a      	ldr	r5, [pc, #104]	; (800af50 <prvParameterEchoCommand+0x94>)
 800aee8:	682a      	ldr	r2, [r5, #0]
 800aeea:	491a      	ldr	r1, [pc, #104]	; (800af54 <prvParameterEchoCommand+0x98>)
 800aeec:	4620      	mov	r0, r4
 800aeee:	f000 ff8e 	bl	800be0e <sprintf>
			strncat( pcWriteBuffer, pcParameter, xParameterStringLength );
 800aef2:	9a01      	ldr	r2, [sp, #4]
 800aef4:	4639      	mov	r1, r7
 800aef6:	4620      	mov	r0, r4
 800aef8:	f001 fc22 	bl	800c740 <strncat>
			strncat( pcWriteBuffer, "\r\n", strlen( "\r\n" ) );
 800aefc:	4620      	mov	r0, r4
 800aefe:	f7f5 f967 	bl	80001d0 <strlen>
 800af02:	1822      	adds	r2, r4, r0
 800af04:	4b14      	ldr	r3, [pc, #80]	; (800af58 <prvParameterEchoCommand+0x9c>)
 800af06:	8819      	ldrh	r1, [r3, #0]
 800af08:	789b      	ldrb	r3, [r3, #2]
 800af0a:	5221      	strh	r1, [r4, r0]
 800af0c:	7093      	strb	r3, [r2, #2]

			/* There might be more parameters to return after this one. */
			xReturn = pdTRUE;
			lParameterNumber++;
 800af0e:	682b      	ldr	r3, [r5, #0]
 800af10:	3301      	adds	r3, #1
 800af12:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 800af14:	2001      	movs	r0, #1
 800af16:	e014      	b.n	800af42 <prvParameterEchoCommand+0x86>
	configASSERT( pcWriteBuffer );
 800af18:	f240 119b 	movw	r1, #411	; 0x19b
 800af1c:	480f      	ldr	r0, [pc, #60]	; (800af5c <prvParameterEchoCommand+0xa0>)
 800af1e:	f001 fa1f 	bl	800c360 <vAssertCalled>
 800af22:	e7d1      	b.n	800aec8 <prvParameterEchoCommand+0xc>
		sprintf( pcWriteBuffer, "The parameters were:\r\n" );
 800af24:	4d0e      	ldr	r5, [pc, #56]	; (800af60 <prvParameterEchoCommand+0xa4>)
 800af26:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800af28:	6020      	str	r0, [r4, #0]
 800af2a:	6061      	str	r1, [r4, #4]
 800af2c:	60a2      	str	r2, [r4, #8]
 800af2e:	60e3      	str	r3, [r4, #12]
 800af30:	6828      	ldr	r0, [r5, #0]
 800af32:	6120      	str	r0, [r4, #16]
 800af34:	88aa      	ldrh	r2, [r5, #4]
 800af36:	79ab      	ldrb	r3, [r5, #6]
 800af38:	82a2      	strh	r2, [r4, #20]
 800af3a:	75a3      	strb	r3, [r4, #22]
		lParameterNumber = 1L;
 800af3c:	2001      	movs	r0, #1
 800af3e:	4b04      	ldr	r3, [pc, #16]	; (800af50 <prvParameterEchoCommand+0x94>)
 800af40:	6018      	str	r0, [r3, #0]
			lParameterNumber = 0;
		}
	}

	return xReturn;
}
 800af42:	b003      	add	sp, #12
 800af44:	bdf0      	pop	{r4, r5, r6, r7, pc}
			pcWriteBuffer[ 0 ] = 0x00;
 800af46:	2000      	movs	r0, #0
 800af48:	7020      	strb	r0, [r4, #0]
			lParameterNumber = 0;
 800af4a:	4b01      	ldr	r3, [pc, #4]	; (800af50 <prvParameterEchoCommand+0x94>)
 800af4c:	6018      	str	r0, [r3, #0]
	return xReturn;
 800af4e:	e7f8      	b.n	800af42 <prvParameterEchoCommand+0x86>
 800af50:	20000ae0 	.word	0x20000ae0
 800af54:	0800d14c 	.word	0x0800d14c
 800af58:	0800d148 	.word	0x0800d148
 800af5c:	0800d154 	.word	0x0800d154
 800af60:	0800d134 	.word	0x0800d134

0800af64 <prvThreeParameterEchoCommand>:
{
 800af64:	b570      	push	{r4, r5, r6, lr}
 800af66:	b082      	sub	sp, #8
 800af68:	460d      	mov	r5, r1
 800af6a:	4616      	mov	r6, r2
	configASSERT( pcWriteBuffer );
 800af6c:	4604      	mov	r4, r0
 800af6e:	b358      	cbz	r0, 800afc8 <prvThreeParameterEchoCommand+0x64>
	if( lParameterNumber == 0 )
 800af70:	4b25      	ldr	r3, [pc, #148]	; (800b008 <prvThreeParameterEchoCommand+0xa4>)
 800af72:	6819      	ldr	r1, [r3, #0]
 800af74:	b371      	cbz	r1, 800afd4 <prvThreeParameterEchoCommand+0x70>
		pcParameter = FreeRTOS_CLIGetParameter
 800af76:	aa01      	add	r2, sp, #4
 800af78:	4630      	mov	r0, r6
 800af7a:	f7f8 f867 	bl	800304c <FreeRTOS_CLIGetParameter>
		configASSERT( pcParameter );
 800af7e:	4606      	mov	r6, r0
 800af80:	2800      	cmp	r0, #0
 800af82:	d037      	beq.n	800aff4 <prvThreeParameterEchoCommand+0x90>
		memset( pcWriteBuffer, 0x00, xWriteBufferLen );
 800af84:	462a      	mov	r2, r5
 800af86:	2100      	movs	r1, #0
 800af88:	4620      	mov	r0, r4
 800af8a:	f001 fbc9 	bl	800c720 <memset>
		sprintf( pcWriteBuffer, "%d: ", ( int ) lParameterNumber );
 800af8e:	4d1e      	ldr	r5, [pc, #120]	; (800b008 <prvThreeParameterEchoCommand+0xa4>)
 800af90:	682a      	ldr	r2, [r5, #0]
 800af92:	491e      	ldr	r1, [pc, #120]	; (800b00c <prvThreeParameterEchoCommand+0xa8>)
 800af94:	4620      	mov	r0, r4
 800af96:	f000 ff3a 	bl	800be0e <sprintf>
		strncat( pcWriteBuffer, pcParameter, xParameterStringLength );
 800af9a:	9a01      	ldr	r2, [sp, #4]
 800af9c:	4631      	mov	r1, r6
 800af9e:	4620      	mov	r0, r4
 800afa0:	f001 fbce 	bl	800c740 <strncat>
		strncat( pcWriteBuffer, "\r\n", strlen( "\r\n" ) );
 800afa4:	4620      	mov	r0, r4
 800afa6:	f7f5 f913 	bl	80001d0 <strlen>
 800afaa:	1822      	adds	r2, r4, r0
 800afac:	4b18      	ldr	r3, [pc, #96]	; (800b010 <prvThreeParameterEchoCommand+0xac>)
 800afae:	8819      	ldrh	r1, [r3, #0]
 800afb0:	789b      	ldrb	r3, [r3, #2]
 800afb2:	5221      	strh	r1, [r4, r0]
 800afb4:	7093      	strb	r3, [r2, #2]
		if( lParameterNumber == 3L )
 800afb6:	682b      	ldr	r3, [r5, #0]
 800afb8:	2b03      	cmp	r3, #3
 800afba:	d021      	beq.n	800b000 <prvThreeParameterEchoCommand+0x9c>
			lParameterNumber++;
 800afbc:	3301      	adds	r3, #1
 800afbe:	4a12      	ldr	r2, [pc, #72]	; (800b008 <prvThreeParameterEchoCommand+0xa4>)
 800afc0:	6013      	str	r3, [r2, #0]
			xReturn = pdTRUE;
 800afc2:	2001      	movs	r0, #1
}
 800afc4:	b002      	add	sp, #8
 800afc6:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pcWriteBuffer );
 800afc8:	f44f 71ac 	mov.w	r1, #344	; 0x158
 800afcc:	4811      	ldr	r0, [pc, #68]	; (800b014 <prvThreeParameterEchoCommand+0xb0>)
 800afce:	f001 f9c7 	bl	800c360 <vAssertCalled>
 800afd2:	e7cd      	b.n	800af70 <prvThreeParameterEchoCommand+0xc>
		sprintf( pcWriteBuffer, "The three parameters were:\r\n" );
 800afd4:	4d10      	ldr	r5, [pc, #64]	; (800b018 <prvThreeParameterEchoCommand+0xb4>)
 800afd6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800afd8:	6020      	str	r0, [r4, #0]
 800afda:	6061      	str	r1, [r4, #4]
 800afdc:	60a2      	str	r2, [r4, #8]
 800afde:	60e3      	str	r3, [r4, #12]
 800afe0:	cd07      	ldmia	r5!, {r0, r1, r2}
 800afe2:	6120      	str	r0, [r4, #16]
 800afe4:	6161      	str	r1, [r4, #20]
 800afe6:	61a2      	str	r2, [r4, #24]
 800afe8:	782b      	ldrb	r3, [r5, #0]
 800afea:	7723      	strb	r3, [r4, #28]
		lParameterNumber = 1L;
 800afec:	2001      	movs	r0, #1
 800afee:	4b06      	ldr	r3, [pc, #24]	; (800b008 <prvThreeParameterEchoCommand+0xa4>)
 800aff0:	6018      	str	r0, [r3, #0]
 800aff2:	e7e7      	b.n	800afc4 <prvThreeParameterEchoCommand+0x60>
		configASSERT( pcParameter );
 800aff4:	f240 1173 	movw	r1, #371	; 0x173
 800aff8:	4806      	ldr	r0, [pc, #24]	; (800b014 <prvThreeParameterEchoCommand+0xb0>)
 800affa:	f001 f9b1 	bl	800c360 <vAssertCalled>
 800affe:	e7c1      	b.n	800af84 <prvThreeParameterEchoCommand+0x20>
			lParameterNumber = 0L;
 800b000:	2000      	movs	r0, #0
 800b002:	6028      	str	r0, [r5, #0]
 800b004:	e7de      	b.n	800afc4 <prvThreeParameterEchoCommand+0x60>
 800b006:	bf00      	nop
 800b008:	20000adc 	.word	0x20000adc
 800b00c:	0800d14c 	.word	0x0800d14c
 800b010:	0800d148 	.word	0x0800d148
 800b014:	0800d154 	.word	0x0800d154
 800b018:	0800d278 	.word	0x0800d278

0800b01c <vRegisterSampleCLICommands>:
{
 800b01c:	b508      	push	{r3, lr}
	FreeRTOS_CLIRegisterCommand( &xThreeParameterEcho );
 800b01e:	4808      	ldr	r0, [pc, #32]	; (800b040 <vRegisterSampleCLICommands+0x24>)
 800b020:	f7f7 ff80 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &xParameterEcho );
 800b024:	4807      	ldr	r0, [pc, #28]	; (800b044 <vRegisterSampleCLICommands+0x28>)
 800b026:	f7f7 ff7d 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xTaskStats );
 800b02a:	4807      	ldr	r0, [pc, #28]	; (800b048 <vRegisterSampleCLICommands+0x2c>)
 800b02c:	f7f7 ff7a 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xRunTimeStats );
 800b030:	4806      	ldr	r0, [pc, #24]	; (800b04c <vRegisterSampleCLICommands+0x30>)
 800b032:	f7f7 ff77 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xQueryHeap );
 800b036:	4806      	ldr	r0, [pc, #24]	; (800b050 <vRegisterSampleCLICommands+0x34>)
 800b038:	f7f7 ff74 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
 800b03c:	bd08      	pop	{r3, pc}
 800b03e:	bf00      	nop
 800b040:	0800d4e0 	.word	0x0800d4e0
 800b044:	0800d4a0 	.word	0x0800d4a0
 800b048:	0800d4d0 	.word	0x0800d4d0
 800b04c:	0800d4c0 	.word	0x0800d4c0
 800b050:	0800d4b0 	.word	0x0800d4b0

0800b054 <prvNetStatCommand>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvNetStatCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
 800b054:	b538      	push	{r3, r4, r5, lr}
 800b056:	4604      	mov	r4, r0
 800b058:	460d      	mov	r5, r1
	( void ) pcWriteBuffer;
	( void ) xWriteBufferLen;
	( void ) pcCommandString;

	FreeRTOS_netstat();
 800b05a:	f7fa ff69 	bl	8005f30 <FreeRTOS_netstat>
	snprintf( pcWriteBuffer, xWriteBufferLen, "FreeRTOS_netstat() called - output uses FreeRTOS_printf\r\n" );
 800b05e:	4a03      	ldr	r2, [pc, #12]	; (800b06c <prvNetStatCommand+0x18>)
 800b060:	4629      	mov	r1, r5
 800b062:	4620      	mov	r0, r4
 800b064:	f001 f82d 	bl	800c0c2 <snprintf>
	return pdFALSE;
}
 800b068:	2000      	movs	r0, #0
 800b06a:	bd38      	pop	{r3, r4, r5, pc}
 800b06c:	0800d548 	.word	0x0800d548

0800b070 <prvPingCommand>:
	{
 800b070:	b570      	push	{r4, r5, r6, lr}
 800b072:	b088      	sub	sp, #32
 800b074:	4615      	mov	r5, r2
		configASSERT( pcWriteBuffer );
 800b076:	4604      	mov	r4, r0
 800b078:	2800      	cmp	r0, #0
 800b07a:	d035      	beq.n	800b0e8 <prvPingCommand+0x78>
		pcWriteBuffer[ 0 ] = 0x00;
 800b07c:	2300      	movs	r3, #0
 800b07e:	7023      	strb	r3, [r4, #0]
		pcParameter = ( char * ) FreeRTOS_CLIGetParameter
 800b080:	aa07      	add	r2, sp, #28
 800b082:	2102      	movs	r1, #2
 800b084:	4628      	mov	r0, r5
 800b086:	f7f7 ffe1 	bl	800304c <FreeRTOS_CLIGetParameter>
		if( pcParameter == NULL )
 800b08a:	b390      	cbz	r0, 800b0f2 <prvPingCommand+0x82>
			ulBytesToPing = atol( pcParameter );
 800b08c:	f001 faec 	bl	800c668 <atol>
 800b090:	4606      	mov	r6, r0
		pcParameter = ( char * ) FreeRTOS_CLIGetParameter
 800b092:	aa07      	add	r2, sp, #28
 800b094:	2101      	movs	r1, #1
 800b096:	4628      	mov	r0, r5
 800b098:	f7f7 ffd8 	bl	800304c <FreeRTOS_CLIGetParameter>
		if( pcParameter != NULL )
 800b09c:	b1b8      	cbz	r0, 800b0ce <prvPingCommand+0x5e>
			pcParameter[ lParameterStringLength ] = 0x00;
 800b09e:	2100      	movs	r1, #0
 800b0a0:	9b07      	ldr	r3, [sp, #28]
 800b0a2:	54c1      	strb	r1, [r0, r3]
			if( ( *pcParameter >= '0' ) && ( *pcParameter <= '9' ) )
 800b0a4:	7803      	ldrb	r3, [r0, #0]
 800b0a6:	3b30      	subs	r3, #48	; 0x30
 800b0a8:	b2db      	uxtb	r3, r3
 800b0aa:	2b09      	cmp	r3, #9
 800b0ac:	d823      	bhi.n	800b0f6 <prvPingCommand+0x86>
				ulIPAddress = FreeRTOS_inet_addr( pcParameter );
 800b0ae:	f7fa f93d 	bl	800532c <FreeRTOS_inet_addr>
 800b0b2:	4605      	mov	r5, r0
			FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
 800b0b4:	0e2b      	lsrs	r3, r5, #24
 800b0b6:	9301      	str	r3, [sp, #4]
 800b0b8:	f3c5 4307 	ubfx	r3, r5, #16, #8
 800b0bc:	9300      	str	r3, [sp, #0]
 800b0be:	f3c5 2307 	ubfx	r3, r5, #8, #8
 800b0c2:	b2ea      	uxtb	r2, r5
 800b0c4:	4916      	ldr	r1, [pc, #88]	; (800b120 <prvPingCommand+0xb0>)
 800b0c6:	a803      	add	r0, sp, #12
 800b0c8:	f000 fea1 	bl	800be0e <sprintf>
			if( ulIPAddress != 0 )
 800b0cc:	b9bd      	cbnz	r5, 800b0fe <prvPingCommand+0x8e>
			sprintf( pcWriteBuffer, "%s", "Could not send ping request\r\n" );
 800b0ce:	4d15      	ldr	r5, [pc, #84]	; (800b124 <prvPingCommand+0xb4>)
 800b0d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b0d2:	6020      	str	r0, [r4, #0]
 800b0d4:	6061      	str	r1, [r4, #4]
 800b0d6:	60a2      	str	r2, [r4, #8]
 800b0d8:	60e3      	str	r3, [r4, #12]
 800b0da:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b0dc:	6120      	str	r0, [r4, #16]
 800b0de:	6161      	str	r1, [r4, #20]
 800b0e0:	61a2      	str	r2, [r4, #24]
 800b0e2:	882b      	ldrh	r3, [r5, #0]
 800b0e4:	83a3      	strh	r3, [r4, #28]
 800b0e6:	e018      	b.n	800b11a <prvPingCommand+0xaa>
		configASSERT( pcWriteBuffer );
 800b0e8:	21c2      	movs	r1, #194	; 0xc2
 800b0ea:	480f      	ldr	r0, [pc, #60]	; (800b128 <prvPingCommand+0xb8>)
 800b0ec:	f001 f938 	bl	800c360 <vAssertCalled>
 800b0f0:	e7c4      	b.n	800b07c <prvPingCommand+0xc>
			ulBytesToPing = ulDefaultBytesToPing;
 800b0f2:	2608      	movs	r6, #8
 800b0f4:	e7cd      	b.n	800b092 <prvPingCommand+0x22>
				ulIPAddress = FreeRTOS_gethostbyname( pcParameter );
 800b0f6:	f7f9 f92f 	bl	8004358 <FreeRTOS_gethostbyname>
 800b0fa:	4605      	mov	r5, r0
 800b0fc:	e7da      	b.n	800b0b4 <prvPingCommand+0x44>
				xReturn = FreeRTOS_SendPingRequest( ulIPAddress, ( uint16_t ) ulBytesToPing, portMAX_DELAY );
 800b0fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b102:	b2b1      	uxth	r1, r6
 800b104:	4628      	mov	r0, r5
 800b106:	f7f9 fab7 	bl	8004678 <FreeRTOS_SendPingRequest>
		if( xReturn == pdFALSE )
 800b10a:	4603      	mov	r3, r0
 800b10c:	2800      	cmp	r0, #0
 800b10e:	d0de      	beq.n	800b0ce <prvPingCommand+0x5e>
			sprintf( pcWriteBuffer, "Ping sent to %s with identifier %d\r\n", cBuffer, ( int ) xReturn );
 800b110:	aa03      	add	r2, sp, #12
 800b112:	4906      	ldr	r1, [pc, #24]	; (800b12c <prvPingCommand+0xbc>)
 800b114:	4620      	mov	r0, r4
 800b116:	f000 fe7a 	bl	800be0e <sprintf>
	}
 800b11a:	2000      	movs	r0, #0
 800b11c:	b008      	add	sp, #32
 800b11e:	bd70      	pop	{r4, r5, r6, pc}
 800b120:	0800d5c4 	.word	0x0800d5c4
 800b124:	0800d5d0 	.word	0x0800d5d0
 800b128:	0800d584 	.word	0x0800d584
 800b12c:	0800d5f0 	.word	0x0800d5f0

0800b130 <prvDisplayIPDebugStats>:
	{
 800b130:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pcWriteBuffer );
 800b132:	4605      	mov	r5, r0
 800b134:	b178      	cbz	r0, 800b156 <prvDisplayIPDebugStats+0x26>
		xIndex++;
 800b136:	4c10      	ldr	r4, [pc, #64]	; (800b178 <prvDisplayIPDebugStats+0x48>)
 800b138:	6823      	ldr	r3, [r4, #0]
 800b13a:	3301      	adds	r3, #1
 800b13c:	6023      	str	r3, [r4, #0]
		if( xIndex < xExampleDebugStatEntries() )
 800b13e:	f000 fb84 	bl	800b84a <xExampleDebugStatEntries>
 800b142:	6823      	ldr	r3, [r4, #0]
 800b144:	4298      	cmp	r0, r3
 800b146:	dc0c      	bgt.n	800b162 <prvDisplayIPDebugStats+0x32>
			xIndex = -1;
 800b148:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b14c:	4b0a      	ldr	r3, [pc, #40]	; (800b178 <prvDisplayIPDebugStats+0x48>)
 800b14e:	601a      	str	r2, [r3, #0]
			pcWriteBuffer[ 0 ] = 0x00;
 800b150:	2000      	movs	r0, #0
 800b152:	7028      	strb	r0, [r5, #0]
	}
 800b154:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( pcWriteBuffer );
 800b156:	f240 1117 	movw	r1, #279	; 0x117
 800b15a:	4808      	ldr	r0, [pc, #32]	; (800b17c <prvDisplayIPDebugStats+0x4c>)
 800b15c:	f001 f900 	bl	800c360 <vAssertCalled>
 800b160:	e7e9      	b.n	800b136 <prvDisplayIPDebugStats+0x6>
			sprintf( pcWriteBuffer, "%s %d\r\n", ( char * ) xIPTraceValues[ xIndex ].pucDescription, ( int ) xIPTraceValues[ xIndex ].ulData );
 800b162:	4a07      	ldr	r2, [pc, #28]	; (800b180 <prvDisplayIPDebugStats+0x50>)
 800b164:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 800b168:	68d3      	ldr	r3, [r2, #12]
 800b16a:	6852      	ldr	r2, [r2, #4]
 800b16c:	4905      	ldr	r1, [pc, #20]	; (800b184 <prvDisplayIPDebugStats+0x54>)
 800b16e:	4628      	mov	r0, r5
 800b170:	f000 fe4d 	bl	800be0e <sprintf>
			xReturn = pdPASS;
 800b174:	2001      	movs	r0, #1
 800b176:	bd38      	pop	{r3, r4, r5, pc}
 800b178:	2000002c 	.word	0x2000002c
 800b17c:	0800d584 	.word	0x0800d584
 800b180:	20000034 	.word	0x20000034
 800b184:	0800d540 	.word	0x0800d540

0800b188 <prvDisplayIPConfig>:
{
 800b188:	b530      	push	{r4, r5, lr}
 800b18a:	b085      	sub	sp, #20
	configASSERT( pcWriteBuffer );
 800b18c:	4604      	mov	r4, r0
 800b18e:	b138      	cbz	r0, 800b1a0 <prvDisplayIPConfig+0x18>
	switch( xIndex )
 800b190:	4b3c      	ldr	r3, [pc, #240]	; (800b284 <prvDisplayIPConfig+0xfc>)
 800b192:	681b      	ldr	r3, [r3, #0]
 800b194:	2b03      	cmp	r3, #3
 800b196:	d85a      	bhi.n	800b24e <prvDisplayIPConfig+0xc6>
 800b198:	e8df f003 	tbb	[pc, r3]
 800b19c:	442f1f08 	.word	0x442f1f08
	configASSERT( pcWriteBuffer );
 800b1a0:	f240 113b 	movw	r1, #315	; 0x13b
 800b1a4:	4838      	ldr	r0, [pc, #224]	; (800b288 <prvDisplayIPConfig+0x100>)
 800b1a6:	f001 f8db 	bl	800c360 <vAssertCalled>
 800b1aa:	e7f1      	b.n	800b190 <prvDisplayIPConfig+0x8>
			FreeRTOS_GetAddressConfiguration( &ulAddress, NULL, NULL, NULL );
 800b1ac:	2300      	movs	r3, #0
 800b1ae:	461a      	mov	r2, r3
 800b1b0:	4619      	mov	r1, r3
 800b1b2:	a803      	add	r0, sp, #12
 800b1b4:	f7f9 f9f0 	bl	8004598 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nIP address " );
 800b1b8:	4b34      	ldr	r3, [pc, #208]	; (800b28c <prvDisplayIPConfig+0x104>)
 800b1ba:	cb07      	ldmia	r3!, {r0, r1, r2}
 800b1bc:	6020      	str	r0, [r4, #0]
 800b1be:	6061      	str	r1, [r4, #4]
 800b1c0:	60a2      	str	r2, [r4, #8]
 800b1c2:	881b      	ldrh	r3, [r3, #0]
 800b1c4:	81a3      	strh	r3, [r4, #12]
			xIndex++;
 800b1c6:	4a2f      	ldr	r2, [pc, #188]	; (800b284 <prvDisplayIPConfig+0xfc>)
 800b1c8:	6813      	ldr	r3, [r2, #0]
 800b1ca:	3301      	adds	r3, #1
 800b1cc:	6013      	str	r3, [r2, #0]
	if( ulAddress != 0 )
 800b1ce:	9d03      	ldr	r5, [sp, #12]
 800b1d0:	2d00      	cmp	r5, #0
 800b1d2:	d145      	bne.n	800b260 <prvDisplayIPConfig+0xd8>
 800b1d4:	2001      	movs	r0, #1
}
 800b1d6:	b005      	add	sp, #20
 800b1d8:	bd30      	pop	{r4, r5, pc}
			FreeRTOS_GetAddressConfiguration( NULL, &ulAddress, NULL, NULL );
 800b1da:	2300      	movs	r3, #0
 800b1dc:	461a      	mov	r2, r3
 800b1de:	a903      	add	r1, sp, #12
 800b1e0:	4618      	mov	r0, r3
 800b1e2:	f7f9 f9d9 	bl	8004598 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nNet mask " );
 800b1e6:	4b2a      	ldr	r3, [pc, #168]	; (800b290 <prvDisplayIPConfig+0x108>)
 800b1e8:	cb07      	ldmia	r3!, {r0, r1, r2}
 800b1ea:	6020      	str	r0, [r4, #0]
 800b1ec:	6061      	str	r1, [r4, #4]
 800b1ee:	60a2      	str	r2, [r4, #8]
			xIndex++;
 800b1f0:	4a24      	ldr	r2, [pc, #144]	; (800b284 <prvDisplayIPConfig+0xfc>)
 800b1f2:	6813      	ldr	r3, [r2, #0]
 800b1f4:	3301      	adds	r3, #1
 800b1f6:	6013      	str	r3, [r2, #0]
			break;
 800b1f8:	e7e9      	b.n	800b1ce <prvDisplayIPConfig+0x46>
			FreeRTOS_GetAddressConfiguration( NULL, NULL, &ulAddress, NULL );
 800b1fa:	2300      	movs	r3, #0
 800b1fc:	aa03      	add	r2, sp, #12
 800b1fe:	4619      	mov	r1, r3
 800b200:	4618      	mov	r0, r3
 800b202:	f7f9 f9c9 	bl	8004598 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nGateway address " );
 800b206:	4d23      	ldr	r5, [pc, #140]	; (800b294 <prvDisplayIPConfig+0x10c>)
 800b208:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b20a:	6020      	str	r0, [r4, #0]
 800b20c:	6061      	str	r1, [r4, #4]
 800b20e:	60a2      	str	r2, [r4, #8]
 800b210:	60e3      	str	r3, [r4, #12]
 800b212:	882a      	ldrh	r2, [r5, #0]
 800b214:	78ab      	ldrb	r3, [r5, #2]
 800b216:	8222      	strh	r2, [r4, #16]
 800b218:	74a3      	strb	r3, [r4, #18]
			xIndex++;
 800b21a:	4a1a      	ldr	r2, [pc, #104]	; (800b284 <prvDisplayIPConfig+0xfc>)
 800b21c:	6813      	ldr	r3, [r2, #0]
 800b21e:	3301      	adds	r3, #1
 800b220:	6013      	str	r3, [r2, #0]
			break;
 800b222:	e7d4      	b.n	800b1ce <prvDisplayIPConfig+0x46>
			FreeRTOS_GetAddressConfiguration( NULL, NULL, NULL, &ulAddress );
 800b224:	ab03      	add	r3, sp, #12
 800b226:	2200      	movs	r2, #0
 800b228:	4611      	mov	r1, r2
 800b22a:	4610      	mov	r0, r2
 800b22c:	f7f9 f9b4 	bl	8004598 <FreeRTOS_GetAddressConfiguration>
			sprintf( pcWriteBuffer, "\r\nDNS server address " );
 800b230:	4d19      	ldr	r5, [pc, #100]	; (800b298 <prvDisplayIPConfig+0x110>)
 800b232:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b234:	6020      	str	r0, [r4, #0]
 800b236:	6061      	str	r1, [r4, #4]
 800b238:	60a2      	str	r2, [r4, #8]
 800b23a:	60e3      	str	r3, [r4, #12]
 800b23c:	6828      	ldr	r0, [r5, #0]
 800b23e:	6120      	str	r0, [r4, #16]
 800b240:	88ab      	ldrh	r3, [r5, #4]
 800b242:	82a3      	strh	r3, [r4, #20]
			xIndex++;
 800b244:	4a0f      	ldr	r2, [pc, #60]	; (800b284 <prvDisplayIPConfig+0xfc>)
 800b246:	6813      	ldr	r3, [r2, #0]
 800b248:	3301      	adds	r3, #1
 800b24a:	6013      	str	r3, [r2, #0]
			break;
 800b24c:	e7bf      	b.n	800b1ce <prvDisplayIPConfig+0x46>
			sprintf( pcWriteBuffer, "\r\n\r\n" );
 800b24e:	4b13      	ldr	r3, [pc, #76]	; (800b29c <prvDisplayIPConfig+0x114>)
 800b250:	6818      	ldr	r0, [r3, #0]
 800b252:	6020      	str	r0, [r4, #0]
 800b254:	791b      	ldrb	r3, [r3, #4]
 800b256:	7123      	strb	r3, [r4, #4]
			xIndex = 0;
 800b258:	2000      	movs	r0, #0
 800b25a:	4b0a      	ldr	r3, [pc, #40]	; (800b284 <prvDisplayIPConfig+0xfc>)
 800b25c:	6018      	str	r0, [r3, #0]
 800b25e:	e7ba      	b.n	800b1d6 <prvDisplayIPConfig+0x4e>
		FreeRTOS_inet_ntoa( ulAddress, ( &( pcWriteBuffer[ strlen( pcWriteBuffer ) ] ) ) );
 800b260:	4620      	mov	r0, r4
 800b262:	f7f4 ffb5 	bl	80001d0 <strlen>
 800b266:	0e2b      	lsrs	r3, r5, #24
 800b268:	9301      	str	r3, [sp, #4]
 800b26a:	f3c5 4307 	ubfx	r3, r5, #16, #8
 800b26e:	9300      	str	r3, [sp, #0]
 800b270:	f3c5 2307 	ubfx	r3, r5, #8, #8
 800b274:	b2ea      	uxtb	r2, r5
 800b276:	490a      	ldr	r1, [pc, #40]	; (800b2a0 <prvDisplayIPConfig+0x118>)
 800b278:	4420      	add	r0, r4
 800b27a:	f000 fdc8 	bl	800be0e <sprintf>
 800b27e:	2001      	movs	r0, #1
 800b280:	e7a9      	b.n	800b1d6 <prvDisplayIPConfig+0x4e>
 800b282:	bf00      	nop
 800b284:	20000ae4 	.word	0x20000ae4
 800b288:	0800d584 	.word	0x0800d584
 800b28c:	0800d4f0 	.word	0x0800d4f0
 800b290:	0800d500 	.word	0x0800d500
 800b294:	0800d50c 	.word	0x0800d50c
 800b298:	0800d520 	.word	0x0800d520
 800b29c:	0800d538 	.word	0x0800d538
 800b2a0:	0800d5c4 	.word	0x0800d5c4

0800b2a4 <vRegisterTCPCLICommands>:
{
 800b2a4:	b508      	push	{r3, lr}
	FreeRTOS_CLIRegisterCommand( &xIPConfig );
 800b2a6:	4806      	ldr	r0, [pc, #24]	; (800b2c0 <vRegisterTCPCLICommands+0x1c>)
 800b2a8:	f7f7 fe3c 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xIPDebugStats );
 800b2ac:	4805      	ldr	r0, [pc, #20]	; (800b2c4 <vRegisterTCPCLICommands+0x20>)
 800b2ae:	f7f7 fe39 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
		FreeRTOS_CLIRegisterCommand( &xPing );
 800b2b2:	4805      	ldr	r0, [pc, #20]	; (800b2c8 <vRegisterTCPCLICommands+0x24>)
 800b2b4:	f7f7 fe36 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
	FreeRTOS_CLIRegisterCommand( &xNetStats );
 800b2b8:	4804      	ldr	r0, [pc, #16]	; (800b2cc <vRegisterTCPCLICommands+0x28>)
 800b2ba:	f7f7 fe33 	bl	8002f24 <FreeRTOS_CLIRegisterCommand>
 800b2be:	bd08      	pop	{r3, pc}
 800b2c0:	0800d768 	.word	0x0800d768
 800b2c4:	0800d778 	.word	0x0800d778
 800b2c8:	0800d798 	.word	0x0800d798
 800b2cc:	0800d788 	.word	0x0800d788

0800b2d0 <prvUDPCommandInterpreterTask>:
	xTaskCreate( prvUDPCommandInterpreterTask, "UDP CLI", usStackSize, ( void * ) ulPort, uxPriority, NULL );
}
/*-----------------------------------------------------------*/

void prvUDPCommandInterpreterTask( void *pvParameters )
{
 800b2d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b2d4:	b08b      	sub	sp, #44	; 0x2c
 800b2d6:	4604      	mov	r4, r0
static char cOutputString[ cmdMAX_OUTPUT_SIZE ], cLocalBuffer[ cmdSOCKET_INPUT_BUFFER_SIZE ];
static char cLastInputString[ cmdMAX_INPUT_SIZE ], cInputString[ cmdMAX_INPUT_SIZE ];
BaseType_t xMoreDataToFollow;
struct freertos_sockaddr xClient;

	memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
 800b2d8:	223c      	movs	r2, #60	; 0x3c
 800b2da:	2100      	movs	r1, #0
 800b2dc:	4856      	ldr	r0, [pc, #344]	; (800b438 <prvUDPCommandInterpreterTask+0x168>)
 800b2de:	f001 fa1f 	bl	800c720 <memset>

static Socket_t prvOpenUDPServerSocket( uint16_t usPort )
{
struct freertos_sockaddr xServer;
Socket_t xServerSocket = FREERTOS_INVALID_SOCKET;
TickType_t xSendTimeOut = 0;
 800b2e2:	2300      	movs	r3, #0
 800b2e4:	9305      	str	r3, [sp, #20]

	xServerSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800b2e6:	2211      	movs	r2, #17
 800b2e8:	2102      	movs	r1, #2
 800b2ea:	4608      	mov	r0, r1
 800b2ec:	f7f9 fd36 	bl	8004d5c <FreeRTOS_socket>
	if( xServerSocket != FREERTOS_INVALID_SOCKET)
 800b2f0:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b2f4:	d01f      	beq.n	800b336 <prvUDPCommandInterpreterTask+0x66>
 800b2f6:	b2a6      	uxth	r6, r4
 800b2f8:	4605      	mov	r5, r0
	{
		/* Set to non-blocking sends with a timeout of zero as the socket might
		also be used for debug prints which should not block. */
		FreeRTOS_setsockopt( xServerSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800b2fa:	2304      	movs	r3, #4
 800b2fc:	9300      	str	r3, [sp, #0]
 800b2fe:	ab05      	add	r3, sp, #20
 800b300:	2201      	movs	r2, #1
 800b302:	2100      	movs	r1, #0
 800b304:	f7fa fc30 	bl	8005b68 <FreeRTOS_setsockopt>

		/* Zero out the server structure. */
		memset( ( void * ) &xServer, 0x00, sizeof( xServer ) );
 800b308:	2300      	movs	r3, #0
 800b30a:	9306      	str	r3, [sp, #24]
 800b30c:	9307      	str	r3, [sp, #28]

		/* Set family and port. */
		xServer.sin_port = FreeRTOS_htons( usPort );
 800b30e:	0223      	lsls	r3, r4, #8
 800b310:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800b314:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800b318:	ea43 2316 	orr.w	r3, r3, r6, lsr #8
 800b31c:	f8ad 301a 	strh.w	r3, [sp, #26]

		/* Bind the address to the socket. */
		if( FreeRTOS_bind( xServerSocket, &xServer, sizeof( xServer ) ) == -1 )
 800b320:	2208      	movs	r2, #8
 800b322:	a906      	add	r1, sp, #24
 800b324:	4628      	mov	r0, r5
 800b326:	f7f9 fe40 	bl	8004faa <FreeRTOS_bind>
 800b32a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b32e:	d16a      	bne.n	800b406 <prvUDPCommandInterpreterTask+0x136>
		{
			FreeRTOS_closesocket( xServerSocket );
 800b330:	4628      	mov	r0, r5
 800b332:	f7f9 ff75 	bl	8005220 <FreeRTOS_closesocket>
	xSocket = prvOpenUDPServerSocket( ( uint16_t ) ( ( uint32_t ) pvParameters ) & 0xffffUL );
 800b336:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b33a:	4b40      	ldr	r3, [pc, #256]	; (800b43c <prvUDPCommandInterpreterTask+0x16c>)
 800b33c:	601a      	str	r2, [r3, #0]
		vTaskDelete( NULL );
 800b33e:	2000      	movs	r0, #0
 800b340:	f7fe fd80 	bl	8009e44 <vTaskDelete>
}
 800b344:	b00b      	add	sp, #44	; 0x2c
 800b346:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						FreeRTOS_sendto( xSocket, pcNewLine,  strlen( pcNewLine ), 0, &xClient, xClientAddressLength );
 800b34a:	683b      	ldr	r3, [r7, #0]
 800b34c:	9301      	str	r3, [sp, #4]
 800b34e:	ab08      	add	r3, sp, #32
 800b350:	9300      	str	r3, [sp, #0]
 800b352:	2300      	movs	r3, #0
 800b354:	2202      	movs	r2, #2
 800b356:	493a      	ldr	r1, [pc, #232]	; (800b440 <prvUDPCommandInterpreterTask+0x170>)
 800b358:	6830      	ldr	r0, [r6, #0]
 800b35a:	f7f9 fe5d 	bl	8005018 <FreeRTOS_sendto>
						if( cInputIndex == 0 )
 800b35e:	2c00      	cmp	r4, #0
 800b360:	d044      	beq.n	800b3ec <prvUDPCommandInterpreterTask+0x11c>
							cOutputString[ 0 ] = 0x00;
 800b362:	4c38      	ldr	r4, [pc, #224]	; (800b444 <prvUDPCommandInterpreterTask+0x174>)
 800b364:	f04f 0900 	mov.w	r9, #0
 800b368:	f884 9000 	strb.w	r9, [r4]
							xMoreDataToFollow = FreeRTOS_CLIProcessCommand( cInputString, cOutputString, cmdMAX_OUTPUT_SIZE );
 800b36c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800b370:	4621      	mov	r1, r4
 800b372:	9803      	ldr	r0, [sp, #12]
 800b374:	f7f7 fdfa 	bl	8002f6c <FreeRTOS_CLIProcessCommand>
 800b378:	4605      	mov	r5, r0
							FreeRTOS_sendto( xSocket, cOutputString,  strlen( ( const char * ) cOutputString ), 0, &xClient, xClientAddressLength );
 800b37a:	4620      	mov	r0, r4
 800b37c:	f7f4 ff28 	bl	80001d0 <strlen>
 800b380:	683b      	ldr	r3, [r7, #0]
 800b382:	9301      	str	r3, [sp, #4]
 800b384:	ab08      	add	r3, sp, #32
 800b386:	9300      	str	r3, [sp, #0]
 800b388:	2300      	movs	r3, #0
 800b38a:	4602      	mov	r2, r0
 800b38c:	4621      	mov	r1, r4
 800b38e:	6830      	ldr	r0, [r6, #0]
 800b390:	f7f9 fe42 	bl	8005018 <FreeRTOS_sendto>
						} while( xMoreDataToFollow != pdFALSE );
 800b394:	2d00      	cmp	r5, #0
 800b396:	d1e7      	bne.n	800b368 <prvUDPCommandInterpreterTask+0x98>
						strcpy( cLastInputString, cInputString );
 800b398:	9c03      	ldr	r4, [sp, #12]
 800b39a:	4621      	mov	r1, r4
 800b39c:	482a      	ldr	r0, [pc, #168]	; (800b448 <prvUDPCommandInterpreterTask+0x178>)
 800b39e:	f001 f9c7 	bl	800c730 <strcpy>
						memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
 800b3a2:	223c      	movs	r2, #60	; 0x3c
 800b3a4:	2100      	movs	r1, #0
 800b3a6:	4620      	mov	r0, r4
 800b3a8:	f001 f9ba 	bl	800c720 <memset>
						FreeRTOS_sendto( xSocket, ( void * ) pcEndOfOutputMessage,  strlen( pcEndOfOutputMessage ), 0, &xClient, xClientAddressLength );
 800b3ac:	683b      	ldr	r3, [r7, #0]
 800b3ae:	9301      	str	r3, [sp, #4]
 800b3b0:	ab08      	add	r3, sp, #32
 800b3b2:	9300      	str	r3, [sp, #0]
 800b3b4:	2300      	movs	r3, #0
 800b3b6:	2238      	movs	r2, #56	; 0x38
 800b3b8:	4924      	ldr	r1, [pc, #144]	; (800b44c <prvUDPCommandInterpreterTask+0x17c>)
 800b3ba:	6830      	ldr	r0, [r6, #0]
 800b3bc:	f7f9 fe2c 	bl	8005018 <FreeRTOS_sendto>
						cInputIndex = 0;
 800b3c0:	2400      	movs	r4, #0
				while( lByte < lBytes )
 800b3c2:	45d0      	cmp	r8, sl
 800b3c4:	dd26      	ble.n	800b414 <prvUDPCommandInterpreterTask+0x144>
					cRxedChar = cLocalBuffer[ lByte ];
 800b3c6:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
					lByte++;
 800b3ca:	f10a 0a01 	add.w	sl, sl, #1
					if( cRxedChar == '\n' )
 800b3ce:	2b0a      	cmp	r3, #10
 800b3d0:	d0bb      	beq.n	800b34a <prvUDPCommandInterpreterTask+0x7a>
						if( cRxedChar == '\r' )
 800b3d2:	2b0d      	cmp	r3, #13
 800b3d4:	d0f5      	beq.n	800b3c2 <prvUDPCommandInterpreterTask+0xf2>
						else if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
 800b3d6:	2b08      	cmp	r3, #8
 800b3d8:	d00d      	beq.n	800b3f6 <prvUDPCommandInterpreterTask+0x126>
 800b3da:	2b7f      	cmp	r3, #127	; 0x7f
 800b3dc:	d00b      	beq.n	800b3f6 <prvUDPCommandInterpreterTask+0x126>
							if( cInputIndex < cmdMAX_INPUT_SIZE )
 800b3de:	2c3b      	cmp	r4, #59	; 0x3b
 800b3e0:	d8ef      	bhi.n	800b3c2 <prvUDPCommandInterpreterTask+0xf2>
								cInputString[ ( int ) cInputIndex ] = cRxedChar;
 800b3e2:	4a15      	ldr	r2, [pc, #84]	; (800b438 <prvUDPCommandInterpreterTask+0x168>)
 800b3e4:	5513      	strb	r3, [r2, r4]
								cInputIndex++;
 800b3e6:	3401      	adds	r4, #1
 800b3e8:	b2e4      	uxtb	r4, r4
 800b3ea:	e7ea      	b.n	800b3c2 <prvUDPCommandInterpreterTask+0xf2>
							strcpy( cInputString, cLastInputString );
 800b3ec:	4916      	ldr	r1, [pc, #88]	; (800b448 <prvUDPCommandInterpreterTask+0x178>)
 800b3ee:	9803      	ldr	r0, [sp, #12]
 800b3f0:	f001 f99e 	bl	800c730 <strcpy>
 800b3f4:	e7b5      	b.n	800b362 <prvUDPCommandInterpreterTask+0x92>
							if( cInputIndex > 0 )
 800b3f6:	2c00      	cmp	r4, #0
 800b3f8:	d0e3      	beq.n	800b3c2 <prvUDPCommandInterpreterTask+0xf2>
								cInputIndex--;
 800b3fa:	3c01      	subs	r4, #1
 800b3fc:	b2e4      	uxtb	r4, r4
								cInputString[ ( int ) cInputIndex ] = '\0';
 800b3fe:	2300      	movs	r3, #0
 800b400:	4a0d      	ldr	r2, [pc, #52]	; (800b438 <prvUDPCommandInterpreterTask+0x168>)
 800b402:	5513      	strb	r3, [r2, r4]
 800b404:	e7dd      	b.n	800b3c2 <prvUDPCommandInterpreterTask+0xf2>
	xSocket = prvOpenUDPServerSocket( ( uint16_t ) ( ( uint32_t ) pvParameters ) & 0xffffUL );
 800b406:	4b0d      	ldr	r3, [pc, #52]	; (800b43c <prvUDPCommandInterpreterTask+0x16c>)
 800b408:	601d      	str	r5, [r3, #0]
 800b40a:	2400      	movs	r4, #0
			lBytes = FreeRTOS_recvfrom( xSocket, ( void * ) cLocalBuffer, sizeof( cLocalBuffer ), 0, &xClient, &xClientAddressLength );
 800b40c:	461e      	mov	r6, r3
 800b40e:	4f10      	ldr	r7, [pc, #64]	; (800b450 <prvUDPCommandInterpreterTask+0x180>)
								cInputString[ ( int ) cInputIndex ] = '\0';
 800b410:	4b09      	ldr	r3, [pc, #36]	; (800b438 <prvUDPCommandInterpreterTask+0x168>)
 800b412:	9303      	str	r3, [sp, #12]
			lBytes = FreeRTOS_recvfrom( xSocket, ( void * ) cLocalBuffer, sizeof( cLocalBuffer ), 0, &xClient, &xClientAddressLength );
 800b414:	9701      	str	r7, [sp, #4]
 800b416:	ab08      	add	r3, sp, #32
 800b418:	9300      	str	r3, [sp, #0]
 800b41a:	2300      	movs	r3, #0
 800b41c:	223c      	movs	r2, #60	; 0x3c
 800b41e:	490d      	ldr	r1, [pc, #52]	; (800b454 <prvUDPCommandInterpreterTask+0x184>)
 800b420:	6830      	ldr	r0, [r6, #0]
 800b422:	f7f9 fd33 	bl	8004e8c <FreeRTOS_recvfrom>
			if( lBytes > 0 )
 800b426:	f1b0 0800 	subs.w	r8, r0, #0
 800b42a:	ddf3      	ble.n	800b414 <prvUDPCommandInterpreterTask+0x144>
 800b42c:	4b09      	ldr	r3, [pc, #36]	; (800b454 <prvUDPCommandInterpreterTask+0x184>)
 800b42e:	f103 3bff 	add.w	fp, r3, #4294967295	; 0xffffffff
 800b432:	f04f 0a00 	mov.w	sl, #0
 800b436:	e7c6      	b.n	800b3c6 <prvUDPCommandInterpreterTask+0xf6>
 800b438:	20000ae8 	.word	0x20000ae8
 800b43c:	20000030 	.word	0x20000030
 800b440:	0800d148 	.word	0x0800d148
 800b444:	20000b9c 	.word	0x20000b9c
 800b448:	20000b24 	.word	0x20000b24
 800b44c:	0800d7a8 	.word	0x0800d7a8
 800b450:	20000f9c 	.word	0x20000f9c
 800b454:	20000b60 	.word	0x20000b60

0800b458 <vStartUDPCommandInterpreterTask>:
{
 800b458:	b500      	push	{lr}
 800b45a:	b083      	sub	sp, #12
	xTaskCreate( prvUDPCommandInterpreterTask, "UDP CLI", usStackSize, ( void * ) ulPort, uxPriority, NULL );
 800b45c:	2300      	movs	r3, #0
 800b45e:	9301      	str	r3, [sp, #4]
 800b460:	9200      	str	r2, [sp, #0]
 800b462:	460b      	mov	r3, r1
 800b464:	4602      	mov	r2, r0
 800b466:	4903      	ldr	r1, [pc, #12]	; (800b474 <vStartUDPCommandInterpreterTask+0x1c>)
 800b468:	4803      	ldr	r0, [pc, #12]	; (800b478 <vStartUDPCommandInterpreterTask+0x20>)
 800b46a:	f7fe fc03 	bl	8009c74 <xTaskCreate>
}
 800b46e:	b003      	add	sp, #12
 800b470:	f85d fb04 	ldr.w	pc, [sp], #4
 800b474:	0800d7e4 	.word	0x0800d7e4
 800b478:	0800b2d1 	.word	0x0800b2d1

0800b47c <prvConnectionListeningTask>:
	usUsedStackSize = usStackSize;
}
/*-----------------------------------------------------------*/

static void prvConnectionListeningTask( void *pvParameters )
{
 800b47c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b480:	b08c      	sub	sp, #48	; 0x30
struct freertos_sockaddr xClient, xBindAddress;
Socket_t xListeningSocket, xConnectedSocket;
socklen_t xSize = sizeof( xClient );
 800b482:	2308      	movs	r3, #8
 800b484:	9307      	str	r3, [sp, #28]

#if( ipconfigUSE_TCP_WIN == 1 )
	WinProperties_t xWinProps;

	/* Fill in the buffer and window sizes that will be used by the socket. */
	xWinProps.lTxBufSize = ipconfigTCP_TX_BUFFER_LENGTH;
 800b486:	f640 3368 	movw	r3, #2920	; 0xb68
 800b48a:	9303      	str	r3, [sp, #12]
	xWinProps.lTxWinSize = configECHO_SERVER_TX_WINDOW_SIZE;
 800b48c:	2002      	movs	r0, #2
 800b48e:	9004      	str	r0, [sp, #16]
	xWinProps.lRxBufSize = ipconfigTCP_RX_BUFFER_LENGTH;
 800b490:	f241 131c 	movw	r3, #4380	; 0x111c
 800b494:	9305      	str	r3, [sp, #20]
	xWinProps.lRxWinSize = configECHO_SERVER_RX_WINDOW_SIZE;
 800b496:	9006      	str	r0, [sp, #24]

	/* Just to prevent compiler warnings. */
	( void ) pvParameters;

	/* Attempt to open the socket. */
	xListeningSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800b498:	2206      	movs	r2, #6
 800b49a:	2101      	movs	r1, #1
 800b49c:	f7f9 fc5e 	bl	8004d5c <FreeRTOS_socket>
 800b4a0:	4605      	mov	r5, r0
	configASSERT( xListeningSocket != FREERTOS_INVALID_SOCKET );
 800b4a2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b4a6:	d021      	beq.n	800b4ec <prvConnectionListeningTask+0x70>

	/* Set a time out so accept() will just wait for a connection. */
	FreeRTOS_setsockopt( xListeningSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800b4a8:	2304      	movs	r3, #4
 800b4aa:	9300      	str	r3, [sp, #0]
 800b4ac:	4b1d      	ldr	r3, [pc, #116]	; (800b524 <prvConnectionListeningTask+0xa8>)
 800b4ae:	2200      	movs	r2, #0
 800b4b0:	4611      	mov	r1, r2
 800b4b2:	4628      	mov	r0, r5
 800b4b4:	f7fa fb58 	bl	8005b68 <FreeRTOS_setsockopt>

	/* Set the window and buffer sizes. */
	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		FreeRTOS_setsockopt( xListeningSocket, 0, FREERTOS_SO_WIN_PROPERTIES, ( void * ) &xWinProps, sizeof( xWinProps ) );
 800b4b8:	2310      	movs	r3, #16
 800b4ba:	9300      	str	r3, [sp, #0]
 800b4bc:	ab03      	add	r3, sp, #12
 800b4be:	220d      	movs	r2, #13
 800b4c0:	2100      	movs	r1, #0
 800b4c2:	4628      	mov	r0, r5
 800b4c4:	f7fa fb50 	bl	8005b68 <FreeRTOS_setsockopt>
	#endif /* ipconfigUSE_TCP_WIN */

	/* Bind the socket to the port that the client task will send to, then
	listen for incoming connections. */
	xBindAddress.sin_port = tcpechoPORT_NUMBER;
	xBindAddress.sin_port = FreeRTOS_htons( xBindAddress.sin_port );
 800b4c8:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 800b4cc:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	FreeRTOS_bind( xListeningSocket, &xBindAddress, sizeof( xBindAddress ) );
 800b4d0:	2208      	movs	r2, #8
 800b4d2:	a908      	add	r1, sp, #32
 800b4d4:	4628      	mov	r0, r5
 800b4d6:	f7f9 fd68 	bl	8004faa <FreeRTOS_bind>
	FreeRTOS_listen( xListeningSocket, xBacklog );
 800b4da:	2114      	movs	r1, #20
 800b4dc:	4628      	mov	r0, r5
 800b4de:	f7fa f9cc 	bl	800587a <FreeRTOS_listen>

	for( ;; )
	{
		/* Wait for a client to connect. */
		xConnectedSocket = FreeRTOS_accept( xListeningSocket, &xClient, &xSize );
		configASSERT( xConnectedSocket != FREERTOS_INVALID_SOCKET );
 800b4e2:	f8df 804c 	ldr.w	r8, [pc, #76]	; 800b530 <prvConnectionListeningTask+0xb4>

		/* Spawn a task to handle the connection. */
		xTaskCreate( prvServerConnectionInstance, "EchoServer", usUsedStackSize, ( void * ) xConnectedSocket, tskIDLE_PRIORITY, NULL );
 800b4e6:	4f10      	ldr	r7, [pc, #64]	; (800b528 <prvConnectionListeningTask+0xac>)
 800b4e8:	4e10      	ldr	r6, [pc, #64]	; (800b52c <prvConnectionListeningTask+0xb0>)
 800b4ea:	e00d      	b.n	800b508 <prvConnectionListeningTask+0x8c>
	configASSERT( xListeningSocket != FREERTOS_INVALID_SOCKET );
 800b4ec:	21b0      	movs	r1, #176	; 0xb0
 800b4ee:	4810      	ldr	r0, [pc, #64]	; (800b530 <prvConnectionListeningTask+0xb4>)
 800b4f0:	f000 ff36 	bl	800c360 <vAssertCalled>
 800b4f4:	e7d8      	b.n	800b4a8 <prvConnectionListeningTask+0x2c>
		xTaskCreate( prvServerConnectionInstance, "EchoServer", usUsedStackSize, ( void * ) xConnectedSocket, tskIDLE_PRIORITY, NULL );
 800b4f6:	883a      	ldrh	r2, [r7, #0]
 800b4f8:	2300      	movs	r3, #0
 800b4fa:	9301      	str	r3, [sp, #4]
 800b4fc:	9300      	str	r3, [sp, #0]
 800b4fe:	4623      	mov	r3, r4
 800b500:	4631      	mov	r1, r6
 800b502:	480c      	ldr	r0, [pc, #48]	; (800b534 <prvConnectionListeningTask+0xb8>)
 800b504:	f7fe fbb6 	bl	8009c74 <xTaskCreate>
		xConnectedSocket = FreeRTOS_accept( xListeningSocket, &xClient, &xSize );
 800b508:	aa07      	add	r2, sp, #28
 800b50a:	a90a      	add	r1, sp, #40	; 0x28
 800b50c:	4628      	mov	r0, r5
 800b50e:	f7f9 ff79 	bl	8005404 <FreeRTOS_accept>
 800b512:	4604      	mov	r4, r0
		configASSERT( xConnectedSocket != FREERTOS_INVALID_SOCKET );
 800b514:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b518:	d1ed      	bne.n	800b4f6 <prvConnectionListeningTask+0x7a>
 800b51a:	21c7      	movs	r1, #199	; 0xc7
 800b51c:	4640      	mov	r0, r8
 800b51e:	f000 ff1f 	bl	800c360 <vAssertCalled>
 800b522:	e7e8      	b.n	800b4f6 <prvConnectionListeningTask+0x7a>
 800b524:	0800d844 	.word	0x0800d844
 800b528:	20000fa0 	.word	0x20000fa0
 800b52c:	0800d828 	.word	0x0800d828
 800b530:	0800d7ec 	.word	0x0800d7ec
 800b534:	0800b539 	.word	0x0800b539

0800b538 <prvServerConnectionInstance>:
	}
}
/*-----------------------------------------------------------*/

static void prvServerConnectionInstance( void *pvParameters )
{
 800b538:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b53c:	b083      	sub	sp, #12
 800b53e:	4607      	mov	r7, r0
	xConnectedSocket = ( Socket_t ) pvParameters;

	/* Attempt to create the buffer used to receive the string to be echoed
	back.  This could be avoided using a zero copy interface that just returned
	the same buffer. */
	pucRxBuffer = ( uint8_t * ) pvPortMalloc( ipconfigTCP_MSS );
 800b540:	f240 50b4 	movw	r0, #1460	; 0x5b4
 800b544:	f7fd fe98 	bl	8009278 <pvPortMalloc>

	if( pucRxBuffer != NULL )
 800b548:	4606      	mov	r6, r0
 800b54a:	b368      	cbz	r0, 800b5a8 <prvServerConnectionInstance+0x70>
	{
		FreeRTOS_setsockopt( xConnectedSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800b54c:	2404      	movs	r4, #4
 800b54e:	9400      	str	r4, [sp, #0]
 800b550:	4b28      	ldr	r3, [pc, #160]	; (800b5f4 <prvServerConnectionInstance+0xbc>)
 800b552:	2200      	movs	r2, #0
 800b554:	4611      	mov	r1, r2
 800b556:	4638      	mov	r0, r7
 800b558:	f7fa fb06 	bl	8005b68 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xConnectedSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xReceiveTimeOut ) );
 800b55c:	9400      	str	r4, [sp, #0]
 800b55e:	4b26      	ldr	r3, [pc, #152]	; (800b5f8 <prvServerConnectionInstance+0xc0>)
 800b560:	2201      	movs	r2, #1
 800b562:	2100      	movs	r1, #0
 800b564:	4638      	mov	r0, r7
 800b566:	f7fa faff 	bl	8005b68 <FreeRTOS_setsockopt>

		for( ;; )
		{
			/* Zero out the receive array so there is NULL at the end of the string
			when it is printed out. */
			memset( pucRxBuffer, 0x00, ipconfigTCP_MSS );
 800b56a:	f240 59b4 	movw	r9, #1460	; 0x5b4
 800b56e:	f04f 0800 	mov.w	r8, #0
 800b572:	464a      	mov	r2, r9
 800b574:	4641      	mov	r1, r8
 800b576:	4630      	mov	r0, r6
 800b578:	f001 f8d2 	bl	800c720 <memset>

			/* Receive data on the socket. */
			lBytes = FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 );
 800b57c:	4643      	mov	r3, r8
 800b57e:	464a      	mov	r2, r9
 800b580:	4631      	mov	r1, r6
 800b582:	4638      	mov	r0, r7
 800b584:	f7f9 ffd4 	bl	8005530 <FreeRTOS_recv>

			/* If data was received, echo it back. */
			if( lBytes >= 0 )
 800b588:	1e05      	subs	r5, r0, #0
 800b58a:	db0d      	blt.n	800b5a8 <prvServerConnectionInstance+0x70>
			{
				lSent = 0;
				lTotalSent = 0;

				/* Call send() until all the data has been sent. */
				while( ( lSent >= 0 ) && ( lTotalSent < lBytes ) )
 800b58c:	ddf1      	ble.n	800b572 <prvServerConnectionInstance+0x3a>
 800b58e:	2400      	movs	r4, #0
				{
					lSent = FreeRTOS_send( xConnectedSocket, pucRxBuffer, lBytes - lTotalSent, 0 );
 800b590:	4643      	mov	r3, r8
 800b592:	1b2a      	subs	r2, r5, r4
 800b594:	4631      	mov	r1, r6
 800b596:	4638      	mov	r0, r7
 800b598:	f7fa f894 	bl	80056c4 <FreeRTOS_send>
					lTotalSent += lSent;
 800b59c:	4404      	add	r4, r0
				while( ( lSent >= 0 ) && ( lTotalSent < lBytes ) )
 800b59e:	2800      	cmp	r0, #0
 800b5a0:	db02      	blt.n	800b5a8 <prvServerConnectionInstance+0x70>
 800b5a2:	42a5      	cmp	r5, r4
 800b5a4:	dcf4      	bgt.n	800b590 <prvServerConnectionInstance+0x58>
 800b5a6:	e7e4      	b.n	800b572 <prvServerConnectionInstance+0x3a>
			}
		}
	}

	/* Initiate a shutdown in case it has not already been initiated. */
	FreeRTOS_shutdown( xConnectedSocket, FREERTOS_SHUT_RDWR );
 800b5a8:	2102      	movs	r1, #2
 800b5aa:	4638      	mov	r0, r7
 800b5ac:	f7fa f9ad 	bl	800590a <FreeRTOS_shutdown>

	/* Wait for the shutdown to take effect, indicated by FreeRTOS_recv()
	returning an error. */
	xTimeOnShutdown = xTaskGetTickCount();
 800b5b0:	f7fe fd3e 	bl	800a030 <xTaskGetTickCount>
 800b5b4:	4681      	mov	r9, r0
	do
	{
		if( FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 ) < 0 )
 800b5b6:	2500      	movs	r5, #0
 800b5b8:	f240 54b4 	movw	r4, #1460	; 0x5b4
		{
			break;
		}
	} while( ( xTaskGetTickCount() - xTimeOnShutdown ) < tcpechoSHUTDOWN_DELAY );
 800b5bc:	f241 3887 	movw	r8, #4999	; 0x1387
		if( FreeRTOS_recv( xConnectedSocket, pucRxBuffer, ipconfigTCP_MSS, 0 ) < 0 )
 800b5c0:	462b      	mov	r3, r5
 800b5c2:	4622      	mov	r2, r4
 800b5c4:	4631      	mov	r1, r6
 800b5c6:	4638      	mov	r0, r7
 800b5c8:	f7f9 ffb2 	bl	8005530 <FreeRTOS_recv>
 800b5cc:	2800      	cmp	r0, #0
 800b5ce:	db05      	blt.n	800b5dc <prvServerConnectionInstance+0xa4>
	} while( ( xTaskGetTickCount() - xTimeOnShutdown ) < tcpechoSHUTDOWN_DELAY );
 800b5d0:	f7fe fd2e 	bl	800a030 <xTaskGetTickCount>
 800b5d4:	eba0 0009 	sub.w	r0, r0, r9
 800b5d8:	4540      	cmp	r0, r8
 800b5da:	d9f1      	bls.n	800b5c0 <prvServerConnectionInstance+0x88>

	/* Finished with the socket, buffer, the task. */
	vPortFree( pucRxBuffer );
 800b5dc:	4630      	mov	r0, r6
 800b5de:	f7fd feb1 	bl	8009344 <vPortFree>
	FreeRTOS_closesocket( xConnectedSocket );
 800b5e2:	4638      	mov	r0, r7
 800b5e4:	f7f9 fe1c 	bl	8005220 <FreeRTOS_closesocket>

	vTaskDelete( NULL );
 800b5e8:	2000      	movs	r0, #0
 800b5ea:	f7fe fc2b 	bl	8009e44 <vTaskDelete>
}
 800b5ee:	b003      	add	sp, #12
 800b5f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800b5f4:	0800d848 	.word	0x0800d848
 800b5f8:	0800d84c 	.word	0x0800d84c

0800b5fc <vStartSimpleTCPServerTasks>:
{
 800b5fc:	b510      	push	{r4, lr}
 800b5fe:	b082      	sub	sp, #8
 800b600:	4604      	mov	r4, r0
	xTaskCreate( prvConnectionListeningTask, "ServerListener", usStackSize, NULL, uxPriority + 1, NULL );
 800b602:	2300      	movs	r3, #0
 800b604:	9301      	str	r3, [sp, #4]
 800b606:	3101      	adds	r1, #1
 800b608:	9100      	str	r1, [sp, #0]
 800b60a:	4602      	mov	r2, r0
 800b60c:	4903      	ldr	r1, [pc, #12]	; (800b61c <vStartSimpleTCPServerTasks+0x20>)
 800b60e:	4804      	ldr	r0, [pc, #16]	; (800b620 <vStartSimpleTCPServerTasks+0x24>)
 800b610:	f7fe fb30 	bl	8009c74 <xTaskCreate>
	usUsedStackSize = usStackSize;
 800b614:	4b03      	ldr	r3, [pc, #12]	; (800b624 <vStartSimpleTCPServerTasks+0x28>)
 800b616:	801c      	strh	r4, [r3, #0]
}
 800b618:	b002      	add	sp, #8
 800b61a:	bd10      	pop	{r4, pc}
 800b61c:	0800d834 	.word	0x0800d834
 800b620:	0800b47d 	.word	0x0800b47d
 800b624:	20000fa0 	.word	0x20000fa0

0800b628 <prvEchoClientTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvEchoClientTask( void *pvParameters )
{
 800b628:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b62c:	b08d      	sub	sp, #52	; 0x34
Socket_t xSocket;
struct freertos_sockaddr xEchoServerAddress;
int32_t lLoopCount = 0UL;
const int32_t lMaxLoopCount = 1;
volatile uint32_t ulTxCount = 0UL;
 800b62e:	2300      	movs	r3, #0
 800b630:	9309      	str	r3, [sp, #36]	; 0x24
	#if( ipconfigUSE_TCP_WIN == 1 )

	WinProperties_t xWinProps;

		/* Fill in the buffer and window sizes that will be used by the socket. */
		xWinProps.lTxBufSize = ipconfigTCP_TX_BUFFER_LENGTH;
 800b632:	f640 3368 	movw	r3, #2920	; 0xb68
 800b636:	9305      	str	r3, [sp, #20]
		xWinProps.lTxWinSize = configECHO_CLIENT_TX_WINDOW_SIZE;
 800b638:	2202      	movs	r2, #2
 800b63a:	9206      	str	r2, [sp, #24]
		xWinProps.lRxBufSize = ipconfigTCP_RX_BUFFER_LENGTH;
 800b63c:	f241 111c 	movw	r1, #4380	; 0x111c
 800b640:	9107      	str	r1, [sp, #28]
		xWinProps.lRxWinSize = configECHO_CLIENT_RX_WINDOW_SIZE;
 800b642:	9208      	str	r2, [sp, #32]
	#endif /* ipconfigUSE_TCP_WIN */

	/* This task can be created a number of times.  Each instance is numbered
	to enable each instance to use a different Rx and Tx buffer.  The number is
	passed in as the task's parameter. */
	xInstance = ( BaseType_t ) pvParameters;
 800b644:	4683      	mov	fp, r0
 800b646:	fb00 f303 	mul.w	r3, r0, r3

	/* Point to the buffers to be used by this instance of this task. */
	pcTransmittedString = &( cTxBuffers[ xInstance ][ 0 ] );
 800b64a:	4a67      	ldr	r2, [pc, #412]	; (800b7e8 <prvEchoClientTask+0x1c0>)
 800b64c:	441a      	add	r2, r3
 800b64e:	9202      	str	r2, [sp, #8]
	pcReceivedString = &( cRxBuffers[ xInstance ][ 0 ] );
 800b650:	4f66      	ldr	r7, [pc, #408]	; (800b7ec <prvEchoClientTask+0x1c4>)
 800b652:	441f      	add	r7, r3

	/* Echo requests are sent to the echo server.  The address of the echo
	server is configured by the constants configECHO_SERVER_ADDR0 to
	configECHO_SERVER_ADDR3 in FreeRTOSConfig.h. */
	xEchoServerAddress.sin_port = FreeRTOS_htons( echoECHO_PORT );
 800b654:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 800b658:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
	xEchoServerAddress.sin_addr = FreeRTOS_inet_addr_quick( configECHO_SERVER_ADDR0,
 800b65c:	4b64      	ldr	r3, [pc, #400]	; (800b7f0 <prvEchoClientTask+0x1c8>)
 800b65e:	930b      	str	r3, [sp, #44]	; 0x2c

	/* Randomise the number of characters that will be sent in the echo
	request. */
	do
	{
		lCharactersToAdd = ipconfigRAND32() % ( ulBufferLength - 20UL );
 800b660:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 800b810 <prvEchoClientTask+0x1e8>
	} while ( ( lCharactersToAdd == 0 ) || ( lCharactersToAdd < lMinimumLength ) ); /* Must be at least enough to add the unique text to the start of the string later. */

	/* Fill the buffer. */
	for( lCharacter = 0; lCharacter < lCharactersToAdd; lCharacter++ )
	{
		cBuffer[ lCharacter ] = cChar;
 800b664:	4b60      	ldr	r3, [pc, #384]	; (800b7e8 <prvEchoClientTask+0x1c0>)
 800b666:	f640 3268 	movw	r2, #2920	; 0xb68
 800b66a:	fb02 3300 	mla	r3, r2, r0, r3
 800b66e:	9303      	str	r3, [sp, #12]
 800b670:	e062      	b.n	800b738 <prvEchoClientTask+0x110>
		configASSERT( xSocket != FREERTOS_INVALID_SOCKET );
 800b672:	21eb      	movs	r1, #235	; 0xeb
 800b674:	485f      	ldr	r0, [pc, #380]	; (800b7f4 <prvEchoClientTask+0x1cc>)
 800b676:	f000 fe73 	bl	800c360 <vAssertCalled>
 800b67a:	e066      	b.n	800b74a <prvEchoClientTask+0x122>
		cBuffer[ lCharacter ] = cChar;
 800b67c:	f802 3b01 	strb.w	r3, [r2], #1
		cChar++;
 800b680:	3301      	adds	r3, #1
 800b682:	b2db      	uxtb	r3, r3

		if( cChar > '~' )
		{
			cChar = '0';
 800b684:	2b7f      	cmp	r3, #127	; 0x7f
 800b686:	bf28      	it	cs
 800b688:	2330      	movcs	r3, #48	; 0x30
	for( lCharacter = 0; lCharacter < lCharactersToAdd; lCharacter++ )
 800b68a:	4291      	cmp	r1, r2
 800b68c:	d1f6      	bne.n	800b67c <prvEchoClientTask+0x54>
				sprintf( pcTransmittedString, "TxRx message number %u", ( unsigned ) ulTxCount );
 800b68e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b690:	4959      	ldr	r1, [pc, #356]	; (800b7f8 <prvEchoClientTask+0x1d0>)
 800b692:	f8dd 9008 	ldr.w	r9, [sp, #8]
 800b696:	4648      	mov	r0, r9
 800b698:	f000 fbb9 	bl	800be0e <sprintf>
				ulTxCount++;
 800b69c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b69e:	3301      	adds	r3, #1
 800b6a0:	9309      	str	r3, [sp, #36]	; 0x24
				lTransmitted = FreeRTOS_send(	xSocket,						/* The socket being sent to. */
 800b6a2:	2300      	movs	r3, #0
 800b6a4:	4622      	mov	r2, r4
 800b6a6:	4649      	mov	r1, r9
 800b6a8:	4630      	mov	r0, r6
 800b6aa:	f7fa f80b 	bl	80056c4 <FreeRTOS_send>
				if( lTransmitted < 0 )
 800b6ae:	1e04      	subs	r4, r0, #0
 800b6b0:	db26      	blt.n	800b700 <prvEchoClientTask+0xd8>
				memset( ( void * ) pcReceivedString, 0x00, echoBUFFER_SIZES );
 800b6b2:	f640 3268 	movw	r2, #2920	; 0xb68
 800b6b6:	2100      	movs	r1, #0
 800b6b8:	4638      	mov	r0, r7
 800b6ba:	f001 f831 	bl	800c720 <memset>
				while( xReceivedBytes < lTransmitted )
 800b6be:	2c00      	cmp	r4, #0
 800b6c0:	dd1e      	ble.n	800b700 <prvEchoClientTask+0xd8>
					xReturned = FreeRTOS_recv( xSocket,								/* The socket being received from. */
 800b6c2:	2300      	movs	r3, #0
 800b6c4:	eba8 0205 	sub.w	r2, r8, r5
 800b6c8:	1979      	adds	r1, r7, r5
 800b6ca:	4630      	mov	r0, r6
 800b6cc:	f7f9 ff30 	bl	8005530 <FreeRTOS_recv>
					if( xReturned < 0 )
 800b6d0:	2800      	cmp	r0, #0
 800b6d2:	db06      	blt.n	800b6e2 <prvEchoClientTask+0xba>
					else if( xReturned == 0 )
 800b6d4:	b120      	cbz	r0, 800b6e0 <prvEchoClientTask+0xb8>
						xReceivedBytes += xReturned;
 800b6d6:	4405      	add	r5, r0
				while( xReceivedBytes < lTransmitted )
 800b6d8:	42ac      	cmp	r4, r5
 800b6da:	dcf2      	bgt.n	800b6c2 <prvEchoClientTask+0x9a>
						xReceivedBytes += xReturned;
 800b6dc:	4628      	mov	r0, r5
 800b6de:	e000      	b.n	800b6e2 <prvEchoClientTask+0xba>
 800b6e0:	4628      	mov	r0, r5
				if( xReceivedBytes > 0 )
 800b6e2:	2800      	cmp	r0, #0
 800b6e4:	dd0c      	ble.n	800b700 <prvEchoClientTask+0xd8>
					configASSERT( strncmp( pcReceivedString, pcTransmittedString, lTransmitted ) == 0 );
 800b6e6:	4622      	mov	r2, r4
 800b6e8:	9902      	ldr	r1, [sp, #8]
 800b6ea:	4638      	mov	r0, r7
 800b6ec:	f001 f83c 	bl	800c768 <strncmp>
 800b6f0:	2800      	cmp	r0, #0
 800b6f2:	d166      	bne.n	800b7c2 <prvEchoClientTask+0x19a>
						ulTxRxCycles[ xInstance ]++;
 800b6f4:	4a41      	ldr	r2, [pc, #260]	; (800b7fc <prvEchoClientTask+0x1d4>)
 800b6f6:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 800b6fa:	3301      	adds	r3, #1
 800b6fc:	f842 302b 	str.w	r3, [r2, fp, lsl #2]
			FreeRTOS_shutdown( xSocket, FREERTOS_SHUT_RDWR );
 800b700:	2102      	movs	r1, #2
 800b702:	4630      	mov	r0, r6
 800b704:	f7fa f901 	bl	800590a <FreeRTOS_shutdown>
			xTimeOnEntering = xTaskGetTickCount();
 800b708:	f7fe fc92 	bl	800a030 <xTaskGetTickCount>
 800b70c:	4604      	mov	r4, r0
				xReturned = FreeRTOS_recv( xSocket,	/* The socket being received from. */
 800b70e:	2300      	movs	r3, #0
 800b710:	f640 3268 	movw	r2, #2920	; 0xb68
 800b714:	4639      	mov	r1, r7
 800b716:	4630      	mov	r0, r6
 800b718:	f7f9 ff0a 	bl	8005530 <FreeRTOS_recv>
				if( xReturned < 0 )
 800b71c:	2800      	cmp	r0, #0
 800b71e:	db05      	blt.n	800b72c <prvEchoClientTask+0x104>
			} while( ( xTaskGetTickCount() - xTimeOnEntering ) < xReceiveTimeOut );
 800b720:	f7fe fc86 	bl	800a030 <xTaskGetTickCount>
 800b724:	1b00      	subs	r0, r0, r4
 800b726:	f5b0 6f7a 	cmp.w	r0, #4000	; 0xfa0
 800b72a:	d3f0      	bcc.n	800b70e <prvEchoClientTask+0xe6>
		FreeRTOS_closesocket( xSocket );
 800b72c:	4630      	mov	r0, r6
 800b72e:	f7f9 fd77 	bl	8005220 <FreeRTOS_closesocket>
		vTaskDelay( echoLOOP_DELAY );
 800b732:	2096      	movs	r0, #150	; 0x96
 800b734:	f7fe fdce 	bl	800a2d4 <vTaskDelay>
		xSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );
 800b738:	2206      	movs	r2, #6
 800b73a:	2101      	movs	r1, #1
 800b73c:	2002      	movs	r0, #2
 800b73e:	f7f9 fb0d 	bl	8004d5c <FreeRTOS_socket>
 800b742:	4606      	mov	r6, r0
		configASSERT( xSocket != FREERTOS_INVALID_SOCKET );
 800b744:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b748:	d093      	beq.n	800b672 <prvEchoClientTask+0x4a>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVTIMEO, &xReceiveTimeOut, sizeof( xReceiveTimeOut ) );
 800b74a:	2404      	movs	r4, #4
 800b74c:	9400      	str	r4, [sp, #0]
 800b74e:	4b2c      	ldr	r3, [pc, #176]	; (800b800 <prvEchoClientTask+0x1d8>)
 800b750:	2200      	movs	r2, #0
 800b752:	4611      	mov	r1, r2
 800b754:	4630      	mov	r0, r6
 800b756:	f7fa fa07 	bl	8005b68 <FreeRTOS_setsockopt>
		FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800b75a:	9400      	str	r4, [sp, #0]
 800b75c:	4b29      	ldr	r3, [pc, #164]	; (800b804 <prvEchoClientTask+0x1dc>)
 800b75e:	2201      	movs	r2, #1
 800b760:	2100      	movs	r1, #0
 800b762:	4630      	mov	r0, r6
 800b764:	f7fa fa00 	bl	8005b68 <FreeRTOS_setsockopt>
			FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_WIN_PROPERTIES, ( void * ) &xWinProps,	sizeof( xWinProps ) );
 800b768:	2310      	movs	r3, #16
 800b76a:	9300      	str	r3, [sp, #0]
 800b76c:	ab05      	add	r3, sp, #20
 800b76e:	220d      	movs	r2, #13
 800b770:	2100      	movs	r1, #0
 800b772:	4630      	mov	r0, r6
 800b774:	f7fa f9f8 	bl	8005b68 <FreeRTOS_setsockopt>
		if( FreeRTOS_connect( xSocket, &xEchoServerAddress, sizeof( xEchoServerAddress ) ) == 0 )
 800b778:	2208      	movs	r2, #8
 800b77a:	a90a      	add	r1, sp, #40	; 0x28
 800b77c:	4630      	mov	r0, r6
 800b77e:	f7fa fb41 	bl	8005e04 <FreeRTOS_connect>
 800b782:	4605      	mov	r5, r0
 800b784:	2800      	cmp	r0, #0
 800b786:	d1d1      	bne.n	800b72c <prvEchoClientTask+0x104>
			ulConnections[ xInstance ]++;
 800b788:	4a1f      	ldr	r2, [pc, #124]	; (800b808 <prvEchoClientTask+0x1e0>)
 800b78a:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 800b78e:	3301      	adds	r3, #1
 800b790:	f842 302b 	str.w	r3, [r2, fp, lsl #2]
		lCharactersToAdd = ipconfigRAND32() % ( ulBufferLength - 20UL );
 800b794:	f640 3954 	movw	r9, #2900	; 0xb54
 800b798:	f000 fea8 	bl	800c4ec <uxRand>
 800b79c:	fbaa 3400 	umull	r3, r4, sl, r0
 800b7a0:	0ae4      	lsrs	r4, r4, #11
 800b7a2:	fb09 0414 	mls	r4, r9, r4, r0
 800b7a6:	46a0      	mov	r8, r4
	} while ( ( lCharactersToAdd == 0 ) || ( lCharactersToAdd < lMinimumLength ) ); /* Must be at least enough to add the unique text to the start of the string later. */
 800b7a8:	2c3b      	cmp	r4, #59	; 0x3b
 800b7aa:	ddf5      	ble.n	800b798 <prvEchoClientTask+0x170>
	for( lCharacter = 0; lCharacter < lCharactersToAdd; lCharacter++ )
 800b7ac:	2c00      	cmp	r4, #0
 800b7ae:	f77f af6e 	ble.w	800b68e <prvEchoClientTask+0x66>
		cBuffer[ lCharacter ] = cChar;
 800b7b2:	2330      	movs	r3, #48	; 0x30
 800b7b4:	9a03      	ldr	r2, [sp, #12]
 800b7b6:	7013      	strb	r3, [r2, #0]
 800b7b8:	9b02      	ldr	r3, [sp, #8]
 800b7ba:	1c5a      	adds	r2, r3, #1
 800b7bc:	1919      	adds	r1, r3, r4
		cChar++;
 800b7be:	2331      	movs	r3, #49	; 0x31
 800b7c0:	e763      	b.n	800b68a <prvEchoClientTask+0x62>
					configASSERT( strncmp( pcReceivedString, pcTransmittedString, lTransmitted ) == 0 );
 800b7c2:	f44f 719d 	mov.w	r1, #314	; 0x13a
 800b7c6:	480b      	ldr	r0, [pc, #44]	; (800b7f4 <prvEchoClientTask+0x1cc>)
 800b7c8:	f000 fdca 	bl	800c360 <vAssertCalled>
					if( strncmp( pcReceivedString, pcTransmittedString, lTransmitted ) == 0 )
 800b7cc:	4622      	mov	r2, r4
 800b7ce:	9902      	ldr	r1, [sp, #8]
 800b7d0:	4638      	mov	r0, r7
 800b7d2:	f000 ffc9 	bl	800c768 <strncmp>
 800b7d6:	2800      	cmp	r0, #0
 800b7d8:	d08c      	beq.n	800b6f4 <prvEchoClientTask+0xcc>
						ulTxRxFailures[ xInstance ]++;
 800b7da:	4a0c      	ldr	r2, [pc, #48]	; (800b80c <prvEchoClientTask+0x1e4>)
 800b7dc:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 800b7e0:	3301      	adds	r3, #1
 800b7e2:	f842 302b 	str.w	r3, [r2, fp, lsl #2]
						break;
 800b7e6:	e78b      	b.n	800b700 <prvEchoClientTask+0xd8>
 800b7e8:	20001b0c 	.word	0x20001b0c
 800b7ec:	20000fa4 	.word	0x20000fa4
 800b7f0:	6400a8c0 	.word	0x6400a8c0
 800b7f4:	0800d850 	.word	0x0800d850
 800b7f8:	0800d894 	.word	0x0800d894
 800b7fc:	20002678 	.word	0x20002678
 800b800:	0800d8b4 	.word	0x0800d8b4
 800b804:	0800d8b8 	.word	0x0800d8b8
 800b808:	20002674 	.word	0x20002674
 800b80c:	2000267c 	.word	0x2000267c
 800b810:	b4c9f9a5 	.word	0xb4c9f9a5

0800b814 <vStartTCPEchoClientTasks_SingleTasks>:
{
 800b814:	b500      	push	{lr}
 800b816:	b083      	sub	sp, #12
		xTaskCreate( 	prvEchoClientTask,	/* The function that implements the task. */
 800b818:	2300      	movs	r3, #0
 800b81a:	9301      	str	r3, [sp, #4]
 800b81c:	9100      	str	r1, [sp, #0]
 800b81e:	4602      	mov	r2, r0
 800b820:	4903      	ldr	r1, [pc, #12]	; (800b830 <vStartTCPEchoClientTasks_SingleTasks+0x1c>)
 800b822:	4804      	ldr	r0, [pc, #16]	; (800b834 <vStartTCPEchoClientTasks_SingleTasks+0x20>)
 800b824:	f7fe fa26 	bl	8009c74 <xTaskCreate>
}
 800b828:	b003      	add	sp, #12
 800b82a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b82e:	bf00      	nop
 800b830:	0800d8ac 	.word	0x0800d8ac
 800b834:	0800b629 	.word	0x0800b629

0800b838 <prvIncrementEventCount>:
{
	/* Each row in the xIPTraceValues[] table contains a pointer to a function
	that updates the value for that row.  Rows that simply increment an event
	count point to this function. */
	( void ) ulCount;
	( *pulCurrentValue )++;
 800b838:	6803      	ldr	r3, [r0, #0]
 800b83a:	3301      	adds	r3, #1
 800b83c:	6003      	str	r3, [r0, #0]
 800b83e:	4770      	bx	lr

0800b840 <prvStoreLowest>:
	/* Each row in the xIPTraceValues[] table contains a pointer to a function
	that updates the value for that row.  Rows that latch the lowest value
	point to this function (for example, this function can be used to latch
	the lowest number of network buffers that were available during the
	execution of the stack). */
	if( ulCount < *pulCurrentValue )
 800b840:	6803      	ldr	r3, [r0, #0]
 800b842:	428b      	cmp	r3, r1
	{
		*pulCurrentValue = ulCount;
 800b844:	bf88      	it	hi
 800b846:	6001      	strhi	r1, [r0, #0]
 800b848:	4770      	bx	lr

0800b84a <xExampleDebugStatEntries>:
}
 800b84a:	2014      	movs	r0, #20
 800b84c:	4770      	bx	lr
	...

0800b850 <vExampleDebugStatUpdate>:
{
 800b850:	b510      	push	{r4, lr}
		if( xIPTraceValues[ xIndex ].ucIdentifier == ucIdentifier )
 800b852:	4b0f      	ldr	r3, [pc, #60]	; (800b890 <vExampleDebugStatUpdate+0x40>)
 800b854:	781b      	ldrb	r3, [r3, #0]
 800b856:	4283      	cmp	r3, r0
 800b858:	d00d      	beq.n	800b876 <vExampleDebugStatUpdate+0x26>
 800b85a:	4b0d      	ldr	r3, [pc, #52]	; (800b890 <vExampleDebugStatUpdate+0x40>)
	for( xIndex = 0; xIndex < xEntries; xIndex++ )
 800b85c:	2401      	movs	r4, #1
		if( xIPTraceValues[ xIndex ].ucIdentifier == ucIdentifier )
 800b85e:	7c1a      	ldrb	r2, [r3, #16]
 800b860:	4282      	cmp	r2, r0
 800b862:	d009      	beq.n	800b878 <vExampleDebugStatUpdate+0x28>
	for( xIndex = 0; xIndex < xEntries; xIndex++ )
 800b864:	3401      	adds	r4, #1
 800b866:	3310      	adds	r3, #16
 800b868:	2c14      	cmp	r4, #20
 800b86a:	d1f8      	bne.n	800b85e <vExampleDebugStatUpdate+0xe>
	configASSERT( xIndex != xEntries );
 800b86c:	21bd      	movs	r1, #189	; 0xbd
 800b86e:	4809      	ldr	r0, [pc, #36]	; (800b894 <vExampleDebugStatUpdate+0x44>)
 800b870:	f000 fd76 	bl	800c360 <vAssertCalled>
}
 800b874:	e00a      	b.n	800b88c <vExampleDebugStatUpdate+0x3c>
	for( xIndex = 0; xIndex < xEntries; xIndex++ )
 800b876:	2400      	movs	r4, #0
			xIPTraceValues[ xIndex ].vPerformAction( &( xIPTraceValues[ xIndex ].ulData ), ulValue );
 800b878:	4a05      	ldr	r2, [pc, #20]	; (800b890 <vExampleDebugStatUpdate+0x40>)
 800b87a:	0123      	lsls	r3, r4, #4
 800b87c:	f103 000c 	add.w	r0, r3, #12
 800b880:	4413      	add	r3, r2
 800b882:	689b      	ldr	r3, [r3, #8]
 800b884:	4410      	add	r0, r2
 800b886:	4798      	blx	r3
	configASSERT( xIndex != xEntries );
 800b888:	2c14      	cmp	r4, #20
 800b88a:	d0ef      	beq.n	800b86c <vExampleDebugStatUpdate+0x1c>
 800b88c:	bd10      	pop	{r4, pc}
 800b88e:	bf00      	nop
 800b890:	20000034 	.word	0x20000034
 800b894:	0800dc04 	.word	0x0800dc04

0800b898 <prvLoggingTask>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void prvLoggingTask( void *pvParameters )
{
 800b898:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b89c:	b089      	sub	sp, #36	; 0x24
	( void ) pvParameters;

	/* A possibility to set some additional task properties. */
	iptraceUDP_LOGGING_TASK_STARTING();

	xRemoteAddress.sin_port = FreeRTOS_htons( configUDP_LOGGING_PORT_REMOTE );
 800b89e:	f64d 4305 	movw	r3, #56325	; 0xdc05
 800b8a2:	f8ad 3012 	strh.w	r3, [sp, #18]
	#if defined( configUDP_LOGGING_ADDR0 )
	{
		/* Use a fixed address to where the logging will be sent. */
		xRemoteAddress.sin_addr = FreeRTOS_inet_addr_quick( configUDP_LOGGING_ADDR0,
 800b8a6:	4b62      	ldr	r3, [pc, #392]	; (800ba30 <prvLoggingTask+0x198>)
 800b8a8:	9305      	str	r3, [sp, #20]
	#endif

	/* Loop until a socket is created. */
	do
	{
		vTaskDelay( xBlockingTime );
 800b8aa:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
		xUDPLoggingSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800b8ae:	2511      	movs	r5, #17
 800b8b0:	4c60      	ldr	r4, [pc, #384]	; (800ba34 <prvLoggingTask+0x19c>)
		vTaskDelay( xBlockingTime );
 800b8b2:	4630      	mov	r0, r6
 800b8b4:	f7fe fd0e 	bl	800a2d4 <vTaskDelay>
		xUDPLoggingSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800b8b8:	462a      	mov	r2, r5
 800b8ba:	2102      	movs	r1, #2
 800b8bc:	4608      	mov	r0, r1
 800b8be:	f7f9 fa4d 	bl	8004d5c <FreeRTOS_socket>
 800b8c2:	6020      	str	r0, [r4, #0]
	} while( xUDPLoggingSocket == FREERTOS_INVALID_SOCKET );
 800b8c4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b8c8:	d0f3      	beq.n	800b8b2 <prvLoggingTask+0x1a>

	xLocalAddress.sin_port = FreeRTOS_htons( configUDP_LOGGING_PORT_LOCAL );
 800b8ca:	f64d 3305 	movw	r3, #56069	; 0xdb05
 800b8ce:	f8ad 301a 	strh.w	r3, [sp, #26]
	xLocalAddress.sin_addr = FreeRTOS_GetIPAddress();
 800b8d2:	f7f9 f9a1 	bl	8004c18 <FreeRTOS_GetIPAddress>
 800b8d6:	9007      	str	r0, [sp, #28]

	FreeRTOS_bind( xUDPLoggingSocket, &xLocalAddress, sizeof( xLocalAddress ) );
 800b8d8:	4e56      	ldr	r6, [pc, #344]	; (800ba34 <prvLoggingTask+0x19c>)
 800b8da:	2208      	movs	r2, #8
 800b8dc:	a906      	add	r1, sp, #24
 800b8de:	6830      	ldr	r0, [r6, #0]
 800b8e0:	f7f9 fb63 	bl	8004faa <FreeRTOS_bind>

	xSendTimeOut = xBlockingTime;
 800b8e4:	ab08      	add	r3, sp, #32
 800b8e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b8ea:	f843 2d14 	str.w	r2, [r3, #-20]!
	FreeRTOS_setsockopt( xUDPLoggingSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800b8ee:	2204      	movs	r2, #4
 800b8f0:	9200      	str	r2, [sp, #0]
 800b8f2:	2201      	movs	r2, #1
 800b8f4:	2100      	movs	r1, #0
 800b8f6:	6830      	ldr	r0, [r6, #0]
 800b8f8:	f7fa f936 	bl	8005b68 <FreeRTOS_setsockopt>

	/* Send a dummy message to resolve the IP address before sending the logging 
	messages. */
	snprintf( cLoggingLine, configUDP_LOGGING_STRING_LENGTH, "Logging Probe\n" );
 800b8fc:	4d4e      	ldr	r5, [pc, #312]	; (800ba38 <prvLoggingTask+0x1a0>)
 800b8fe:	4b4f      	ldr	r3, [pc, #316]	; (800ba3c <prvLoggingTask+0x1a4>)
 800b900:	462c      	mov	r4, r5
 800b902:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800b904:	c407      	stmia	r4!, {r0, r1, r2}
 800b906:	f824 3b02 	strh.w	r3, [r4], #2
 800b90a:	0c1b      	lsrs	r3, r3, #16
 800b90c:	7023      	strb	r3, [r4, #0]
	FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, strlen( cLoggingLine ), 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
 800b90e:	4628      	mov	r0, r5
 800b910:	f7f4 fc5e 	bl	80001d0 <strlen>
 800b914:	6834      	ldr	r4, [r6, #0]
 800b916:	2308      	movs	r3, #8
 800b918:	9301      	str	r3, [sp, #4]
 800b91a:	ab04      	add	r3, sp, #16
 800b91c:	9300      	str	r3, [sp, #0]
 800b91e:	2300      	movs	r3, #0
 800b920:	4602      	mov	r2, r0
 800b922:	4629      	mov	r1, r5
 800b924:	4620      	mov	r0, r4
 800b926:	f7f9 fb77 	bl	8005018 <FreeRTOS_sendto>
	vTaskDelay( xResolveDelay );
 800b92a:	20fa      	movs	r0, #250	; 0xfa
 800b92c:	f7fe fcd2 	bl	800a2d4 <vTaskDelay>
	if( pxStreamBuffer != NULL )
 800b930:	4f43      	ldr	r7, [pc, #268]	; (800ba40 <prvLoggingTask+0x1a8>)
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) xLogEntry.cMessage, xMessageLength, pdFALSE );
 800b932:	f8df 8110 	ldr.w	r8, [pc, #272]	; 800ba44 <prvLoggingTask+0x1ac>
 800b936:	e06c      	b.n	800ba12 <prvLoggingTask+0x17a>
			vTaskSuspendAll();
 800b938:	f7fe fb72 	bl	800a020 <vTaskSuspendAll>
				uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) &xMessageLength, sizeof( xMessageLength ), pdFALSE );
 800b93c:	2100      	movs	r1, #0
 800b93e:	9100      	str	r1, [sp, #0]
 800b940:	2304      	movs	r3, #4
 800b942:	aa02      	add	r2, sp, #8
 800b944:	6838      	ldr	r0, [r7, #0]
 800b946:	f7fa fccc 	bl	80062e2 <uxStreamBufferGet>
				if( xBufferLength < xMessageLength )
 800b94a:	9b02      	ldr	r3, [sp, #8]
 800b94c:	2bc8      	cmp	r3, #200	; 0xc8
 800b94e:	d922      	bls.n	800b996 <prvLoggingTask+0xfe>
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) xLogEntry.cMessage, xMessageLength, pdFALSE );
 800b950:	2500      	movs	r5, #0
 800b952:	9500      	str	r5, [sp, #0]
 800b954:	4642      	mov	r2, r8
 800b956:	4629      	mov	r1, r5
 800b958:	6838      	ldr	r0, [r7, #0]
 800b95a:	f7fa fcc2 	bl	80062e2 <uxStreamBufferGet>
					memcpy( pcBuffer, xLogEntry.cMessage, xBufferLength );
 800b95e:	f04f 09c8 	mov.w	r9, #200	; 0xc8
 800b962:	464a      	mov	r2, r9
 800b964:	4641      	mov	r1, r8
 800b966:	4620      	mov	r0, r4
 800b968:	f000 feb5 	bl	800c6d6 <memcpy>
					xMessageLength = xBufferLength;
 800b96c:	f8cd 9008 	str.w	r9, [sp, #8]
					pcBuffer[ xBufferLength - 1 ] = 0x00;
 800b970:	f884 50c7 	strb.w	r5, [r4, #199]	; 0xc7
			xTaskResumeAll();
 800b974:	f7fe fc2e 	bl	800a1d4 <xTaskResumeAll>
	return xMessageLength;
 800b978:	9a02      	ldr	r2, [sp, #8]
			/* Check for messages in the buffer. */
			for( lLines = 0; lLines < configUDP_LOGGING_MAX_MESSAGES_IN_BUFFER; lLines++ )
			{
				xCount = prvGetMessageFromStreamBuffer ( cLoggingLine, sizeof( cLoggingLine ) );

				if( xCount <= 0 )
 800b97a:	2a00      	cmp	r2, #0
 800b97c:	d049      	beq.n	800ba12 <prvLoggingTask+0x17a>
					newline.  If 'configUDP_LOGGING_NEEDS_CR_LF' is defined as non-zero,
					every "\n" will be translated into a "\r\n". */
					pcTarget = cLoggingLine;
					pcSource = cLoggingLine;

					while( ( *pcSource != 0x00 ) && ( pcSource < ( cLoggingLine + xCount ) ) )
 800b97e:	7820      	ldrb	r0, [r4, #0]
 800b980:	b368      	cbz	r0, 800b9de <prvLoggingTask+0x146>
 800b982:	18a3      	adds	r3, r4, r2
 800b984:	429c      	cmp	r4, r3
 800b986:	d22a      	bcs.n	800b9de <prvLoggingTask+0x146>
 800b988:	4b2b      	ldr	r3, [pc, #172]	; (800ba38 <prvLoggingTask+0x1a0>)
 800b98a:	4619      	mov	r1, r3
					{
						*pcTarget = *pcSource;

						if( ( ( pcSource == cLoggingLine ) || ( pcSource[ -1 ] != logASCII_CR ) ) && ( pcSource[ 0 ] == logASCII_NL ) )
						{
							pcTarget[ 0 ] = logASCII_CR;
 800b98c:	f04f 0c0d 	mov.w	ip, #13
							pcTarget[ 1 ] = logASCII_NL;
 800b990:	f04f 0e0a 	mov.w	lr, #10
 800b994:	e010      	b.n	800b9b8 <prvLoggingTask+0x120>
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) pcBuffer, xMessageLength, pdFALSE );
 800b996:	2500      	movs	r5, #0
 800b998:	9500      	str	r5, [sp, #0]
 800b99a:	4622      	mov	r2, r4
 800b99c:	4629      	mov	r1, r5
 800b99e:	6838      	ldr	r0, [r7, #0]
 800b9a0:	f7fa fc9f 	bl	80062e2 <uxStreamBufferGet>
					pcBuffer[ xMessageLength ] = 0x00;
 800b9a4:	9b02      	ldr	r3, [sp, #8]
 800b9a6:	54e5      	strb	r5, [r4, r3]
 800b9a8:	e7e4      	b.n	800b974 <prvLoggingTask+0xdc>
								xCount++;
								pcTarget++;
							}
						}

						pcTarget++;
 800b9aa:	3101      	adds	r1, #1
					while( ( *pcSource != 0x00 ) && ( pcSource < ( cLoggingLine + xCount ) ) )
 800b9ac:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 800b9b0:	b1a8      	cbz	r0, 800b9de <prvLoggingTask+0x146>
 800b9b2:	18a5      	adds	r5, r4, r2
 800b9b4:	42ab      	cmp	r3, r5
 800b9b6:	d212      	bcs.n	800b9de <prvLoggingTask+0x146>
						*pcTarget = *pcSource;
 800b9b8:	7008      	strb	r0, [r1, #0]
						if( ( ( pcSource == cLoggingLine ) || ( pcSource[ -1 ] != logASCII_CR ) ) && ( pcSource[ 0 ] == logASCII_NL ) )
 800b9ba:	42a3      	cmp	r3, r4
 800b9bc:	d003      	beq.n	800b9c6 <prvLoggingTask+0x12e>
 800b9be:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 800b9c2:	280d      	cmp	r0, #13
 800b9c4:	d0f1      	beq.n	800b9aa <prvLoggingTask+0x112>
 800b9c6:	7818      	ldrb	r0, [r3, #0]
 800b9c8:	280a      	cmp	r0, #10
 800b9ca:	d1ee      	bne.n	800b9aa <prvLoggingTask+0x112>
							pcTarget[ 0 ] = logASCII_CR;
 800b9cc:	f881 c000 	strb.w	ip, [r1]
							pcTarget[ 1 ] = logASCII_NL;
 800b9d0:	f881 e001 	strb.w	lr, [r1, #1]
							if( xCount < ( sizeof( cLoggingLine ) - 1 ) )
 800b9d4:	2ac6      	cmp	r2, #198	; 0xc6
								xCount++;
 800b9d6:	bf9c      	itt	ls
 800b9d8:	3201      	addls	r2, #1
								pcTarget++;
 800b9da:	3101      	addls	r1, #1
 800b9dc:	e7e5      	b.n	800b9aa <prvLoggingTask+0x112>
						pcSource++;
					}
				}
				#endif

				FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, xCount, 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
 800b9de:	4b15      	ldr	r3, [pc, #84]	; (800ba34 <prvLoggingTask+0x19c>)
 800b9e0:	6818      	ldr	r0, [r3, #0]
 800b9e2:	2308      	movs	r3, #8
 800b9e4:	9301      	str	r3, [sp, #4]
 800b9e6:	ab04      	add	r3, sp, #16
 800b9e8:	9300      	str	r3, [sp, #0]
 800b9ea:	2300      	movs	r3, #0
 800b9ec:	4621      	mov	r1, r4
 800b9ee:	f7f9 fb13 	bl	8005018 <FreeRTOS_sendto>
			for( lLines = 0; lLines < configUDP_LOGGING_MAX_MESSAGES_IN_BUFFER; lLines++ )
 800b9f2:	3e01      	subs	r6, #1
 800b9f4:	d00e      	beq.n	800ba14 <prvLoggingTask+0x17c>
size_t xMessageLength = 0;
 800b9f6:	2300      	movs	r3, #0
 800b9f8:	9302      	str	r3, [sp, #8]
	if( pxStreamBuffer != NULL )
 800b9fa:	683a      	ldr	r2, [r7, #0]
 800b9fc:	b14a      	cbz	r2, 800ba12 <prvLoggingTask+0x17a>
size_t uxHead = pxBuffer->uxHead;
 800b9fe:	6893      	ldr	r3, [r2, #8]
size_t uxTail = pxBuffer->uxTail;
 800ba00:	6811      	ldr	r1, [r2, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 800ba02:	6912      	ldr	r2, [r2, #16]
 800ba04:	4413      	add	r3, r2
 800ba06:	1a5b      	subs	r3, r3, r1
	if ( uxCount >= pxBuffer->LENGTH )
 800ba08:	429a      	cmp	r2, r3
		uxCount -= pxBuffer->LENGTH;
 800ba0a:	bf98      	it	ls
 800ba0c:	1a9b      	subls	r3, r3, r2
		if( uxLength > sizeof( size_t ) )
 800ba0e:	2b04      	cmp	r3, #4
 800ba10:	d892      	bhi.n	800b938 <prvLoggingTask+0xa0>
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) pcBuffer, xMessageLength, pdFALSE );
 800ba12:	4c09      	ldr	r4, [pc, #36]	; (800ba38 <prvLoggingTask+0x1a0>)
		ulTaskNotifyTake( pdTRUE, xBlockingTime );
 800ba14:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800ba18:	2501      	movs	r5, #1
 800ba1a:	4631      	mov	r1, r6
 800ba1c:	4628      	mov	r0, r5
 800ba1e:	f7ff f8e5 	bl	800abec <ulTaskNotifyTake>
		if( xGetPhyLinkStatus() != pdFALSE )
 800ba22:	f7fd f8e1 	bl	8008be8 <xGetPhyLinkStatus>
 800ba26:	2800      	cmp	r0, #0
 800ba28:	d0f7      	beq.n	800ba1a <prvLoggingTask+0x182>
 800ba2a:	2614      	movs	r6, #20
 800ba2c:	e7e3      	b.n	800b9f6 <prvLoggingTask+0x15e>
 800ba2e:	bf00      	nop
 800ba30:	6400a8c0 	.word	0x6400a8c0
 800ba34:	20000174 	.word	0x20000174
 800ba38:	20002680 	.word	0x20002680
 800ba3c:	0800dc90 	.word	0x0800dc90
 800ba40:	20002748 	.word	0x20002748
 800ba44:	20002758 	.word	0x20002758

0800ba48 <lUDPLoggingPrintf>:
{
 800ba48:	b40f      	push	{r0, r1, r2, r3}
 800ba4a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ba4e:	b086      	sub	sp, #24
	if( xLoggingInitialised == pdFALSE )
 800ba50:	4b4a      	ldr	r3, [pc, #296]	; (800bb7c <lUDPLoggingPrintf+0x134>)
 800ba52:	681b      	ldr	r3, [r3, #0]
 800ba54:	2b00      	cmp	r3, #0
 800ba56:	d05e      	beq.n	800bb16 <lUDPLoggingPrintf+0xce>
		va_start (args, pcFormatString);//和可变参数有关的，由编译器实现
 800ba58:	ad0f      	add	r5, sp, #60	; 0x3c
 800ba5a:	9504      	str	r5, [sp, #16]
	configASSERT( pxStreamBuffer );
 800ba5c:	4b48      	ldr	r3, [pc, #288]	; (800bb80 <lUDPLoggingPrintf+0x138>)
 800ba5e:	681b      	ldr	r3, [r3, #0]
 800ba60:	2b00      	cmp	r3, #0
 800ba62:	d077      	beq.n	800bb54 <lUDPLoggingPrintf+0x10c>
	vTaskSuspendAll();
 800ba64:	f7fe fadc 	bl	800a020 <vTaskSuspendAll>
		ullCurrentTime = ullGetHighResolutionTime();
 800ba68:	f000 fb86 	bl	800c178 <ullGetHighResolutionTime>
 800ba6c:	4680      	mov	r8, r0
 800ba6e:	4689      	mov	r9, r1
		ullCurrentTime = ullCurrentTime % 1000000ull;
 800ba70:	4a44      	ldr	r2, [pc, #272]	; (800bb84 <lUDPLoggingPrintf+0x13c>)
 800ba72:	2300      	movs	r3, #0
 800ba74:	f7f4 fbb4 	bl	80001e0 <__aeabi_uldivmod>
 800ba78:	4616      	mov	r6, r2
 800ba7a:	461f      	mov	r7, r3
		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800ba7c:	2000      	movs	r0, #0
 800ba7e:	f7fe fadd 	bl	800a03c <pcTaskGetName>
 800ba82:	4682      	mov	sl, r0
		ulSeconds = ( uint32_t ) ( ullCurrentTime / 1000000ull );
 800ba84:	4a3f      	ldr	r2, [pc, #252]	; (800bb84 <lUDPLoggingPrintf+0x13c>)
 800ba86:	2300      	movs	r3, #0
 800ba88:	4640      	mov	r0, r8
 800ba8a:	4649      	mov	r1, r9
 800ba8c:	f7f4 fba8 	bl	80001e0 <__aeabi_uldivmod>
 800ba90:	4680      	mov	r8, r0
		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800ba92:	4c3d      	ldr	r4, [pc, #244]	; (800bb88 <lUDPLoggingPrintf+0x140>)
 800ba94:	f8cd a008 	str.w	sl, [sp, #8]
		ulMicroSeconds = ( uint32_t ) ( ullCurrentTime % 1000ull );
 800ba98:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800ba9c:	2300      	movs	r3, #0
 800ba9e:	4630      	mov	r0, r6
 800baa0:	4639      	mov	r1, r7
 800baa2:	f7f4 fb9d 	bl	80001e0 <__aeabi_uldivmod>
 800baa6:	9201      	str	r2, [sp, #4]
		ulMilliSeconds = ( uint32_t ) ( ullCurrentTime / 1000ull );
 800baa8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800baac:	2300      	movs	r3, #0
 800baae:	4630      	mov	r0, r6
 800bab0:	4639      	mov	r1, r7
 800bab2:	f7f4 fb95 	bl	80001e0 <__aeabi_uldivmod>
 800bab6:	9000      	str	r0, [sp, #0]
		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800bab8:	4643      	mov	r3, r8
 800baba:	4a34      	ldr	r2, [pc, #208]	; (800bb8c <lUDPLoggingPrintf+0x144>)
 800babc:	21c8      	movs	r1, #200	; 0xc8
 800babe:	4620      	mov	r0, r4
 800bac0:	f000 faff 	bl	800c0c2 <snprintf>
 800bac4:	9005      	str	r0, [sp, #20]
		xLength += ( size_t ) vsnprintf( xLogEntry.cMessage + xLength, sizeof( xLogEntry.cMessage ) - xLength, pcFormatString, xArgs );
 800bac6:	462b      	mov	r3, r5
 800bac8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800baca:	f1c0 01c8 	rsb	r1, r0, #200	; 0xc8
 800bace:	4420      	add	r0, r4
 800bad0:	f000 fae6 	bl	800c0a0 <vsnprintf>
 800bad4:	9a05      	ldr	r2, [sp, #20]
 800bad6:	4402      	add	r2, r0
 800bad8:	9205      	str	r2, [sp, #20]
		xSpace = uxStreamBufferGetSpace( pxStreamBuffer );
 800bada:	4b29      	ldr	r3, [pc, #164]	; (800bb80 <lUDPLoggingPrintf+0x138>)
 800badc:	6818      	ldr	r0, [r3, #0]
size_t uxHead = pxBuffer->uxHead;
 800bade:	6884      	ldr	r4, [r0, #8]
size_t uxTail = pxBuffer->uxTail;
 800bae0:	6803      	ldr	r3, [r0, #0]
	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 800bae2:	6901      	ldr	r1, [r0, #16]
 800bae4:	440b      	add	r3, r1
 800bae6:	3b01      	subs	r3, #1
 800bae8:	1b1b      	subs	r3, r3, r4
	if( uxCount >= pxBuffer->LENGTH )
 800baea:	4299      	cmp	r1, r3
		uxCount -= pxBuffer->LENGTH;
 800baec:	bf98      	it	ls
 800baee:	1a5b      	subls	r3, r3, r1
		if( xSpace > ( xLength + sizeof( BaseType_t ) ) )
 800baf0:	3204      	adds	r2, #4
 800baf2:	429a      	cmp	r2, r3
 800baf4:	d334      	bcc.n	800bb60 <lUDPLoggingPrintf+0x118>
	xTaskResumeAll();
 800baf6:	f7fe fb6d 	bl	800a1d4 <xTaskResumeAll>
	if( xLoggingTask != NULL )
 800bafa:	4b25      	ldr	r3, [pc, #148]	; (800bb90 <lUDPLoggingPrintf+0x148>)
 800bafc:	6818      	ldr	r0, [r3, #0]
 800bafe:	b120      	cbz	r0, 800bb0a <lUDPLoggingPrintf+0xc2>
		xTaskNotifyGive( xLoggingTask );
 800bb00:	2300      	movs	r3, #0
 800bb02:	2202      	movs	r2, #2
 800bb04:	4619      	mov	r1, r3
 800bb06:	f7ff f8ad 	bl	800ac64 <xTaskGenericNotify>
	return xLength;
 800bb0a:	9805      	ldr	r0, [sp, #20]
}
 800bb0c:	b006      	add	sp, #24
 800bb0e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800bb12:	b004      	add	sp, #16
 800bb14:	4770      	bx	lr
		if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800bb16:	f7fe feb7 	bl	800a888 <xTaskGetSchedulerState>
 800bb1a:	2802      	cmp	r0, #2
 800bb1c:	d005      	beq.n	800bb2a <lUDPLoggingPrintf+0xe2>
	return xLoggingInitialised;
 800bb1e:	4b17      	ldr	r3, [pc, #92]	; (800bb7c <lUDPLoggingPrintf+0x134>)
	if( prvInitialiseLogging() != pdFALSE )
 800bb20:	681b      	ldr	r3, [r3, #0]
		xLength = 0;
 800bb22:	2000      	movs	r0, #0
	if( prvInitialiseLogging() != pdFALSE )
 800bb24:	2b00      	cmp	r3, #0
 800bb26:	d0f1      	beq.n	800bb0c <lUDPLoggingPrintf+0xc4>
 800bb28:	e796      	b.n	800ba58 <lUDPLoggingPrintf+0x10>
			pxStreamBuffer = pvPortMalloc( xSize );
 800bb2a:	f640 70b5 	movw	r0, #4021	; 0xfb5
 800bb2e:	f7fd fba3 	bl	8009278 <pvPortMalloc>
 800bb32:	4604      	mov	r4, r0
 800bb34:	4b12      	ldr	r3, [pc, #72]	; (800bb80 <lUDPLoggingPrintf+0x138>)
 800bb36:	6018      	str	r0, [r3, #0]
			if( pxStreamBuffer != NULL )
 800bb38:	2800      	cmp	r0, #0
 800bb3a:	d0f0      	beq.n	800bb1e <lUDPLoggingPrintf+0xd6>
				memset( pxStreamBuffer, '\0', xSize );
 800bb3c:	f640 72b5 	movw	r2, #4021	; 0xfb5
 800bb40:	2100      	movs	r1, #0
 800bb42:	f000 fded 	bl	800c720 <memset>
				pxStreamBuffer->LENGTH = logMESSAGE_BUFFER_SIZE_BYTES + 1;
 800bb46:	f640 73a1 	movw	r3, #4001	; 0xfa1
 800bb4a:	6123      	str	r3, [r4, #16]
				xLoggingInitialised = pdTRUE;
 800bb4c:	2201      	movs	r2, #1
 800bb4e:	4b0b      	ldr	r3, [pc, #44]	; (800bb7c <lUDPLoggingPrintf+0x134>)
 800bb50:	601a      	str	r2, [r3, #0]
 800bb52:	e781      	b.n	800ba58 <lUDPLoggingPrintf+0x10>
	configASSERT( pxStreamBuffer );
 800bb54:	f44f 7195 	mov.w	r1, #298	; 0x12a
 800bb58:	480e      	ldr	r0, [pc, #56]	; (800bb94 <lUDPLoggingPrintf+0x14c>)
 800bb5a:	f000 fc01 	bl	800c360 <vAssertCalled>
 800bb5e:	e781      	b.n	800ba64 <lUDPLoggingPrintf+0x1c>
			uxStreamBufferAdd( pxStreamBuffer, 0, ( const uint8_t * ) &xLength, sizeof( xLength ) );
 800bb60:	2304      	movs	r3, #4
 800bb62:	aa05      	add	r2, sp, #20
 800bb64:	2100      	movs	r1, #0
 800bb66:	f7fa fb58 	bl	800621a <uxStreamBufferAdd>
			uxStreamBufferAdd( pxStreamBuffer, 0, ( const uint8_t * ) ( xLogEntry.cMessage ), xLength );
 800bb6a:	9b05      	ldr	r3, [sp, #20]
 800bb6c:	4a06      	ldr	r2, [pc, #24]	; (800bb88 <lUDPLoggingPrintf+0x140>)
 800bb6e:	2100      	movs	r1, #0
 800bb70:	4803      	ldr	r0, [pc, #12]	; (800bb80 <lUDPLoggingPrintf+0x138>)
 800bb72:	6800      	ldr	r0, [r0, #0]
 800bb74:	f7fa fb51 	bl	800621a <uxStreamBufferAdd>
 800bb78:	e7bd      	b.n	800baf6 <lUDPLoggingPrintf+0xae>
 800bb7a:	bf00      	nop
 800bb7c:	20002820 	.word	0x20002820
 800bb80:	20002748 	.word	0x20002748
 800bb84:	000f4240 	.word	0x000f4240
 800bb88:	20002758 	.word	0x20002758
 800bb8c:	0800dc78 	.word	0x0800dc78
 800bb90:	20002824 	.word	0x20002824
 800bb94:	0800dc4c 	.word	0x0800dc4c

0800bb98 <vUDPLoggingTaskCreate>:
{
 800bb98:	b500      	push	{lr}
 800bb9a:	b083      	sub	sp, #12
	xTaskCreate( prvLoggingTask, "LogTask", configUDP_LOGGING_TASK_STACK_SIZE, NULL, configUDP_LOGGING_TASK_PRIORITY, &xLoggingTask );
 800bb9c:	4b06      	ldr	r3, [pc, #24]	; (800bbb8 <vUDPLoggingTaskCreate+0x20>)
 800bb9e:	9301      	str	r3, [sp, #4]
 800bba0:	2301      	movs	r3, #1
 800bba2:	9300      	str	r3, [sp, #0]
 800bba4:	2300      	movs	r3, #0
 800bba6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800bbaa:	4904      	ldr	r1, [pc, #16]	; (800bbbc <vUDPLoggingTaskCreate+0x24>)
 800bbac:	4804      	ldr	r0, [pc, #16]	; (800bbc0 <vUDPLoggingTaskCreate+0x28>)
 800bbae:	f7fe f861 	bl	8009c74 <xTaskCreate>
}
 800bbb2:	b003      	add	sp, #12
 800bbb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800bbb8:	20002824 	.word	0x20002824
 800bbbc:	0800dca0 	.word	0x0800dca0
 800bbc0:	0800b899 	.word	0x0800b899

0800bbc4 <strbuf_init>:
	struct xPrintFlags flags;
};

static void strbuf_init( struct SStringBuf *apStr, char *apBuf, const char *apMaxStr )
{
	apStr->str = apBuf;
 800bbc4:	6001      	str	r1, [r0, #0]
	apStr->orgStr = apBuf;
 800bbc6:	6041      	str	r1, [r0, #4]
	apStr->nulPos = apMaxStr-1;
 800bbc8:	3a01      	subs	r2, #1
 800bbca:	6082      	str	r2, [r0, #8]
	apStr->curLen = 0;
 800bbcc:	2300      	movs	r3, #0
 800bbce:	60c3      	str	r3, [r0, #12]

	memset( &apStr->flags, '\0', sizeof( apStr->flags ) );
 800bbd0:	6103      	str	r3, [r0, #16]
 800bbd2:	6143      	str	r3, [r0, #20]
 800bbd4:	6183      	str	r3, [r0, #24]
 800bbd6:	61c3      	str	r3, [r0, #28]
 800bbd8:	4770      	bx	lr

0800bbda <strbuf_printchar>:
}
/*-----------------------------------------------------------*/

static BaseType_t strbuf_printchar( struct SStringBuf *apStr, int c )
{
	if( apStr->str == NULL )
 800bbda:	6803      	ldr	r3, [r0, #0]
 800bbdc:	b133      	cbz	r3, 800bbec <strbuf_printchar+0x12>
	{
		vOutputChar( ( char ) c, xTicksToWait );
		apStr->curLen++;
		return pdTRUE;
	}
	if( apStr->str < apStr->nulPos )
 800bbde:	6882      	ldr	r2, [r0, #8]
 800bbe0:	4293      	cmp	r3, r2
 800bbe2:	d30f      	bcc.n	800bc04 <strbuf_printchar+0x2a>
	{
		*( apStr->str++ ) = c;
		apStr->curLen++;
		return pdTRUE;
	}
	if( apStr->str == apStr->nulPos )
 800bbe4:	4293      	cmp	r3, r2
 800bbe6:	d015      	beq.n	800bc14 <strbuf_printchar+0x3a>
	{
		*( apStr->str++ ) = '\0';
	}
	return pdFALSE;
 800bbe8:	2000      	movs	r0, #0
 800bbea:	4770      	bx	lr
{
 800bbec:	b510      	push	{r4, lr}
 800bbee:	460b      	mov	r3, r1
 800bbf0:	4604      	mov	r4, r0
		vOutputChar( ( char ) c, xTicksToWait );
 800bbf2:	2114      	movs	r1, #20
 800bbf4:	b2d8      	uxtb	r0, r3
 800bbf6:	f000 fca4 	bl	800c542 <vOutputChar>
		apStr->curLen++;
 800bbfa:	68e3      	ldr	r3, [r4, #12]
 800bbfc:	3301      	adds	r3, #1
 800bbfe:	60e3      	str	r3, [r4, #12]
		return pdTRUE;
 800bc00:	2001      	movs	r0, #1
 800bc02:	bd10      	pop	{r4, pc}
		*( apStr->str++ ) = c;
 800bc04:	1c5a      	adds	r2, r3, #1
 800bc06:	6002      	str	r2, [r0, #0]
 800bc08:	7019      	strb	r1, [r3, #0]
		apStr->curLen++;
 800bc0a:	68c3      	ldr	r3, [r0, #12]
 800bc0c:	3301      	adds	r3, #1
 800bc0e:	60c3      	str	r3, [r0, #12]
		return pdTRUE;
 800bc10:	2001      	movs	r0, #1
 800bc12:	4770      	bx	lr
		*( apStr->str++ ) = '\0';
 800bc14:	1c5a      	adds	r2, r3, #1
 800bc16:	6002      	str	r2, [r0, #0]
 800bc18:	2000      	movs	r0, #0
 800bc1a:	7018      	strb	r0, [r3, #0]
 800bc1c:	4770      	bx	lr
	...

0800bc20 <prints>:
	return iResult;
}
/*-----------------------------------------------------------*/

static BaseType_t prints(struct SStringBuf *apBuf, const char *apString )
{
 800bc20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bc24:	4604      	mov	r4, r0
 800bc26:	460e      	mov	r6, r1
	register int padchar = ' ';
	int i,len;

	if( apBuf->flags.width > 0 )
 800bc28:	6940      	ldr	r0, [r0, #20]
 800bc2a:	2800      	cmp	r0, #0
 800bc2c:	dd2b      	ble.n	800bc86 <prints+0x66>
	{
		register int len = 0;
		register const char *ptr;
		for( ptr = apString; *ptr; ++ptr )
 800bc2e:	780b      	ldrb	r3, [r1, #0]
 800bc30:	b32b      	cbz	r3, 800bc7e <prints+0x5e>
 800bc32:	460a      	mov	r2, r1
 800bc34:	2300      	movs	r3, #0
		{
			++len;
 800bc36:	3301      	adds	r3, #1
		for( ptr = apString; *ptr; ++ptr )
 800bc38:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800bc3c:	2900      	cmp	r1, #0
 800bc3e:	d1fa      	bne.n	800bc36 <prints+0x16>
		}

		if( len >= apBuf->flags.width )
 800bc40:	4298      	cmp	r0, r3
 800bc42:	dc1d      	bgt.n	800bc80 <prints+0x60>
		{
			apBuf->flags.width = 0;
 800bc44:	2300      	movs	r3, #0
 800bc46:	6163      	str	r3, [r4, #20]
		else
		{
			apBuf->flags.width -= len;
		}

		if( apBuf->flags.pad & PAD_ZERO )
 800bc48:	7f23      	ldrb	r3, [r4, #28]
 800bc4a:	f003 0302 	and.w	r3, r3, #2
		{
			padchar = '0';
 800bc4e:	2b00      	cmp	r3, #0
 800bc50:	bf0c      	ite	eq
 800bc52:	2520      	moveq	r5, #32
 800bc54:	2530      	movne	r5, #48	; 0x30
		}
	}
	if( ( apBuf->flags.pad & PAD_RIGHT ) == 0 )
 800bc56:	7f23      	ldrb	r3, [r4, #28]
 800bc58:	f013 0f01 	tst.w	r3, #1
 800bc5c:	d114      	bne.n	800bc88 <prints+0x68>
	{
		for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800bc5e:	6963      	ldr	r3, [r4, #20]
 800bc60:	2b00      	cmp	r3, #0
 800bc62:	dd11      	ble.n	800bc88 <prints+0x68>
		{
			if( strbuf_printchar( apBuf, padchar ) == 0 )
 800bc64:	4629      	mov	r1, r5
 800bc66:	4620      	mov	r0, r4
 800bc68:	f7ff ffb7 	bl	800bbda <strbuf_printchar>
 800bc6c:	4603      	mov	r3, r0
 800bc6e:	2800      	cmp	r0, #0
 800bc70:	d032      	beq.n	800bcd8 <prints+0xb8>
		for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800bc72:	6963      	ldr	r3, [r4, #20]
 800bc74:	3b01      	subs	r3, #1
 800bc76:	6163      	str	r3, [r4, #20]
 800bc78:	2b00      	cmp	r3, #0
 800bc7a:	dcf3      	bgt.n	800bc64 <prints+0x44>
 800bc7c:	e004      	b.n	800bc88 <prints+0x68>
		for( ptr = apString; *ptr; ++ptr )
 800bc7e:	2300      	movs	r3, #0
			apBuf->flags.width -= len;
 800bc80:	1ac3      	subs	r3, r0, r3
 800bc82:	6163      	str	r3, [r4, #20]
 800bc84:	e7e0      	b.n	800bc48 <prints+0x28>
	register int padchar = ' ';
 800bc86:	2520      	movs	r5, #32
			{
				return pdFALSE;
			}
		}
	}
	if( ( apBuf->flags.isNumber == pdTRUE ) && ( apBuf->flags.pad == pdTRUE ) )
 800bc88:	69e3      	ldr	r3, [r4, #28]
 800bc8a:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 800bc8e:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 800bc92:	4a1e      	ldr	r2, [pc, #120]	; (800bd0c <prints+0xec>)
 800bc94:	4293      	cmp	r3, r2
 800bc96:	d022      	beq.n	800bcde <prints+0xbe>
		}
	}
	/* The string to print is not the result of a number conversion to ascii.
	 * For a string, printLimit is the max number of characters to display
	 */
	for( ; apBuf->flags.printLimit && *apString ; ++apString, --apBuf->flags.printLimit )
 800bc98:	69a3      	ldr	r3, [r4, #24]
 800bc9a:	b173      	cbz	r3, 800bcba <prints+0x9a>
 800bc9c:	7831      	ldrb	r1, [r6, #0]
 800bc9e:	b161      	cbz	r1, 800bcba <prints+0x9a>
	{
		if( !strbuf_printchar( apBuf, *apString ) )
 800bca0:	4620      	mov	r0, r4
 800bca2:	f7ff ff9a 	bl	800bbda <strbuf_printchar>
 800bca6:	4603      	mov	r3, r0
 800bca8:	b1b0      	cbz	r0, 800bcd8 <prints+0xb8>
	for( ; apBuf->flags.printLimit && *apString ; ++apString, --apBuf->flags.printLimit )
 800bcaa:	69a3      	ldr	r3, [r4, #24]
 800bcac:	3b01      	subs	r3, #1
 800bcae:	61a3      	str	r3, [r4, #24]
 800bcb0:	b11b      	cbz	r3, 800bcba <prints+0x9a>
 800bcb2:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800bcb6:	2900      	cmp	r1, #0
 800bcb8:	d1f2      	bne.n	800bca0 <prints+0x80>
		{
			return pdFALSE;
		}
	}

	for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800bcba:	6963      	ldr	r3, [r4, #20]
 800bcbc:	2b00      	cmp	r3, #0
 800bcbe:	dd22      	ble.n	800bd06 <prints+0xe6>
	{
		if( !strbuf_printchar( apBuf, padchar ) )
 800bcc0:	4629      	mov	r1, r5
 800bcc2:	4620      	mov	r0, r4
 800bcc4:	f7ff ff89 	bl	800bbda <strbuf_printchar>
 800bcc8:	4603      	mov	r3, r0
 800bcca:	b128      	cbz	r0, 800bcd8 <prints+0xb8>
	for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800bccc:	6963      	ldr	r3, [r4, #20]
 800bcce:	3b01      	subs	r3, #1
 800bcd0:	6163      	str	r3, [r4, #20]
 800bcd2:	2b00      	cmp	r3, #0
 800bcd4:	dcf4      	bgt.n	800bcc0 <prints+0xa0>
		{
			return pdFALSE;
		}
	}

	return pdTRUE;
 800bcd6:	2301      	movs	r3, #1
}
 800bcd8:	4618      	mov	r0, r3
 800bcda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		len = strlen( apString );
 800bcde:	4630      	mov	r0, r6
 800bce0:	f7f4 fa76 	bl	80001d0 <strlen>
		if( len < apBuf->flags.printLimit )
 800bce4:	69a7      	ldr	r7, [r4, #24]
 800bce6:	42b8      	cmp	r0, r7
 800bce8:	dad6      	bge.n	800bc98 <prints+0x78>
			for( ; i; i-- )
 800bcea:	1a3f      	subs	r7, r7, r0
 800bcec:	d0d4      	beq.n	800bc98 <prints+0x78>
				if( strbuf_printchar( apBuf, '0' )  == 0 )
 800bcee:	f04f 0830 	mov.w	r8, #48	; 0x30
 800bcf2:	4641      	mov	r1, r8
 800bcf4:	4620      	mov	r0, r4
 800bcf6:	f7ff ff70 	bl	800bbda <strbuf_printchar>
 800bcfa:	4603      	mov	r3, r0
 800bcfc:	2800      	cmp	r0, #0
 800bcfe:	d0eb      	beq.n	800bcd8 <prints+0xb8>
			for( ; i; i-- )
 800bd00:	3f01      	subs	r7, #1
 800bd02:	d1f6      	bne.n	800bcf2 <prints+0xd2>
 800bd04:	e7c8      	b.n	800bc98 <prints+0x78>
	return pdTRUE;
 800bd06:	2301      	movs	r3, #1
 800bd08:	e7e6      	b.n	800bcd8 <prints+0xb8>
 800bd0a:	bf00      	nop
 800bd0c:	00020001 	.word	0x00020001

0800bd10 <printi>:
}
#endif	/* SPRINTF_LONG_LONG */
/*-----------------------------------------------------------*/

static BaseType_t printi( struct SStringBuf *apBuf, int i )
{
 800bd10:	b570      	push	{r4, r5, r6, lr}
 800bd12:	b084      	sub	sp, #16
 800bd14:	4605      	mov	r5, r0
	char print_buf[ PRINT_BUF_LEN ];
	register char *s;
	register int t, neg = 0;
	register unsigned int u = i;
	register unsigned base = apBuf->flags.base;
 800bd16:	6902      	ldr	r2, [r0, #16]

	apBuf->flags.isNumber = pdTRUE;	/* Parameter for prints */
 800bd18:	7f84      	ldrb	r4, [r0, #30]
 800bd1a:	f044 0402 	orr.w	r4, r4, #2
 800bd1e:	7784      	strb	r4, [r0, #30]

	if( i == 0 )
 800bd20:	b199      	cbz	r1, 800bd4a <printi+0x3a>
 800bd22:	460b      	mov	r3, r1
 800bd24:	4610      	mov	r0, r2
		print_buf[ 0 ] = '0';
		print_buf[ 1 ] = '\0';
		return prints( apBuf, print_buf );
	}

	if( ( apBuf->flags.isSigned == pdTRUE ) && ( base == 10 ) && ( i < 0 ) )
 800bd26:	7fac      	ldrb	r4, [r5, #30]
 800bd28:	f014 0f01 	tst.w	r4, #1
 800bd2c:	d001      	beq.n	800bd32 <printi+0x22>
 800bd2e:	2a0a      	cmp	r2, #10
 800bd30:	d016      	beq.n	800bd60 <printi+0x50>
		u = -i;
	}

	s = print_buf + sizeof( print_buf ) - 1;

	*s = '\0';
 800bd32:	2100      	movs	r1, #0
 800bd34:	f88d 100f 	strb.w	r1, [sp, #15]
	switch( base )
 800bd38:	2a0a      	cmp	r2, #10
 800bd3a:	d02b      	beq.n	800bd94 <printi+0x84>
 800bd3c:	2a10      	cmp	r2, #16
 800bd3e:	d022      	beq.n	800bd86 <printi+0x76>
 800bd40:	2a08      	cmp	r2, #8
 800bd42:	d027      	beq.n	800bd94 <printi+0x84>
	s = print_buf + sizeof( print_buf ) - 1;
 800bd44:	f10d 010f 	add.w	r1, sp, #15
 800bd48:	e03f      	b.n	800bdca <printi+0xba>
		print_buf[ 0 ] = '0';
 800bd4a:	2330      	movs	r3, #48	; 0x30
 800bd4c:	f88d 3004 	strb.w	r3, [sp, #4]
		print_buf[ 1 ] = '\0';
 800bd50:	2300      	movs	r3, #0
 800bd52:	f88d 3005 	strb.w	r3, [sp, #5]
		return prints( apBuf, print_buf );
 800bd56:	a901      	add	r1, sp, #4
 800bd58:	f7ff ff62 	bl	800bc20 <prints>
 800bd5c:	4603      	mov	r3, r0
 800bd5e:	e038      	b.n	800bdd2 <printi+0xc2>
	if( ( apBuf->flags.isSigned == pdTRUE ) && ( base == 10 ) && ( i < 0 ) )
 800bd60:	2900      	cmp	r1, #0
 800bd62:	dae6      	bge.n	800bd32 <printi+0x22>
		u = -i;
 800bd64:	424b      	negs	r3, r1
	*s = '\0';
 800bd66:	2100      	movs	r1, #0
 800bd68:	f88d 100f 	strb.w	r1, [sp, #15]
	switch( base )
 800bd6c:	2a0a      	cmp	r2, #10
 800bd6e:	d006      	beq.n	800bd7e <printi+0x6e>
 800bd70:	2a10      	cmp	r2, #16
 800bd72:	d006      	beq.n	800bd82 <printi+0x72>
 800bd74:	2a08      	cmp	r2, #8
	s = print_buf + sizeof( print_buf ) - 1;
 800bd76:	bf18      	it	ne
 800bd78:	f10d 040f 	addne.w	r4, sp, #15
	switch( base )
 800bd7c:	d11b      	bne.n	800bdb6 <printi+0xa6>
		neg = 1;
 800bd7e:	2601      	movs	r6, #1
 800bd80:	e009      	b.n	800bd96 <printi+0x86>
 800bd82:	2601      	movs	r6, #1
 800bd84:	e000      	b.n	800bd88 <printi+0x78>
	switch( base )
 800bd86:	2600      	movs	r6, #0
	{
	case 16:
		while( u != 0 )
 800bd88:	f10d 040f 	add.w	r4, sp, #15
 800bd8c:	b193      	cbz	r3, 800bdb4 <printi+0xa4>
 800bd8e:	f10d 040f 	add.w	r4, sp, #15
 800bd92:	e026      	b.n	800bde2 <printi+0xd2>
	switch( base )
 800bd94:	2600      	movs	r6, #0
		break;

	case 8:
	case 10:
		/* GCC compiles very efficient */
		while( u )
 800bd96:	f10d 040f 	add.w	r4, sp, #15
 800bd9a:	b15b      	cbz	r3, 800bdb4 <printi+0xa4>
 800bd9c:	f10d 040f 	add.w	r4, sp, #15
		{
			t = u % base;
 800bda0:	fbb3 f2f0 	udiv	r2, r3, r0
 800bda4:	fb00 3312 	mls	r3, r0, r2, r3
			*( --s ) = t + '0';
 800bda8:	3330      	adds	r3, #48	; 0x30
 800bdaa:	f804 3d01 	strb.w	r3, [r4, #-1]!
			u /= base;
 800bdae:	4613      	mov	r3, r2
		while( u )
 800bdb0:	2a00      	cmp	r2, #0
 800bdb2:	d1f5      	bne.n	800bda0 <printi+0x90>
		}
		break;
*/
	}

	if( neg != 0 )
 800bdb4:	b34e      	cbz	r6, 800be0a <printi+0xfa>
	{
		if( apBuf->flags.width && (apBuf->flags.pad & PAD_ZERO ) )
 800bdb6:	696b      	ldr	r3, [r5, #20]
 800bdb8:	b11b      	cbz	r3, 800bdc2 <printi+0xb2>
 800bdba:	7f2b      	ldrb	r3, [r5, #28]
 800bdbc:	f013 0f02 	tst.w	r3, #2
 800bdc0:	d117      	bne.n	800bdf2 <printi+0xe2>
			}
			--apBuf->flags.width;
		}
		else
		{
			*( --s ) = '-';
 800bdc2:	1e61      	subs	r1, r4, #1
 800bdc4:	232d      	movs	r3, #45	; 0x2d
 800bdc6:	f804 3c01 	strb.w	r3, [r4, #-1]
		}
	}

	return prints( apBuf, s );
 800bdca:	4628      	mov	r0, r5
 800bdcc:	f7ff ff28 	bl	800bc20 <prints>
 800bdd0:	4603      	mov	r3, r0
}
 800bdd2:	4618      	mov	r0, r3
 800bdd4:	b004      	add	sp, #16
 800bdd6:	bd70      	pop	{r4, r5, r6, pc}
			*( --s ) = t + '0';
 800bdd8:	3230      	adds	r2, #48	; 0x30
 800bdda:	f804 2d01 	strb.w	r2, [r4, #-1]!
		while( u != 0 )
 800bdde:	091b      	lsrs	r3, r3, #4
 800bde0:	d0e8      	beq.n	800bdb4 <printi+0xa4>
			t = u & 0xF;
 800bde2:	f003 020f 	and.w	r2, r3, #15
			if( t >= 10 )
 800bde6:	2a09      	cmp	r2, #9
 800bde8:	ddf6      	ble.n	800bdd8 <printi+0xc8>
				t += apBuf->flags.letBase - '0' - 10;
 800bdea:	7f69      	ldrb	r1, [r5, #29]
 800bdec:	393a      	subs	r1, #58	; 0x3a
 800bdee:	440a      	add	r2, r1
 800bdf0:	e7f2      	b.n	800bdd8 <printi+0xc8>
			if( strbuf_printchar( apBuf, '-' ) == 0 )
 800bdf2:	212d      	movs	r1, #45	; 0x2d
 800bdf4:	4628      	mov	r0, r5
 800bdf6:	f7ff fef0 	bl	800bbda <strbuf_printchar>
 800bdfa:	4603      	mov	r3, r0
 800bdfc:	2800      	cmp	r0, #0
 800bdfe:	d0e8      	beq.n	800bdd2 <printi+0xc2>
			--apBuf->flags.width;
 800be00:	696b      	ldr	r3, [r5, #20]
 800be02:	3b01      	subs	r3, #1
 800be04:	616b      	str	r3, [r5, #20]
 800be06:	4621      	mov	r1, r4
 800be08:	e7df      	b.n	800bdca <printi+0xba>
 800be0a:	4621      	mov	r1, r4
 800be0c:	e7dd      	b.n	800bdca <printi+0xba>

0800be0e <sprintf>:
	return strBuf.curLen;
}
/*-----------------------------------------------------------*/

int sprintf( char *apBuf, const char *apFmt, ... )
{
 800be0e:	b40e      	push	{r1, r2, r3}
 800be10:	b510      	push	{r4, lr}
 800be12:	b08b      	sub	sp, #44	; 0x2c
 800be14:	4601      	mov	r1, r0
 800be16:	ab0d      	add	r3, sp, #52	; 0x34
 800be18:	f853 4b04 	ldr.w	r4, [r3], #4
	va_list args;

	va_start( args,  apFmt );
 800be1c:	9309      	str	r3, [sp, #36]	; 0x24
	struct SStringBuf strBuf;
	strbuf_init( &strBuf, apBuf, ( const char * )apBuf + 1024 );
 800be1e:	f500 6280 	add.w	r2, r0, #1024	; 0x400
 800be22:	a801      	add	r0, sp, #4
 800be24:	f7ff fece 	bl	800bbc4 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800be28:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800be2a:	4621      	mov	r1, r4
 800be2c:	a801      	add	r0, sp, #4
 800be2e:	f000 f807 	bl	800be40 <tiny_print>
	va_end( args );

	return strBuf.curLen;
}
 800be32:	9804      	ldr	r0, [sp, #16]
 800be34:	b00b      	add	sp, #44	; 0x2c
 800be36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800be3a:	b003      	add	sp, #12
 800be3c:	4770      	bx	lr
	...

0800be40 <tiny_print>:
{
 800be40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800be44:	b087      	sub	sp, #28
 800be46:	4604      	mov	r4, r0
 800be48:	468a      	mov	sl, r1
 800be4a:	4616      	mov	r6, r2
		vOutputChar( ( char ) c, xTicksToWait );
 800be4c:	f04f 0b14 	mov.w	fp, #20
	sprintf( print_buf, "%u.%u.%u.%u",
 800be50:	f8df 9244 	ldr.w	r9, [pc, #580]	; 800c098 <tiny_print+0x258>
			if( prints( apBuf, s ? s : "(null)" ) == 0 )
 800be54:	f8df 8244 	ldr.w	r8, [pc, #580]	; 800c09c <tiny_print+0x25c>
		int ch = *( format++ );
 800be58:	f10a 0501 	add.w	r5, sl, #1
 800be5c:	f89a 7000 	ldrb.w	r7, [sl]
		if( ch != '%' )
 800be60:	2f25      	cmp	r7, #37	; 0x25
 800be62:	d163      	bne.n	800bf2c <tiny_print+0xec>
		ch = *( format++ );
 800be64:	f105 0a01 	add.w	sl, r5, #1
 800be68:	782b      	ldrb	r3, [r5, #0]
		if( ch == '\0' )
 800be6a:	2b00      	cmp	r3, #0
 800be6c:	f000 810e 	beq.w	800c08c <tiny_print+0x24c>
		if( ch == '%' )
 800be70:	2b25      	cmp	r3, #37	; 0x25
 800be72:	d073      	beq.n	800bf5c <tiny_print+0x11c>
		memset( &apBuf->flags, '\0', sizeof( apBuf->flags ) );
 800be74:	2100      	movs	r1, #0
 800be76:	6121      	str	r1, [r4, #16]
 800be78:	6161      	str	r1, [r4, #20]
 800be7a:	61a1      	str	r1, [r4, #24]
 800be7c:	61e1      	str	r1, [r4, #28]
		if( ch == '-' )
 800be7e:	2b2d      	cmp	r3, #45	; 0x2d
 800be80:	d073      	beq.n	800bf6a <tiny_print+0x12a>
		while( ch == '0' )
 800be82:	2b30      	cmp	r3, #48	; 0x30
 800be84:	d107      	bne.n	800be96 <tiny_print+0x56>
			ch = *( format++ );
 800be86:	f81a 3b01 	ldrb.w	r3, [sl], #1
			apBuf->flags.pad |= PAD_ZERO;
 800be8a:	7f22      	ldrb	r2, [r4, #28]
 800be8c:	f042 0202 	orr.w	r2, r2, #2
 800be90:	7722      	strb	r2, [r4, #28]
		while( ch == '0' )
 800be92:	2b30      	cmp	r3, #48	; 0x30
 800be94:	d0f7      	beq.n	800be86 <tiny_print+0x46>
		if( ch == '*' )
 800be96:	2b2a      	cmp	r3, #42	; 0x2a
 800be98:	d06d      	beq.n	800bf76 <tiny_print+0x136>
			while( ch >= '0' && ch <= '9' )
 800be9a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800be9e:	2a09      	cmp	r2, #9
 800bea0:	d80c      	bhi.n	800bebc <tiny_print+0x7c>
				apBuf->flags.width *= 10;
 800bea2:	6962      	ldr	r2, [r4, #20]
 800bea4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
				apBuf->flags.width += ch - '0';
 800bea8:	3b30      	subs	r3, #48	; 0x30
 800beaa:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 800beae:	6162      	str	r2, [r4, #20]
				ch = *( format++ );
 800beb0:	f81a 3b01 	ldrb.w	r3, [sl], #1
			while( ch >= '0' && ch <= '9' )
 800beb4:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800beb8:	2a09      	cmp	r2, #9
 800beba:	d9f2      	bls.n	800bea2 <tiny_print+0x62>
		if( ch == '.' )
 800bebc:	2b2e      	cmp	r3, #46	; 0x2e
 800bebe:	d062      	beq.n	800bf86 <tiny_print+0x146>
		if( apBuf->flags.printLimit == 0 )
 800bec0:	69a2      	ldr	r2, [r4, #24]
 800bec2:	b912      	cbnz	r2, 800beca <tiny_print+0x8a>
			apBuf->flags.printLimit--;  /* -1: make it unlimited */
 800bec4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800bec8:	61a2      	str	r2, [r4, #24]
		if( ch == 's' )
 800beca:	2b73      	cmp	r3, #115	; 0x73
 800becc:	d07e      	beq.n	800bfcc <tiny_print+0x18c>
		if( ch == 'c' )
 800bece:	2b63      	cmp	r3, #99	; 0x63
 800bed0:	f000 8087 	beq.w	800bfe2 <tiny_print+0x1a2>
		if( ch == 'l' )
 800bed4:	2b6c      	cmp	r3, #108	; 0x6c
 800bed6:	f000 808c 	beq.w	800bff2 <tiny_print+0x1b2>
		if( ch == 'L' )
 800beda:	2b4c      	cmp	r3, #76	; 0x4c
 800bedc:	f000 8092 	beq.w	800c004 <tiny_print+0x1c4>
		apBuf->flags.base = 10;
 800bee0:	220a      	movs	r2, #10
 800bee2:	6122      	str	r2, [r4, #16]
		apBuf->flags.letBase = 'a';
 800bee4:	2261      	movs	r2, #97	; 0x61
 800bee6:	7762      	strb	r2, [r4, #29]
		if( ch == 'd' || ch == 'u' )
 800bee8:	2b64      	cmp	r3, #100	; 0x64
 800beea:	f000 8094 	beq.w	800c016 <tiny_print+0x1d6>
 800beee:	2b75      	cmp	r3, #117	; 0x75
 800bef0:	f000 8091 	beq.w	800c016 <tiny_print+0x1d6>
		apBuf->flags.base = 16;		/* From here all hexadecimal */
 800bef4:	2210      	movs	r2, #16
 800bef6:	6122      	str	r2, [r4, #16]
		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800bef8:	2b78      	cmp	r3, #120	; 0x78
 800befa:	f000 809b 	beq.w	800c034 <tiny_print+0x1f4>
		if( ch == 'x' || ch == 'X' || ch == 'p' || ch == 'o' )
 800befe:	2b58      	cmp	r3, #88	; 0x58
 800bf00:	f000 80c1 	beq.w	800c086 <tiny_print+0x246>
 800bf04:	2b70      	cmp	r3, #112	; 0x70
 800bf06:	f000 8099 	beq.w	800c03c <tiny_print+0x1fc>
 800bf0a:	2b6f      	cmp	r3, #111	; 0x6f
 800bf0c:	d1a4      	bne.n	800be58 <tiny_print+0x18>
				apBuf->flags.base = 8;
 800bf0e:	2308      	movs	r3, #8
 800bf10:	6123      	str	r3, [r4, #16]
 800bf12:	e093      	b.n	800c03c <tiny_print+0x1fc>
		vOutputChar( ( char ) c, xTicksToWait );
 800bf14:	4659      	mov	r1, fp
 800bf16:	4638      	mov	r0, r7
 800bf18:	f000 fb13 	bl	800c542 <vOutputChar>
		if( c == 0 )
 800bf1c:	b1b7      	cbz	r7, 800bf4c <tiny_print+0x10c>
		apStr->curLen++;
 800bf1e:	68e3      	ldr	r3, [r4, #12]
 800bf20:	3301      	adds	r3, #1
 800bf22:	60e3      	str	r3, [r4, #12]
				ch = *( format++ );
 800bf24:	f815 7b01 	ldrb.w	r7, [r5], #1
			} while( ch != '%' );
 800bf28:	2f25      	cmp	r7, #37	; 0x25
 800bf2a:	d09b      	beq.n	800be64 <tiny_print+0x24>
	if( apStr->str == NULL )
 800bf2c:	6823      	ldr	r3, [r4, #0]
 800bf2e:	2b00      	cmp	r3, #0
 800bf30:	d0f0      	beq.n	800bf14 <tiny_print+0xd4>
	if( apStr->str < apStr->nulPos )
 800bf32:	68a2      	ldr	r2, [r4, #8]
 800bf34:	4293      	cmp	r3, r2
 800bf36:	d207      	bcs.n	800bf48 <tiny_print+0x108>
		*(apStr->str++) = c;
 800bf38:	1c5a      	adds	r2, r3, #1
 800bf3a:	6022      	str	r2, [r4, #0]
 800bf3c:	701f      	strb	r7, [r3, #0]
		if( c == 0 )
 800bf3e:	b12f      	cbz	r7, 800bf4c <tiny_print+0x10c>
		apStr->curLen++;
 800bf40:	68e3      	ldr	r3, [r4, #12]
 800bf42:	3301      	adds	r3, #1
 800bf44:	60e3      	str	r3, [r4, #12]
 800bf46:	e7ed      	b.n	800bf24 <tiny_print+0xe4>
	if( apStr->str == apStr->nulPos )
 800bf48:	4293      	cmp	r3, r2
 800bf4a:	d002      	beq.n	800bf52 <tiny_print+0x112>
}
 800bf4c:	b007      	add	sp, #28
 800bf4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*( apStr->str++ ) = '\0';
 800bf52:	1c53      	adds	r3, r2, #1
 800bf54:	6023      	str	r3, [r4, #0]
 800bf56:	2300      	movs	r3, #0
 800bf58:	7013      	strb	r3, [r2, #0]
 800bf5a:	e7f7      	b.n	800bf4c <tiny_print+0x10c>
			if( strbuf_printchar( apBuf, ch ) == 0 )
 800bf5c:	2125      	movs	r1, #37	; 0x25
 800bf5e:	4620      	mov	r0, r4
 800bf60:	f7ff fe3b 	bl	800bbda <strbuf_printchar>
 800bf64:	2800      	cmp	r0, #0
 800bf66:	d0f1      	beq.n	800bf4c <tiny_print+0x10c>
 800bf68:	e776      	b.n	800be58 <tiny_print+0x18>
			ch = *( format++ );
 800bf6a:	f105 0a02 	add.w	sl, r5, #2
 800bf6e:	786b      	ldrb	r3, [r5, #1]
			apBuf->flags.pad = PAD_RIGHT;
 800bf70:	2201      	movs	r2, #1
 800bf72:	7722      	strb	r2, [r4, #28]
 800bf74:	e785      	b.n	800be82 <tiny_print+0x42>
			ch = *( format++ );
 800bf76:	f89a 3000 	ldrb.w	r3, [sl]
			apBuf->flags.width = va_arg( args, int );
 800bf7a:	6832      	ldr	r2, [r6, #0]
 800bf7c:	6162      	str	r2, [r4, #20]
 800bf7e:	3604      	adds	r6, #4
			ch = *( format++ );
 800bf80:	f10a 0a01 	add.w	sl, sl, #1
 800bf84:	e79a      	b.n	800bebc <tiny_print+0x7c>
			ch = *( format++ );
 800bf86:	f10a 0101 	add.w	r1, sl, #1
 800bf8a:	f89a 2000 	ldrb.w	r2, [sl]
 800bf8e:	4613      	mov	r3, r2
			if( ch == '*' )
 800bf90:	2a2a      	cmp	r2, #42	; 0x2a
 800bf92:	d013      	beq.n	800bfbc <tiny_print+0x17c>
				while( ch >= '0' && ch <= '9' )
 800bf94:	3a30      	subs	r2, #48	; 0x30
 800bf96:	2a09      	cmp	r2, #9
 800bf98:	bf88      	it	hi
 800bf9a:	468a      	movhi	sl, r1
 800bf9c:	d890      	bhi.n	800bec0 <tiny_print+0x80>
					apBuf->flags.printLimit *= 10;
 800bf9e:	69a2      	ldr	r2, [r4, #24]
 800bfa0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
					apBuf->flags.printLimit += ch - '0';
 800bfa4:	3b30      	subs	r3, #48	; 0x30
 800bfa6:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 800bfaa:	61a2      	str	r2, [r4, #24]
					ch = *( format++ );
 800bfac:	f811 3b01 	ldrb.w	r3, [r1], #1
				while( ch >= '0' && ch <= '9' )
 800bfb0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800bfb4:	2a09      	cmp	r2, #9
 800bfb6:	d9f2      	bls.n	800bf9e <tiny_print+0x15e>
					ch = *( format++ );
 800bfb8:	468a      	mov	sl, r1
 800bfba:	e781      	b.n	800bec0 <tiny_print+0x80>
				apBuf->flags.printLimit = va_arg( args, int );
 800bfbc:	6833      	ldr	r3, [r6, #0]
 800bfbe:	61a3      	str	r3, [r4, #24]
				ch = *( format++ );
 800bfc0:	f89a 3001 	ldrb.w	r3, [sl, #1]
				apBuf->flags.printLimit = va_arg( args, int );
 800bfc4:	3604      	adds	r6, #4
				ch = *( format++ );
 800bfc6:	f10a 0a02 	add.w	sl, sl, #2
 800bfca:	e779      	b.n	800bec0 <tiny_print+0x80>
			register char *s = ( char * )va_arg( args, int );
 800bfcc:	6831      	ldr	r1, [r6, #0]
			if( prints( apBuf, s ? s : "(null)" ) == 0 )
 800bfce:	2900      	cmp	r1, #0
 800bfd0:	bf08      	it	eq
 800bfd2:	4641      	moveq	r1, r8
 800bfd4:	4620      	mov	r0, r4
 800bfd6:	f7ff fe23 	bl	800bc20 <prints>
 800bfda:	2800      	cmp	r0, #0
 800bfdc:	d056      	beq.n	800c08c <tiny_print+0x24c>
			register char *s = ( char * )va_arg( args, int );
 800bfde:	3604      	adds	r6, #4
 800bfe0:	e73a      	b.n	800be58 <tiny_print+0x18>
			if( strbuf_printchar( apBuf, scr[0] )  == 0 )
 800bfe2:	7831      	ldrb	r1, [r6, #0]
 800bfe4:	4620      	mov	r0, r4
 800bfe6:	f7ff fdf8 	bl	800bbda <strbuf_printchar>
 800bfea:	2800      	cmp	r0, #0
 800bfec:	d0ae      	beq.n	800bf4c <tiny_print+0x10c>
			scr[0] = ( char ) va_arg( args, int );
 800bfee:	3604      	adds	r6, #4
 800bff0:	e732      	b.n	800be58 <tiny_print+0x18>
			ch = *( format++ );
 800bff2:	f89a 3000 	ldrb.w	r3, [sl]
			apBuf->flags.long32 = 1;
 800bff6:	7fa2      	ldrb	r2, [r4, #30]
 800bff8:	f042 0204 	orr.w	r2, r2, #4
 800bffc:	77a2      	strb	r2, [r4, #30]
			ch = *( format++ );
 800bffe:	f10a 0a01 	add.w	sl, sl, #1
 800c002:	e76a      	b.n	800beda <tiny_print+0x9a>
			ch = *( format++ );
 800c004:	f89a 3000 	ldrb.w	r3, [sl]
			apBuf->flags.long64 = 1;
 800c008:	7fa2      	ldrb	r2, [r4, #30]
 800c00a:	f042 0208 	orr.w	r2, r2, #8
 800c00e:	77a2      	strb	r2, [r4, #30]
			ch = *( format++ );
 800c010:	f10a 0a01 	add.w	sl, sl, #1
 800c014:	e764      	b.n	800bee0 <tiny_print+0xa0>
			apBuf->flags.isSigned = ( ch == 'd' );
 800c016:	2b64      	cmp	r3, #100	; 0x64
 800c018:	bf14      	ite	ne
 800c01a:	2300      	movne	r3, #0
 800c01c:	2301      	moveq	r3, #1
 800c01e:	7fa2      	ldrb	r2, [r4, #30]
 800c020:	f363 0200 	bfi	r2, r3, #0, #1
 800c024:	77a2      	strb	r2, [r4, #30]
			if( printi( apBuf, va_arg( args, int ) ) == 0 )
 800c026:	6831      	ldr	r1, [r6, #0]
 800c028:	4620      	mov	r0, r4
 800c02a:	f7ff fe71 	bl	800bd10 <printi>
 800c02e:	b368      	cbz	r0, 800c08c <tiny_print+0x24c>
 800c030:	3604      	adds	r6, #4
 800c032:	e711      	b.n	800be58 <tiny_print+0x18>
		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800c034:	f89a 3000 	ldrb.w	r3, [sl]
 800c038:	2b69      	cmp	r3, #105	; 0x69
 800c03a:	d006      	beq.n	800c04a <tiny_print+0x20a>
			if( printi( apBuf, va_arg( args, int ) ) == 0 )
 800c03c:	6831      	ldr	r1, [r6, #0]
 800c03e:	4620      	mov	r0, r4
 800c040:	f7ff fe66 	bl	800bd10 <printi>
 800c044:	b310      	cbz	r0, 800c08c <tiny_print+0x24c>
 800c046:	3604      	adds	r6, #4
 800c048:	e706      	b.n	800be58 <tiny_print+0x18>
		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800c04a:	f89a 3001 	ldrb.w	r3, [sl, #1]
 800c04e:	2b70      	cmp	r3, #112	; 0x70
 800c050:	d1f4      	bne.n	800c03c <tiny_print+0x1fc>
			format += 2;	/* eat the "xi" of "xip" */
 800c052:	f10a 0a02 	add.w	sl, sl, #2
			if( printIp( apBuf, va_arg( args, int ) ) == 0 )
 800c056:	1d35      	adds	r5, r6, #4
 800c058:	6832      	ldr	r2, [r6, #0]
	sprintf( print_buf, "%u.%u.%u.%u",
 800c05a:	b2d3      	uxtb	r3, r2
 800c05c:	9301      	str	r3, [sp, #4]
 800c05e:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800c062:	9300      	str	r3, [sp, #0]
 800c064:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800c068:	0e12      	lsrs	r2, r2, #24
 800c06a:	4649      	mov	r1, r9
 800c06c:	a802      	add	r0, sp, #8
 800c06e:	f7ff fece 	bl	800be0e <sprintf>
	apBuf->flags.isNumber = pdTRUE;	/* Parameter for prints */
 800c072:	7fa3      	ldrb	r3, [r4, #30]
 800c074:	f043 0302 	orr.w	r3, r3, #2
 800c078:	77a3      	strb	r3, [r4, #30]
	prints( apBuf, print_buf );
 800c07a:	a902      	add	r1, sp, #8
 800c07c:	4620      	mov	r0, r4
 800c07e:	f7ff fdcf 	bl	800bc20 <prints>
			if( printIp( apBuf, va_arg( args, int ) ) == 0 )
 800c082:	462e      	mov	r6, r5
			continue;
 800c084:	e6e8      	b.n	800be58 <tiny_print+0x18>
				apBuf->flags.letBase = 'A';
 800c086:	2341      	movs	r3, #65	; 0x41
 800c088:	7763      	strb	r3, [r4, #29]
 800c08a:	e7d7      	b.n	800c03c <tiny_print+0x1fc>
	strbuf_printchar( apBuf, '\0' );
 800c08c:	2100      	movs	r1, #0
 800c08e:	4620      	mov	r0, r4
 800c090:	f7ff fda3 	bl	800bbda <strbuf_printchar>
 800c094:	e75a      	b.n	800bf4c <tiny_print+0x10c>
 800c096:	bf00      	nop
 800c098:	0800d5c4 	.word	0x0800d5c4
 800c09c:	0800dca8 	.word	0x0800dca8

0800c0a0 <vsnprintf>:
{
 800c0a0:	b530      	push	{r4, r5, lr}
 800c0a2:	b089      	sub	sp, #36	; 0x24
 800c0a4:	4614      	mov	r4, r2
 800c0a6:	461d      	mov	r5, r3
	strbuf_init( &strBuf, apBuf, ( const char* )apBuf + aMaxLen );
 800c0a8:	1842      	adds	r2, r0, r1
 800c0aa:	4601      	mov	r1, r0
 800c0ac:	4668      	mov	r0, sp
 800c0ae:	f7ff fd89 	bl	800bbc4 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800c0b2:	462a      	mov	r2, r5
 800c0b4:	4621      	mov	r1, r4
 800c0b6:	4668      	mov	r0, sp
 800c0b8:	f7ff fec2 	bl	800be40 <tiny_print>
}
 800c0bc:	9803      	ldr	r0, [sp, #12]
 800c0be:	b009      	add	sp, #36	; 0x24
 800c0c0:	bd30      	pop	{r4, r5, pc}

0800c0c2 <snprintf>:
{
 800c0c2:	b40c      	push	{r2, r3}
 800c0c4:	b510      	push	{r4, lr}
 800c0c6:	b08a      	sub	sp, #40	; 0x28
 800c0c8:	ab0c      	add	r3, sp, #48	; 0x30
 800c0ca:	f853 4b04 	ldr.w	r4, [r3], #4
	va_start( args,  apFmt );
 800c0ce:	9309      	str	r3, [sp, #36]	; 0x24
	strbuf_init( &strBuf, apBuf, ( const char* )apBuf + aMaxLen );
 800c0d0:	1842      	adds	r2, r0, r1
 800c0d2:	4601      	mov	r1, r0
 800c0d4:	a801      	add	r0, sp, #4
 800c0d6:	f7ff fd75 	bl	800bbc4 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800c0da:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c0dc:	4621      	mov	r1, r4
 800c0de:	a801      	add	r0, sp, #4
 800c0e0:	f7ff feae 	bl	800be40 <tiny_print>
}
 800c0e4:	9804      	ldr	r0, [sp, #16]
 800c0e6:	b00a      	add	sp, #40	; 0x28
 800c0e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800c0ec:	b002      	add	sp, #8
 800c0ee:	4770      	bx	lr

0800c0f0 <TIM2_IRQHandler>:
static uint32_t ulInterruptCount = 0;

uint32_t ulTimer2Flags;
void TIM2_IRQHandler(void)
{
	ulTimer2Flags = tim2_handle.Instance->SR;
 800c0f0:	4b07      	ldr	r3, [pc, #28]	; (800c110 <TIM2_IRQHandler+0x20>)
 800c0f2:	681a      	ldr	r2, [r3, #0]
 800c0f4:	6913      	ldr	r3, [r2, #16]
 800c0f6:	4907      	ldr	r1, [pc, #28]	; (800c114 <TIM2_IRQHandler+0x24>)
 800c0f8:	600b      	str	r3, [r1, #0]
	if( ( ulTimer2Flags & TIM_FLAG_UPDATE ) != 0 )
 800c0fa:	f013 0f01 	tst.w	r3, #1
 800c0fe:	d006      	beq.n	800c10e <TIM2_IRQHandler+0x1e>
	{
		__HAL_TIM_CLEAR_FLAG( &tim2_handle, TIM_FLAG_UPDATE );
 800c100:	f06f 0301 	mvn.w	r3, #1
 800c104:	6113      	str	r3, [r2, #16]
		ulInterruptCount++;
 800c106:	4a04      	ldr	r2, [pc, #16]	; (800c118 <TIM2_IRQHandler+0x28>)
 800c108:	6813      	ldr	r3, [r2, #0]
 800c10a:	3301      	adds	r3, #1
 800c10c:	6013      	str	r3, [r2, #0]
 800c10e:	4770      	bx	lr
 800c110:	20004d2c 	.word	0x20004d2c
 800c114:	20004d28 	.word	0x20004d28
 800c118:	20002828 	.word	0x20002828

0800c11c <vStartHighResolutionTimer>:
}


/* Timer2 initialization function */
void vStartHighResolutionTimer( void )
{
 800c11c:	b510      	push	{r4, lr}
	/* TIM2 clock enable */
	__HAL_RCC_TIM2_CLK_ENABLE();
 800c11e:	4a12      	ldr	r2, [pc, #72]	; (800c168 <vStartHighResolutionTimer+0x4c>)
 800c120:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800c122:	f043 0301 	orr.w	r3, r3, #1
 800c126:	6413      	str	r3, [r2, #64]	; 0x40

	tim2_handle.Instance = TIM2;     /* Register base address             */
 800c128:	4c10      	ldr	r4, [pc, #64]	; (800c16c <vStartHighResolutionTimer+0x50>)
 800c12a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800c12e:	6023      	str	r3, [r4, #0]

	tim2_handle.Init.Prescaler = ( ulPrescale - 1ul );			/* Specifies the prescaler value used to divide the TIM clock. */
 800c130:	2353      	movs	r3, #83	; 0x53
 800c132:	6063      	str	r3, [r4, #4]
	tim2_handle.Init.CounterMode = TIM_COUNTERMODE_UP;			/* Specifies the counter mode. */
 800c134:	2200      	movs	r2, #0
 800c136:	60a2      	str	r2, [r4, #8]
	tim2_handle.Init.Period = ( ulReloadCount - 1ul );			/* Specifies the period value to be loaded into the active. */
 800c138:	4b0d      	ldr	r3, [pc, #52]	; (800c170 <vStartHighResolutionTimer+0x54>)
 800c13a:	60e3      	str	r3, [r4, #12]
	tim2_handle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;	/* Specifies the clock division. */
 800c13c:	6122      	str	r2, [r4, #16]
	tim2_handle.Init.RepetitionCounter = 0ul;					/* Specifies the repetition counter value. */
 800c13e:	6162      	str	r2, [r4, #20]
	tim2_handle.Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800c140:	2301      	movs	r3, #1
 800c142:	7623      	strb	r3, [r4, #24]

	/* NVIC configuration for DMA transfer complete interrupt */
	HAL_NVIC_SetPriority( TIM2_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 1, 0 );
 800c144:	2106      	movs	r1, #6
 800c146:	201c      	movs	r0, #28
 800c148:	f7f4 fa90 	bl	800066c <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ( TIM2_IRQn );
 800c14c:	201c      	movs	r0, #28
 800c14e:	f7f4 fabd 	bl	80006cc <HAL_NVIC_EnableIRQ>


	HAL_TIM_Base_Init( &tim2_handle );
 800c152:	4620      	mov	r0, r4
 800c154:	f7f6 feb4 	bl	8002ec0 <HAL_TIM_Base_Init>
	HAL_TIM_Base_Start_IT( &tim2_handle );
 800c158:	4620      	mov	r0, r4
 800c15a:	f7f6 fe3a 	bl	8002dd2 <HAL_TIM_Base_Start_IT>
	ulTimer2Flags = tim2_handle.Instance->SR;
 800c15e:	6823      	ldr	r3, [r4, #0]
 800c160:	691a      	ldr	r2, [r3, #16]
 800c162:	4b04      	ldr	r3, [pc, #16]	; (800c174 <vStartHighResolutionTimer+0x58>)
 800c164:	601a      	str	r2, [r3, #0]
 800c166:	bd10      	pop	{r4, pc}
 800c168:	40023800 	.word	0x40023800
 800c16c:	20004d2c 	.word	0x20004d2c
 800c170:	0098967f 	.word	0x0098967f
 800c174:	20004d28 	.word	0x20004d28

0800c178 <ullGetHighResolutionTime>:
}

uint64_t ullGetHighResolutionTime()
{
 800c178:	b538      	push	{r3, r4, r5, lr}
uint64_t ullReturn;
	if( tim2_handle.Instance == NULL )
 800c17a:	4b12      	ldr	r3, [pc, #72]	; (800c1c4 <ullGetHighResolutionTime+0x4c>)
 800c17c:	681b      	ldr	r3, [r3, #0]
 800c17e:	b153      	cbz	r3, 800c196 <ullGetHighResolutionTime+0x1e>
	uint32_t ulCounts[2];
	uint32_t ulSlowCount;

		for( ;; )
		{
			ulCounts[ 0 ] = tim2_handle.Instance->CNT;
 800c180:	6a5a      	ldr	r2, [r3, #36]	; 0x24
			ulSlowCount = ulInterruptCount;
			ulCounts[ 1 ] = tim2_handle.Instance->CNT;
 800c182:	6a58      	ldr	r0, [r3, #36]	; 0x24
			if( ulCounts[ 1 ] >= ulCounts[ 0 ] )
 800c184:	4282      	cmp	r2, r0
 800c186:	d8fb      	bhi.n	800c180 <ullGetHighResolutionTime+0x8>
			ulSlowCount = ulInterruptCount;
 800c188:	4b0f      	ldr	r3, [pc, #60]	; (800c1c8 <ullGetHighResolutionTime+0x50>)
			{
				/* TIM2_IRQHandler() has not occurred in between. */
				break;
			}
		}
		ullReturn = ( uint64_t )ulSlowCount * ulReloadCount + ulCounts[ 1 ];
 800c18a:	681a      	ldr	r2, [r3, #0]
 800c18c:	2100      	movs	r1, #0
 800c18e:	4b0f      	ldr	r3, [pc, #60]	; (800c1cc <ullGetHighResolutionTime+0x54>)
 800c190:	fbe3 0102 	umlal	r0, r1, r3, r2
	}

	return ullReturn;
}
 800c194:	bd38      	pop	{r3, r4, r5, pc}
		ullReturn = 1000ull * xTaskGetTickCount();
 800c196:	f7fd ff4b 	bl	800a030 <xTaskGetTickCount>
 800c19a:	4604      	mov	r4, r0
 800c19c:	2500      	movs	r5, #0
 800c19e:	0142      	lsls	r2, r0, #5
 800c1a0:	0ec3      	lsrs	r3, r0, #27
 800c1a2:	1a12      	subs	r2, r2, r0
 800c1a4:	eb63 0305 	sbc.w	r3, r3, r5
 800c1a8:	009b      	lsls	r3, r3, #2
 800c1aa:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
 800c1ae:	0092      	lsls	r2, r2, #2
 800c1b0:	1910      	adds	r0, r2, r4
 800c1b2:	eb43 0105 	adc.w	r1, r3, r5
 800c1b6:	00cb      	lsls	r3, r1, #3
 800c1b8:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 800c1bc:	00c2      	lsls	r2, r0, #3
 800c1be:	4610      	mov	r0, r2
 800c1c0:	4619      	mov	r1, r3
 800c1c2:	bd38      	pop	{r3, r4, r5, pc}
 800c1c4:	20004d2c 	.word	0x20004d2c
 800c1c8:	20002828 	.word	0x20002828
 800c1cc:	00989680 	.word	0x00989680

0800c1d0 <main>:

/*-----------------------------------------------------------*/

/* See http://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_TCP/TCP-IP_FAT_Examples_ST_STM32F407.html */
int main( void )
{
 800c1d0:	b580      	push	{r7, lr}
 800c1d2:	b098      	sub	sp, #96	; 0x60
static void prvMiscInitialisation( void )
{
GPIO_InitTypeDef GPIO_InitStruct;

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	__asm volatile( "cpsid i" );
 800c1d4:	b672      	cpsid	i
	HAL_Init();
 800c1d6:	f7f4 fa01 	bl	80005dc <HAL_Init>
	__PWR_CLK_ENABLE();
 800c1da:	4d47      	ldr	r5, [pc, #284]	; (800c2f8 <main+0x128>)
 800c1dc:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800c1de:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c1e2:	642b      	str	r3, [r5, #64]	; 0x40
	__HAL_PWR_VOLTAGESCALING_CONFIG( PWR_REGULATOR_VOLTAGE_SCALE1 );
 800c1e4:	4a45      	ldr	r2, [pc, #276]	; (800c2fc <main+0x12c>)
 800c1e6:	6813      	ldr	r3, [r2, #0]
 800c1e8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800c1ec:	6013      	str	r3, [r2, #0]
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
 800c1ee:	2309      	movs	r3, #9
 800c1f0:	930c      	str	r3, [sp, #48]	; 0x30
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800c1f2:	2701      	movs	r7, #1
 800c1f4:	970d      	str	r7, [sp, #52]	; 0x34
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800c1f6:	9711      	str	r7, [sp, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800c1f8:	2602      	movs	r6, #2
 800c1fa:	9612      	str	r6, [sp, #72]	; 0x48
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800c1fc:	f44f 0880 	mov.w	r8, #4194304	; 0x400000
 800c200:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
	RCC_OscInitStruct.PLL.PLLM = 25;
 800c204:	2319      	movs	r3, #25
 800c206:	9314      	str	r3, [sp, #80]	; 0x50
	RCC_OscInitStruct.PLL.PLLN = 336;
 800c208:	f44f 73a8 	mov.w	r3, #336	; 0x150
 800c20c:	9315      	str	r3, [sp, #84]	; 0x54
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800c20e:	9616      	str	r6, [sp, #88]	; 0x58
	RCC_OscInitStruct.PLL.PLLQ = 7;
 800c210:	2307      	movs	r3, #7
 800c212:	9317      	str	r3, [sp, #92]	; 0x5c
	HAL_RCC_OscConfig( &RCC_OscInitStruct ); //初始化晶振
 800c214:	a80c      	add	r0, sp, #48	; 0x30
 800c216:	f7f6 f95f 	bl	80024d8 <HAL_RCC_OscConfig>
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800c21a:	230d      	movs	r3, #13
 800c21c:	9307      	str	r3, [sp, #28]
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800c21e:	9608      	str	r6, [sp, #32]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800c220:	2400      	movs	r4, #0
 800c222:	9409      	str	r4, [sp, #36]	; 0x24
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800c224:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800c228:	930a      	str	r3, [sp, #40]	; 0x28
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800c22a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c22e:	930b      	str	r3, [sp, #44]	; 0x2c
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);//Initializes the CPU, AHB and APB busses clocks
 800c230:	2105      	movs	r1, #5
 800c232:	a807      	add	r0, sp, #28
 800c234:	f7f6 fb1c 	bl	8002870 <HAL_RCC_ClockConfig>
	PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800c238:	9603      	str	r6, [sp, #12]
	PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 800c23a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c23e:	9306      	str	r3, [sp, #24]
	HAL_RCCEx_PeriphCLKConfig( &PeriphClkInitStruct );  //调用stm32库函数
 800c240:	a803      	add	r0, sp, #12
 800c242:	f7f6 fcc9 	bl	8002bd8 <HAL_RCCEx_PeriphCLKConfig>
	HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSE, RCC_MCODIV_1); //开发板这个引脚应该没有使用
 800c246:	4622      	mov	r2, r4
 800c248:	4641      	mov	r1, r8
 800c24a:	4620      	mov	r0, r4
 800c24c:	f7f6 fc28 	bl	8002aa0 <HAL_RCC_MCOConfig>

	/* Configure clocks. */
	prvConfigureClocks();

	/* 打开GPIO端口时钟，GPIO Ports Clock Enable */
	__GPIOD_CLK_ENABLE();
 800c250:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800c252:	f043 0308 	orr.w	r3, r3, #8
 800c256:	632b      	str	r3, [r5, #48]	; 0x30
	__GPIOE_CLK_ENABLE();
 800c258:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800c25a:	f043 0310 	orr.w	r3, r3, #16
 800c25e:	632b      	str	r3, [r5, #48]	; 0x30
	__GPIOF_CLK_ENABLE();
 800c260:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800c262:	f043 0320 	orr.w	r3, r3, #32
 800c266:	632b      	str	r3, [r5, #48]	; 0x30
	__GPIOH_CLK_ENABLE();
 800c268:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800c26a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c26e:	632b      	str	r3, [r5, #48]	; 0x30
	/* Configure GPIO pins : PE2 PE5 PE6 和JLink相关*/
	GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5|GPIO_PIN_6;
 800c270:	2364      	movs	r3, #100	; 0x64
 800c272:	930c      	str	r3, [sp, #48]	; 0x30
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c274:	960d      	str	r6, [sp, #52]	; 0x34
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c276:	940e      	str	r4, [sp, #56]	; 0x38
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800c278:	940f      	str	r4, [sp, #60]	; 0x3c
	GPIO_InitStruct.Alternate = GPIO_AF0_TRACE;
 800c27a:	9410      	str	r4, [sp, #64]	; 0x40
	HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800c27c:	a90c      	add	r1, sp, #48	; 0x30
 800c27e:	4820      	ldr	r0, [pc, #128]	; (800c300 <main+0x130>)
 800c280:	f7f6 f836 	bl	80022f0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PG12 PG8 PG6 (LED已经ok). */
	GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 800c284:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800c288:	930c      	str	r3, [sp, #48]	; 0x30
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800c28a:	970d      	str	r7, [sp, #52]	; 0x34
	GPIO_InitStruct.Pull = GPIO_PULLUP;
 800c28c:	970e      	str	r7, [sp, #56]	; 0x38
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800c28e:	940f      	str	r4, [sp, #60]	; 0x3c
	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 800c290:	a90c      	add	r1, sp, #48	; 0x30
 800c292:	481c      	ldr	r0, [pc, #112]	; (800c304 <main+0x134>)
 800c294:	f7f6 f82c 	bl	80022f0 <HAL_GPIO_Init>

	/*开发板上没有关于SD卡自动检测的引脚，Configure GPIO pin : PH13 (SD card detect) */
	GPIO_InitStruct.Pin = GPIO_PIN_13;
 800c298:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c29c:	930c      	str	r3, [sp, #48]	; 0x30
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800c29e:	940d      	str	r4, [sp, #52]	; 0x34
   //GPIO_InitStruct.Pull = GPIO_PULLUP;
	//检测引脚下拉，这样就会一直认为有sd卡
	GPIO_InitStruct.Pull =GPIO_PULLDOWN;
 800c2a0:	960e      	str	r6, [sp, #56]	; 0x38
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 800c2a2:	a90c      	add	r1, sp, #48	; 0x30
 800c2a4:	4818      	ldr	r0, [pc, #96]	; (800c308 <main+0x138>)
 800c2a6:	f7f6 f823 	bl	80022f0 <HAL_GPIO_Init>

	/* Heap_5 is used so the maximum heap size can be calculated and initialised
	at run time. */
	pucHeapStart = ( uint8_t * ) ( ( ( ( uint32_t ) &HEAP_START ) + 7 ) & ~0x07ul );

	ulHeapSize = ( uint32_t ) ( &HEAP_END - &HEAP_START );
 800c2aa:	4b18      	ldr	r3, [pc, #96]	; (800c30c <main+0x13c>)
 800c2ac:	4a18      	ldr	r2, [pc, #96]	; (800c310 <main+0x140>)
 800c2ae:	1ad2      	subs	r2, r2, r3
 800c2b0:	9203      	str	r2, [sp, #12]
	ulHeapSize &= ~0x07ul;
 800c2b2:	9a03      	ldr	r2, [sp, #12]
 800c2b4:	f022 0207 	bic.w	r2, r2, #7
 800c2b8:	9203      	str	r2, [sp, #12]
	ulHeapSize -= 1024;
 800c2ba:	9a03      	ldr	r2, [sp, #12]
 800c2bc:	f5a2 6280 	sub.w	r2, r2, #1024	; 0x400
 800c2c0:	9203      	str	r2, [sp, #12]
	pucHeapStart = ( uint8_t * ) ( ( ( ( uint32_t ) &HEAP_START ) + 7 ) & ~0x07ul );
 800c2c2:	3307      	adds	r3, #7
 800c2c4:	f023 0307 	bic.w	r3, r3, #7

	HeapRegion_t xHeapRegions[] =
 800c2c8:	9307      	str	r3, [sp, #28]
 800c2ca:	9b03      	ldr	r3, [sp, #12]
 800c2cc:	9308      	str	r3, [sp, #32]
 800c2ce:	9409      	str	r4, [sp, #36]	; 0x24
 800c2d0:	940a      	str	r4, [sp, #40]	; 0x28
	{
		{ ( unsigned char *) pucHeapStart, ulHeapSize },
		{ NULL, 0 }
 	};

	vPortDefineHeapRegions( xHeapRegions );
 800c2d2:	a807      	add	r0, sp, #28
 800c2d4:	f7fd f88c 	bl	80093f0 <vPortDefineHeapRegions>
	vStartHighResolutionTimer();
 800c2d8:	f7ff ff20 	bl	800c11c <vStartHighResolutionTimer>
	FreeRTOS_printf( ( "FreeRTOS_IPInit\n" ) );
 800c2dc:	480d      	ldr	r0, [pc, #52]	; (800c314 <main+0x144>)
 800c2de:	f7ff fbb3 	bl	800ba48 <lUDPLoggingPrintf>
	FreeRTOS_IPInit( ucIPAddress, ucNetMask, ucGatewayAddress, ucDNSServerAddress, ucMACAddress );
 800c2e2:	4b0d      	ldr	r3, [pc, #52]	; (800c318 <main+0x148>)
 800c2e4:	9300      	str	r3, [sp, #0]
 800c2e6:	4b0d      	ldr	r3, [pc, #52]	; (800c31c <main+0x14c>)
 800c2e8:	4a0d      	ldr	r2, [pc, #52]	; (800c320 <main+0x150>)
 800c2ea:	490e      	ldr	r1, [pc, #56]	; (800c324 <main+0x154>)
 800c2ec:	480e      	ldr	r0, [pc, #56]	; (800c328 <main+0x158>)
 800c2ee:	f7f8 f8b3 	bl	8004458 <FreeRTOS_IPInit>
	vTaskStartScheduler();
 800c2f2:	f7fd fe59 	bl	8009fa8 <vTaskStartScheduler>
 800c2f6:	e7fe      	b.n	800c2f6 <main+0x126>
 800c2f8:	40023800 	.word	0x40023800
 800c2fc:	40007000 	.word	0x40007000
 800c300:	40021000 	.word	0x40021000
 800c304:	40021400 	.word	0x40021400
 800c308:	40021c00 	.word	0x40021c00
 800c30c:	20004d68 	.word	0x20004d68
 800c310:	20020000 	.word	0x20020000
 800c314:	0800dcb0 	.word	0x0800dcb0
 800c318:	0800dcdc 	.word	0x0800dcdc
 800c31c:	0800dcd0 	.word	0x0800dcd0
 800c320:	0800dcd4 	.word	0x0800dcd4
 800c324:	0800dce4 	.word	0x0800dce4
 800c328:	0800dcd8 	.word	0x0800dcd8

0800c32c <vApplicationIdleHook>:
{
 800c32c:	b508      	push	{r3, lr}
	xTimeNow = xTaskGetTickCount();
 800c32e:	f7fd fe7f 	bl	800a030 <xTaskGetTickCount>
	if( ( xTimeNow - xLastToggle ) >= xToggleRate )
 800c332:	4b09      	ldr	r3, [pc, #36]	; (800c358 <vApplicationIdleHook+0x2c>)
 800c334:	681b      	ldr	r3, [r3, #0]
 800c336:	1ac0      	subs	r0, r0, r3
 800c338:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800c33c:	d200      	bcs.n	800c340 <vApplicationIdleHook+0x14>
 800c33e:	bd08      	pop	{r3, pc}
		HAL_GPIO_TogglePin( GPIOF, GPIO_PIN_9 );//led灯取反
 800c340:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c344:	4805      	ldr	r0, [pc, #20]	; (800c35c <vApplicationIdleHook+0x30>)
 800c346:	f7f6 f8b5 	bl	80024b4 <HAL_GPIO_TogglePin>
		xLastToggle += xToggleRate;
 800c34a:	4a03      	ldr	r2, [pc, #12]	; (800c358 <vApplicationIdleHook+0x2c>)
 800c34c:	6813      	ldr	r3, [r2, #0]
 800c34e:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 800c352:	6013      	str	r3, [r2, #0]
}
 800c354:	e7f3      	b.n	800c33e <vApplicationIdleHook+0x12>
 800c356:	bf00      	nop
 800c358:	20002834 	.word	0x20002834
 800c35c:	40021400 	.word	0x40021400

0800c360 <vAssertCalled>:
{
 800c360:	b570      	push	{r4, r5, r6, lr}
 800c362:	b084      	sub	sp, #16
 800c364:	4606      	mov	r6, r0
 800c366:	460d      	mov	r5, r1
volatile uint32_t ulBlockVariable = 0UL;
 800c368:	2400      	movs	r4, #0
 800c36a:	9403      	str	r4, [sp, #12]
	ulAssertedLine = ulLine;
 800c36c:	9101      	str	r1, [sp, #4]

static portINLINE int stdioGET_ERRNO( void )
{
void *pvResult;

	pvResult = pvTaskGetThreadLocalStoragePointer( NULL, ffconfigCWD_THREAD_LOCAL_INDEX );
 800c36e:	4621      	mov	r1, r4
 800c370:	4620      	mov	r0, r4
 800c372:	f7fe f9a9 	bl	800a6c8 <pvTaskGetThreadLocalStoragePointer>
	iAssertedErrno = stdioGET_ERRNO();
 800c376:	9002      	str	r0, [sp, #8]
 */
static portINLINE FF_Error_t stdioGET_FF_ERROR( void )
{
void *pvResult;

	pvResult = pvTaskGetThreadLocalStoragePointer( NULL, stdioFF_ERROR_THREAD_LOCAL_OFFSET );
 800c378:	2102      	movs	r1, #2
 800c37a:	4620      	mov	r0, r4
 800c37c:	f7fe f9a4 	bl	800a6c8 <pvTaskGetThreadLocalStoragePointer>
	xAssertedFF_Error = stdioGET_FF_ERROR( );
 800c380:	9000      	str	r0, [sp, #0]
	( void ) ulAssertedLine;
 800c382:	9b01      	ldr	r3, [sp, #4]
	( void ) iAssertedErrno;
 800c384:	9b02      	ldr	r3, [sp, #8]
	( void ) xAssertedFF_Error;
 800c386:	9b00      	ldr	r3, [sp, #0]
	FreeRTOS_printf( ( "vAssertCalled( %s, %ld\n", pcFile, ulLine ) );
 800c388:	462a      	mov	r2, r5
 800c38a:	4631      	mov	r1, r6
 800c38c:	480a      	ldr	r0, [pc, #40]	; (800c3b8 <vAssertCalled+0x58>)
 800c38e:	f7ff fb5b 	bl	800ba48 <lUDPLoggingPrintf>
	__asm volatile
 800c392:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c396:	f383 8811 	msr	BASEPRI, r3
 800c39a:	f3bf 8f6f 	isb	sy
 800c39e:	f3bf 8f4f 	dsb	sy
		while( ulBlockVariable == 0UL )
 800c3a2:	9b03      	ldr	r3, [sp, #12]
 800c3a4:	b91b      	cbnz	r3, 800c3ae <vAssertCalled+0x4e>
			__asm volatile( "NOP" );
 800c3a6:	bf00      	nop
		while( ulBlockVariable == 0UL )
 800c3a8:	9b03      	ldr	r3, [sp, #12]
 800c3aa:	2b00      	cmp	r3, #0
 800c3ac:	d0fb      	beq.n	800c3a6 <vAssertCalled+0x46>
	__asm volatile
 800c3ae:	2300      	movs	r3, #0
 800c3b0:	f383 8811 	msr	BASEPRI, r3
}
 800c3b4:	b004      	add	sp, #16
 800c3b6:	bd70      	pop	{r4, r5, r6, pc}
 800c3b8:	0800dd68 	.word	0x0800dd68

0800c3bc <vApplicationCardDetectChangeHookFromISR>:
{
 800c3bc:	4770      	bx	lr
	...

0800c3c0 <vApplicationIPNetworkEventHook>:
{
 800c3c0:	b510      	push	{r4, lr}
 800c3c2:	b08a      	sub	sp, #40	; 0x28
 800c3c4:	4604      	mov	r4, r0
	FreeRTOS_printf( ( "vApplicationIPNetworkEventHook: event %ld\n", eNetworkEvent ) );
 800c3c6:	4601      	mov	r1, r0
 800c3c8:	4838      	ldr	r0, [pc, #224]	; (800c4ac <vApplicationIPNetworkEventHook+0xec>)
 800c3ca:	f7ff fb3d 	bl	800ba48 <lUDPLoggingPrintf>
	if( eNetworkEvent == eNetworkUp )
 800c3ce:	2c00      	cmp	r4, #0
 800c3d0:	d14e      	bne.n	800c470 <vApplicationIPNetworkEventHook+0xb0>
		if( xTasksAlreadyCreated == pdFALSE )
 800c3d2:	4b37      	ldr	r3, [pc, #220]	; (800c4b0 <vApplicationIPNetworkEventHook+0xf0>)
 800c3d4:	681b      	ldr	r3, [r3, #0]
 800c3d6:	2b00      	cmp	r3, #0
 800c3d8:	d04c      	beq.n	800c474 <vApplicationIPNetworkEventHook+0xb4>
		FreeRTOS_GetAddressConfiguration( &ulIPAddress, &ulNetMask, &ulGatewayAddress, &ulDNSServerAddress );
 800c3da:	ab06      	add	r3, sp, #24
 800c3dc:	aa07      	add	r2, sp, #28
 800c3de:	a908      	add	r1, sp, #32
 800c3e0:	a809      	add	r0, sp, #36	; 0x24
 800c3e2:	f7f8 f8d9 	bl	8004598 <FreeRTOS_GetAddressConfiguration>
		FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
 800c3e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c3e8:	4c32      	ldr	r4, [pc, #200]	; (800c4b4 <vApplicationIPNetworkEventHook+0xf4>)
 800c3ea:	0e13      	lsrs	r3, r2, #24
 800c3ec:	9301      	str	r3, [sp, #4]
 800c3ee:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800c3f2:	9300      	str	r3, [sp, #0]
 800c3f4:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800c3f8:	b2d2      	uxtb	r2, r2
 800c3fa:	4621      	mov	r1, r4
 800c3fc:	a802      	add	r0, sp, #8
 800c3fe:	f7ff fd06 	bl	800be0e <sprintf>
		FreeRTOS_printf( ( "IP Address: %s\n", cBuffer ) );
 800c402:	a902      	add	r1, sp, #8
 800c404:	482c      	ldr	r0, [pc, #176]	; (800c4b8 <vApplicationIPNetworkEventHook+0xf8>)
 800c406:	f7ff fb1f 	bl	800ba48 <lUDPLoggingPrintf>
		FreeRTOS_inet_ntoa( ulNetMask, cBuffer );
 800c40a:	9a08      	ldr	r2, [sp, #32]
 800c40c:	0e13      	lsrs	r3, r2, #24
 800c40e:	9301      	str	r3, [sp, #4]
 800c410:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800c414:	9300      	str	r3, [sp, #0]
 800c416:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800c41a:	b2d2      	uxtb	r2, r2
 800c41c:	4621      	mov	r1, r4
 800c41e:	a802      	add	r0, sp, #8
 800c420:	f7ff fcf5 	bl	800be0e <sprintf>
		FreeRTOS_printf( ( "Subnet Mask: %s\n", cBuffer ) );
 800c424:	a902      	add	r1, sp, #8
 800c426:	4825      	ldr	r0, [pc, #148]	; (800c4bc <vApplicationIPNetworkEventHook+0xfc>)
 800c428:	f7ff fb0e 	bl	800ba48 <lUDPLoggingPrintf>
		FreeRTOS_inet_ntoa( ulGatewayAddress, cBuffer );
 800c42c:	9a07      	ldr	r2, [sp, #28]
 800c42e:	0e13      	lsrs	r3, r2, #24
 800c430:	9301      	str	r3, [sp, #4]
 800c432:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800c436:	9300      	str	r3, [sp, #0]
 800c438:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800c43c:	b2d2      	uxtb	r2, r2
 800c43e:	4621      	mov	r1, r4
 800c440:	a802      	add	r0, sp, #8
 800c442:	f7ff fce4 	bl	800be0e <sprintf>
		FreeRTOS_printf( ( "Gateway Address: %s\n", cBuffer ) );
 800c446:	a902      	add	r1, sp, #8
 800c448:	481d      	ldr	r0, [pc, #116]	; (800c4c0 <vApplicationIPNetworkEventHook+0x100>)
 800c44a:	f7ff fafd 	bl	800ba48 <lUDPLoggingPrintf>
		FreeRTOS_inet_ntoa( ulDNSServerAddress, cBuffer );
 800c44e:	9a06      	ldr	r2, [sp, #24]
 800c450:	0e13      	lsrs	r3, r2, #24
 800c452:	9301      	str	r3, [sp, #4]
 800c454:	f3c2 4307 	ubfx	r3, r2, #16, #8
 800c458:	9300      	str	r3, [sp, #0]
 800c45a:	f3c2 2307 	ubfx	r3, r2, #8, #8
 800c45e:	b2d2      	uxtb	r2, r2
 800c460:	4621      	mov	r1, r4
 800c462:	a802      	add	r0, sp, #8
 800c464:	f7ff fcd3 	bl	800be0e <sprintf>
		FreeRTOS_printf( ( "DNS Server Address: %s\n", cBuffer ) );
 800c468:	a902      	add	r1, sp, #8
 800c46a:	4816      	ldr	r0, [pc, #88]	; (800c4c4 <vApplicationIPNetworkEventHook+0x104>)
 800c46c:	f7ff faec 	bl	800ba48 <lUDPLoggingPrintf>
}
 800c470:	b00a      	add	sp, #40	; 0x28
 800c472:	bd10      	pop	{r4, pc}
				vUDPLoggingTaskCreate();
 800c474:	f7ff fb90 	bl	800bb98 <vUDPLoggingTaskCreate>
				vStartTCPEchoClientTasks_SingleTasks( mainECHO_CLIENT_TASK_STACK_SIZE, mainECHO_CLIENT_TASK_PRIORITY );
 800c478:	2101      	movs	r1, #1
 800c47a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800c47e:	f7ff f9c9 	bl	800b814 <vStartTCPEchoClientTasks_SingleTasks>
				vStartSimpleTCPServerTasks( mainECHO_SERVER_STACK_SIZE, mainECHO_SERVER_TASK_PRIORITY );
 800c482:	2102      	movs	r1, #2
 800c484:	f44f 7000 	mov.w	r0, #512	; 0x200
 800c488:	f7ff f8b8 	bl	800b5fc <vStartSimpleTCPServerTasks>
				vRegisterSampleCLICommands();
 800c48c:	f7fe fdc6 	bl	800b01c <vRegisterSampleCLICommands>
				vRegisterTCPCLICommands();
 800c490:	f7fe ff08 	bl	800b2a4 <vRegisterTCPCLICommands>
				vStartUDPCommandInterpreterTask( mainUDP_CLI_TASK_STACK_SIZE, mainUDP_CLI_PORT_NUMBER, mainUDP_CLI_TASK_PRIORITY );
 800c494:	2201      	movs	r2, #1
 800c496:	f241 3189 	movw	r1, #5001	; 0x1389
 800c49a:	f44f 7020 	mov.w	r0, #640	; 0x280
 800c49e:	f7fe ffdb 	bl	800b458 <vStartUDPCommandInterpreterTask>
			xTasksAlreadyCreated = pdTRUE;
 800c4a2:	2201      	movs	r2, #1
 800c4a4:	4b02      	ldr	r3, [pc, #8]	; (800c4b0 <vApplicationIPNetworkEventHook+0xf0>)
 800c4a6:	601a      	str	r2, [r3, #0]
 800c4a8:	e797      	b.n	800c3da <vApplicationIPNetworkEventHook+0x1a>
 800c4aa:	bf00      	nop
 800c4ac:	0800dce8 	.word	0x0800dce8
 800c4b0:	20002838 	.word	0x20002838
 800c4b4:	0800d5c4 	.word	0x0800d5c4
 800c4b8:	0800dd14 	.word	0x0800dd14
 800c4bc:	0800dd24 	.word	0x0800dd24
 800c4c0:	0800dd38 	.word	0x0800dd38
 800c4c4:	0800dd50 	.word	0x0800dd50

0800c4c8 <vApplicationMallocFailedHook>:
{
 800c4c8:	b082      	sub	sp, #8
volatile uint32_t ulMallocFailures = 0;
 800c4ca:	2300      	movs	r3, #0
 800c4cc:	9301      	str	r3, [sp, #4]
	ulMallocFailures++;
 800c4ce:	9b01      	ldr	r3, [sp, #4]
 800c4d0:	3301      	adds	r3, #1
 800c4d2:	9301      	str	r3, [sp, #4]
}
 800c4d4:	b002      	add	sp, #8
 800c4d6:	4770      	bx	lr

0800c4d8 <vApplicationStackOverflowHook>:
	__asm volatile
 800c4d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c4dc:	f383 8811 	msr	BASEPRI, r3
 800c4e0:	f3bf 8f6f 	isb	sy
 800c4e4:	f3bf 8f4f 	dsb	sy
 800c4e8:	e7fe      	b.n	800c4e8 <vApplicationStackOverflowHook+0x10>
	...

0800c4ec <uxRand>:
{
 800c4ec:	b500      	push	{lr}
 800c4ee:	b085      	sub	sp, #20
	if( xInitialised == pdFALSE )
 800c4f0:	4b10      	ldr	r3, [pc, #64]	; (800c534 <uxRand+0x48>)
 800c4f2:	681b      	ldr	r3, [r3, #0]
 800c4f4:	b15b      	cbz	r3, 800c50e <uxRand+0x22>
	ulNextRand = ( ulMultiplier * ulNextRand ) + ulIncrement;
 800c4f6:	4b10      	ldr	r3, [pc, #64]	; (800c538 <uxRand+0x4c>)
 800c4f8:	681a      	ldr	r2, [r3, #0]
 800c4fa:	4810      	ldr	r0, [pc, #64]	; (800c53c <uxRand+0x50>)
 800c4fc:	fb00 f002 	mul.w	r0, r0, r2
 800c500:	3001      	adds	r0, #1
 800c502:	6018      	str	r0, [r3, #0]
}
 800c504:	f3c0 400e 	ubfx	r0, r0, #16, #15
 800c508:	b005      	add	sp, #20
 800c50a:	f85d fb04 	ldr.w	pc, [sp], #4
		if( xTaskGetSchedulerState() !=  taskSCHEDULER_NOT_STARTED )
 800c50e:	f7fe f9bb 	bl	800a888 <xTaskGetSchedulerState>
 800c512:	2801      	cmp	r0, #1
 800c514:	d0ef      	beq.n	800c4f6 <uxRand+0xa>
			HAL_RNG_Init( &xRND );
 800c516:	a801      	add	r0, sp, #4
 800c518:	f7f6 fc0f 	bl	8002d3a <HAL_RNG_Init>
			HAL_RNG_GenerateRandomNumber( &xRND, &ulSeed );
 800c51c:	4669      	mov	r1, sp
 800c51e:	a801      	add	r0, sp, #4
 800c520:	f7f6 fc28 	bl	8002d74 <HAL_RNG_GenerateRandomNumber>
	ulNextRand = ulSeed;
 800c524:	9a00      	ldr	r2, [sp, #0]
 800c526:	4b04      	ldr	r3, [pc, #16]	; (800c538 <uxRand+0x4c>)
 800c528:	601a      	str	r2, [r3, #0]
			xInitialised = pdTRUE;
 800c52a:	2201      	movs	r2, #1
 800c52c:	4b01      	ldr	r3, [pc, #4]	; (800c534 <uxRand+0x48>)
 800c52e:	601a      	str	r2, [r3, #0]
 800c530:	e7e1      	b.n	800c4f6 <uxRand+0xa>
 800c532:	bf00      	nop
 800c534:	20002830 	.word	0x20002830
 800c538:	2000282c 	.word	0x2000282c
 800c53c:	015a4e35 	.word	0x015a4e35

0800c540 <vApplicationPingReplyHook>:
{
 800c540:	4770      	bx	lr

0800c542 <vOutputChar>:
}
/*-----------------------------------------------------------*/

void vOutputChar( const char cChar, const TickType_t xTicksToWait  )
{
 800c542:	4770      	bx	lr

0800c544 <pcApplicationHostnameHook>:
{
	/* Assign the name "rtosdemo" to this network node.  This function will be
	called during the DHCP: the machine will be registered with an IP address
	plus this name. */
	return mainHOST_NAME;
}
 800c544:	4800      	ldr	r0, [pc, #0]	; (800c548 <pcApplicationHostnameHook+0x4>)
 800c546:	4770      	bx	lr
 800c548:	0800dcc4 	.word	0x0800dcc4

0800c54c <xApplicationDNSQueryHook>:
/*-----------------------------------------------------------*/


BaseType_t xApplicationDNSQueryHook( const char *pcName )
{
 800c54c:	b510      	push	{r4, lr}
 800c54e:	4604      	mov	r4, r0
BaseType_t xReturn;

	/* Determine if a name lookup is for this node.  Two names are given
	to this node: that returned by pcApplicationHostnameHook() and that set
	by mainDEVICE_NICK_NAME. */
	if( strcasecmp( pcName, pcApplicationHostnameHook() ) == 0 )
 800c550:	4906      	ldr	r1, [pc, #24]	; (800c56c <xApplicationDNSQueryHook+0x20>)
 800c552:	f7f6 fdaf 	bl	80030b4 <strcasecmp>
 800c556:	b138      	cbz	r0, 800c568 <xApplicationDNSQueryHook+0x1c>
	{
		xReturn = pdPASS;
	}
	else if( strcasecmp( pcName, mainDEVICE_NICK_NAME ) == 0 )
 800c558:	4905      	ldr	r1, [pc, #20]	; (800c570 <xApplicationDNSQueryHook+0x24>)
 800c55a:	4620      	mov	r0, r4
 800c55c:	f7f6 fdaa 	bl	80030b4 <strcasecmp>
 800c560:	fab0 f080 	clz	r0, r0
 800c564:	0940      	lsrs	r0, r0, #5
 800c566:	bd10      	pop	{r4, pc}
 800c568:	2001      	movs	r0, #1
	{
		xReturn = pdFAIL;
	}

	return xReturn;
}
 800c56a:	bd10      	pop	{r4, pc}
 800c56c:	0800dcc4 	.word	0x0800dcc4
 800c570:	0800dd80 	.word	0x0800dd80

0800c574 <xGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

uint32_t xGetRunTimeCounterValue( void )
{
 800c574:	b508      	push	{r3, lr}
static uint64_t ullHiresTime = 0; /* Is always 0? */

	return ( uint32_t ) ( ullGetHighResolutionTime() - ullHiresTime );
 800c576:	f7ff fdff 	bl	800c178 <ullGetHighResolutionTime>
}
 800c57a:	bd08      	pop	{r3, pc}

0800c57c <vApplicationTickHook>:
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
 800c57c:	b508      	push	{r3, lr}
	/* Call the ST HAL tick function. */
	HAL_IncTick();
 800c57e:	f7f4 f847 	bl	8000610 <HAL_IncTick>
 800c582:	bd08      	pop	{r3, pc}

0800c584 <HAL_ETH_MspInit>:
 */
void HAL_ETH_MspInit( ETH_HandleTypeDef* xETHHandle )
{
GPIO_InitTypeDef GPIO_InitStruct;

	if( xETHHandle->Instance == ETH )
 800c584:	6802      	ldr	r2, [r0, #0]
 800c586:	4b34      	ldr	r3, [pc, #208]	; (800c658 <HAL_ETH_MspInit+0xd4>)
 800c588:	429a      	cmp	r2, r3
 800c58a:	d000      	beq.n	800c58e <HAL_ETH_MspInit+0xa>
 800c58c:	4770      	bx	lr
{
 800c58e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c592:	b087      	sub	sp, #28
	{
		/* Peripheral clock enable */
		__ETH_CLK_ENABLE();			/* defined as __HAL_RCC_ETH_CLK_ENABLE. */
 800c594:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
 800c598:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c59a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800c59e:	631a      	str	r2, [r3, #48]	; 0x30
 800c5a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5a2:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800c5a6:	631a      	str	r2, [r3, #48]	; 0x30
 800c5a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5aa:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800c5ae:	631a      	str	r2, [r3, #48]	; 0x30
		__ETHMACRX_CLK_ENABLE();	/* defined as __HAL_RCC_ETHMACRX_CLK_ENABLE. */
 800c5b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5b2:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800c5b6:	631a      	str	r2, [r3, #48]	; 0x30
		__ETHMACTX_CLK_ENABLE();	/* defined as __HAL_RCC_ETHMACTX_CLK_ENABLE. */
 800c5b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5ba:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800c5be:	631a      	str	r2, [r3, #48]	; 0x30

		//包括以太网的IO端口；
		__GPIOA_CLK_ENABLE();
 800c5c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5c2:	f042 0201 	orr.w	r2, r2, #1
 800c5c6:	631a      	str	r2, [r3, #48]	; 0x30
		__GPIOB_CLK_ENABLE();
 800c5c8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5ca:	f042 0202 	orr.w	r2, r2, #2
 800c5ce:	631a      	str	r2, [r3, #48]	; 0x30
		__GPIOC_CLK_ENABLE();
 800c5d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5d2:	f042 0204 	orr.w	r2, r2, #4
 800c5d6:	631a      	str	r2, [r3, #48]	; 0x30
		__GPIOG_CLK_ENABLE();
 800c5d8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c5da:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800c5de:	631a      	str	r2, [r3, #48]	; 0x30
	//	GPIO_InitStruct.Pull = GPIO_NOPULL;
	//	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
	//	GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
	//	HAL_GPIO_Init( GPIOB, &GPIO_InitStruct );

		GPIO_InitStruct.Pin = GPIO_PIN_14 | GPIO_PIN_13 | GPIO_PIN_11;
 800c5e0:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
 800c5e4:	9301      	str	r3, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c5e6:	2702      	movs	r7, #2
 800c5e8:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c5ea:	2400      	movs	r4, #0
 800c5ec:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800c5ee:	2603      	movs	r6, #3
 800c5f0:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800c5f2:	250b      	movs	r5, #11
 800c5f4:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOG, &GPIO_InitStruct );
 800c5f6:	a901      	add	r1, sp, #4
 800c5f8:	4818      	ldr	r0, [pc, #96]	; (800c65c <HAL_ETH_MspInit+0xd8>)
 800c5fa:	f7f5 fe79 	bl	80022f0 <HAL_GPIO_Init>
	//	GPIO_InitStruct.Pull = GPIO_NOPULL;
	//	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
	//	GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
	//	HAL_GPIO_Init( GPIOH, &GPIO_InitStruct );

		GPIO_InitStruct.Pin = GPIO_PIN_1  | GPIO_PIN_4 | GPIO_PIN_5;
 800c5fe:	2332      	movs	r3, #50	; 0x32
 800c600:	9301      	str	r3, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c602:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c604:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800c606:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800c608:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOC, &GPIO_InitStruct );
 800c60a:	a901      	add	r1, sp, #4
 800c60c:	4814      	ldr	r0, [pc, #80]	; (800c660 <HAL_ETH_MspInit+0xdc>)
 800c60e:	f7f5 fe6f 	bl	80022f0 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
 800c612:	f04f 0986 	mov.w	r9, #134	; 0x86
 800c616:	f8cd 9004 	str.w	r9, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c61a:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c61c:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800c61e:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800c620:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOA, &GPIO_InitStruct );
 800c622:	f8df 8040 	ldr.w	r8, [pc, #64]	; 800c664 <HAL_ETH_MspInit+0xe0>
 800c626:	a901      	add	r1, sp, #4
 800c628:	4640      	mov	r0, r8
 800c62a:	f7f5 fe61 	bl	80022f0 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
 800c62e:	f8cd 9004 	str.w	r9, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c632:	9702      	str	r7, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c634:	9403      	str	r4, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800c636:	9604      	str	r6, [sp, #16]
		GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800c638:	9505      	str	r5, [sp, #20]
		HAL_GPIO_Init( GPIOA, &GPIO_InitStruct );
 800c63a:	a901      	add	r1, sp, #4
 800c63c:	4640      	mov	r0, r8
 800c63e:	f7f5 fe57 	bl	80022f0 <HAL_GPIO_Init>
//		GPIO_InitStruct.Pull = GPIO_NOPULL;
//		GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
//		GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
//		HAL_GPIO_Init( GPIOA, &GPIO_InitStruct );

		HAL_NVIC_SetPriority( ETH_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY, 0 );
 800c642:	4622      	mov	r2, r4
 800c644:	2105      	movs	r1, #5
 800c646:	203d      	movs	r0, #61	; 0x3d
 800c648:	f7f4 f810 	bl	800066c <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ( ETH_IRQn );
 800c64c:	203d      	movs	r0, #61	; 0x3d
 800c64e:	f7f4 f83d 	bl	80006cc <HAL_NVIC_EnableIRQ>
	}
}
 800c652:	b007      	add	sp, #28
 800c654:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800c658:	40028000 	.word	0x40028000
 800c65c:	40021800 	.word	0x40021800
 800c660:	40020800 	.word	0x40020800
 800c664:	40020000 	.word	0x40020000

0800c668 <atol>:
 800c668:	220a      	movs	r2, #10
 800c66a:	2100      	movs	r1, #0
 800c66c:	f000 b924 	b.w	800c8b8 <strtol>

0800c670 <__libc_init_array>:
 800c670:	b570      	push	{r4, r5, r6, lr}
 800c672:	4e0d      	ldr	r6, [pc, #52]	; (800c6a8 <__libc_init_array+0x38>)
 800c674:	4c0d      	ldr	r4, [pc, #52]	; (800c6ac <__libc_init_array+0x3c>)
 800c676:	1ba4      	subs	r4, r4, r6
 800c678:	10a4      	asrs	r4, r4, #2
 800c67a:	2500      	movs	r5, #0
 800c67c:	42a5      	cmp	r5, r4
 800c67e:	d109      	bne.n	800c694 <__libc_init_array+0x24>
 800c680:	4e0b      	ldr	r6, [pc, #44]	; (800c6b0 <__libc_init_array+0x40>)
 800c682:	4c0c      	ldr	r4, [pc, #48]	; (800c6b4 <__libc_init_array+0x44>)
 800c684:	f000 f950 	bl	800c928 <_init>
 800c688:	1ba4      	subs	r4, r4, r6
 800c68a:	10a4      	asrs	r4, r4, #2
 800c68c:	2500      	movs	r5, #0
 800c68e:	42a5      	cmp	r5, r4
 800c690:	d105      	bne.n	800c69e <__libc_init_array+0x2e>
 800c692:	bd70      	pop	{r4, r5, r6, pc}
 800c694:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c698:	4798      	blx	r3
 800c69a:	3501      	adds	r5, #1
 800c69c:	e7ee      	b.n	800c67c <__libc_init_array+0xc>
 800c69e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c6a2:	4798      	blx	r3
 800c6a4:	3501      	adds	r5, #1
 800c6a6:	e7f2      	b.n	800c68e <__libc_init_array+0x1e>
 800c6a8:	0800defc 	.word	0x0800defc
 800c6ac:	0800defc 	.word	0x0800defc
 800c6b0:	0800defc 	.word	0x0800defc
 800c6b4:	0800df00 	.word	0x0800df00

0800c6b8 <memcmp>:
 800c6b8:	b510      	push	{r4, lr}
 800c6ba:	3901      	subs	r1, #1
 800c6bc:	4402      	add	r2, r0
 800c6be:	4290      	cmp	r0, r2
 800c6c0:	d101      	bne.n	800c6c6 <memcmp+0xe>
 800c6c2:	2000      	movs	r0, #0
 800c6c4:	bd10      	pop	{r4, pc}
 800c6c6:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c6ca:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800c6ce:	42a3      	cmp	r3, r4
 800c6d0:	d0f5      	beq.n	800c6be <memcmp+0x6>
 800c6d2:	1b18      	subs	r0, r3, r4
 800c6d4:	bd10      	pop	{r4, pc}

0800c6d6 <memcpy>:
 800c6d6:	b510      	push	{r4, lr}
 800c6d8:	1e43      	subs	r3, r0, #1
 800c6da:	440a      	add	r2, r1
 800c6dc:	4291      	cmp	r1, r2
 800c6de:	d100      	bne.n	800c6e2 <memcpy+0xc>
 800c6e0:	bd10      	pop	{r4, pc}
 800c6e2:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c6e6:	f803 4f01 	strb.w	r4, [r3, #1]!
 800c6ea:	e7f7      	b.n	800c6dc <memcpy+0x6>

0800c6ec <memmove>:
 800c6ec:	4288      	cmp	r0, r1
 800c6ee:	b510      	push	{r4, lr}
 800c6f0:	eb01 0302 	add.w	r3, r1, r2
 800c6f4:	d803      	bhi.n	800c6fe <memmove+0x12>
 800c6f6:	1e42      	subs	r2, r0, #1
 800c6f8:	4299      	cmp	r1, r3
 800c6fa:	d10c      	bne.n	800c716 <memmove+0x2a>
 800c6fc:	bd10      	pop	{r4, pc}
 800c6fe:	4298      	cmp	r0, r3
 800c700:	d2f9      	bcs.n	800c6f6 <memmove+0xa>
 800c702:	1881      	adds	r1, r0, r2
 800c704:	1ad2      	subs	r2, r2, r3
 800c706:	42d3      	cmn	r3, r2
 800c708:	d100      	bne.n	800c70c <memmove+0x20>
 800c70a:	bd10      	pop	{r4, pc}
 800c70c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800c710:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800c714:	e7f7      	b.n	800c706 <memmove+0x1a>
 800c716:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c71a:	f802 4f01 	strb.w	r4, [r2, #1]!
 800c71e:	e7eb      	b.n	800c6f8 <memmove+0xc>

0800c720 <memset>:
 800c720:	4402      	add	r2, r0
 800c722:	4603      	mov	r3, r0
 800c724:	4293      	cmp	r3, r2
 800c726:	d100      	bne.n	800c72a <memset+0xa>
 800c728:	4770      	bx	lr
 800c72a:	f803 1b01 	strb.w	r1, [r3], #1
 800c72e:	e7f9      	b.n	800c724 <memset+0x4>

0800c730 <strcpy>:
 800c730:	4603      	mov	r3, r0
 800c732:	f811 2b01 	ldrb.w	r2, [r1], #1
 800c736:	f803 2b01 	strb.w	r2, [r3], #1
 800c73a:	2a00      	cmp	r2, #0
 800c73c:	d1f9      	bne.n	800c732 <strcpy+0x2>
 800c73e:	4770      	bx	lr

0800c740 <strncat>:
 800c740:	b530      	push	{r4, r5, lr}
 800c742:	4603      	mov	r3, r0
 800c744:	781c      	ldrb	r4, [r3, #0]
 800c746:	1c5d      	adds	r5, r3, #1
 800c748:	b944      	cbnz	r4, 800c75c <strncat+0x1c>
 800c74a:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
 800c74e:	d304      	bcc.n	800c75a <strncat+0x1a>
 800c750:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c754:	f803 4b01 	strb.w	r4, [r3], #1
 800c758:	b914      	cbnz	r4, 800c760 <strncat+0x20>
 800c75a:	bd30      	pop	{r4, r5, pc}
 800c75c:	462b      	mov	r3, r5
 800c75e:	e7f1      	b.n	800c744 <strncat+0x4>
 800c760:	2a00      	cmp	r2, #0
 800c762:	d1f2      	bne.n	800c74a <strncat+0xa>
 800c764:	701a      	strb	r2, [r3, #0]
 800c766:	e7f0      	b.n	800c74a <strncat+0xa>

0800c768 <strncmp>:
 800c768:	b510      	push	{r4, lr}
 800c76a:	b16a      	cbz	r2, 800c788 <strncmp+0x20>
 800c76c:	3901      	subs	r1, #1
 800c76e:	1884      	adds	r4, r0, r2
 800c770:	f810 3b01 	ldrb.w	r3, [r0], #1
 800c774:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800c778:	4293      	cmp	r3, r2
 800c77a:	d103      	bne.n	800c784 <strncmp+0x1c>
 800c77c:	42a0      	cmp	r0, r4
 800c77e:	d001      	beq.n	800c784 <strncmp+0x1c>
 800c780:	2b00      	cmp	r3, #0
 800c782:	d1f5      	bne.n	800c770 <strncmp+0x8>
 800c784:	1a98      	subs	r0, r3, r2
 800c786:	bd10      	pop	{r4, pc}
 800c788:	4610      	mov	r0, r2
 800c78a:	bd10      	pop	{r4, pc}

0800c78c <strncpy>:
 800c78c:	b570      	push	{r4, r5, r6, lr}
 800c78e:	4604      	mov	r4, r0
 800c790:	b902      	cbnz	r2, 800c794 <strncpy+0x8>
 800c792:	bd70      	pop	{r4, r5, r6, pc}
 800c794:	4623      	mov	r3, r4
 800c796:	f811 5b01 	ldrb.w	r5, [r1], #1
 800c79a:	f803 5b01 	strb.w	r5, [r3], #1
 800c79e:	1e56      	subs	r6, r2, #1
 800c7a0:	b91d      	cbnz	r5, 800c7aa <strncpy+0x1e>
 800c7a2:	4414      	add	r4, r2
 800c7a4:	42a3      	cmp	r3, r4
 800c7a6:	d103      	bne.n	800c7b0 <strncpy+0x24>
 800c7a8:	bd70      	pop	{r4, r5, r6, pc}
 800c7aa:	461c      	mov	r4, r3
 800c7ac:	4632      	mov	r2, r6
 800c7ae:	e7ef      	b.n	800c790 <strncpy+0x4>
 800c7b0:	f803 5b01 	strb.w	r5, [r3], #1
 800c7b4:	e7f6      	b.n	800c7a4 <strncpy+0x18>

0800c7b6 <_strtol_l.isra.0>:
 800c7b6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c7ba:	4680      	mov	r8, r0
 800c7bc:	4689      	mov	r9, r1
 800c7be:	4692      	mov	sl, r2
 800c7c0:	461f      	mov	r7, r3
 800c7c2:	468b      	mov	fp, r1
 800c7c4:	465d      	mov	r5, fp
 800c7c6:	980a      	ldr	r0, [sp, #40]	; 0x28
 800c7c8:	f815 4b01 	ldrb.w	r4, [r5], #1
 800c7cc:	f000 f88a 	bl	800c8e4 <__locale_ctype_ptr_l>
 800c7d0:	4420      	add	r0, r4
 800c7d2:	7846      	ldrb	r6, [r0, #1]
 800c7d4:	f016 0608 	ands.w	r6, r6, #8
 800c7d8:	d10b      	bne.n	800c7f2 <_strtol_l.isra.0+0x3c>
 800c7da:	2c2d      	cmp	r4, #45	; 0x2d
 800c7dc:	d10b      	bne.n	800c7f6 <_strtol_l.isra.0+0x40>
 800c7de:	782c      	ldrb	r4, [r5, #0]
 800c7e0:	2601      	movs	r6, #1
 800c7e2:	f10b 0502 	add.w	r5, fp, #2
 800c7e6:	b167      	cbz	r7, 800c802 <_strtol_l.isra.0+0x4c>
 800c7e8:	2f10      	cmp	r7, #16
 800c7ea:	d114      	bne.n	800c816 <_strtol_l.isra.0+0x60>
 800c7ec:	2c30      	cmp	r4, #48	; 0x30
 800c7ee:	d00a      	beq.n	800c806 <_strtol_l.isra.0+0x50>
 800c7f0:	e011      	b.n	800c816 <_strtol_l.isra.0+0x60>
 800c7f2:	46ab      	mov	fp, r5
 800c7f4:	e7e6      	b.n	800c7c4 <_strtol_l.isra.0+0xe>
 800c7f6:	2c2b      	cmp	r4, #43	; 0x2b
 800c7f8:	bf04      	itt	eq
 800c7fa:	782c      	ldrbeq	r4, [r5, #0]
 800c7fc:	f10b 0502 	addeq.w	r5, fp, #2
 800c800:	e7f1      	b.n	800c7e6 <_strtol_l.isra.0+0x30>
 800c802:	2c30      	cmp	r4, #48	; 0x30
 800c804:	d127      	bne.n	800c856 <_strtol_l.isra.0+0xa0>
 800c806:	782b      	ldrb	r3, [r5, #0]
 800c808:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 800c80c:	2b58      	cmp	r3, #88	; 0x58
 800c80e:	d14b      	bne.n	800c8a8 <_strtol_l.isra.0+0xf2>
 800c810:	786c      	ldrb	r4, [r5, #1]
 800c812:	2710      	movs	r7, #16
 800c814:	3502      	adds	r5, #2
 800c816:	2e00      	cmp	r6, #0
 800c818:	bf0c      	ite	eq
 800c81a:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 800c81e:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 800c822:	2200      	movs	r2, #0
 800c824:	fbb1 fef7 	udiv	lr, r1, r7
 800c828:	4610      	mov	r0, r2
 800c82a:	fb07 1c1e 	mls	ip, r7, lr, r1
 800c82e:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 800c832:	2b09      	cmp	r3, #9
 800c834:	d811      	bhi.n	800c85a <_strtol_l.isra.0+0xa4>
 800c836:	461c      	mov	r4, r3
 800c838:	42a7      	cmp	r7, r4
 800c83a:	dd1d      	ble.n	800c878 <_strtol_l.isra.0+0xc2>
 800c83c:	1c53      	adds	r3, r2, #1
 800c83e:	d007      	beq.n	800c850 <_strtol_l.isra.0+0x9a>
 800c840:	4586      	cmp	lr, r0
 800c842:	d316      	bcc.n	800c872 <_strtol_l.isra.0+0xbc>
 800c844:	d101      	bne.n	800c84a <_strtol_l.isra.0+0x94>
 800c846:	45a4      	cmp	ip, r4
 800c848:	db13      	blt.n	800c872 <_strtol_l.isra.0+0xbc>
 800c84a:	fb00 4007 	mla	r0, r0, r7, r4
 800c84e:	2201      	movs	r2, #1
 800c850:	f815 4b01 	ldrb.w	r4, [r5], #1
 800c854:	e7eb      	b.n	800c82e <_strtol_l.isra.0+0x78>
 800c856:	270a      	movs	r7, #10
 800c858:	e7dd      	b.n	800c816 <_strtol_l.isra.0+0x60>
 800c85a:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 800c85e:	2b19      	cmp	r3, #25
 800c860:	d801      	bhi.n	800c866 <_strtol_l.isra.0+0xb0>
 800c862:	3c37      	subs	r4, #55	; 0x37
 800c864:	e7e8      	b.n	800c838 <_strtol_l.isra.0+0x82>
 800c866:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 800c86a:	2b19      	cmp	r3, #25
 800c86c:	d804      	bhi.n	800c878 <_strtol_l.isra.0+0xc2>
 800c86e:	3c57      	subs	r4, #87	; 0x57
 800c870:	e7e2      	b.n	800c838 <_strtol_l.isra.0+0x82>
 800c872:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c876:	e7eb      	b.n	800c850 <_strtol_l.isra.0+0x9a>
 800c878:	1c53      	adds	r3, r2, #1
 800c87a:	d108      	bne.n	800c88e <_strtol_l.isra.0+0xd8>
 800c87c:	2322      	movs	r3, #34	; 0x22
 800c87e:	f8c8 3000 	str.w	r3, [r8]
 800c882:	4608      	mov	r0, r1
 800c884:	f1ba 0f00 	cmp.w	sl, #0
 800c888:	d107      	bne.n	800c89a <_strtol_l.isra.0+0xe4>
 800c88a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c88e:	b106      	cbz	r6, 800c892 <_strtol_l.isra.0+0xdc>
 800c890:	4240      	negs	r0, r0
 800c892:	f1ba 0f00 	cmp.w	sl, #0
 800c896:	d00c      	beq.n	800c8b2 <_strtol_l.isra.0+0xfc>
 800c898:	b122      	cbz	r2, 800c8a4 <_strtol_l.isra.0+0xee>
 800c89a:	3d01      	subs	r5, #1
 800c89c:	f8ca 5000 	str.w	r5, [sl]
 800c8a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c8a4:	464d      	mov	r5, r9
 800c8a6:	e7f9      	b.n	800c89c <_strtol_l.isra.0+0xe6>
 800c8a8:	2430      	movs	r4, #48	; 0x30
 800c8aa:	2f00      	cmp	r7, #0
 800c8ac:	d1b3      	bne.n	800c816 <_strtol_l.isra.0+0x60>
 800c8ae:	2708      	movs	r7, #8
 800c8b0:	e7b1      	b.n	800c816 <_strtol_l.isra.0+0x60>
 800c8b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800c8b8 <strtol>:
 800c8b8:	4b08      	ldr	r3, [pc, #32]	; (800c8dc <strtol+0x24>)
 800c8ba:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800c8bc:	681c      	ldr	r4, [r3, #0]
 800c8be:	4d08      	ldr	r5, [pc, #32]	; (800c8e0 <strtol+0x28>)
 800c8c0:	6a23      	ldr	r3, [r4, #32]
 800c8c2:	2b00      	cmp	r3, #0
 800c8c4:	bf08      	it	eq
 800c8c6:	462b      	moveq	r3, r5
 800c8c8:	9300      	str	r3, [sp, #0]
 800c8ca:	4613      	mov	r3, r2
 800c8cc:	460a      	mov	r2, r1
 800c8ce:	4601      	mov	r1, r0
 800c8d0:	4620      	mov	r0, r4
 800c8d2:	f7ff ff70 	bl	800c7b6 <_strtol_l.isra.0>
 800c8d6:	b003      	add	sp, #12
 800c8d8:	bd30      	pop	{r4, r5, pc}
 800c8da:	bf00      	nop
 800c8dc:	20000178 	.word	0x20000178
 800c8e0:	200001dc 	.word	0x200001dc

0800c8e4 <__locale_ctype_ptr_l>:
 800c8e4:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800c8e8:	4770      	bx	lr

0800c8ea <__ascii_mbtowc>:
 800c8ea:	b082      	sub	sp, #8
 800c8ec:	b901      	cbnz	r1, 800c8f0 <__ascii_mbtowc+0x6>
 800c8ee:	a901      	add	r1, sp, #4
 800c8f0:	b142      	cbz	r2, 800c904 <__ascii_mbtowc+0x1a>
 800c8f2:	b14b      	cbz	r3, 800c908 <__ascii_mbtowc+0x1e>
 800c8f4:	7813      	ldrb	r3, [r2, #0]
 800c8f6:	600b      	str	r3, [r1, #0]
 800c8f8:	7812      	ldrb	r2, [r2, #0]
 800c8fa:	1c10      	adds	r0, r2, #0
 800c8fc:	bf18      	it	ne
 800c8fe:	2001      	movne	r0, #1
 800c900:	b002      	add	sp, #8
 800c902:	4770      	bx	lr
 800c904:	4610      	mov	r0, r2
 800c906:	e7fb      	b.n	800c900 <__ascii_mbtowc+0x16>
 800c908:	f06f 0001 	mvn.w	r0, #1
 800c90c:	e7f8      	b.n	800c900 <__ascii_mbtowc+0x16>

0800c90e <__ascii_wctomb>:
 800c90e:	b149      	cbz	r1, 800c924 <__ascii_wctomb+0x16>
 800c910:	2aff      	cmp	r2, #255	; 0xff
 800c912:	bf85      	ittet	hi
 800c914:	238a      	movhi	r3, #138	; 0x8a
 800c916:	6003      	strhi	r3, [r0, #0]
 800c918:	700a      	strbls	r2, [r1, #0]
 800c91a:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
 800c91e:	bf98      	it	ls
 800c920:	2001      	movls	r0, #1
 800c922:	4770      	bx	lr
 800c924:	4608      	mov	r0, r1
 800c926:	4770      	bx	lr

0800c928 <_init>:
 800c928:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c92a:	bf00      	nop
 800c92c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c92e:	bc08      	pop	{r3}
 800c930:	469e      	mov	lr, r3
 800c932:	4770      	bx	lr

0800c934 <_fini>:
 800c934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c936:	bf00      	nop
 800c938:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c93a:	bc08      	pop	{r3}
 800c93c:	469e      	mov	lr, r3
 800c93e:	4770      	bx	lr
